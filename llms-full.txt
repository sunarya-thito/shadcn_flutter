<div align="center">
# üé® shadcn_flutter
**A cohesive shadcn/ui ecosystem for Flutter‚Äîcomponents, theming, and
tooling‚Äîready to ditch Material and Cupertino**
[![Pub Likes](https://img.shields.io/pub/likes/shadcn_flutter?style=for-the-badge&logo=dart&logoColor=white)](https://pub.dev/packages/shadcn_flutter)
[![Pub Points](https://img.shields.io/pub/points/shadcn_flutter?style=for-the-badge&logo=dart&logoColor=white)](https://pub.dev/packages/shadcn_flutter)
[![Pub Version](https://img.shields.io/pub/v/shadcn_flutter?style=for-the-badge&logo=dart&logoColor=white)](https://pub.dev/packages/shadcn_flutter)
[![GitHub Sponsors](https://img.shields.io/github/sponsors/sunarya-thito?style=for-the-badge&logo=github&logoColor=white)](https://github.com/sponsors/sunarya-thito)
[![GitHub Repo stars](https://img.shields.io/github/stars/sunarya-thito/shadcn_flutter?style=for-the-badge&logo=github&logoColor=white)](https://github.com/sunarya-thito/shadcn_flutter)
**[üìö Widget Catalog](https://sunarya-thito.github.io/shadcn_flutter/)** ‚Ä¢
**[üì¶ pub.dev](https://pub.dev/packages/shadcn_flutter)** ‚Ä¢
**[üí¨ Discord](https://discord.gg/ZzfBPQG4sV)**
</div>
---
## Introduction
Welcome to shadcn_flutter, a cohesive UI ecosystem built on the shadcn/ui design
system for Flutter applications across mobile, web, and desktop. Rather than a
one‚Äëto‚Äëone design‚Äësystem port, this project focuses on delivering a consistent,
production‚Äëready experience that feels at home on every platform.
> [!NOTE]
> Already using Material or Cupertino? You can adopt shadcn_flutter
> incrementally: mix components inside your existing MaterialApp/CupertinoApp,
> keep your navigation (e.g., GoRouter), and align visuals with your
> shadcn_flutter theme. Interop is optional‚Äîgo all‚Äëin when you're ready.
## Features
- 84 components and growing!
- Standalone ecosystem: no Material or Cupertino requirement; optional interop
  when needed.
- shadcn/ui design tokens and ready-to-use New York theme.
- Works inside MaterialApp and CupertinoApp; mix and match while you migrate.
- First-class support across Android, iOS, Web, macOS, Windows, and Linux.
- Various widget extensions for typography purposes.
## Components Library
### Animation
[![AnimatedValueBuilder](https://raw.githubusercontent.com/sunarya-thito/shadcn_flutter/master/docs_images/animatedvaluebuilder.png)](https://sunarya-thito.github.io/shadcn_flutter/#/components/animated_value_builder)
[![Number Ticker](https://raw.githubusercontent.com/sunarya-thito/shadcn_flutter/master/docs_images/number_ticker.png)](https://sunarya-thito.github.io/shadcn_flutter/#/components/number_ticker)
[![RepeatedAnimationBuilder](https://raw.githubusercontent.com/sunarya-thito/shadcn_flutter/master/docs_images/repeatedanimationbuilder.png)](https://sunarya-thito.github.io/shadcn_flutter/#/components/repeated_animation_builder)
### Disclosure
[![Accordion](https://raw.githubusercontent.com/sunarya-thito/shadcn_flutter/master/docs_images/accordion.png)](https://sunarya-thito.github.io/shadcn_flutter/#/components/accordion)
[![Collapsible](https://raw.githubusercontent.com/sunarya-thito/shadcn_flutter/master/docs_images/collapsible.png)](https://sunarya-thito.github.io/shadcn_flutter/#/components/collapsible)
### Feedback
[![Alert](https://raw.githubusercontent.com/sunarya-thito/shadcn_flutter/master/docs_images/alert.png)](https://sunarya-thito.github.io/shadcn_flutter/#/components/alert)
[![Alert Dialog](https://raw.githubusercontent.com/sunarya-thito/shadcn_flutter/master/docs_images/alert_dialog.png)](https://sunarya-thito.github.io/shadcn_flutter/#/components/alert-dialog)
[![Circular Progress](https://raw.githubusercontent.com/sunarya-thito/shadcn_flutter/master/docs_images/circular_progress.png)](https://sunarya-thito.github.io/shadcn_flutter/#/components/circular-progress)
[![Progress Bar](https://raw.githubusercontent.com/sunarya-thito/shadcn_flutter/master/docs_images/progress.png)](https://sunarya-thito.github.io/shadcn_flutter/#/components/progress)
[![Skeleton](https://raw.githubusercontent.com/sunarya-thito/shadcn_flutter/master/docs_images/skeleton.png)](https://sunarya-thito.github.io/shadcn_flutter/#/components/skeleton)
[![Toast](https://raw.githubusercontent.com/sunarya-thito/shadcn_flutter/master/docs_images/toast.png)](https://sunarya-thito.github.io/shadcn_flutter/#/components/toast)
### Forms
[![Button](https://raw.githubusercontent.com/sunarya-thito/shadcn_flutter/master/docs_images/button.png)](https://sunarya-thito.github.io/shadcn_flutter/#/components/button)
[![Checkbox](https://raw.githubusercontent.com/sunarya-thito/shadcn_flutter/master/docs_images/checkbox.png)](https://sunarya-thito.github.io/shadcn_flutter/#/components/checkbox)
[![Chip Input](https://raw.githubusercontent.com/sunarya-thito/shadcn_flutter/master/docs_images/chip_input.png)](https://sunarya-thito.github.io/shadcn_flutter/#/components/chip_input)
[![Color Picker](https://raw.githubusercontent.com/sunarya-thito/shadcn_flutter/master/docs_images/colorpicker.png)](https://sunarya-thito.github.io/shadcn_flutter/#/components/color-picker)
[![Date Picker](https://raw.githubusercontent.com/sunarya-thito/shadcn_flutter/master/docs_images/datepicker.png)](https://sunarya-thito.github.io/shadcn_flutter/#/components/date_picker)
[![Form](https://raw.githubusercontent.com/sunarya-thito/shadcn_flutter/master/docs_images/form.png)](https://sunarya-thito.github.io/shadcn_flutter/#/components/form)
[![Input](https://raw.githubusercontent.com/sunarya-thito/shadcn_flutter/master/docs_images/input.png)](https://sunarya-thito.github.io/shadcn_flutter/#/components/input)
[![Input OTP](https://raw.githubusercontent.com/sunarya-thito/shadcn_flutter/master/docs_images/inputotp.png)](https://sunarya-thito.github.io/shadcn_flutter/#/components/input_otp)
[![Phone Input](https://raw.githubusercontent.com/sunarya-thito/shadcn_flutter/master/docs_images/phone_input.png)](https://sunarya-thito.github.io/shadcn_flutter/#/components/phone_input)
[![Radio Group](https://raw.githubusercontent.com/sunarya-thito/shadcn_flutter/master/docs_images/radiogroup.png)](https://sunarya-thito.github.io/shadcn_flutter/#/components/radio_group)
[![Select](https://raw.githubusercontent.com/sunarya-thito/shadcn_flutter/master/docs_images/select.png)](https://sunarya-thito.github.io/shadcn_flutter/#/components/select)
[![Slider](https://raw.githubusercontent.com/sunarya-thito/shadcn_flutter/master/docs_images/slider.png)](https://sunarya-thito.github.io/shadcn_flutter/#/components/slider)
[![Star Rating](https://raw.githubusercontent.com/sunarya-thito/shadcn_flutter/master/docs_images/star_rating.png)](https://sunarya-thito.github.io/shadcn_flutter/#/components/star_rating)
[![Switch](https://raw.githubusercontent.com/sunarya-thito/shadcn_flutter/master/docs_images/switch.png)](https://sunarya-thito.github.io/shadcn_flutter/#/components/switch)
[![Text Area](https://raw.githubusercontent.com/sunarya-thito/shadcn_flutter/master/docs_images/textarea.png)](https://sunarya-thito.github.io/shadcn_flutter/#/components/text_area)
[![Time Picker](https://raw.githubusercontent.com/sunarya-thito/shadcn_flutter/master/docs_images/time_picker.png)](https://sunarya-thito.github.io/shadcn_flutter/#/components/time_picker)
[![Toggle](https://raw.githubusercontent.com/sunarya-thito/shadcn_flutter/master/docs_images/toggle.png)](https://sunarya-thito.github.io/shadcn_flutter/#/components/toggle)
### Layout
[![Card](https://raw.githubusercontent.com/sunarya-thito/shadcn_flutter/master/docs_images/card.png)](https://sunarya-thito.github.io/shadcn_flutter/#/components/card)
[![Carousel](https://raw.githubusercontent.com/sunarya-thito/shadcn_flutter/master/docs_images/carousel.png)](https://sunarya-thito.github.io/shadcn_flutter/#/components/carousel)
[![Divider](https://raw.githubusercontent.com/sunarya-thito/shadcn_flutter/master/docs_images/divider.png)](https://sunarya-thito.github.io/shadcn_flutter/#/components/divider)
[![Resizable](https://raw.githubusercontent.com/sunarya-thito/shadcn_flutter/master/docs_images/resizable.png)](https://sunarya-thito.github.io/shadcn_flutter/#/components/resizable)
[![Stepper](https://raw.githubusercontent.com/sunarya-thito/shadcn_flutter/master/docs_images/stepper.png)](https://sunarya-thito.github.io/shadcn_flutter/#/components/stepper)
[![Steps](https://raw.githubusercontent.com/sunarya-thito/shadcn_flutter/master/docs_images/steps.png)](https://sunarya-thito.github.io/shadcn_flutter/#/components/steps)
[![Timeline](https://raw.githubusercontent.com/sunarya-thito/shadcn_flutter/master/docs_images/timeline.png)](https://sunarya-thito.github.io/shadcn_flutter/#/components/timeline)
### Navigation
[![Breadcrumb](https://raw.githubusercontent.com/sunarya-thito/shadcn_flutter/master/docs_images/breadcrumb.png)](https://sunarya-thito.github.io/shadcn_flutter/#/components/breadcrumb)
[![Menubar](https://raw.githubusercontent.com/sunarya-thito/shadcn_flutter/master/docs_images/menubar.png)](https://sunarya-thito.github.io/shadcn_flutter/#/components/menubar)
[![Navigation Menu](https://raw.githubusercontent.com/sunarya-thito/shadcn_flutter/master/docs_images/navigation_menu.png)](https://sunarya-thito.github.io/shadcn_flutter/#/components/navigation_menu)
[![Pagination](https://raw.githubusercontent.com/sunarya-thito/shadcn_flutter/master/docs_images/pagination.png)](https://sunarya-thito.github.io/shadcn_flutter/#/components/pagination)
[![Tabs](https://raw.githubusercontent.com/sunarya-thito/shadcn_flutter/master/docs_images/tabs.png)](https://sunarya-thito.github.io/shadcn_flutter/#/components/tabs)
[![Tab List](https://raw.githubusercontent.com/sunarya-thito/shadcn_flutter/master/docs_images/tablist.png)](https://sunarya-thito.github.io/shadcn_flutter/#/components/tab_list)
[![Tree](https://raw.githubusercontent.com/sunarya-thito/shadcn_flutter/master/docs_images/tree.png)](https://sunarya-thito.github.io/shadcn_flutter/#/components/tree)
### Surfaces
[![Dialog](https://raw.githubusercontent.com/sunarya-thito/shadcn_flutter/master/docs_images/dialog.png)](https://sunarya-thito.github.io/shadcn_flutter/#/components/dialog)
[![Drawer](https://raw.githubusercontent.com/sunarya-thito/shadcn_flutter/master/docs_images/drawer.png)](https://sunarya-thito.github.io/shadcn_flutter/#/components/drawer)
[![Hover Card](https://raw.githubusercontent.com/sunarya-thito/shadcn_flutter/master/docs_images/hover_card.png)](https://sunarya-thito.github.io/shadcn_flutter/#/components/hover_card)
[![Popover](https://raw.githubusercontent.com/sunarya-thito/shadcn_flutter/master/docs_images/popover.png)](https://sunarya-thito.github.io/shadcn_flutter/#/components/popover)
[![Sheet](https://raw.githubusercontent.com/sunarya-thito/shadcn_flutter/master/docs_images/sheet.png)](https://sunarya-thito.github.io/shadcn_flutter/#/components/sheet)
[![Tooltip](https://raw.githubusercontent.com/sunarya-thito/shadcn_flutter/master/docs_images/tooltip.png)](https://sunarya-thito.github.io/shadcn_flutter/#/components/tooltip)
### Data Display
[![Avatar](https://raw.githubusercontent.com/sunarya-thito/shadcn_flutter/master/docs_images/avatar.png)](https://sunarya-thito.github.io/shadcn_flutter/#/components/avatar)
[![Avatar Group](https://raw.githubusercontent.com/sunarya-thito/shadcn_flutter/master/docs_images/avatar_group.png)](https://sunarya-thito.github.io/shadcn_flutter/#/components/avatar_group)
[![Code Snippet](https://raw.githubusercontent.com/sunarya-thito/shadcn_flutter/master/docs_images/codesnippet.png)](https://sunarya-thito.github.io/shadcn_flutter/#/components/code-snippet)
[![Tracker](https://raw.githubusercontent.com/sunarya-thito/shadcn_flutter/master/docs_images/tracker.png)](https://sunarya-thito.github.io/shadcn_flutter/#/components/tracker)
### Utilities
[![Badge](https://raw.githubusercontent.com/sunarya-thito/shadcn_flutter/master/docs_images/badge.png)](https://sunarya-thito.github.io/shadcn_flutter/#/components/badge)
[![Calendar](https://raw.githubusercontent.com/sunarya-thito/shadcn_flutter/master/docs_images/calendar.png)](https://sunarya-thito.github.io/shadcn_flutter/#/components/calendar)
[![Command](https://raw.githubusercontent.com/sunarya-thito/shadcn_flutter/master/docs_images/command.png)](https://sunarya-thito.github.io/shadcn_flutter/#/components/command)
[![Context Menu](https://raw.githubusercontent.com/sunarya-thito/shadcn_flutter/master/docs_images/context_menu.png)](https://sunarya-thito.github.io/shadcn_flutter/#/components/context_menu)
[![Dropdown Menu](https://raw.githubusercontent.com/sunarya-thito/shadcn_flutter/master/docs_images/dropdown_menu.png)](https://sunarya-thito.github.io/shadcn_flutter/#/components/dropdown_menu)
## LLMs Support
This repository includes a prebuilt, machine‚Äëfriendly reference file you can
feed to LLMs and editor assistants:
- [`llms-full.txt`](https://sunarya-thito.github.io/shadcn_flutter/llms-full.txt) -
  Full component reference with props, methods, and usage examples
## FAQ
<details>
<summary><strong>Does this replace Material/Cupertino?</strong></summary>
Yes. shadcn_flutter is a standalone ecosystem built on the shadcn/ui design
system. Interop with Material/Cupertino is optional so you can adopt it
incrementally or go all‚Äëin.
</details>
<details>
<summary><strong>Can I use it with my existing MaterialApp/CupertinoApp?</strong></summary>
Yes. Drop shadcn_flutter components into your app, keep your current routing
(e.g., GoRouter) and state management, and migrate over time.
</details>
<details>
<summary><strong>Does it support GoRouter?</strong></summary>
Yes.
</details>
<details>
<summary><strong>Which platforms are supported?</strong></summary>
Android, iOS, Web, macOS, Windows, and Linux.
</details>
<details>
<summary><strong>Can I use it commercially?</strong></summary>
Yes. Free to use for personal and commercial projects. No attribution required.
</details>
<details>
<summary><strong>Can I choose between Default and New York styles?</strong></summary>
This package currently supports the New York style. If you need the default
style of shadcn/ui, consider this package:
[flutter-shadcn-ui](https://github.com/nank1ro/flutter-shadcn-ui) by
[@nank1ro](https://x.com/nank1ro).
</details>
## Contributing & Support
We welcome contributions from the community! Here's how you can help make
shadcn_flutter even better:
### Ways to Contribute
<div align="center">
[![‚≠ê Star on GitHub](https://img.shields.io/badge/‚≠ê_Star_on_GitHub-black?style=for-the-badge&logo=github)](https://github.com/sunarya-thito/shadcn_flutter)
[![üíñ Sponsor](https://img.shields.io/badge/üíñ_Sponsor-pink?style=for-the-badge&logo=github-sponsors)](https://github.com/sponsors/sunarya-thito)
[![üêõ Report Bug](https://img.shields.io/badge/üêõ_Report_Bug-red?style=for-the-badge&logo=github)](https://github.com/sunarya-thito/shadcn_flutter/issues)
[![üí° Request Feature](https://img.shields.io/badge/üí°_Request_Feature-blue?style=for-the-badge&logo=github)](https://github.com/sunarya-thito/shadcn_flutter/issues)
</div>
#### Financial Support
- **[GitHub Sponsors](https://github.com/sponsors/sunarya-thito)** - Support
  ongoing development
- **[PayPal](https://paypal.me/sunaryathito)** - Support ongoing development
- **Star the repository** - Help us reach more developers
- **Share the project** - Spread the word in your community
#### Code Contributions
- **Bug fixes** - Help us squash those pesky bugs
- **New features** - Add components or enhance existing ones
- **Documentation** - Improve guides, examples, and API docs
- **Testing** - Write tests to improve reliability
#### Community Support
- **[Join our Discord](https://discord.gg/ZzfBPQG4sV)** - Get help and connect
  with other developers
- **Help others** - Answer questions and share your knowledge
- **Write tutorials** - Create blog posts or video tutorials
### Recognition
This project is funded and maintained by the community. Every contribution, no
matter how small, makes a difference and helps ensure the continued development
of shadcn_flutter.
**Thank you to all our contributors and supporters! üôè**
---
<div align="center">
**Built with ‚ù§Ô∏è by [Thito Yalasatria Sunarya](https://github.com/sunarya-thito)
and the community**
_Made in Indonesia üáÆüá©_
</div>
class ColorSchemes {
  static const ColorScheme lightGray = ColorScheme(brightness: Brightness.light, background: Color(0xFFFFFFFF), foreground: Color(0xFF030712), card: Color(0xFFFFFFFF), cardForeground: Color(0xFF030712), popover: Color(0xFFFFFFFF), popoverForeground: Color(0xFF030712), primary: Color(0xFF111827), primaryForeground: Color(0xFFF9FAFB), secondary: Color(0xFFF3F4F6), secondaryForeground: Color(0xFF111827), muted: Color(0xFFF3F4F6), mutedForeground: Color(0xFF6B7280), accent: Color(0xFFF3F4F6), accentForeground: Color(0xFF111827), destructive: Color(0xFFEF4444), destructiveForeground: Color(0xFFF9FAFB), border: Color(0xFFE5E7EB), input: Color(0xFFE5E7EB), ring: Color(0xFF030712), chart1: Color(0xFFE76E50), chart2: Color(0xFF2A9D90), chart3: Color(0xFF274754), chart4: Color(0xFFE8C468), chart5: Color(0xFFF4A462));
  static const ColorScheme darkGray = ColorScheme(brightness: Brightness.dark, background: Color(0xFF030712), foreground: Color(0xFFF9FAFB), card: Color(0xFF030712), cardForeground: Color(0xFFF9FAFB), popover: Color(0xFF030712), popoverForeground: Color(0xFFF9FAFB), primary: Color(0xFFF9FAFB), primaryForeground: Color(0xFF111827), secondary: Color(0xFF1F2937), secondaryForeground: Color(0xFFF9FAFB), muted: Color(0xFF1F2937), mutedForeground: Color(0xFF9CA3AF), accent: Color(0xFF1F2937), accentForeground: Color(0xFFF9FAFB), destructive: Color(0xFF7F1D1D), destructiveForeground: Color(0xFFF9FAFB), border: Color(0xFF1F2937), input: Color(0xFF1F2937), ring: Color(0xFFD1D5DB), chart1: Color(0xFF2662D9), chart2: Color(0xFF2EB88A), chart3: Color(0xFFE88C30), chart4: Color(0xFFAF57DB), chart5: Color(0xFFE23670));
  static ColorScheme gray(ThemeMode mode);
  static const ColorScheme lightNeutral = ColorScheme(brightness: Brightness.light, background: Color(0xFFFFFFFF), foreground: Color(0xFF0A0A0A), card: Color(0xFFFFFFFF), cardForeground: Color(0xFF0A0A0A), popover: Color(0xFFFFFFFF), popoverForeground: Color(0xFF0A0A0A), primary: Color(0xFF171717), primaryForeground: Color(0xFFFAFAFA), secondary: Color(0xFFF5F5F5), secondaryForeground: Color(0xFF171717), muted: Color(0xFFF5F5F5), mutedForeground: Color(0xFF737373), accent: Color(0xFFF5F5F5), accentForeground: Color(0xFF171717), destructive: Color(0xFFEF4444), destructiveForeground: Color(0xFFFAFAFA), border: Color(0xFFE5E5E5), input: Color(0xFFE5E5E5), ring: Color(0xFF0A0A0A), chart1: Color(0xFFE76E50), chart2: Color(0xFF2A9D90), chart3: Color(0xFF274754), chart4: Color(0xFFE8C468), chart5: Color(0xFFF4A462));
  static const ColorScheme darkNeutral = ColorScheme(brightness: Brightness.dark, background: Color(0xFF0A0A0A), foreground: Color(0xFFFAFAFA), card: Color(0xFF0A0A0A), cardForeground: Color(0xFFFAFAFA), popover: Color(0xFF0A0A0A), popoverForeground: Color(0xFFFAFAFA), primary: Color(0xFFFAFAFA), primaryForeground: Color(0xFF171717), secondary: Color(0xFF262626), secondaryForeground: Color(0xFFFAFAFA), muted: Color(0xFF262626), mutedForeground: Color(0xFFA3A3A3), accent: Color(0xFF262626), accentForeground: Color(0xFFFAFAFA), destructive: Color(0xFF7F1D1D), destructiveForeground: Color(0xFFFAFAFA), border: Color(0xFF262626), input: Color(0xFF262626), ring: Color(0xFFD4D4D4), chart1: Color(0xFF2662D9), chart2: Color(0xFF2EB88A), chart3: Color(0xFFE88C30), chart4: Color(0xFFAF57DB), chart5: Color(0xFFE23670));
  static ColorScheme neutral(ThemeMode mode);
  static const ColorScheme lightSlate = ColorScheme(brightness: Brightness.light, background: Color(0xFFFFFFFF), foreground: Color(0xFF020817), card: Color(0xFFFFFFFF), cardForeground: Color(0xFF020817), popover: Color(0xFFFFFFFF), popoverForeground: Color(0xFF020817), primary: Color(0xFF0F172A), primaryForeground: Color(0xFFF8FAFC), secondary: Color(0xFFF1F5F9), secondaryForeground: Color(0xFF0F172A), muted: Color(0xFFF1F5F9), mutedForeground: Color(0xFF64748B), accent: Color(0xFFF1F5F9), accentForeground: Color(0xFF0F172A), destructive: Color(0xFFEF4444), destructiveForeground: Color(0xFFF8FAFC), border: Color(0xFFE2E8F0), input: Color(0xFFE2E8F0), ring: Color(0xFF020817), chart1: Color(0xFFE76E50), chart2: Color(0xFF2A9D90), chart3: Color(0xFF274754), chart4: Color(0xFFE8C468), chart5: Color(0xFFF4A462));
  static const ColorScheme darkSlate = ColorScheme(brightness: Brightness.dark, background: Color(0xFF020817), foreground: Color(0xFFF8FAFC), card: Color(0xFF020817), cardForeground: Color(0xFFF8FAFC), popover: Color(0xFF020817), popoverForeground: Color(0xFFF8FAFC), primary: Color(0xFFF8FAFC), primaryForeground: Color(0xFF0F172A), secondary: Color(0xFF1E293B), secondaryForeground: Color(0xFFF8FAFC), muted: Color(0xFF1E293B), mutedForeground: Color(0xFF94A3B8), accent: Color(0xFF1E293B), accentForeground: Color(0xFFF8FAFC), destructive: Color(0xFF7F1D1D), destructiveForeground: Color(0xFFF8FAFC), border: Color(0xFF1E293B), input: Color(0xFF1E293B), ring: Color(0xFFCBD5E1), chart1: Color(0xFF2662D9), chart2: Color(0xFF2EB88A), chart3: Color(0xFFE88C30), chart4: Color(0xFFAF57DB), chart5: Color(0xFFE23670));
  static ColorScheme slate(ThemeMode mode);
  static const ColorScheme lightStone = ColorScheme(brightness: Brightness.light, background: Color(0xFFFFFFFF), foreground: Color(0xFF0C0A09), card: Color(0xFFFFFFFF), cardForeground: Color(0xFF0C0A09), popover: Color(0xFFFFFFFF), popoverForeground: Color(0xFF0C0A09), primary: Color(0xFF1C1917), primaryForeground: Color(0xFFFAFAF9), secondary: Color(0xFFF5F5F4), secondaryForeground: Color(0xFF1C1917), muted: Color(0xFFF5F5F4), mutedForeground: Color(0xFF78716C), accent: Color(0xFFF5F5F4), accentForeground: Color(0xFF1C1917), destructive: Color(0xFFEF4444), destructiveForeground: Color(0xFFFAFAF9), border: Color(0xFFE7E5E4), input: Color(0xFFE7E5E4), ring: Color(0xFF0C0A09), chart1: Color(0xFFE76E50), chart2: Color(0xFF2A9D90), chart3: Color(0xFF274754), chart4: Color(0xFFE8C468), chart5: Color(0xFFF4A462));
  static const ColorScheme darkStone = ColorScheme(brightness: Brightness.dark, background: Color(0xFF0C0A09), foreground: Color(0xFFFAFAF9), card: Color(0xFF0C0A09), cardForeground: Color(0xFFFAFAF9), popover: Color(0xFF0C0A09), popoverForeground: Color(0xFFFAFAF9), primary: Color(0xFFFAFAF9), primaryForeground: Color(0xFF1C1917), secondary: Color(0xFF292524), secondaryForeground: Color(0xFFFAFAF9), muted: Color(0xFF292524), mutedForeground: Color(0xFFA8A29E), accent: Color(0xFF292524), accentForeground: Color(0xFFFAFAF9), destructive: Color(0xFF7F1D1D), destructiveForeground: Color(0xFFFAFAF9), border: Color(0xFF292524), input: Color(0xFF292524), ring: Color(0xFFD6D3D1), chart1: Color(0xFF2662D9), chart2: Color(0xFF2EB88A), chart3: Color(0xFFE88C30), chart4: Color(0xFFAF57DB), chart5: Color(0xFFE23670));
  static ColorScheme stone(ThemeMode mode);
  static const ColorScheme lightZinc = ColorScheme(brightness: Brightness.light, background: Color(0xFFFFFFFF), foreground: Color(0xFF09090B), card: Color(0xFFFFFFFF), cardForeground: Color(0xFF09090B), popover: Color(0xFFFFFFFF), popoverForeground: Color(0xFF09090B), primary: Color(0xFF18181B), primaryForeground: Color(0xFFFAFAFA), secondary: Color(0xFFF4F4F5), secondaryForeground: Color(0xFF18181B), muted: Color(0xFFF4F4F5), mutedForeground: Color(0xFF71717A), accent: Color(0xFFF4F4F5), accentForeground: Color(0xFF18181B), destructive: Color(0xFFEF4444), destructiveForeground: Color(0xFFFAFAFA), border: Color(0xFFE4E4E7), input: Color(0xFFE4E4E7), ring: Color(0xFF09090B), chart1: Color(0xFFE76E50), chart2: Color(0xFF2A9D90), chart3: Color(0xFF274754), chart4: Color(0xFFE8C468), chart5: Color(0xFFF4A462));
  static const ColorScheme darkZinc = ColorScheme(brightness: Brightness.dark, background: Color(0xFF09090B), foreground: Color(0xFFFAFAFA), card: Color(0xFF09090B), cardForeground: Color(0xFFFAFAFA), popover: Color(0xFF09090B), popoverForeground: Color(0xFFFAFAFA), primary: Color(0xFFFAFAFA), primaryForeground: Color(0xFF18181B), secondary: Color(0xFF27272A), secondaryForeground: Color(0xFFFAFAFA), muted: Color(0xFF27272A), mutedForeground: Color(0xFFA1A1AA), accent: Color(0xFF27272A), accentForeground: Color(0xFFFAFAFA), destructive: Color(0xFF7F1D1D), destructiveForeground: Color(0xFFFAFAFA), border: Color(0xFF27272A), input: Color(0xFF27272A), ring: Color(0xFFD4D4D8), chart1: Color(0xFF2662D9), chart2: Color(0xFF2EB88A), chart3: Color(0xFFE88C30), chart4: Color(0xFFAF57DB), chart5: Color(0xFFE23670));
  static ColorScheme zinc(ThemeMode mode);
}
/// Typography definitions for shadcn_flutter.
///
/// Provides predefined text styles for different purposes including
/// sizes, weights, and semantic styles like headings and paragraphs.
class Typography {
/// Sans-serif font style.
  TextStyle sans;
/// Monospace font style.
  TextStyle mono;
/// Extra small text (12px).
  TextStyle xSmall;
/// Small text (14px).
  TextStyle small;
/// Base text size (16px).
  TextStyle base;
/// Large text (18px).
  TextStyle large;
/// Extra large text (20px).
  TextStyle xLarge;
/// 2x large text (24px).
  TextStyle x2Large;
/// 3x large text (30px).
  TextStyle x3Large;
/// 4x large text (36px).
  TextStyle x4Large;
/// 5x large text (48px).
  TextStyle x5Large;
/// 6x large text (60px).
  TextStyle x6Large;
/// 7x large text (72px).
  TextStyle x7Large;
/// 8x large text (96px).
  TextStyle x8Large;
/// 9x large text (144px).
  TextStyle x9Large;
/// Thin font weight (100).
  TextStyle thin;
/// Light font weight (300).
  TextStyle light;
/// Extra light font weight (200).
  TextStyle extraLight;
/// Normal font weight (400).
  TextStyle normal;
/// Medium font weight (500).
  TextStyle medium;
/// Semi-bold font weight (600).
  TextStyle semiBold;
/// Bold font weight (700).
  TextStyle bold;
/// Extra bold font weight (800).
  TextStyle extraBold;
/// Black font weight (900).
  TextStyle black;
/// Italic text style.
  TextStyle italic;
/// Heading 1 style.
  TextStyle h1;
/// Heading 2 style.
  TextStyle h2;
/// Heading 3 style.
  TextStyle h3;
/// Heading 4 style.
  TextStyle h4;
/// Paragraph style.
  TextStyle p;
/// Block quote style.
  TextStyle blockQuote;
/// Inline code style.
  TextStyle inlineCode;
/// Lead text style.
  TextStyle lead;
/// Large text style.
  TextStyle textLarge;
/// Small text style.
  TextStyle textSmall;
/// Muted text style.
  TextStyle textMuted;
/// Creates a typography with Geist font family.
  const Typography.geist({this.sans = const TextStyle(fontFamily: 'GeistSans', package: 'shadcn_flutter'), this.mono = const TextStyle(fontFamily: 'GeistMono', package: 'shadcn_flutter'), this.xSmall = const TextStyle(fontSize: 12), this.small = const TextStyle(fontSize: 14), this.base = const TextStyle(fontSize: 16), this.large = const TextStyle(fontSize: 18), this.xLarge = const TextStyle(fontSize: 20), this.x2Large = const TextStyle(fontSize: 24), this.x3Large = const TextStyle(fontSize: 30), this.x4Large = const TextStyle(fontSize: 36), this.x5Large = const TextStyle(fontSize: 48), this.x6Large = const TextStyle(fontSize: 60), this.x7Large = const TextStyle(fontSize: 72), this.x8Large = const TextStyle(fontSize: 96), this.x9Large = const TextStyle(fontSize: 144), this.thin = const TextStyle(fontWeight: FontWeight.w100), this.light = const TextStyle(fontWeight: FontWeight.w300), this.extraLight = const TextStyle(fontWeight: FontWeight.w200), this.normal = const TextStyle(fontWeight: FontWeight.w400), this.medium = const TextStyle(fontWeight: FontWeight.w500), this.semiBold = const TextStyle(fontWeight: FontWeight.w600), this.bold = const TextStyle(fontWeight: FontWeight.w700), this.extraBold = const TextStyle(fontWeight: FontWeight.w800), this.black = const TextStyle(fontWeight: FontWeight.w900), this.italic = const TextStyle(fontStyle: FontStyle.italic), this.h1 = const TextStyle(fontSize: 36, fontWeight: FontWeight.w800), this.h2 = const TextStyle(fontSize: 30, fontWeight: FontWeight.w600), this.h3 = const TextStyle(fontSize: 24, fontWeight: FontWeight.w600), this.h4 = const TextStyle(fontSize: 18, fontWeight: FontWeight.w600), this.p = const TextStyle(fontSize: 16, fontWeight: FontWeight.w400), this.blockQuote = const TextStyle(fontSize: 16, fontWeight: FontWeight.w400, fontStyle: FontStyle.italic), this.inlineCode = const TextStyle(fontFamily: 'GeistMono', fontSize: 14, fontWeight: FontWeight.w600), this.lead = const TextStyle(fontSize: 20), this.textLarge = const TextStyle(fontSize: 20, fontWeight: FontWeight.w600), this.textSmall = const TextStyle(fontSize: 14, fontWeight: FontWeight.w500), this.textMuted = const TextStyle(fontSize: 14, fontWeight: FontWeight.w400)});
/// Creates a custom typography with all required text styles.
  const Typography({required this.sans, required this.mono, required this.xSmall, required this.small, required this.base, required this.large, required this.xLarge, required this.x2Large, required this.x3Large, required this.x4Large, required this.x5Large, required this.x6Large, required this.x7Large, required this.x8Large, required this.x9Large, required this.thin, required this.light, required this.extraLight, required this.normal, required this.medium, required this.semiBold, required this.bold, required this.extraBold, required this.black, required this.italic, required this.h1, required this.h2, required this.h3, required this.h4, required this.p, required this.blockQuote, required this.inlineCode, required this.lead, required this.textLarge, required this.textSmall, required this.textMuted});
/// Creates a copy of this typography with the given fields replaced.
  Typography copyWith({ValueGetter<TextStyle>? sans, ValueGetter<TextStyle>? mono, ValueGetter<TextStyle>? xSmall, ValueGetter<TextStyle>? small, ValueGetter<TextStyle>? base, ValueGetter<TextStyle>? large, ValueGetter<TextStyle>? xLarge, ValueGetter<TextStyle>? x2Large, ValueGetter<TextStyle>? x3Large, ValueGetter<TextStyle>? x4Large, ValueGetter<TextStyle>? x5Large, ValueGetter<TextStyle>? x6Large, ValueGetter<TextStyle>? x7Large, ValueGetter<TextStyle>? x8Large, ValueGetter<TextStyle>? x9Large, ValueGetter<TextStyle>? thin, ValueGetter<TextStyle>? light, ValueGetter<TextStyle>? extraLight, ValueGetter<TextStyle>? normal, ValueGetter<TextStyle>? medium, ValueGetter<TextStyle>? semiBold, ValueGetter<TextStyle>? bold, ValueGetter<TextStyle>? extraBold, ValueGetter<TextStyle>? black, ValueGetter<TextStyle>? italic, ValueGetter<TextStyle>? h1, ValueGetter<TextStyle>? h2, ValueGetter<TextStyle>? h3, ValueGetter<TextStyle>? h4, ValueGetter<TextStyle>? p, ValueGetter<TextStyle>? blockQuote, ValueGetter<TextStyle>? inlineCode, ValueGetter<TextStyle>? lead, ValueGetter<TextStyle>? textLarge, ValueGetter<TextStyle>? textSmall, ValueGetter<TextStyle>? textMuted});
/// Scales all typography font sizes by the given factor.
///
/// Parameters:
/// - [factor] (`double`, required): Scaling factor to apply.
///
/// Returns: `Typography` ‚Äî scaled typography.
  Typography scale(double factor);
/// Linearly interpolates between two typographies.
///
/// Parameters:
/// - [a] (`Typography`, required): Start typography.
/// - [b] (`Typography`, required): End typography.
/// - [t] (`double`, required): Interpolation position (0.0 to 1.0).
///
/// Returns: `Typography` ‚Äî interpolated typography.
  static Typography lerp(Typography a, Typography b, double t);
  bool operator ==(Object other);
  int get hashCode;
  String toString();
}
/// A collection of color constants and shades for shadcn_flutter.
///
/// This class provides predefined colors and color shades that can be used
/// throughout the application. All colors follow the shadcn design system.
class Colors {
/// Pure black color.
  static const Color black = Color(0xff000000);
/// Pure white color.
  static const Color white = Color(0xffffffff);
/// Slate color shades (50-950).
  static const ColorShades slate = ColorShades.raw({50 : Color(0xfff8fafc), 100 : Color(0xfff1f5f9), 200 : Color(0xffe2e8f0), 300 : Color(0xffcbd5e1), 400 : Color(0xff94a3b8), 500 : Color(0xff64748b), 600 : Color(0xff475569), 700 : Color(0xff334155), 800 : Color(0xff1e293b), 900 : Color(0xff0f172a), 950 : Color(0xff020617)});
/// Gray color shades (50-950).
  static const ColorShades gray = ColorShades.raw({50 : Color(0xfff9fafb), 100 : Color(0xfff3f4f6), 200 : Color(0xffe5e7eb), 300 : Color(0xffd1d5db), 400 : Color(0xff9ca3af), 500 : Color(0xff6b7280), 600 : Color(0xff4b5563), 700 : Color(0xff374151), 800 : Color(0xff1f2937), 900 : Color(0xff111827), 950 : Color(0xff030712)});
/// Zinc color shades (50-950).
  static const ColorShades zinc = ColorShades.raw({50 : Color(0xfffafafa), 100 : Color(0xfff4f4f5), 200 : Color(0xffe4e4e7), 300 : Color(0xffd4d4d8), 400 : Color(0xffa1a1aa), 500 : Color(0xff71717a), 600 : Color(0xff52525b), 700 : Color(0xff3f3f46), 800 : Color(0xff27272a), 900 : Color(0xff18181b), 950 : Color(0xff09090b)});
/// Neutral color shades (50-950).
  static const ColorShades neutral = ColorShades.raw({50 : Color(0xfffafafa), 100 : Color(0xfff5f5f5), 200 : Color(0xffe5e5e5), 300 : Color(0xffd4d4d4), 400 : Color(0xffa3a3a3), 500 : Color(0xff737373), 600 : Color(0xff525252), 700 : Color(0xff404040), 800 : Color(0xff262626), 900 : Color(0xff171717), 950 : Color(0xff0a0a0a)});
/// Stone color shades (50-950).
  static const ColorShades stone = ColorShades.raw({50 : Color(0xfffafaf9), 100 : Color(0xfff5f5f4), 200 : Color(0xffe7e5e4), 300 : Color(0xffd6d3d1), 400 : Color(0xffa8a29e), 500 : Color(0xff78716c), 600 : Color(0xff57534e), 700 : Color(0xff44403c), 800 : Color(0xff292524), 900 : Color(0xff1c1917), 950 : Color(0xff0c0a09)});
/// Red color shades (50-950).
  static const ColorShades red = ColorShades.raw({50 : Color(0xfffef2f2), 100 : Color(0xfffee2e2), 200 : Color(0xfffecaca), 300 : Color(0xfffca5a5), 400 : Color(0xfff87171), 500 : Color(0xffef4444), 600 : Color(0xffdc2626), 700 : Color(0xffb91c1c), 800 : Color(0xff991b1b), 900 : Color(0xff7f1d1d), 950 : Color(0xff450a0a)});
/// Orange color shades (50-950).
  static const ColorShades orange = ColorShades.raw({50 : Color(0xfffff7ed), 100 : Color(0xffffedd5), 200 : Color(0xfffed7aa), 300 : Color(0xfffdba74), 400 : Color(0xfffb923c), 500 : Color(0xfff97316), 600 : Color(0xffea580c), 700 : Color(0xffc2410c), 800 : Color(0xff9a3412), 900 : Color(0xff7c2d12), 950 : Color(0xff431407)});
/// Amber color shades (50-950).
  static const ColorShades amber = ColorShades.raw({50 : Color(0xfffffbeb), 100 : Color(0xfffef3c7), 200 : Color(0xfffde68a), 300 : Color(0xfffcd34d), 400 : Color(0xfffbbf24), 500 : Color(0xfff59e0b), 600 : Color(0xffd97706), 700 : Color(0xffb45309), 800 : Color(0xff92400e), 900 : Color(0xff78350f), 950 : Color(0xff451a03)});
/// Yellow color shades (50-950).
  static const ColorShades yellow = ColorShades.raw({50 : Color(0xfffefce8), 100 : Color(0xfffef9c3), 200 : Color(0xfffef08a), 300 : Color(0xfffde047), 400 : Color(0xfffacc15), 500 : Color(0xffeab308), 600 : Color(0xffca8a04), 700 : Color(0xffa16207), 800 : Color(0xff854d0e), 900 : Color(0xff713f12), 950 : Color(0xff422006)});
/// Lime color shades (50-950).
  static const ColorShades lime = ColorShades.raw({50 : Color(0xfff7fee7), 100 : Color(0xffecfccb), 200 : Color(0xffd9f99d), 300 : Color(0xffbef264), 400 : Color(0xffa3e635), 500 : Color(0xff84cc16), 600 : Color(0xff65a30d), 700 : Color(0xff4d7c0f), 800 : Color(0xff3f6212), 900 : Color(0xff365314), 950 : Color(0xff1a2e05)});
/// Green color shades (50-950).
  static const ColorShades green = ColorShades.raw({50 : Color(0xfff0fdf4), 100 : Color(0xffdcfce7), 200 : Color(0xffbbf7d0), 300 : Color(0xff86efac), 400 : Color(0xff4ade80), 500 : Color(0xff22c55e), 600 : Color(0xff16a34a), 700 : Color(0xff15803d), 800 : Color(0xff166534), 900 : Color(0xff14532d), 950 : Color(0xff052e16)});
/// Emerald color shades (50-950).
  static const ColorShades emerald = ColorShades.raw({50 : Color(0xffecfdf5), 100 : Color(0xffd1fae5), 200 : Color(0xffa7f3d0), 300 : Color(0xff6ee7b7), 400 : Color(0xff34d399), 500 : Color(0xff10b981), 600 : Color(0xff059669), 700 : Color(0xff047857), 800 : Color(0xff065f46), 900 : Color(0xff064e3b), 950 : Color(0xff022c22)});
/// Teal color shades (50-950).
  static const ColorShades teal = ColorShades.raw({50 : Color(0xfff0fdfa), 100 : Color(0xffccfbf1), 200 : Color(0xff99f6e4), 300 : Color(0xff5eead4), 400 : Color(0xff2dd4bf), 500 : Color(0xff14b8a6), 600 : Color(0xff0d9488), 700 : Color(0xff0f766e), 800 : Color(0xff115e59), 900 : Color(0xff134e4a), 950 : Color(0xff042f2e)});
/// Cyan color shades (50-950).
  static const ColorShades cyan = ColorShades.raw({50 : Color(0xffecfeff), 100 : Color(0xffcffafe), 200 : Color(0xffa5f3fc), 300 : Color(0xff67e8f9), 400 : Color(0xff22d3ee), 500 : Color(0xff06b6d4), 600 : Color(0xff0891b2), 700 : Color(0xff0e7490), 800 : Color(0xff155e75), 900 : Color(0xff164e63), 950 : Color(0xff083344)});
/// Sky color shades (50-950).
  static const ColorShades sky = ColorShades.raw({50 : Color(0xfff0f9ff), 100 : Color(0xffe0f2fe), 200 : Color(0xffbae6fd), 300 : Color(0xff7dd3fc), 400 : Color(0xff38bdf8), 500 : Color(0xff0ea5e9), 600 : Color(0xff0284c7), 700 : Color(0xff0369a1), 800 : Color(0xff075985), 900 : Color(0xff0c4a6e), 950 : Color(0xff082f49)});
/// Blue color shades (50-950).
  static const ColorShades blue = ColorShades.raw({50 : Color(0xffeff6ff), 100 : Color(0xffdbeafe), 200 : Color(0xffbfdbfe), 300 : Color(0xff93c5fd), 400 : Color(0xff60a5fa), 500 : Color(0xff3b82f6), 600 : Color(0xff2563eb), 700 : Color(0xff1d4ed8), 800 : Color(0xff1e40af), 900 : Color(0xff1e3a8a), 950 : Color(0xff172554)});
/// Indigo color shades (50-950).
  static const ColorShades indigo = ColorShades.raw({50 : Color(0xffeef2ff), 100 : Color(0xffe0e7ff), 200 : Color(0xffc7d2fe), 300 : Color(0xffa5b4fc), 400 : Color(0xff818cf8), 500 : Color(0xff6366f1), 600 : Color(0xff4f46e5), 700 : Color(0xff4338ca), 800 : Color(0xff3730a3), 900 : Color(0xff312e81), 950 : Color(0xff1e1b4b)});
/// Violet color shades (50-950).
  static const ColorShades violet = ColorShades.raw({50 : Color(0xfff5f3ff), 100 : Color(0xffede9fe), 200 : Color(0xffddd6fe), 300 : Color(0xffc4b5fd), 400 : Color(0xffa78bfa), 500 : Color(0xff8b5cf6), 600 : Color(0xff7c3aed), 700 : Color(0xff6d28d9), 800 : Color(0xff5b21b6), 900 : Color(0xff4c1d95), 950 : Color(0xff1e1b4b)});
/// Purple color shades (50-950).
  static const ColorShades purple = ColorShades.raw({50 : Color(0xfffaf5ff), 100 : Color(0xfff3e8ff), 200 : Color(0xffe9d5ff), 300 : Color(0xffd8b4fe), 400 : Color(0xffc084fc), 500 : Color(0xffa855f7), 600 : Color(0xff9333ea), 700 : Color(0xff7e22ce), 800 : Color(0xff6b21a8), 900 : Color(0xff581c87), 950 : Color(0xff3b0764)});
/// Fuchsia color shades (50-950).
  static const ColorShades fuchsia = ColorShades.raw({50 : Color(0xfffdf4ff), 100 : Color(0xfffae8ff), 200 : Color(0xfff5d0fe), 300 : Color(0xfff0abfc), 400 : Color(0xffe879f9), 500 : Color(0xffd946ef), 600 : Color(0xffc026d3), 700 : Color(0xffa21caf), 800 : Color(0xff86198f), 900 : Color(0xff701a75), 950 : Color(0xff4a044e)});
/// Pink color shades (50-950).
  static const ColorShades pink = ColorShades.raw({50 : Color(0xfffdf2f8), 100 : Color(0xfffce7f3), 200 : Color(0xfffbcfe8), 300 : Color(0xfff9a8d4), 400 : Color(0xfff472b6), 500 : Color(0xffec4899), 600 : Color(0xffdb2777), 700 : Color(0xffbe185d), 800 : Color(0xff9d174d), 900 : Color(0xff831843), 950 : Color(0xff500724)});
/// Rose color shades (50-950).
  static const ColorShades rose = ColorShades.raw({50 : Color(0xfffff1f2), 100 : Color(0xffffe4e6), 200 : Color(0xfffecdd3), 300 : Color(0xfffda4af), 400 : Color(0xfffb7185), 500 : Color(0xfff43f5e), 600 : Color(0xffe11d48), 700 : Color(0xffbe123c), 800 : Color(0xff9f1239), 900 : Color(0xff881337), 950 : Color(0xff4c0519)});
/// Fully transparent color.
  static const Color transparent = Color(0x00000000);
/// List of primary color swatches from the Material color palette.
///
/// Contains all standard Material Design color shades (slate, gray, zinc,
/// neutral, stone, red, orange, amber, yellow, lime, green, emerald, etc.).
  static List<Color> primaries;
}
/// A chart color scheme that uses a single color for all chart elements.
class SingleChartColorScheme implements ChartColorScheme {
/// The single color used for all chart elements.
  Color color;
/// Creates a single color chart scheme.
  const SingleChartColorScheme(this.color);
  List<Color> get chartColors;
  Color get chart1;
  Color get chart2;
  Color get chart3;
  Color get chart4;
  Color get chart5;
}
/// A color scheme for charts with 5 distinct colors.
///
/// Provides colors for up to 5 different data series in charts.
class ChartColorScheme {
/// The list of chart colors.
  List<Color> chartColors;
/// Creates a chart color scheme with the given colors.
  const ChartColorScheme(this.chartColors);
/// Creates a chart color scheme using a single color for all elements.
  factory ChartColorScheme.single(Color color);
/// Color for the first chart series.
  Color get chart1;
/// Color for the second chart series.
  Color get chart2;
/// Color for the third chart series.
  Color get chart3;
/// Color for the fourth chart series.
  Color get chart4;
/// Color for the fifth chart series.
  Color get chart5;
}
/// A collection of color shades from light to dark.
///
/// Implements both [Color] and [ColorSwatch] to provide a primary color
/// and access to different shade values (50, 100, 200, ..., 950).
class ColorShades implements Color, ColorSwatch {
/// Standard shade values used in color palettes.
///
/// Contains the standard Material Design shade values from lightest (50)
/// to darkest (950): [50, 100, 200, 300, 400, 500, 600, 700, 800, 900, 950].
  static const List<int> shadeValues = [50, 100, 200, 300, 400, 500, 600, 700, 800, 900, 950];
/// Creates color shades from a raw map.
  const ColorShades.raw(this._colors);
/// Creates color shades from a sorted list of colors.
///
/// The list must contain exactly 11 colors corresponding to shades
/// 50, 100, 200, 300, 400, 500, 600, 700, 800, 900, and 950.
  factory ColorShades.sorted(List<Color> colors);
/// Creates color shades from an accent color.
///
/// Generates a full shade range by shifting the accent color's HSL values.
/// [base] is the shade value for the accent color (default: 500).
/// [hueShift], [saturationStepDown], [saturationStepUp], [lightnessStepDown],
/// and [lightnessStepUp] control how shades are generated.
  factory ColorShades.fromAccent(Color accent, {int base = 500, int hueShift = 0, int saturationStepDown = 0, int saturationStepUp = 0, int lightnessStepDown = 8, int lightnessStepUp = 9});
/// Creates color shades from an accent HSL color.
///
/// Similar to [fromAccent] but takes an HSL color directly.
  factory ColorShades.fromAccentHSL(HSLColor accent, {int base = 500, int hueShift = 0, int saturationStepDown = 0, int saturationStepUp = 0, int lightnessStepDown = 8, int lightnessStepUp = 9});
/// Shifts an HSL color to a target shade value.
///
/// Used internally to generate shade variations.
  static HSLColor shiftHSL(HSLColor hsv, int targetBase, {int base = 500, int hueShift = 0, int saturationStepUp = 0, int saturationStepDown = 0, int lightnessStepUp = 9, int lightnessStepDown = 8});
/// Creates color shades from a map of shade values to colors.
///
/// The map must contain all standard shade values (50-950).
  factory ColorShades.fromMap(Map<int, Color> colors);
/// Gets the color for a specific shade value.
  Color get(int key);
/// Gets the lightest shade (50).
  Color get shade50;
/// Gets shade 100.
  Color get shade100;
/// Gets shade 200.
  Color get shade200;
/// Gets shade 300.
  Color get shade300;
/// Gets shade 400.
  Color get shade400;
/// Gets the medium/default shade (500).
  Color get shade500;
/// Gets shade 600.
  Color get shade600;
/// Gets shade 700.
  Color get shade700;
/// Gets shade 800.
  Color get shade800;
/// Gets shade 900.
  Color get shade900;
/// Gets the darkest shade (950).
  Color get shade950;
  int get alpha;
  int get blue;
  double computeLuminance();
  int get green;
  double get opacity;
  int get red;
  int get value;
  ColorShades withAlpha(int a);
  ColorShades withBlue(int b);
  Color withGreen(int g);
  Color withOpacity(double opacity);
  Color withRed(int r);
  Color operator [](index);
  double get a;
  double get b;
  ColorSpace get colorSpace;
  double get g;
  Iterable get keys;
  double get r;
  Color withValues({double? alpha, double? red, double? green, double? blue, ColorSpace? colorSpace});
  int toARGB32();
  int get hashCode;
  bool operator ==(Object other);
}
/// Converts a Flutter [Color] to hexadecimal string representation.
///
/// Returns a hex string with hash prefix (e.g., "#RRGGBB" or "#AARRGGBB").
///
/// Parameters:
/// - [color] (Color, required): Color to convert
///
/// Returns hex string representation.
String hexFromColor(Color color);
/// The color scheme for shadcn_flutter applications.
///
/// Defines all the semantic colors used throughout the app including
/// background, foreground, primary, secondary, destructive colors, etc.
/// Also includes chart colors.
class ColorScheme implements ChartColorScheme {
/// Returns the color scheme for the given context.
///
/// Parameters:
/// - [context] (BuildContext, required): The build context.
///
/// Returns the color scheme for the given context.
  static ColorScheme of(BuildContext context);
/// Set of recognized color key names for the color scheme.
///
/// Contains all valid color property names that can be used when
/// constructing or serializing a ColorScheme.
  static const Set<String> colorKeys = {'background', 'foreground', 'card', 'cardForeground', 'popover', 'popoverForeground', 'primary', 'primaryForeground', 'secondary', 'secondaryForeground', 'muted', 'mutedForeground', 'accent', 'accentForeground', 'destructive', 'destructiveForeground', 'border', 'input', 'ring', 'chart1', 'chart2', 'chart3', 'chart4', 'chart5'};
/// The brightness of this color scheme (light or dark).
  Brightness brightness;
/// The background color.
  Color background;
/// The foreground color (typically text).
  Color foreground;
/// The card background color.
  Color card;
/// The card foreground color.
  Color cardForeground;
/// The popover background color.
  Color popover;
/// The popover foreground color.
  Color popoverForeground;
/// The primary brand color.
  Color primary;
/// The foreground color for primary elements.
  Color primaryForeground;
/// The secondary color.
  Color secondary;
/// The foreground color for secondary elements.
  Color secondaryForeground;
/// The muted background color.
  Color muted;
/// The muted foreground color.
  Color mutedForeground;
/// The accent color.
  Color accent;
/// The foreground color for accented elements.
  Color accentForeground;
/// The destructive action color (typically red).
  Color destructive;
/// The foreground color for destructive elements.
  Color destructiveForeground;
/// The border color.
  Color border;
/// The input field border color.
  Color input;
/// The focus ring color.
  Color ring;
  Color chart1;
  Color chart2;
  Color chart3;
  Color chart4;
  Color chart5;
/// Creates a color scheme with all required colors.
  const ColorScheme({required this.brightness, required this.background, required this.foreground, required this.card, required this.cardForeground, required this.popover, required this.popoverForeground, required this.primary, required this.primaryForeground, required this.secondary, required this.secondaryForeground, required this.muted, required this.mutedForeground, required this.accent, required this.accentForeground, required this.destructive, this.destructiveForeground = Colors.transparent, required this.border, required this.input, required this.ring, required this.chart1, required this.chart2, required this.chart3, required this.chart4, required this.chart5});
/// Creates a color scheme from a map of color names to values.
  ColorScheme.fromMap(Map<String, dynamic> map);
/// Converts the color scheme to a map of hex color strings.
///
/// Returns a map where keys are color property names and values are
/// hex-encoded color strings (e.g., "#RRGGBB").
///
/// Useful for serialization or CSS generation.
  Map<String, String> toMap();
/// Converts the color scheme to a map of Color objects.
///
/// Returns a map where keys are color property names and values are
/// Flutter Color objects.
///
/// Useful for programmatic color access.
  Map<String, Color> toColorMap();
/// Creates a ColorScheme from a map of colors.
///
/// Constructs a ColorScheme by looking up color values from a map.
///
/// Parameters:
/// - [colors] (`Map<String, Color>`, required): Map of color name to Color
/// - [brightness] (Brightness, required): Theme brightness (light or dark)
///
/// Example:
/// ```dart
/// ColorScheme.fromColors(
///   colors: {'background': Colors.white, 'foreground': Colors.black, ...},
///   brightness: Brightness.light,
/// )
/// ```
  ColorScheme.fromColors({required Map<String, Color> colors, required Brightness brightness});
/// Creates a copy of this ColorScheme with specified properties replaced.
///
/// Returns a new ColorScheme with any provided properties replaced.
/// Uses ValueGetter for each property to allow lazy evaluation.
///
/// Parameters are ValueGetters for all color scheme properties. Only
/// provided parameters will be replaced in the copy.
///
/// Example:
/// ```dart
/// scheme.copyWith(
///   background: () => Colors.white,
///   foreground: () => Colors.black,
/// )
/// ```
  ColorScheme copyWith({ValueGetter<Brightness>? brightness, ValueGetter<Color>? background, ValueGetter<Color>? foreground, ValueGetter<Color>? card, ValueGetter<Color>? cardForeground, ValueGetter<Color>? popover, ValueGetter<Color>? popoverForeground, ValueGetter<Color>? primary, ValueGetter<Color>? primaryForeground, ValueGetter<Color>? secondary, ValueGetter<Color>? secondaryForeground, ValueGetter<Color>? muted, ValueGetter<Color>? mutedForeground, ValueGetter<Color>? accent, ValueGetter<Color>? accentForeground, ValueGetter<Color>? destructive, ValueGetter<Color>? destructiveForeground, ValueGetter<Color>? border, ValueGetter<Color>? input, ValueGetter<Color>? ring, ValueGetter<Color>? chart1, ValueGetter<Color>? chart2, ValueGetter<Color>? chart3, ValueGetter<Color>? chart4, ValueGetter<Color>? chart5});
  List<Color> get chartColors;
/// Linearly interpolates between two ColorSchemes.
///
/// Creates a new ColorScheme that represents a transition between [a] and [b]
/// at position [t]. When t=0, returns [a]; when t=1, returns [b].
///
/// Parameters:
/// - [a] (ColorScheme, required): Start color scheme
/// - [b] (ColorScheme, required): End color scheme
/// - [t] (double, required): Interpolation position (0.0 to 1.0)
///
/// Returns interpolated ColorScheme.
  static ColorScheme lerp(ColorScheme a, ColorScheme b, double t);
  bool operator ==(Object other);
  int get hashCode;
  String toString();
}
/// Helpers for deriving accent variants from a base [ColorScheme].
extension ColorSchemeRecolorExtension on ColorScheme {
/// Returns a copy of this scheme using [primary] as the accent color.
  ColorScheme recolor(Color primary);
/// Returns a slate-accented scheme.
  ColorScheme get slate;
/// Returns a gray-accented scheme.
  ColorScheme get gray;
/// Returns a zinc-accented scheme.
  ColorScheme get zinc;
/// Returns a neutral-accented scheme.
  ColorScheme get neutral;
/// Returns a stone-accented scheme.
  ColorScheme get stone;
/// Returns a red-accented scheme.
  ColorScheme get red;
/// Returns an orange-accented scheme.
  ColorScheme get orange;
/// Returns an amber-accented scheme.
  ColorScheme get amber;
/// Returns a yellow-accented scheme.
  ColorScheme get yellow;
/// Returns a lime-accented scheme.
  ColorScheme get lime;
/// Returns a green-accented scheme.
  ColorScheme get green;
/// Returns an emerald-accented scheme.
  ColorScheme get emerald;
/// Returns a teal-accented scheme.
  ColorScheme get teal;
/// Returns a cyan-accented scheme.
  ColorScheme get cyan;
/// Returns a sky-accented scheme.
  ColorScheme get sky;
/// Returns a blue-accented scheme.
  ColorScheme get blue;
/// Returns an indigo-accented scheme.
  ColorScheme get indigo;
/// Returns a violet-accented scheme.
  ColorScheme get violet;
/// Returns a purple-accented scheme.
  ColorScheme get purple;
/// Returns a fuchsia-accented scheme.
  ColorScheme get fuchsia;
/// Returns a pink-accented scheme.
  ColorScheme get pink;
/// Returns a rose-accented scheme.
  ColorScheme get rose;
}
/// Defines scaling behavior for adaptive layouts.
///
/// Provides different scaling strategies for text and icons.
class AdaptiveScaling {
/// Default scaling for desktop layouts (1.0).
  static const AdaptiveScaling desktop = AdaptiveScaling();
/// Default scaling for mobile layouts (1.25x).
  static const AdaptiveScaling mobile = AdaptiveScaling(1.25);
/// Scaling factor for border radius.
  double radiusScaling;
/// Scaling factor for component sizes.
  double sizeScaling;
/// Scaling factor for text.
  double textScaling;
/// Creates uniform [AdaptiveScaling] with the same factor for all properties.
///
/// Parameters:
/// - [scaling] (`double`, default: 1): Scaling factor for radius, size, and text.
  const AdaptiveScaling([double scaling = 1]);
/// Creates [AdaptiveScaling] with individual scaling factors.
///
/// Parameters:
/// - [radiusScaling] (`double`, default: 1): Border radius scaling factor.
/// - [sizeScaling] (`double`, default: 1): Size and spacing scaling factor.
/// - [textScaling] (`double`, default: 1): Text and icon scaling factor.
  const AdaptiveScaling.only({this.radiusScaling = 1, this.sizeScaling = 1, this.textScaling = 1});
/// Applies this scaling to a theme.
///
/// Returns a new ThemeData with radius, sizing, typography, and icon theme
/// scaled according to this AdaptiveScaling's factors.
///
/// Parameters:
/// - [theme] (ThemeData, required): Theme to scale
///
/// Returns scaled ThemeData.
  ThemeData scale(ThemeData theme);
/// Linearly interpolates between two AdaptiveScaling instances.
///
/// Creates a new AdaptiveScaling that represents a transition between [a] and [b]
/// at position [t]. When t=0, returns [a]; when t=1, returns [b].
///
/// Parameters:
/// - [a] (AdaptiveScaling, required): Start scaling
/// - [b] (AdaptiveScaling, required): End scaling
/// - [t] (double, required): Interpolation position (0.0 to 1.0)
///
/// Returns interpolated AdaptiveScaling.
  static AdaptiveScaling lerp(AdaptiveScaling a, AdaptiveScaling b, double t);
}
/// A widget that applies adaptive scaling to its descendants.
class AdaptiveScaler extends StatelessWidget {
/// Gets the default adaptive scaling for the current context.
///
/// Returns [AdaptiveScaling.mobile] for iOS/Android platforms,
/// [AdaptiveScaling.desktop] for other platforms.
  static AdaptiveScaling defaultScalingOf(BuildContext context);
/// Gets the default adaptive scaling for the given theme.
///
/// Returns [AdaptiveScaling.mobile] for iOS/Android platforms,
/// [AdaptiveScaling.desktop] for other platforms.
  static AdaptiveScaling defaultScaling(ThemeData theme);
/// The scaling to apply.
  AdaptiveScaling scaling;
/// The widget below this widget in the tree.
  Widget child;
/// Creates an [AdaptiveScaler].
///
/// Parameters:
/// - [scaling] (`AdaptiveScaling`, required): Scaling factors to apply.
/// - [child] (`Widget`, required): Child widget.
  const AdaptiveScaler({super.key, required this.scaling, required this.child});
  Widget build(BuildContext context);
}
/// The theme data for shadcn_flutter.
///
/// Contains all theming information including colors, typography,
/// scaling, and platform-specific settings.
class ThemeData {
/// The color scheme for this theme.
  ColorScheme colorScheme;
/// The typography settings for this theme.
  Typography typography;
/// Base radius multiplier for border radius calculations.
  double radius;
/// Scale factor for sizes and spacing.
  double scaling;
/// Icon theme properties defining icon sizes across different scales.
  IconThemeProperties iconTheme;
/// Default opacity for surface overlays (0.0 to 1.0).
  double? surfaceOpacity;
/// Default blur radius for surface effects.
  double? surfaceBlur;
/// Default setting for feedback on mobile platforms (e.g., iOS, Android, Fuchsia).
  bool? enableFeedback;
/// Density settings that scale spacing and padding.
  Density density;
/// Creates a [ThemeData] with light color scheme.
///
/// Parameters:
/// - [colorScheme] (`ColorScheme`, default: light colors): Color palette.
/// - [radius] (`double`, default: 0.5): Base radius multiplier.
/// - [scaling] (`double`, default: 1): Size scaling factor.
/// - [typography] (`Typography`, default: Geist): Typography settings.
/// - [iconTheme] (`IconThemeProperties`, default: standard sizes): Icon theme.
/// - [platform] (`TargetPlatform?`, optional): Target platform override.
/// - [surfaceOpacity] (`double?`, optional): Surface overlay opacity.
/// - [surfaceBlur] (`double?`, optional): Surface blur radius.
  const ThemeData({this.colorScheme = ColorSchemes.lightSlate, this.radius = 0.5, this.scaling = 1, this.typography = const Typography.geist(), this.iconTheme = const IconThemeProperties(), TargetPlatform? platform, this.surfaceOpacity, this.enableFeedback, this.surfaceBlur, this.density = Density.defaultDensity});
/// Creates a [ThemeData] with dark color scheme.
///
/// Parameters:
/// - [colorScheme] (`ColorScheme`, default: dark colors): Color palette.
/// - [radius] (`double`, default: 0.5): Base radius multiplier.
/// - [scaling] (`double`, default: 1): Size scaling factor.
/// - [typography] (`Typography`, default: Geist): Typography settings.
/// - [iconTheme] (`IconThemeProperties`, default: standard sizes): Icon theme.
/// - [platform] (`TargetPlatform?`, optional): Target platform override.
/// - [surfaceOpacity] (`double?`, optional): Surface overlay opacity.
/// - [surfaceBlur] (`double?`, optional): Surface blur radius.
  const ThemeData.dark({this.colorScheme = ColorSchemes.darkSlate, this.radius = 0.5, this.scaling = 1, this.typography = const Typography.geist(), this.iconTheme = const IconThemeProperties(), TargetPlatform? platform, this.surfaceOpacity, this.surfaceBlur, this.density = Density.defaultDensity, this.enableFeedback});
/// The current platform.
  TargetPlatform get platform;
/// The specified platform, or null if not overridden.
  TargetPlatform? get specifiedPlatform;
/// At normal radius, the scaled radius is 24
  double get radiusXxl;
/// At normal radius, the scaled radius is 20
  double get radiusXl;
/// At normal radius, the scaled radius is 16
  double get radiusLg;
/// At normal radius, the scaled radius is 12
  double get radiusMd;
/// At normal radius, the scaled radius is 8
  double get radiusSm;
/// At normal radius, the scaled radius is 4
  double get radiusXs;
/// Creates a circular border radius using [radiusXxl].
  BorderRadius get borderRadiusXxl;
/// Creates a circular border radius using [radiusXl].
  BorderRadius get borderRadiusXl;
/// Creates a circular border radius using [radiusLg].
  BorderRadius get borderRadiusLg;
/// Creates a circular border radius using [radiusMd].
  BorderRadius get borderRadiusMd;
/// Creates a circular border radius using [radiusSm].
  BorderRadius get borderRadiusSm;
/// Creates a circular border radius using [radiusXs].
  BorderRadius get borderRadiusXs;
/// Creates a circular radius using [radiusXxl].
  Radius get radiusXxlRadius;
/// Creates a circular radius using [radiusXl].
  Radius get radiusXlRadius;
/// Creates a circular radius using [radiusLg].
  Radius get radiusLgRadius;
/// Creates a circular radius using [radiusMd].
  Radius get radiusMdRadius;
/// Creates a circular radius using [radiusSm].
  Radius get radiusSmRadius;
/// Creates a circular radius using [radiusXs].
  Radius get radiusXsRadius;
/// Gets the brightness (light or dark) from the color scheme.
  Brightness get brightness;
/// Creates a copy of this theme with specified properties overridden.
///
/// All parameters are optional getters that provide new values when present.
///
/// Returns: `ThemeData` ‚Äî a new theme with updated values.
  ThemeData copyWith({ValueGetter<ColorScheme>? colorScheme, ValueGetter<double>? radius, ValueGetter<Typography>? typography, ValueGetter<TargetPlatform>? platform, ValueGetter<double>? scaling, ValueGetter<IconThemeProperties>? iconTheme, ValueGetter<double>? surfaceOpacity, ValueGetter<double>? surfaceBlur, ValueGetter<bool?>? enableFeedback, ValueGetter<Density>? density});
/// Linearly interpolates between two theme datas.
///
/// Parameters:
/// - [a] (`ThemeData`, required): Start theme.
/// - [b] (`ThemeData`, required): End theme.
/// - [t] (`double`, required): Interpolation position (0.0 to 1.0).
///
/// Returns: `ThemeData` ‚Äî interpolated theme.
  static ThemeData lerp(ThemeData a, ThemeData b, double t);
  bool operator ==(Object other);
  int get hashCode;
  String toString();
}
/// An inherited widget that provides theme data to its descendants.
class Theme extends InheritedTheme {
/// The theme data to provide to descendants.
  ThemeData data;
/// Creates a [Theme].
///
/// Parameters:
/// - [data] (`ThemeData`, required): Theme data to provide.
/// - [child] (`Widget`, required): Child widget.
  const Theme({super.key, required this.data, required super.child});
/// Gets the [ThemeData] from the closest [Theme] ancestor.
///
/// Throws if no [Theme] is found in the widget tree.
///
/// Returns: `ThemeData` ‚Äî the theme data.
  static ThemeData of(BuildContext context);
  bool updateShouldNotify(covariant Theme oldWidget);
  Widget wrap(BuildContext context, Widget child);
  void debugFillProperties(DiagnosticPropertiesBuilder properties);
}
/// A tween for animating between two [ThemeData] values.
class ThemeDataTween extends Tween<ThemeData> {
/// Creates a [ThemeDataTween].
///
/// Parameters:
/// - [begin] (`ThemeData`, required): Starting theme.
/// - [end] (`ThemeData`, required): Ending theme.
  ThemeDataTween({required ThemeData super.begin, required super.end});
  ThemeData lerp(double t);
}
/// A widget that animates theme changes over time.
class AnimatedTheme extends ImplicitlyAnimatedWidget {
/// The target theme data to animate to.
  ThemeData data;
/// The widget below this widget in the tree.
  Widget child;
/// Creates an [AnimatedTheme].
///
/// Parameters:
/// - [data] (`ThemeData`, required): Target theme.
/// - [duration] (`Duration`, required): Animation duration.
/// - [curve] (`Curve`, optional): Animation curve.
/// - [child] (`Widget`, required): Child widget.
  const AnimatedTheme({super.key, required this.data, required super.duration, super.curve, required this.child});
  AnimatedWidgetBaseState<AnimatedTheme> createState();
}
/// Properties for icon theming.
///
/// Defines size and color for different icon sizes across the theme.
class IconThemeProperties {
/// Icon theme for 4x-small icons (6px).
  IconThemeData x4Small;
/// Icon theme for 3x-small icons (8px).
  IconThemeData x3Small;
/// Icon theme for 2x-small icons (10px).
  IconThemeData x2Small;
/// Icon theme for extra-small icons (12px).
  IconThemeData xSmall;
/// Icon theme for small icons (16px).
  IconThemeData small;
/// Icon theme for medium icons (20px).
  IconThemeData medium;
/// Icon theme for large icons (24px).
  IconThemeData large;
/// Icon theme for extra-large icons (32px).
  IconThemeData xLarge;
/// Icon theme for 2x-large icons (40px).
  IconThemeData x2Large;
/// Icon theme for 3x-large icons (48px).
  IconThemeData x3Large;
/// Icon theme for 4x-large icons (56px).
  IconThemeData x4Large;
/// Creates [IconThemeProperties] with default icon sizes.
///
/// All parameters are optional and default to predefined sizes.
  const IconThemeProperties({this.x4Small = const IconThemeData(size: 6), this.x3Small = const IconThemeData(size: 8), this.x2Small = const IconThemeData(size: 10), this.xSmall = const IconThemeData(size: 12), this.small = const IconThemeData(size: 16), this.medium = const IconThemeData(size: 20), this.large = const IconThemeData(size: 24), this.xLarge = const IconThemeData(size: 32), this.x2Large = const IconThemeData(size: 40), this.x3Large = const IconThemeData(size: 48), this.x4Large = const IconThemeData(size: 56)});
/// Creates a copy with updated icon themes.
///
/// All parameters are optional getters. Omitted values retain their current value.
///
/// Returns: `IconThemeProperties` ‚Äî a new instance with updated values.
  IconThemeProperties copyWith({ValueGetter<IconThemeData>? x4Small, ValueGetter<IconThemeData>? x3Small, ValueGetter<IconThemeData>? x2Small, ValueGetter<IconThemeData>? xSmall, ValueGetter<IconThemeData>? small, ValueGetter<IconThemeData>? medium, ValueGetter<IconThemeData>? large, ValueGetter<IconThemeData>? xLarge, ValueGetter<IconThemeData>? x2Large, ValueGetter<IconThemeData>? x3Large, ValueGetter<IconThemeData>? x4Large});
/// Scales all icon sizes by the given factor.
///
/// Parameters:
/// - [factor] (`double`, required): Scaling factor to apply.
///
/// Returns: `IconThemeProperties` ‚Äî scaled icon theme properties.
  IconThemeProperties scale(double factor);
/// Linearly interpolates between two icon theme properties.
///
/// Parameters:
/// - [a] (`IconThemeProperties`, required): Start properties.
/// - [b] (`IconThemeProperties`, required): End properties.
/// - [t] (`double`, required): Interpolation position (0.0 to 1.0).
///
/// Returns: `IconThemeProperties` ‚Äî interpolated properties.
  static IconThemeProperties lerp(IconThemeProperties a, IconThemeProperties b, double t);
  bool operator ==(Object other);
  int get hashCode;
  String toString();
}
/// A base class for component-specific theme data.
///
/// This class is used as a base class for component-specific theme data,
/// whether as super class or as interface.
abstract class ComponentThemeData {
/// Creates a [ComponentThemeData].
  const ComponentThemeData();
}
/// An inherited widget that provides component-specific theme data.
///
/// Allows components to provide custom theme data that overrides or extends
/// the global theme. The type parameter `T` specifies the theme data type.
///
/// Example:
/// ```dart
/// ComponentTheme<ButtonTheme>(
///   data: ButtonTheme(backgroundColor: Colors.blue),
///   child: MyButton(),
/// )
/// ```
class ComponentTheme<T extends ComponentThemeData> extends InheritedTheme {
/// The component theme data to provide to descendants.
  T data;
/// Creates a [ComponentTheme].
///
/// Parameters:
/// - [data] (`T`, required): Theme data for this component type.
/// - [child] (`Widget`, required): Child widget.
  const ComponentTheme({super.key, required this.data, required super.child});
  Widget wrap(BuildContext context, Widget child);
/// Gets the component theme data of type `T` from the closest ancestor.
///
/// Throws if no [ComponentTheme] of type `T` is found.
///
/// Returns: `T` ‚Äî the component theme data.
  static T of<T extends ComponentThemeData>(BuildContext context);
/// Gets the component theme data of type `T` from the closest ancestor.
///
/// Returns `null` if no [ComponentTheme] of type `T` is found.
///
/// Returns: `T?` ‚Äî the component theme data, or null.
  static T? maybeOf<T extends ComponentThemeData>(BuildContext context);
  bool updateShouldNotify(covariant ComponentTheme<T> oldWidget);
}
/// Determines which theme mode to use.
///
/// - `system`: Follow system theme preference
/// - `light`: Always use light theme
/// - `dark`: Always use dark theme
enum ThemeMode { system, light, dark }
/// Theme extension for [BuildContext]
extension ThemeExtension on BuildContext {
/// Get the theme data
  ThemeData get theme;
/// Get component theme
  T? componentTheme<T extends ComponentThemeData>();
}
/// 2x extra small padding multiplier (0.25).
///
/// At default density (base 16px), produces ~4px padding.
const padX2s = 0.25;
/// Extra small padding multiplier (0.5).
///
/// At default density (base 16px), produces ~8px padding.
const padXs = 0.5;
/// Small padding multiplier (1.0).
///
/// At default density (base 16px), produces ~16px padding.
const padSm = 1.0;
/// Medium padding multiplier (1.5).
///
/// At default density (base 16px), produces ~24px padding.
const padMd = 1.5;
/// Standard/large padding multiplier (2.0).
///
/// At default density (base 16px), produces 32px padding.
/// This is the baseline multiplier for normal spacing.
const padLg = 2.0;
/// Extra large padding multiplier (2.5).
///
/// At default density (base 16px), produces ~40px padding.
const padXl = 2.5;
/// 2x extra large padding multiplier (3.0).
///
/// At default density (base 16px), produces ~48px padding.
const pad2xl = 3.0;
/// 3x extra large padding multiplier (3.5).
///
/// At default density (base 16px), produces ~56px padding.
const pad3xl = 3.5;
/// 4x extra large padding multiplier (4.0).
///
/// At default density (base 16px), produces ~64px padding.
const pad4xl = 4.0;
/// Extra small gap multiplier (0.5).
///
/// At default density (base 8px), produces ~4px gap.
const gapXs = 0.5;
/// Small gap multiplier (1.0).
///
/// At default density (base 8px), produces ~8px gap.
const gapSm = 1.0;
/// Medium gap multiplier (1.5).
///
/// At default density (base 8px), produces ~12px gap.
const gapMd = 1.5;
/// Standard/large gap multiplier (2.0).
///
/// At default density (base 8px), produces 16px gap.
/// This is the baseline multiplier for normal spacing.
const gapLg = 2.0;
/// Extra large gap multiplier (2.5).
///
/// At default density (base 8px), produces ~20px gap.
const gapXl = 2.5;
/// 2x extra large gap multiplier (3.0).
///
/// At default density (base 8px), produces ~24px gap.
const gap2xl = 3.0;
/// 3x extra large gap multiplier (3.5).
///
/// At default density (base 8px), produces ~28px gap.
const gap3xl = 3.5;
/// 4x extra large gap multiplier (4.0).
///
/// At default density (base 8px), produces ~32px gap.
const gap4xl = 4.0;
/// Defines density settings for spacing throughout the UI.
///
/// [Density] provides base values that are multiplied by padding constants
/// (e.g., [padXs], [padSm], [padLg]) to produce final pixel values.
/// This allows consistent scaling of all spacing when switching density modes.
///
/// There are two types of padding:
/// - **Container padding**: Used for widgets that contain multiple children
///   (e.g., Card, AlertDialog, ListView panels)
/// - **Content padding**: Used for widgets that contain content
///   (e.g., Button, TextField, Chip)
///
/// Example:
/// ```dart
/// // Apply compact density to reduce spacing
/// Theme(
///   data: ThemeData(density: Density.compactDensity),
///   child: MyApp(),
/// )
/// ```
class Density {
/// Linearly interpolates between two density settings.
///
/// Parameters:
/// - [a] (`Density`, required): The starting density.
/// - [b] (`Density`, required): The ending density.
/// - [t] (`double`, required): The interpolation factor (0.0 to 1.0).
  static Density lerp(Density a, Density b, double t);
/// Default density with standard spacing (16px base).
  static const defaultDensity = Density(baseContainerPadding: 16.0, baseGap: 8.0, baseContentPadding: 16.0);
/// Reduced density for slightly more compact layouts (12px base).
  static const reducedDensity = Density(baseContainerPadding: 12.0, baseGap: 6.0, baseContentPadding: 12.0);
/// Spacious density for more generous spacing (20px base).
  static const spaciousDensity = Density(baseContainerPadding: 20.0, baseGap: 10.0, baseContentPadding: 20.0);
/// Compact density for maximizing content density (8px base).
  static const compactDensity = Density(baseContainerPadding: 8.0, baseGap: 4.0, baseContentPadding: 8.0);
/// Base padding for container widgets (Card, AlertDialog, etc.).
  double baseContainerPadding;
/// Base gap between items in rows, columns, and flex layouts.
  double baseGap;
/// Base padding for content widgets (Button, TextField, etc.).
  double baseContentPadding;
/// Creates a [Density] with custom base values.
///
/// Parameters:
/// - [baseContainerPadding] (`double`, required): Base padding for containers.
/// - [baseGap] (`double`, required): Base gap between items.
/// - [baseContentPadding] (`double`, required): Base padding for content.
  const Density({required this.baseContainerPadding, required this.baseGap, required this.baseContentPadding});
/// Creates a copy of this density with the specified values replaced.
  Density copyWith({ValueGetter<double>? baseContainerPadding, ValueGetter<double>? baseGap, ValueGetter<double>? baseContentPadding});
  String toString();
  bool operator ==(Object other);
  int get hashCode;
}
/// Interface for edge insets that can be resolved using density settings.
///
/// Implement this interface to create custom density-aware edge insets.
/// Use [DirectionalEdgeInsetsDensity] for RTL-aware insets or
/// [EdgeInsetsDensity] for fixed left/right insets.
abstract class DensityEdgeInsetsGeometry extends EdgeInsetsGeometry {
/// Resolves the density multipliers to actual pixel values.
///
/// Parameters:
/// - [basePadding] (`double`, required): The base padding from [Density].
  EdgeInsetsGeometry resolveDensity(double basePadding);
}
/// Direction-aware density edge insets using start/end instead of left/right.
///
/// Use this for RTL-aware layouts. The [start] and [end] values are
/// multipliers that will be multiplied by the base padding from [Density].
///
/// Example:
/// ```dart
/// // Creates padding that adapts to density and text direction
/// const DirectionalEdgeInsetsDensity.symmetric(
///   horizontal: padLg,  // 1.0 * basePadding on start and end
///   vertical: padSm,    // 0.5 * basePadding on top and bottom
/// )
/// ```
class DirectionalEdgeInsetsDensity extends EdgeInsetsDirectional implements DensityEdgeInsetsGeometry {
/// Creates directional density insets with individual values.
///
/// All values default to 0.0 (no padding).
  const DirectionalEdgeInsetsDensity.only({super.start = 0.0, super.top = 0.0, super.end = 0.0, super.bottom = 0.0});
/// Creates directional density insets with the same value on all sides.
  const DirectionalEdgeInsetsDensity.all(super.value);
/// Creates directional density insets with symmetric values.
  const DirectionalEdgeInsetsDensity.symmetric({super.vertical = 0.0, super.horizontal = 0.0});
  EdgeInsetsDirectional resolveDensity(double basePadding);
  DirectionalEdgeInsetsDensity copyWith({double? start, double? top, double? end, double? bottom});
}
/// Fixed direction density edge insets using left/right.
///
/// Use this when direction is fixed (not RTL-aware). Values are multipliers
/// that will be multiplied by the base padding from [Density].
///
/// Example:
/// ```dart
/// // Creates fixed padding that adapts to density
/// const EdgeInsetsDensity.symmetric(
///   horizontal: padLg,  // 1.0 * basePadding on left and right
///   vertical: padSm,    // 0.5 * basePadding on top and bottom
/// )
/// ```
class EdgeInsetsDensity extends EdgeInsets implements DensityEdgeInsetsGeometry {
/// Creates density insets with individual values.
  const EdgeInsetsDensity.only({super.left = 0.0, super.top = 0.0, super.right = 0.0, super.bottom = 0.0});
/// Creates density insets with the same value on all sides.
  const EdgeInsetsDensity.all(super.value);
/// Creates density insets with symmetric values.
  const EdgeInsetsDensity.symmetric({super.vertical = 0.0, super.horizontal = 0.0});
  EdgeInsets resolveDensity(double basePadding);
  EdgeInsetsDensity copyWith({double? left, double? top, double? right, double? bottom});
}
/// Resolves [EdgeInsetsGeometry] using the appropriate density base.
///
/// If [padding] implements [DensityEdgeInsetsGeometry], it is resolved
/// using [basePadding]. Otherwise, the original padding is returned unchanged.
///
/// This function is used internally by density widgets to resolve padding.
EdgeInsetsGeometry resolveEdgeInsets(EdgeInsetsGeometry padding, double basePadding);
/// A padding widget that resolves density insets using content padding base.
///
/// Use this for widgets that contain content (buttons, text fields, chips).
/// The padding is resolved using [Density.baseContentPadding].
///
/// Example:
/// ```dart
/// DensityContentPadding(
///   padding: const DirectionalEdgeInsetsDensity.symmetric(
///     horizontal: padLg,
///     vertical: padSm,
///   ),
///   child: Text('Button content'),
/// )
/// ```
class DensityContentPadding extends StatelessWidget {
/// The padding to apply, can be density-aware or absolute.
  EdgeInsetsGeometry padding;
/// The child widget to apply padding to.
  Widget child;
/// Creates a [DensityContentPadding].
///
/// Parameters:
/// - [padding] (`EdgeInsetsGeometry`, required): The padding specification.
/// - [child] (`Widget`, required): The child to wrap with padding.
  const DensityContentPadding({super.key, required this.padding, required this.child});
  Widget build(BuildContext context);
}
/// A padding widget that resolves density insets using container padding base.
///
/// Use this for widgets that contain multiple children (cards, dialogs, panels).
/// The padding is resolved using [Density.baseContainerPadding].
///
/// Example:
/// ```dart
/// DensityContainerPadding(
///   padding: const DirectionalEdgeInsetsDensity.all(padLg),
///   child: Column(children: [...]),
/// )
/// ```
class DensityContainerPadding extends StatelessWidget {
/// The padding to apply, can be density-aware or absolute.
  EdgeInsetsGeometry padding;
/// The child widget to apply padding to.
  Widget child;
/// Creates a [DensityContainerPadding].
///
/// Parameters:
/// - [padding] (`EdgeInsetsGeometry`, required): The padding specification.
/// - [child] (`Widget`, required): The child to wrap with padding.
  const DensityContainerPadding({super.key, required this.padding, required this.child});
  Widget build(BuildContext context);
}
/// A gap widget that resolves spacing using density settings.
///
/// Use this instead of [Gap] when you want spacing to adapt to density.
/// The [gap] value is a multiplier applied to [Density.baseGap].
///
/// Example:
/// ```dart
/// Column(
///   children: [
///     Text('First'),
///     DensityGap(gap: gapLg),  // Gap adapts to density
///     Text('Second'),
///   ],
/// )
/// ```
class DensityGap extends StatelessWidget {
/// The gap multiplier, applied to [Density.baseGap].
  double gap;
/// Creates a [DensityGap].
///
/// Parameters:
/// - [gap] (`double`, required): Gap multiplier (use constants like [gapLg]).
  const DensityGap(this.gap, {super.key});
  Widget build(BuildContext context);
}
/// A row widget with density-aware spacing between children.
///
/// Use instead of [Row] when you want the spacing to adapt to density settings.
/// The [spacing] value is a multiplier applied to [Density.baseGap].
///
/// Example:
/// ```dart
/// DensityRow(
///   spacing: padLg,
///   children: [
///     Icon(Icons.star),
///     Text('Rating'),
///   ],
/// )
/// ```
class DensityRow extends StatelessWidget {
/// The spacing multiplier between children.
  double spacing;
/// The children widgets.
  List<Widget> children;
/// How the children should be placed along the main axis.
  MainAxisAlignment mainAxisAlignment;
/// How the children should be placed along the cross axis.
  CrossAxisAlignment crossAxisAlignment;
/// How much space should be occupied in the main axis.
  MainAxisSize mainAxisSize;
/// The text direction to use for rendering.
  TextDirection? textDirection;
/// The vertical direction to use for layout.
  VerticalDirection verticalDirection;
/// The baseline to use for aligning children.
  TextBaseline? textBaseline;
/// Creates a [DensityRow].
///
/// Parameters:
/// - [spacing] (`double`, default: 0): Gap multiplier between children.
/// - [children] (`List<Widget>`, required): The row's children.
  const DensityRow({super.key, this.spacing = 0, required this.children, this.mainAxisAlignment = MainAxisAlignment.start, this.crossAxisAlignment = CrossAxisAlignment.center, this.mainAxisSize = MainAxisSize.max, this.textDirection, this.verticalDirection = VerticalDirection.down, this.textBaseline});
  Widget build(BuildContext context);
}
/// A column widget with density-aware spacing between children.
///
/// Use instead of [Column] when you want the spacing to adapt to density.
/// The [spacing] value is a multiplier applied to [Density.baseGap].
///
/// Example:
/// ```dart
/// DensityColumn(
///   spacing: padMd,
///   children: [
///     Text('Title'),
///     Text('Subtitle'),
///   ],
/// )
/// ```
class DensityColumn extends StatelessWidget {
/// The spacing multiplier between children.
  double spacing;
/// The children widgets.
  List<Widget> children;
/// How the children should be placed along the main axis.
  MainAxisAlignment mainAxisAlignment;
/// How the children should be placed along the cross axis.
  CrossAxisAlignment crossAxisAlignment;
/// How much space should be occupied in the main axis.
  MainAxisSize mainAxisSize;
/// The text direction to use for rendering.
  TextDirection? textDirection;
/// The vertical direction to use for layout.
  VerticalDirection verticalDirection;
/// The baseline to use for aligning children.
  TextBaseline? textBaseline;
/// Creates a [DensityColumn].
///
/// Parameters:
/// - [spacing] (`double`, default: 0): Gap multiplier between children.
/// - [children] (`List<Widget>`, required): The column's children.
  const DensityColumn({super.key, this.spacing = 0, required this.children, this.mainAxisAlignment = MainAxisAlignment.start, this.crossAxisAlignment = CrossAxisAlignment.center, this.mainAxisSize = MainAxisSize.max, this.textDirection, this.verticalDirection = VerticalDirection.down, this.textBaseline});
  Widget build(BuildContext context);
}
/// A flex widget with density-aware spacing between children.
///
/// Use instead of [Flex] when you want the spacing to adapt to density.
/// The [spacing] value is a multiplier applied to [Density.baseGap].
///
/// Example:
/// ```dart
/// DensityFlex(
///   direction: Axis.horizontal,
///   spacing: padSm,
///   children: [
///     Chip(label: Text('Tag 1')),
///     Chip(label: Text('Tag 2')),
///   ],
/// )
/// ```
class DensityFlex extends StatelessWidget {
/// The direction to use as the main axis.
  Axis direction;
/// The spacing multiplier between children.
  double spacing;
/// The children widgets.
  List<Widget> children;
/// How the children should be placed along the main axis.
  MainAxisAlignment mainAxisAlignment;
/// How the children should be placed along the cross axis.
  CrossAxisAlignment crossAxisAlignment;
/// How much space should be occupied in the main axis.
  MainAxisSize mainAxisSize;
/// The text direction to use for rendering.
  TextDirection? textDirection;
/// The vertical direction to use for layout.
  VerticalDirection verticalDirection;
/// The baseline to use for aligning children.
  TextBaseline? textBaseline;
/// The clip behavior of the flex widget.
  Clip clipBehavior;
/// Creates a [DensityFlex].
///
/// Parameters:
/// - [direction] (`Axis`, required): The main axis direction.
/// - [spacing] (`double`, default: 0): Gap multiplier between children.
/// - [children] (`List<Widget>`, required): The flex's children.
  const DensityFlex({super.key, required this.direction, this.spacing = 0, required this.children, this.mainAxisAlignment = MainAxisAlignment.start, this.crossAxisAlignment = CrossAxisAlignment.center, this.mainAxisSize = MainAxisSize.max, this.textDirection, this.verticalDirection = VerticalDirection.down, this.textBaseline, this.clipBehavior = Clip.none});
  Widget build(BuildContext context);
}
/// Legacy color schemes using HSL color definitions.
///
/// These color schemes use HSL (Hue, Saturation, Lightness) for color definition
/// and are provided for backward compatibility. New code should prefer
/// using the RGB-based [ColorSchemes] class.
class LegacyColorSchemes {
/// Returns light zinc color scheme.
  static ColorScheme lightZinc();
/// Returns dark zinc color scheme.
  static ColorScheme darkZinc();
/// Returns zinc color scheme for the given [mode].
///
/// The [mode] must be either [ThemeMode.light] or [ThemeMode.dark].
/// [ThemeMode.system] is not supported.
  static ColorScheme zinc(ThemeMode mode);
/// Returns light slate color scheme.
  static ColorScheme lightSlate();
/// Returns dark slate color scheme.
  static ColorScheme darkSlate();
/// Returns slate color scheme for the given [mode].
///
/// The [mode] must be either [ThemeMode.light] or [ThemeMode.dark].
/// [ThemeMode.system] is not supported.
  static ColorScheme slate(ThemeMode mode);
/// Returns light stone color scheme.
  static ColorScheme lightStone();
/// Returns dark stone color scheme.
  static ColorScheme darkStone();
/// Returns stone color scheme for the given [mode].
///
/// The [mode] must be either [ThemeMode.light] or [ThemeMode.dark].
/// [ThemeMode.system] is not supported.
  static ColorScheme stone(ThemeMode mode);
/// Returns light gray color scheme.
  static ColorScheme lightGray();
/// Returns dark gray color scheme.
  static ColorScheme darkGray();
/// Returns gray color scheme for the given [mode].
///
/// The [mode] must be either [ThemeMode.light] or [ThemeMode.dark].
/// [ThemeMode.system] is not supported.
  static ColorScheme gray(ThemeMode mode);
/// Returns light neutral color scheme.
  static ColorScheme lightNeutral();
/// Returns dark neutral color scheme.
  static ColorScheme darkNeutral();
/// Returns neutral color scheme for the given [mode].
///
/// The [mode] must be either [ThemeMode.light] or [ThemeMode.dark].
/// [ThemeMode.system] is not supported.
  static ColorScheme neutral(ThemeMode mode);
/// Returns light red color scheme.
  static ColorScheme lightRed();
/// Returns dark red color scheme.
  static ColorScheme darkRed();
/// Returns red color scheme for the given [mode].
///
/// The [mode] must be either [ThemeMode.light] or [ThemeMode.dark].
/// [ThemeMode.system] is not supported.
  static ColorScheme red(ThemeMode mode);
/// Returns light rose color scheme.
  static ColorScheme lightRose();
/// Returns dark rose color scheme.
  static ColorScheme darkRose();
/// Returns rose color scheme for the given [mode].
///
/// The [mode] must be either [ThemeMode.light] or [ThemeMode.dark].
/// [ThemeMode.system] is not supported.
  static ColorScheme rose(ThemeMode mode);
/// Returns light orange color scheme.
  static ColorScheme lightOrange();
/// Returns dark orange color scheme.
  static ColorScheme darkOrange();
/// Returns orange color scheme for the given [mode].
///
/// The [mode] must be either [ThemeMode.light] or [ThemeMode.dark].
/// [ThemeMode.system] is not supported.
  static ColorScheme orange(ThemeMode mode);
/// Returns light green color scheme.
  static ColorScheme lightGreen();
/// Returns dark green color scheme.
  static ColorScheme darkGreen();
/// Returns green color scheme for the given [mode].
///
/// The [mode] must be either [ThemeMode.light] or [ThemeMode.dark].
/// [ThemeMode.system] is not supported.
  static ColorScheme green(ThemeMode mode);
/// Returns light blue color scheme.
  static ColorScheme lightBlue();
/// Returns dark blue color scheme.
  static ColorScheme darkBlue();
/// Returns blue color scheme for the given [mode].
///
/// The [mode] must be either [ThemeMode.light] or [ThemeMode.dark].
/// [ThemeMode.system] is not supported.
  static ColorScheme blue(ThemeMode mode);
/// Returns light yellow color scheme.
  static ColorScheme lightYellow();
/// Returns dark yellow color scheme.
  static ColorScheme darkYellow();
/// Returns yellow color scheme for the given [mode].
///
/// The [mode] must be either [ThemeMode.light] or [ThemeMode.dark].
/// [ThemeMode.system] is not supported.
  static ColorScheme yellow(ThemeMode mode);
/// Returns light violet color scheme.
  static ColorScheme lightViolet();
/// Returns dark violet color scheme.
  static ColorScheme darkViolet();
/// Returns violet color scheme for the given [mode].
///
/// The [mode] must be either [ThemeMode.light] or [ThemeMode.dark].
/// [ThemeMode.system] is not supported.
  static ColorScheme violet(ThemeMode mode);
}
/// Configuration for file size unit formatting.
///
/// Defines the base (1024 for binary) and unit labels for formatting
/// file sizes and data volumes.
class SizeUnitLocale {
/// Base for unit conversion (typically 1024 for binary units).
  int base;
/// List of unit labels (e.g., ['B', 'KB', 'MB', 'GB']).
  List<String> units;
/// Separator for digit grouping (e.g., ',' for 1,000,000).
  String separator;
/// Creates a [SizeUnitLocale].
///
/// Parameters:
/// - [base] (`int`, required): Base for unit conversion.
/// - [units] (`List<String>`, required): Unit labels.
/// - [separator] (`String`, default: ','): Digit separator.
  const SizeUnitLocale(this.base, this.units, {this.separator = ','});
/// Standard file size units in bytes (B, KB, MB, GB, etc.).
  static const SizeUnitLocale fileBytes = _fileByteUnits;
/// Binary file size units (Bi, KiB, MiB, GiB, etc.).
  static const SizeUnitLocale fileBits = _fileBitUnits;
/// Gets the appropriate unit label for a value.
///
/// Parameters:
/// - [value] (`int`, required): The value to get unit for.
///
/// Returns: `String` ‚Äî the unit label.
  String getUnit(int value);
}
/// Formats a file size in bytes to a human-readable string.
///
/// Converts byte values to appropriate units (B, KB, MB, GB, etc.) based
/// on the provided locale unit configuration.
///
/// Parameters:
/// - [bytes] (`int`, required): File size in bytes.
/// - [unit] (`SizeUnitLocale`, required): Unit locale configuration.
///
/// Returns: `String` ‚Äî formatted file size with unit.
///
/// Example:
/// ```dart
/// formatFileSize(1024, SizeUnitLocale.fileBytes) // "1 KB"
/// formatFileSize(1536, SizeUnitLocale.fileBytes) // "1.5 KB"
/// ```
String formatFileSize(int bytes, SizeUnitLocale unit);
/// Represents a part of a date (year, month, or day).
///
/// Provides metadata and operations for individual date components.
enum DatePart { year, month, day }
/// Represents a part of a duration (day, hour, minute, or second).
enum DurationPart { day, hour, minute, second }
/// Represents a part of a time (hour, minute, or second).
enum TimePart { hour, minute, second }
/// The translations for English (`en`).
class ShadcnLocalizationsEn extends ShadcnLocalizations {
  ShadcnLocalizationsEn([String locale = 'en']);
  String get formNotEmpty;
  String get invalidValue;
  String get invalidEmail;
  String get invalidURL;
  String formLessThan(double value);
  String formGreaterThan(double value);
  String formLessThanOrEqualTo(double value);
  String formGreaterThanOrEqualTo(double value);
  String formBetweenInclusively(double min, double max);
  String formBetweenExclusively(double min, double max);
  String formLengthLessThan(int value);
  String formLengthGreaterThan(int value);
  String get formPasswordDigits;
  String get formPasswordLowercase;
  String get formPasswordUppercase;
  String get formPasswordSpecial;
  String get commandSearch;
  String get commandEmpty;
  String get datePickerSelectYear;
  String get abbreviatedMonday;
  String get abbreviatedTuesday;
  String get abbreviatedWednesday;
  String get abbreviatedThursday;
  String get abbreviatedFriday;
  String get abbreviatedSaturday;
  String get abbreviatedSunday;
  String get monthJanuary;
  String get monthFebruary;
  String get monthMarch;
  String get monthApril;
  String get monthMay;
  String get monthJune;
  String get monthJuly;
  String get monthAugust;
  String get monthSeptember;
  String get monthOctober;
  String get monthNovember;
  String get monthDecember;
  String get abbreviatedJanuary;
  String get abbreviatedFebruary;
  String get abbreviatedMarch;
  String get abbreviatedApril;
  String get abbreviatedMay;
  String get abbreviatedJune;
  String get abbreviatedJuly;
  String get abbreviatedAugust;
  String get abbreviatedSeptember;
  String get abbreviatedOctober;
  String get abbreviatedNovember;
  String get abbreviatedDecember;
  String get buttonCancel;
  String get buttonSave;
  String get timeHour;
  String get timeMinute;
  String get timeSecond;
  String get timeAM;
  String get timePM;
  String get colorRed;
  String get colorGreen;
  String get colorBlue;
  String get colorAlpha;
  String get colorHue;
  String get colorSaturation;
  String get colorValue;
  String get colorLightness;
  String get menuCut;
  String get menuCopy;
  String get menuPaste;
  String get menuSelectAll;
  String get menuUndo;
  String get menuRedo;
  String get menuDelete;
  String get menuShare;
  String get menuSearchWeb;
  String get menuLiveTextInput;
  String get placeholderDatePicker;
  String get placeholderTimePicker;
  String get placeholderColorPicker;
  String get buttonPrevious;
  String get buttonNext;
  String get refreshTriggerPull;
  String get refreshTriggerRelease;
  String get refreshTriggerRefreshing;
  String get refreshTriggerComplete;
  String get colorPickerTabRecent;
  String get colorPickerTabRGB;
  String get colorPickerTabHSV;
  String get colorPickerTabHSL;
  String get colorPickerTabHEX;
  String get commandMoveUp;
  String get commandMoveDown;
  String get commandActivate;
  String dataTableSelectedRows(int count, int total);
  String get dataTableNext;
  String get dataTablePrevious;
  String get dataTableColumns;
  String get timeDaysAbbreviation;
  String get timeHoursAbbreviation;
  String get timeMinutesAbbreviation;
  String get timeSecondsAbbreviation;
  String get placeholderDurationPicker;
  String get durationDay;
  String get durationHour;
  String get durationMinute;
  String get durationSecond;
}
/// Extension methods for [ShadcnLocalizations] to provide additional formatting and utility functions.
extension ShadcnLocalizationsExtensions on ShadcnLocalizations {
/// The order of date parts for the current locale.
///
/// Default is [DatePart.month], [DatePart.day], [DatePart.year].
  List<DatePart> get datePartsOrder;
/// The abbreviation for the year component (e.g., 'YYYY').
  String get dateYearAbbreviation;
/// The abbreviation for the month component (e.g., 'MM').
  String get dateMonthAbbreviation;
/// The abbreviation for the day component (e.g., 'DD').
  String get dateDayAbbreviation;
/// Gets the abbreviation for a specific [DatePart].
  String getDatePartAbbreviation(DatePart part);
/// Formats a [DateTime] object into a string.
///
/// [showDate] - Whether to include the date part.
/// [showTime] - Whether to include the time part.
/// [showSeconds] - Whether to include seconds in the time part.
/// [use24HourFormat] - Whether to use 24-hour format for time.
  String formatDateTime(DateTime dateTime, {bool showDate = true, bool showTime = true, bool showSeconds = false, bool use24HourFormat = true});
/// Formats a [TimeOfDay] object into a string.
///
/// [use24HourFormat] - Whether to use 24-hour format.
/// [showSeconds] - Whether to include seconds.
  String formatTimeOfDay(TimeOfDay time, {bool use24HourFormat = true, bool showSeconds = false});
/// Formats a number as a string, removing decimal point if it's an integer.
  String formatNumber(double value);
/// Gets the localized label for a [ColorPickerMode].
  String getColorPickerMode(ColorPickerMode mode);
/// Gets the abbreviated weekday name for a given weekday index (1-7).
  String getAbbreviatedWeekday(int weekday);
/// Gets the full month name for a given month index (1-12).
  String getMonth(int month);
/// Gets the abbreviated month name for a given month index (1-12).
  String getAbbreviatedMonth(int month);
/// Formats a [Duration] into a string.
///
/// [showDays] - Whether to show days.
/// [showHours] - Whether to show hours.
/// [showMinutes] - Whether to show minutes.
/// [showSeconds] - Whether to show seconds.
  String formatDuration(Duration duration, {bool showDays = true, bool showHours = true, bool showMinutes = true, bool showSeconds = true});
/// Gets the abbreviation for a [DurationPart].
  String getDurationPartAbbreviation(DurationPart part);
/// Gets the abbreviation for a [TimePart].
  String getTimePartAbbreviation(TimePart part);
}
/// Callers can lookup localized strings with an instance of ShadcnLocalizations
/// returned by `ShadcnLocalizations.of(context)`.
///
/// Applications need to include `ShadcnLocalizations.delegate()` in their app's
/// `localizationDelegates` list, and the locales they support in the app's
/// `supportedLocales` list. For example:
///
/// ```dart
/// import 'locale/shadcn_localizations.dart';
///
/// return MaterialApp(
///   localizationsDelegates: ShadcnLocalizations.localizationsDelegates,
///   supportedLocales: ShadcnLocalizations.supportedLocales,
///   home: MyApplicationHome(),
/// );
/// ```
///
/// ## Update pubspec.yaml
///
/// Please make sure to update your pubspec.yaml to include the following
/// packages:
///
/// ```yaml
/// dependencies:
///   # Internationalization support.
///   flutter_localizations:
///     sdk: flutter
///   intl: any # Use the pinned version from flutter_localizations
///
///   # Rest of dependencies
/// ```
///
/// ## iOS Applications
///
/// iOS applications define key application metadata, including supported
/// locales, in an Info.plist file that is built into the application bundle.
/// To configure the locales supported by your app, you‚Äôll need to edit this
/// file.
///
/// First, open your project‚Äôs ios/Runner.xcworkspace Xcode workspace file.
/// Then, in the Project Navigator, open the Info.plist file under the Runner
/// project‚Äôs Runner folder.
///
/// Next, select the Information Property List item, select Add Item from the
/// Editor menu, then select Localizations from the pop-up menu.
///
/// Select and expand the newly-created Localizations item then, for each
/// locale your application supports, add a new item and select the locale
/// you wish to add from the pop-up menu in the Value field. This list should
/// be consistent with the languages listed in the ShadcnLocalizations.supportedLocales
/// property.
abstract class ShadcnLocalizations {
  ShadcnLocalizations(String locale);
  String localeName;
  static ShadcnLocalizations of(BuildContext context);
  static const LocalizationsDelegate<ShadcnLocalizations> delegate = _ShadcnLocalizationsDelegate();
/// A list of this localizations delegate along with the default localizations
/// delegates.
///
/// Returns a list of localizations delegates containing this delegate along with
/// GlobalMaterialLocalizations.delegate, GlobalCupertinoLocalizations.delegate,
/// and GlobalWidgetsLocalizations.delegate.
///
/// Additional delegates can be added by appending to this list in
/// MaterialApp. This list does not have to be used at all if a custom list
/// of delegates is preferred or required.
  static const List<LocalizationsDelegate<dynamic>> localizationsDelegates = <LocalizationsDelegate<dynamic>>[delegate, GlobalMaterialLocalizations.delegate, GlobalCupertinoLocalizations.delegate, GlobalWidgetsLocalizations.delegate];
/// A list of this localizations delegate's supported locales.
  static const List<Locale> supportedLocales = <Locale>[Locale('en')];
/// No description provided for @formNotEmpty.
///
/// In en, this message translates to:
/// **'This field cannot be empty'**
  String get formNotEmpty;
/// No description provided for @invalidValue.
///
/// In en, this message translates to:
/// **'Invalid value'**
  String get invalidValue;
/// No description provided for @invalidEmail.
///
/// In en, this message translates to:
/// **'Invalid email'**
  String get invalidEmail;
/// No description provided for @invalidURL.
///
/// In en, this message translates to:
/// **'Invalid URL'**
  String get invalidURL;
/// No description provided for @formLessThan.
///
/// In en, this message translates to:
/// **'Must be less than {value}'**
  String formLessThan(double value);
/// No description provided for @formGreaterThan.
///
/// In en, this message translates to:
/// **'Must be greater than {value}'**
  String formGreaterThan(double value);
/// No description provided for @formLessThanOrEqualTo.
///
/// In en, this message translates to:
/// **'Must be less than or equal to {value}'**
  String formLessThanOrEqualTo(double value);
/// No description provided for @formGreaterThanOrEqualTo.
///
/// In en, this message translates to:
/// **'Must be greater than or equal to {value}'**
  String formGreaterThanOrEqualTo(double value);
/// No description provided for @formBetweenInclusively.
///
/// In en, this message translates to:
/// **'Must be between {min} and {max} (inclusive)'**
  String formBetweenInclusively(double min, double max);
/// No description provided for @formBetweenExclusively.
///
/// In en, this message translates to:
/// **'Must be between {min} and {max} (exclusive)'**
  String formBetweenExclusively(double min, double max);
/// No description provided for @formLengthLessThan.
///
/// In en, this message translates to:
/// **'Must be at least {value} characters'**
  String formLengthLessThan(int value);
/// No description provided for @formLengthGreaterThan.
///
/// In en, this message translates to:
/// **'Must be at most {value} characters'**
  String formLengthGreaterThan(int value);
/// No description provided for @formPasswordDigits.
///
/// In en, this message translates to:
/// **'Must contain at least one digit'**
  String get formPasswordDigits;
/// No description provided for @formPasswordLowercase.
///
/// In en, this message translates to:
/// **'Must contain at least one lowercase letter'**
  String get formPasswordLowercase;
/// No description provided for @formPasswordUppercase.
///
/// In en, this message translates to:
/// **'Must contain at least one uppercase letter'**
  String get formPasswordUppercase;
/// No description provided for @formPasswordSpecial.
///
/// In en, this message translates to:
/// **'Must contain at least one special character'**
  String get formPasswordSpecial;
/// No description provided for @commandSearch.
///
/// In en, this message translates to:
/// **'Type a command or search...'**
  String get commandSearch;
/// No description provided for @commandEmpty.
///
/// In en, this message translates to:
/// **'No results found.'**
  String get commandEmpty;
/// No description provided for @datePickerSelectYear.
///
/// In en, this message translates to:
/// **'Select a year'**
  String get datePickerSelectYear;
/// No description provided for @abbreviatedMonday.
///
/// In en, this message translates to:
/// **'Mo'**
  String get abbreviatedMonday;
/// No description provided for @abbreviatedTuesday.
///
/// In en, this message translates to:
/// **'Tu'**
  String get abbreviatedTuesday;
/// No description provided for @abbreviatedWednesday.
///
/// In en, this message translates to:
/// **'We'**
  String get abbreviatedWednesday;
/// No description provided for @abbreviatedThursday.
///
/// In en, this message translates to:
/// **'Th'**
  String get abbreviatedThursday;
/// No description provided for @abbreviatedFriday.
///
/// In en, this message translates to:
/// **'Fr'**
  String get abbreviatedFriday;
/// No description provided for @abbreviatedSaturday.
///
/// In en, this message translates to:
/// **'Sa'**
  String get abbreviatedSaturday;
/// No description provided for @abbreviatedSunday.
///
/// In en, this message translates to:
/// **'Su'**
  String get abbreviatedSunday;
/// No description provided for @monthJanuary.
///
/// In en, this message translates to:
/// **'January'**
  String get monthJanuary;
/// No description provided for @monthFebruary.
///
/// In en, this message translates to:
/// **'February'**
  String get monthFebruary;
/// No description provided for @monthMarch.
///
/// In en, this message translates to:
/// **'March'**
  String get monthMarch;
/// No description provided for @monthApril.
///
/// In en, this message translates to:
/// **'April'**
  String get monthApril;
/// No description provided for @monthMay.
///
/// In en, this message translates to:
/// **'May'**
  String get monthMay;
/// No description provided for @monthJune.
///
/// In en, this message translates to:
/// **'June'**
  String get monthJune;
/// No description provided for @monthJuly.
///
/// In en, this message translates to:
/// **'July'**
  String get monthJuly;
/// No description provided for @monthAugust.
///
/// In en, this message translates to:
/// **'August'**
  String get monthAugust;
/// No description provided for @monthSeptember.
///
/// In en, this message translates to:
/// **'September'**
  String get monthSeptember;
/// No description provided for @monthOctober.
///
/// In en, this message translates to:
/// **'October'**
  String get monthOctober;
/// No description provided for @monthNovember.
///
/// In en, this message translates to:
/// **'November'**
  String get monthNovember;
/// No description provided for @monthDecember.
///
/// In en, this message translates to:
/// **'December'**
  String get monthDecember;
/// No description provided for @abbreviatedJanuary.
///
/// In en, this message translates to:
/// **'Jan'**
  String get abbreviatedJanuary;
/// No description provided for @abbreviatedFebruary.
///
/// In en, this message translates to:
/// **'Feb'**
  String get abbreviatedFebruary;
/// No description provided for @abbreviatedMarch.
///
/// In en, this message translates to:
/// **'Mar'**
  String get abbreviatedMarch;
/// No description provided for @abbreviatedApril.
///
/// In en, this message translates to:
/// **'Apr'**
  String get abbreviatedApril;
/// No description provided for @abbreviatedMay.
///
/// In en, this message translates to:
/// **'May'**
  String get abbreviatedMay;
/// No description provided for @abbreviatedJune.
///
/// In en, this message translates to:
/// **'Jun'**
  String get abbreviatedJune;
/// No description provided for @abbreviatedJuly.
///
/// In en, this message translates to:
/// **'Jul'**
  String get abbreviatedJuly;
/// No description provided for @abbreviatedAugust.
///
/// In en, this message translates to:
/// **'Aug'**
  String get abbreviatedAugust;
/// No description provided for @abbreviatedSeptember.
///
/// In en, this message translates to:
/// **'Sep'**
  String get abbreviatedSeptember;
/// No description provided for @abbreviatedOctober.
///
/// In en, this message translates to:
/// **'Oct'**
  String get abbreviatedOctober;
/// No description provided for @abbreviatedNovember.
///
/// In en, this message translates to:
/// **'Nov'**
  String get abbreviatedNovember;
/// No description provided for @abbreviatedDecember.
///
/// In en, this message translates to:
/// **'Dec'**
  String get abbreviatedDecember;
/// No description provided for @buttonCancel.
///
/// In en, this message translates to:
/// **'Cancel'**
  String get buttonCancel;
/// No description provided for @buttonSave.
///
/// In en, this message translates to:
/// **'Save'**
  String get buttonSave;
/// No description provided for @timeHour.
///
/// In en, this message translates to:
/// **'Hour'**
  String get timeHour;
/// No description provided for @timeMinute.
///
/// In en, this message translates to:
/// **'Minute'**
  String get timeMinute;
/// No description provided for @timeSecond.
///
/// In en, this message translates to:
/// **'Second'**
  String get timeSecond;
/// No description provided for @timeAM.
///
/// In en, this message translates to:
/// **'AM'**
  String get timeAM;
/// No description provided for @timePM.
///
/// In en, this message translates to:
/// **'PM'**
  String get timePM;
/// No description provided for @colorRed.
///
/// In en, this message translates to:
/// **'Red'**
  String get colorRed;
/// No description provided for @colorGreen.
///
/// In en, this message translates to:
/// **'Green'**
  String get colorGreen;
/// No description provided for @colorBlue.
///
/// In en, this message translates to:
/// **'Blue'**
  String get colorBlue;
/// No description provided for @colorAlpha.
///
/// In en, this message translates to:
/// **'Alpha'**
  String get colorAlpha;
/// No description provided for @colorHue.
///
/// In en, this message translates to:
/// **'Hue'**
  String get colorHue;
/// No description provided for @colorSaturation.
///
/// In en, this message translates to:
/// **'Sat'**
  String get colorSaturation;
/// No description provided for @colorValue.
///
/// In en, this message translates to:
/// **'Val'**
  String get colorValue;
/// No description provided for @colorLightness.
///
/// In en, this message translates to:
/// **'Lum'**
  String get colorLightness;
/// No description provided for @menuCut.
///
/// In en, this message translates to:
/// **'Cut'**
  String get menuCut;
/// No description provided for @menuCopy.
///
/// In en, this message translates to:
/// **'Copy'**
  String get menuCopy;
/// No description provided for @menuPaste.
///
/// In en, this message translates to:
/// **'Paste'**
  String get menuPaste;
/// No description provided for @menuSelectAll.
///
/// In en, this message translates to:
/// **'Select All'**
  String get menuSelectAll;
/// No description provided for @menuUndo.
///
/// In en, this message translates to:
/// **'Undo'**
  String get menuUndo;
/// No description provided for @menuRedo.
///
/// In en, this message translates to:
/// **'Redo'**
  String get menuRedo;
/// No description provided for @menuDelete.
///
/// In en, this message translates to:
/// **'Delete'**
  String get menuDelete;
/// No description provided for @menuShare.
///
/// In en, this message translates to:
/// **'Share'**
  String get menuShare;
/// No description provided for @menuSearchWeb.
///
/// In en, this message translates to:
/// **'Search Web'**
  String get menuSearchWeb;
/// No description provided for @menuLiveTextInput.
///
/// In en, this message translates to:
/// **'Live Text Input'**
  String get menuLiveTextInput;
/// No description provided for @placeholderDatePicker.
///
/// In en, this message translates to:
/// **'Select a date'**
  String get placeholderDatePicker;
/// No description provided for @placeholderTimePicker.
///
/// In en, this message translates to:
/// **'Select a time'**
  String get placeholderTimePicker;
/// No description provided for @placeholderColorPicker.
///
/// In en, this message translates to:
/// **'Select a color'**
  String get placeholderColorPicker;
/// No description provided for @buttonPrevious.
///
/// In en, this message translates to:
/// **'Previous'**
  String get buttonPrevious;
/// No description provided for @buttonNext.
///
/// In en, this message translates to:
/// **'Next'**
  String get buttonNext;
/// No description provided for @refreshTriggerPull.
///
/// In en, this message translates to:
/// **'Pull to refresh'**
  String get refreshTriggerPull;
/// No description provided for @refreshTriggerRelease.
///
/// In en, this message translates to:
/// **'Release to refresh'**
  String get refreshTriggerRelease;
/// No description provided for @refreshTriggerRefreshing.
///
/// In en, this message translates to:
/// **'Refreshing...'**
  String get refreshTriggerRefreshing;
/// No description provided for @refreshTriggerComplete.
///
/// In en, this message translates to:
/// **'Refresh complete'**
  String get refreshTriggerComplete;
/// No description provided for @colorPickerTabRecent.
///
/// In en, this message translates to:
/// **'Recent'**
  String get colorPickerTabRecent;
/// No description provided for @colorPickerTabRGB.
///
/// In en, this message translates to:
/// **'RGB'**
  String get colorPickerTabRGB;
/// No description provided for @colorPickerTabHSV.
///
/// In en, this message translates to:
/// **'HSV'**
  String get colorPickerTabHSV;
/// No description provided for @colorPickerTabHSL.
///
/// In en, this message translates to:
/// **'HSL'**
  String get colorPickerTabHSL;
/// No description provided for @colorPickerTabHEX.
///
/// In en, this message translates to:
/// **'HEX'**
  String get colorPickerTabHEX;
/// No description provided for @commandMoveUp.
///
/// In en, this message translates to:
/// **'Move Up'**
  String get commandMoveUp;
/// No description provided for @commandMoveDown.
///
/// In en, this message translates to:
/// **'Move Down'**
  String get commandMoveDown;
/// No description provided for @commandActivate.
///
/// In en, this message translates to:
/// **'Select'**
  String get commandActivate;
/// No description provided for @dataTableSelectedRows.
///
/// In en, this message translates to:
/// **'{count} of {total} row(s) selected.'**
  String dataTableSelectedRows(int count, int total);
/// No description provided for @dataTableNext.
///
/// In en, this message translates to:
/// **'Next'**
  String get dataTableNext;
/// No description provided for @dataTablePrevious.
///
/// In en, this message translates to:
/// **'Previous'**
  String get dataTablePrevious;
/// No description provided for @dataTableColumns.
///
/// In en, this message translates to:
/// **'Columns'**
  String get dataTableColumns;
/// No description provided for @timeDaysAbbreviation.
///
/// In en, this message translates to:
/// **'DD'**
  String get timeDaysAbbreviation;
/// No description provided for @timeHoursAbbreviation.
///
/// In en, this message translates to:
/// **'HH'**
  String get timeHoursAbbreviation;
/// No description provided for @timeMinutesAbbreviation.
///
/// In en, this message translates to:
/// **'MM'**
  String get timeMinutesAbbreviation;
/// No description provided for @timeSecondsAbbreviation.
///
/// In en, this message translates to:
/// **'SS'**
  String get timeSecondsAbbreviation;
/// No description provided for @placeholderDurationPicker.
///
/// In en, this message translates to:
/// **'Select a duration'**
  String get placeholderDurationPicker;
/// No description provided for @durationDay.
///
/// In en, this message translates to:
/// **'Day'**
  String get durationDay;
/// No description provided for @durationHour.
///
/// In en, this message translates to:
/// **'Hour'**
  String get durationHour;
/// No description provided for @durationMinute.
///
/// In en, this message translates to:
/// **'Minute'**
  String get durationMinute;
/// No description provided for @durationSecond.
///
/// In en, this message translates to:
/// **'Second'**
  String get durationSecond;
}
ShadcnLocalizations lookupShadcnLocalizations(Locale locale);
/// Whether debug stickers are visible in the UI.
const kDebugStickerVisible = true;
/// Whether debug containers are visible in the UI.
const kDebugContainerVisible = true;
/// Posts a temporary debug sticker overlay at the specified position.
///
/// Displays a semi-transparent colored box with text at the given [rect] position
/// for 2 seconds, useful for debugging layout and positioning issues.
/// Only active in debug mode when [kDebugStickerVisible] is true.
///
/// Parameters:
/// - [context]: The build context for the overlay.
/// - [rect]: The position and size of the sticker.
/// - [color]: The background color of the sticker.
/// - [text]: The text to display in the sticker.
void debugPostSticker(BuildContext context, Rect rect, Color color, String text);
/// Extension that adds debug container wrapping functionality to widgets.
///
/// Provides a [debugContainer] method to wrap widgets with a colored container
/// for debugging layout issues. Only active when [kDebugContainerVisible] is true.
extension DebugContainer on Widget {
/// Wraps this widget with a colored debug container.
///
/// The container uses the specified [color] (defaults to red) to highlight
/// the widget's bounds, making it easier to visualize layout during development.
/// Returns the original widget unchanged if [kDebugContainerVisible] is false.
  Widget debugContainer([Color color = Colors.red]);
}
/// Widget that intercepts scroll events to simulate middle-button drag scrolling.
///
/// Helps simulate middle-hold scroll on web and desktop platforms by intercepting
/// pointer events and converting drag gestures into scroll events.
class ScrollViewInterceptor extends StatefulWidget {
/// The child widget to wrap with scroll interception functionality.
  Widget child;
/// Whether scroll interception is enabled.
  bool enabled;
/// Creates a scroll view interceptor.
  const ScrollViewInterceptor({super.key, required this.child, this.enabled = true});
  State<ScrollViewInterceptor> createState();
}
/// The drag speed multiplier for scroll interception (0.02).
const double kScrollDragSpeed = 0.02;
/// The maximum scroll speed allowed (10.0).
const double kMaxScrollSpeed = 10.0;
/// A custom pointer scroll event for desktop platforms.
///
/// Extends [PointerScrollEvent] with desktop-specific scroll event handling.
class DesktopPointerScrollEvent extends PointerScrollEvent {
/// Creates a desktop pointer scroll event.
  const DesktopPointerScrollEvent({required super.position, required super.device, required super.embedderId, required super.kind, required super.timeStamp, required super.viewId, required super.scrollDelta});
}
/// A default widget displayed when command search returns no results.
///
/// Displays a localized "No results" message with standard styling.
class CommandEmpty extends StatelessWidget {
/// Creates a [CommandEmpty] widget.
///
/// Displays a standard empty state message when no command results are found.
  const CommandEmpty({super.key});
  Widget build(BuildContext context);
}
/// Shows a command palette in a modal dialog.
///
/// Displays a [Command] widget in a modal dialog with customizable constraints,
/// backdrop effects, and search behavior.
///
/// ## Parameters
///
/// * [context] - The build context.
/// * [builder] - The command builder for search results.
/// * [constraints] - Optional size constraints. Defaults to 510x349.
/// * [autofocus] - Whether to auto-focus the search field. Defaults to `true`.
/// * [debounceDuration] - Search debounce delay. Defaults to 500ms.
/// * [emptyBuilder] - Custom widget for empty results.
/// * [errorBuilder] - Custom widget for error states.
/// * [loadingBuilder] - Custom widget for loading states.
/// * [surfaceOpacity] - Modal surface opacity.
/// * [surfaceBlur] - Modal surface blur amount.
///
/// ## Returns
///
/// A `Future` that completes with the dialog result of type [T], or `null` if dismissed.
///
/// ## Example
///
/// ```dart
/// final result = await showCommandDialog<String>(
///   context: context,
///   builder: (context, query) async* {
///     yield commands.where((c) => c.contains(query ?? '')).toList();
///   },
/// );
/// ```
Future<T?> showCommandDialog<T>({required BuildContext context, required CommandBuilder builder, BoxConstraints? constraints, bool autofocus = true, Duration debounceDuration = const Duration(milliseconds: 500), WidgetBuilder? emptyBuilder, ErrorWidgetBuilder? errorBuilder, WidgetBuilder? loadingBuilder, double? surfaceOpacity, double? surfaceBlur});
/// Interactive command palette with search functionality and dynamic results.
///
/// A powerful search and command interface that provides real-time filtering
/// of commands or items based on user input. Features debounced search,
/// keyboard navigation, and customizable result presentation.
///
/// ## Features
///
/// - **Real-time search**: Dynamic filtering with configurable debounce timing
/// - **Keyboard navigation**: Full arrow key and Enter/Escape support
/// - **Async data loading**: Stream-based results with loading and error states
/// - **Customizable states**: Custom builders for empty, loading, and error states
/// - **Auto-focus**: Optional automatic focus on the search input
/// - **Accessibility**: Screen reader friendly with proper focus management
///
/// The command palette is commonly used for:
/// - Quick action selection (Cmd+K style interfaces)
/// - Searchable option lists
/// - Dynamic content filtering
/// - Command-driven workflows
///
/// Example:
/// ```dart
/// Command(
///   autofocus: true,
///   debounceDuration: Duration(milliseconds: 300),
///   builder: (context, query) async* {
///     final results = await searchService.search(query);
///     yield results.map((item) => CommandItem(
///       onTap: () => handleCommand(item),
///       title: Text(item.title),
///     )).toList();
///   },
///   emptyBuilder: (context) => Text('No results found'),
/// );
/// ```
class Command extends StatefulWidget {
/// Whether the search input should be auto-focused when the command palette opens.
///
/// Defaults to `true` for convenient keyboard-driven interaction.
  bool autofocus;
/// Async builder function that provides search results based on the query.
///
/// Receives the current search query string and should return a stream of
/// widget lists representing the filtered command results.
  CommandBuilder builder;
/// Debounce duration for search input to prevent excessive rebuilds.
///
/// The builder is called only after the user stops typing for this duration,
/// reducing unnecessary API calls or computations. Defaults to 500ms.
  Duration debounceDuration;
/// Custom widget builder for displaying empty search results.
///
/// If `null`, displays a default "No results" message via [CommandEmpty].
  WidgetBuilder? emptyBuilder;
/// Custom widget builder for displaying error states.
///
/// Receives the error object and stack trace for custom error presentation.
  ErrorWidgetBuilder? errorBuilder;
/// Custom widget builder for displaying loading state while fetching results.
///
/// If `null`, displays a default loading spinner.
  WidgetBuilder? loadingBuilder;
/// Optional opacity override for the command palette surface.
///
/// When provided, overrides the theme's default surface opacity.
  double? surfaceOpacity;
/// Optional blur amount override for the command palette surface backdrop.
///
/// When provided, overrides the theme's default surface blur.
  double? surfaceBlur;
/// Optional custom placeholder widget for the search input field.
///
/// If `null`, displays default localized placeholder text.
  Widget? searchPlaceholder;
/// Creates a [Command] palette.
///
/// The [builder] function receives the current search query and should return
/// a stream of widgets representing the filtered results.
///
/// Parameters:
/// - [builder] (CommandBuilder, required): async builder for search results
/// - [autofocus] (bool, default: true): whether to auto-focus search input
/// - [debounceDuration] (Duration, default: 500ms): debounce delay for search
/// - [emptyBuilder] (WidgetBuilder?, optional): custom widget for empty state
/// - [errorBuilder] (ErrorWidgetBuilder?, optional): custom error display
/// - [loadingBuilder] (WidgetBuilder?, optional): custom loading indicator
/// - [surfaceOpacity] (double?, optional): surface opacity override
/// - [surfaceBlur] (double?, optional): surface blur override
/// - [searchPlaceholder] (Widget?, optional): placeholder text for search input
///
/// Example:
/// ```dart
/// Command(
///   autofocus: false,
///   debounceDuration: Duration(milliseconds: 200),
///   searchPlaceholder: Text('Search commands...'),
///   builder: (context, query) async* {
///     final filtered = commands.where((cmd) =>
///       cmd.name.toLowerCase().contains(query?.toLowerCase() ?? '')
///     );
///     yield filtered.map((cmd) => CommandItem(
///       title: Text(cmd.name),
///       onTap: () => cmd.execute(),
///     )).toList();
///   },
/// )
/// ```
  const Command({super.key, required this.builder, this.autofocus = true, this.debounceDuration = const Duration(milliseconds: 500), this.emptyBuilder, this.errorBuilder, this.loadingBuilder, this.surfaceOpacity, this.surfaceBlur, this.searchPlaceholder});
  State<Command> createState();
}
/// A category grouping for command items in a command palette.
///
/// Groups related command items under an optional category title. Items within
/// a category are visually grouped and can be navigated as a unit.
///
/// ## Example
///
/// ```dart
/// CommandCategory(
///   title: Text('File'),
///   children: [
///     CommandItem(title: Text('New File'), onTap: () {}),
///     CommandItem(title: Text('Open File'), onTap: () {}),
///     CommandItem(title: Text('Save'), onTap: () {}),
///   ],
/// )
/// ```
class CommandCategory extends StatelessWidget {
/// The list of command items in this category.
  List<Widget> children;
/// Optional title widget displayed above the category items.
  Widget? title;
/// Creates a [CommandCategory] to group related command items.
///
/// Parameters:
/// - [children] (`List<Widget>`, required): The command items in this category
/// - [title] (Widget?, optional): Optional category header text
///
/// Example:
/// ```dart
/// CommandCategory(
///   title: Text('Edit'),
///   children: [
///     CommandItem(title: Text('Cut'), onTap: () => cut()),
///     CommandItem(title: Text('Copy'), onTap: () => copy()),
///   ],
/// )
/// ```
  const CommandCategory({super.key, required this.children, this.title});
  Widget build(BuildContext context);
}
/// An individual selectable item in a command palette.
///
/// Represents a single command or option that can be selected via click or
/// keyboard navigation. Supports optional leading and trailing widgets for
/// icons, shortcuts, or other decorations.
///
/// ## Example
///
/// ```dart
/// CommandItem(
///   leading: Icon(Icons.save),
///   title: Text('Save File'),
///   trailing: Text('Ctrl+S'),
///   onTap: () => saveFile(),
/// )
/// ```
class CommandItem extends StatefulWidget {
/// Optional widget displayed before the title (e.g., an icon).
  Widget? leading;
/// The main title/label of the command item.
  Widget title;
/// Optional widget displayed after the title (e.g., keyboard shortcut).
  Widget? trailing;
/// Called when the item is selected/tapped.
  VoidCallback? onTap;
/// Creates a [CommandItem] for display in a command palette.
///
/// Parameters:
/// - [title] (Widget, required): The main label for this command
/// - [leading] (Widget?, optional): Widget displayed before the title (e.g., icon)
/// - [trailing] (Widget?, optional): Widget displayed after the title (e.g., shortcut)
/// - [onTap] (VoidCallback?, optional): Callback when the item is selected
///
/// Example:
/// ```dart
/// CommandItem(
///   leading: Icon(Icons.file_copy),
///   title: Text('Duplicate'),
///   trailing: Text('Ctrl+D'),
///   onTap: () => duplicate(),
/// )
/// ```
  const CommandItem({super.key, this.leading, required this.title, this.trailing, this.onTap});
  State<CommandItem> createState();
}
/// Extension on `Set<WidgetState>` providing convenient boolean getters for common states.
///
/// This extension simplifies checking for widget states by providing readable
/// property accessors instead of using `contains()` calls.
///
/// ## Example
///
/// ```dart
/// Set<WidgetState> states = {WidgetState.hovered, WidgetState.focused};
///
/// if (states.hovered) {
///   // Handle hover state
/// }
/// if (states.disabled) {
///   // Handle disabled state
/// }
/// ```
extension WidgetStateExtension on Set<WidgetState> {
/// Whether the widget is in a disabled state.
  bool get disabled;
/// Whether the widget is in an error state.
  bool get error;
/// Whether the widget is in a selected state.
  bool get selected;
/// Whether the widget is in a pressed state.
  bool get pressed;
/// Whether the widget is in a hovered state.
  bool get hovered;
/// Whether the widget is in a focused state.
  bool get focused;
}
/// An abstract widget that provides state-aware visual variations.
///
/// Enables widgets to display different appearances based on their current
/// interactive state (disabled, selected, pressed, hovered, focused, error).
/// The widget automatically selects the appropriate visual representation
/// from provided alternatives based on a configurable state priority order.
///
/// Three factory constructors provide different approaches to state handling:
/// - Default constructor: Explicit widgets for each state
/// - `.map()`: Map-based state-to-widget associations
/// - `.builder()`: Function-based dynamic state handling
///
/// The state resolution follows a priority order where earlier states in the
/// order take precedence over later ones. This ensures consistent behavior
/// when multiple states are active simultaneously.
///
/// Example:
/// ```dart
/// StatedWidget(
///   child: Text('Default'),
///   disabled: Text('Disabled State'),
///   hovered: Text('Hovered State'),
///   pressed: Text('Pressed State'),
///   selected: Text('Selected State'),
/// )
/// ```
abstract class StatedWidget extends StatelessWidget {
/// Default state priority order for resolving multiple active states.
///
/// Defines the precedence when multiple widget states are active simultaneously.
/// States earlier in the list take priority over later ones. The default order
/// prioritizes accessibility and interaction feedback appropriately.
  static const List<WidgetState> defaultStateOrder = [WidgetState.disabled, WidgetState.error, WidgetState.selected, WidgetState.pressed, WidgetState.hovered, WidgetState.focused];
/// Creates a [StatedWidget] with explicit state-specific widgets.
///
/// Provides dedicated widget instances for each supported state.
/// The [child] serves as the default widget when no specific state
/// matches or when no state-specific widget is provided.
///
/// State resolution follows the [order] priority, with earlier states
/// taking precedence. The first matching state with a non-null widget
/// is selected for display.
///
/// Parameters:
/// - [child] (Widget, required): Default widget for normal state
/// - [order] (`List<WidgetState>`, default: defaultStateOrder): State priority order
/// - [disabled] (Widget?, optional): Widget for disabled state
/// - [selected] (Widget?, optional): Widget for selected state
/// - [pressed] (Widget?, optional): Widget for pressed/active state
/// - [hovered] (Widget?, optional): Widget for hover state
/// - [focused] (Widget?, optional): Widget for focused state
/// - [error] (Widget?, optional): Widget for error state
///
/// Example:
/// ```dart
/// StatedWidget(
///   child: Icon(Icons.star_border),
///   selected: Icon(Icons.star, color: Colors.yellow),
///   hovered: Icon(Icons.star_border, color: Colors.grey),
///   disabled: Icon(Icons.star_border, color: Colors.grey.shade300),
/// )
/// ```
  factory StatedWidget({Key? key, required Widget child, List<WidgetState> order, Widget? disabled, Widget? selected, Widget? pressed, Widget? hovered, Widget? focused, Widget? error});
/// Creates a [StatedWidget] using a map-based state configuration.
///
/// Provides a flexible approach where states are defined using a map
/// with keys representing state identifiers and values being the
/// corresponding widgets. This approach is useful when states are
/// determined dynamically or when working with custom state types.
///
/// The [child] parameter serves as a fallback when no matching state
/// is found in the states map. State resolution prioritizes exact
/// matches in the provided map.
///
/// Parameters:
/// - [states] (`Map<Object, Widget>`, required): Map of state-to-widget mappings
/// - [child] (Widget?, optional): Fallback widget when no state matches
///
/// Example:
/// ```dart
/// StatedWidget.map(
///   states: {
///     WidgetState.selected: Icon(Icons.check_circle, color: Colors.green),
///     WidgetState.error: Icon(Icons.error, color: Colors.red),
///     'custom': Icon(Icons.star, color: Colors.blue),
///   },
///   child: Icon(Icons.circle_outlined),
/// )
/// ```
  factory StatedWidget.map({Key? key, required Map<Object, Widget> states, Widget? child});
/// Creates a [StatedWidget] using a builder function for dynamic state handling.
///
/// Provides maximum flexibility by using a builder function that receives
/// the current set of active widget states and returns the appropriate
/// widget. This approach allows for complex state logic, animations,
/// and dynamic visual computations based on state combinations.
///
/// The builder function is called whenever the widget states change,
/// allowing for real-time adaptation to state transitions. This is
/// ideal for complex UI that needs to respond to multiple simultaneous states.
///
/// Parameters:
/// - [builder] (Function, required): Builder function receiving context and states
///
/// Example:
/// ```dart
/// StatedWidget.builder(
///   builder: (context, states) {
///     if (states.contains(WidgetState.disabled)) {
///       return Opacity(opacity: 0.5, child: Icon(Icons.block));
///     }
///     if (states.contains(WidgetState.selected)) {
///       return Icon(Icons.check_circle, color: Colors.green);
///     }
///     if (states.contains(WidgetState.hovered)) {
///       return AnimatedScale(scale: 1.1, child: Icon(Icons.star));
///     }
///     return Icon(Icons.star_border);
///   },
/// )
/// ```
  factory StatedWidget.builder({Key? key, required Widget Function(BuildContext context, Set<WidgetState> states) builder});
}
/// A widget that provides widget state information to descendants via `Data`.
///
/// [WidgetStatesProvider] manages and propagates widget states (like hovered,
/// pressed, disabled) down the widget tree using the Data inheritance mechanism.
/// It supports both static state sets and dynamic controller-based states.
///
/// ## Overview
///
/// Use [WidgetStatesProvider] to:
/// - Share widget states with descendant widgets
/// - Control states programmatically via [WidgetStatesController]
/// - Inherit states from ancestor providers
/// - Create state boundaries to isolate state contexts
///
/// ## Example
///
/// ```dart
/// WidgetStatesProvider(
///   states: {WidgetState.hovered},
///   child: StatedWidget(
///     child: Text('Normal'),
///     hovered: Text('Hovered'),
///   ),
/// )
/// ```
class WidgetStatesProvider extends StatelessWidget {
/// Optional controller for programmatic state management.
  WidgetStatesController? controller;
/// Static set of widget states to provide.
  Set<WidgetState>? states;
/// The child widget that can access the provided states.
  Widget child;
/// Whether to inherit states from ancestor providers.
///
/// When `true`, combines local states with inherited states.
  bool inherit;
/// Whether this provider acts as a state boundary.
  bool boundary;
/// Creates a widget states provider with optional controller and states.
///
/// ## Parameters
///
/// * [controller] - Optional controller for dynamic state management.
/// * [child] - The descendant widget that can access states.
/// * [states] - Static set of states to provide. Defaults to empty set.
/// * [inherit] - Whether to inherit from ancestors. Defaults to `true`.
  const WidgetStatesProvider({super.key, this.controller, required this.child, this.states = const {}, this.inherit = true});
/// Creates a widget states provider that acts as a state boundary.
///
/// A boundary provider blocks state inheritance from ancestors, creating
/// an isolated state context for its descendants.
///
/// ## Parameters
///
/// * [child] - The descendant widget.
  const WidgetStatesProvider.boundary({super.key, required this.child});
  Widget build(BuildContext context);
}
/// Data class wrapping a set of widget states.
///
/// [WidgetStatesData] is a simple container for a `Set<WidgetState>` that can
/// be passed through the widget tree using the [Data] inherited widget system.
/// It's used by components like [Clickable] to propagate state information
/// (hovered, pressed, focused, etc.) to descendant widgets.
///
/// Example:
/// ```dart
/// const statesData = WidgetStatesData({WidgetState.hovered, WidgetState.focused});
/// ```
class WidgetStatesData {
/// The set of current widget states.
///
/// Common states include [WidgetState.hovered], [WidgetState.pressed],
/// [WidgetState.focused], [WidgetState.disabled], and [WidgetState.selected].
  Set<WidgetState> states;
/// Creates widget states data with the specified states.
  const WidgetStatesData(this.states);
  bool operator ==(Object other);
  int get hashCode;
  String toString();
}
/// A highly configurable clickable widget with extensive gesture and state support.
///
/// [Clickable] provides a comprehensive foundation for interactive widgets, handling
/// various input gestures (tap, double-tap, long-press, etc.), visual states, and
/// accessibility features. It manages decoration, styling, and transitions based on
/// widget states like hover, focus, and press.
///
/// ## Overview
///
/// Use [Clickable] when building custom interactive components that need:
/// - Fine-grained gesture control (primary, secondary, tertiary taps)
/// - State-aware styling (decoration, text style, mouse cursor, etc.)
/// - Focus management and keyboard shortcuts
/// - Smooth transitions between states
/// - Accessibility features like focus outlines
///
/// ## Example
///
/// ```dart
/// Clickable(
///   onPressed: () => print('Clicked!'),
///   decoration: WidgetStateProperty.resolveWith((states) {
///     if (states.contains(WidgetState.pressed)) {
///       return BoxDecoration(color: Colors.blue.shade700);
///     }
///     return BoxDecoration(color: Colors.blue);
///   }),
///   child: Padding(
///     padding: EdgeInsets.all(8),
///     child: Text('Click Me'),
///   ),
/// )
/// ```
class Clickable extends StatefulWidget {
/// The child widget displayed within the clickable area.
  Widget child;
/// Whether the widget is enabled and can respond to interactions.
  bool enabled;
/// Called when hover state changes.
  ValueChanged<bool>? onHover;
/// Called when focus state changes.
  ValueChanged<bool>? onFocus;
/// State-aware decoration for the widget.
  WidgetStateProperty<Decoration?>? decoration;
/// State-aware mouse cursor style.
  WidgetStateProperty<MouseCursor?>? mouseCursor;
/// State-aware padding around the child.
  WidgetStateProperty<EdgeInsetsGeometry?>? padding;
/// State-aware text style applied to text descendants.
  WidgetStateProperty<TextStyle?>? textStyle;
/// State-aware icon theme applied to icon descendants.
  WidgetStateProperty<IconThemeData?>? iconTheme;
/// State-aware margin around the widget.
  WidgetStateProperty<EdgeInsetsGeometry?>? margin;
/// State-aware transformation matrix.
  WidgetStateProperty<Matrix4?>? transform;
/// Called when the widget is tapped (primary button).
  VoidCallback? onPressed;
/// Called when the widget is double-tapped.
  VoidCallback? onDoubleTap;
/// Focus node for keyboard focus management.
  FocusNode? focusNode;
/// How to behave during hit testing.
  HitTestBehavior behavior;
/// Whether to disable state transition animations.
  bool disableTransition;
/// Keyboard shortcuts to handle.
  Map<LogicalKeySet, Intent>? shortcuts;
/// Actions to handle for intents.
  Map<Type, Action<Intent>>? actions;
/// Whether to show focus outline for accessibility.
  bool focusOutline;
/// Whether to enable haptic/audio feedback.
  bool enableFeedback;
/// Called when long-pressed.
  VoidCallback? onLongPress;
/// Called on primary tap down.
  GestureTapDownCallback? onTapDown;
/// Called on primary tap up.
  GestureTapUpCallback? onTapUp;
/// Called when primary tap is cancelled.
  GestureTapCancelCallback? onTapCancel;
/// Called on secondary (right-click) tap down.
  GestureTapDownCallback? onSecondaryTapDown;
/// Called on secondary tap up.
  GestureTapUpCallback? onSecondaryTapUp;
/// Called when secondary tap is cancelled.
  GestureTapCancelCallback? onSecondaryTapCancel;
/// Called on tertiary (middle-click) tap down.
  GestureTapDownCallback? onTertiaryTapDown;
/// Called on tertiary tap up.
  GestureTapUpCallback? onTertiaryTapUp;
/// Called when tertiary tap is cancelled.
  GestureTapCancelCallback? onTertiaryTapCancel;
/// Called when long press starts.
  GestureLongPressStartCallback? onLongPressStart;
/// Called when long press is released.
  GestureLongPressUpCallback? onLongPressUp;
/// Called when long press moves.
  GestureLongPressMoveUpdateCallback? onLongPressMoveUpdate;
/// Called when long press ends.
  GestureLongPressEndCallback? onLongPressEnd;
/// Called on secondary long press completion.
  GestureLongPressUpCallback? onSecondaryLongPress;
/// Called on tertiary long press completion.
  GestureLongPressUpCallback? onTertiaryLongPress;
/// Whether to disable hover visual effects.
  bool disableHoverEffect;
/// Optional controller for programmatic state management.
  WidgetStatesController? statesController;
/// Alignment for applying margin.
  AlignmentGeometry? marginAlignment;
/// Whether to disable the focus outline.
  bool disableFocusOutline;
/// Creates a [Clickable] widget.
///
/// A clickable area with state-dependent styling and comprehensive gesture support.
///
/// Parameters:
/// - [child] (required): The widget to display and make clickable
/// - [enabled]: Whether the widget is enabled. Defaults to `true`
/// - [onPressed]: Primary tap callback. If `null`, widget is disabled
/// - [decoration], [mouseCursor], [padding], [textStyle], [iconTheme], [margin], [transform]:
///   State-dependent property functions for styling
/// - [focusNode]: Optional focus node for keyboard focus management
/// - [behavior]: Hit test behavior. Defaults to [HitTestBehavior.translucent]
/// - [onHover], [onFocus]: State change callbacks
/// - [disableTransition]: If `true`, disables animation transitions. Defaults to `false`
/// - [disableHoverEffect]: If `true`, disables hover visual effects. Defaults to `false`
/// - [onDoubleTap]: Double tap callback
/// - [shortcuts], [actions]: Keyboard shortcuts and actions
/// - [focusOutline]: Whether to show focus outline. Defaults to `true`
/// - [enableFeedback]: Whether to enable haptic/audio feedback. Defaults to `true`
/// - [onTapDown], [onTapUp], [onTapCancel]: Primary tap gesture callbacks
/// - [onSecondaryTapDown], [onSecondaryTapUp], [onSecondaryTapCancel]: Secondary tap callbacks
/// - [onTertiaryTapDown], [onTertiaryTapUp], [onTertiaryTapCancel]: Tertiary tap callbacks
/// - [onLongPress], [onLongPressStart], [onLongPressUp], [onLongPressMoveUpdate], [onLongPressEnd]:
///   Long press gesture callbacks
/// - [onSecondaryLongPress], [onTertiaryLongPress]: Secondary and tertiary long press callbacks
/// - [statesController]: Optional controller for programmatic state management
/// - [marginAlignment]: Alignment for applying margin
/// - [disableFocusOutline]: Whether to disable the focus outline. Defaults to `false`
  const Clickable({super.key, required this.child, this.statesController, this.enabled = true, this.decoration, this.mouseCursor, this.padding, this.textStyle, this.iconTheme, this.onPressed, this.focusNode, this.behavior = HitTestBehavior.translucent, this.onHover, this.onFocus, this.disableTransition = false, this.disableHoverEffect = false, this.margin, this.onDoubleTap, this.shortcuts, this.actions, this.focusOutline = true, this.enableFeedback = true, this.transform, this.onLongPress, this.onTapDown, this.onTapUp, this.onTapCancel, this.onSecondaryTapDown, this.onSecondaryTapUp, this.onSecondaryTapCancel, this.onTertiaryTapDown, this.onTertiaryTapUp, this.onTertiaryTapCancel, this.onLongPressStart, this.onLongPressUp, this.onLongPressMoveUpdate, this.onLongPressEnd, this.onSecondaryLongPress, this.onTertiaryLongPress, this.marginAlignment, this.disableFocusOutline = false});
  State<Clickable> createState();
}
/// Minimum time interval between taps to be considered a double tap.
///
/// Taps that occur within this duration (300ms) of a previous tap are counted
/// as part of a multi-tap gesture sequence. Used internally by [Clickable] to
/// detect double-tap gestures.
const kDoubleTapMinTime = Duration(milliseconds: 300);
/// A controller for managing toggle state in toggle buttons and switches.
///
/// [ToggleController] extends [ValueNotifier] to provide reactive state management
/// for boolean toggle values. It implements [ComponentController] to integrate
/// with the shadcn_flutter form system and provides convenient methods for
/// programmatic state changes.
///
/// The controller maintains a boolean value representing the toggle state and
/// notifies listeners when the state changes, making it suitable for use with
/// toggle buttons, switches, and other binary state controls.
///
/// Example:
/// ```dart
/// final toggleController = ToggleController(false);
///
/// // Listen to changes
/// toggleController.addListener(() {
///   print('Toggle state: ${toggleController.value}');
/// });
///
/// // Toggle the state programmatically
/// toggleController.toggle();
///
/// // Set specific value
/// toggleController.value = true;
/// ```
class ToggleController extends ValueNotifier<bool> with ComponentController<bool> {
/// Creates a [ToggleController] with an initial toggle state.
///
/// Parameters:
/// - [value] (bool, default: false): The initial toggle state.
///
/// Example:
/// ```dart
/// // Create controller starting in off state
/// final controller = ToggleController();
///
/// // Create controller starting in on state
/// final controller = ToggleController(true);
/// ```
  ToggleController([super.value = false]);
/// Toggles the current boolean state.
///
/// Changes `true` to `false` and `false` to `true`, then notifies all listeners
/// of the change. This is equivalent to setting `value = !value` but provides
/// a more semantic API for toggle operations.
///
/// Example:
/// ```dart
/// final controller = ToggleController(false);
/// controller.toggle(); // value is now true
/// controller.toggle(); // value is now false
/// ```
  void toggle();
}
/// A controlled version of [Toggle] that integrates with form state management.
///
/// [ControlledToggle] implements the [ControlledComponent] mixin to provide
/// automatic form integration, validation, and state management. It serves as
/// a bridge between external state management (via [ToggleController] or
/// [onChanged] callbacks) and the underlying [Toggle] widget.
///
/// This widget is ideal for use in forms where the toggle state needs to be
/// managed externally, validated, or persisted. It automatically handles the
/// conversion between controlled and uncontrolled modes based on the provided
/// parameters.
///
/// Example:
/// ```dart
/// final controller = ToggleController(false);
///
/// ControlledToggle(
///   controller: controller,
///   child: Row(
///     children: [
///       Icon(Icons.notifications),
///       Text('Enable notifications'),
///     ],
///   ),
/// );
/// ```
class ControlledToggle extends StatelessWidget with ControlledComponent<bool> {
/// The initial toggle state when no controller is provided.
///
/// Used only in uncontrolled mode. If both [controller] and [initialValue]
/// are provided, [controller] takes precedence.
  bool? initialValue;
/// Callback invoked when the toggle state changes.
///
/// Called with the new boolean value whenever the user toggles the button.
/// If null, the toggle becomes read-only (though it can still be controlled
/// via [controller] if provided).
  ValueChanged<bool>? onChanged;
/// Whether the toggle is interactive.
///
/// When false, the toggle appears disabled and doesn't respond to user input.
/// The toggle can still be changed programmatically via [controller].
  bool enabled;
/// Controller for managing toggle state externally.
///
/// When provided, the toggle operates in controlled mode and its state is
/// managed entirely by this controller. Changes are reflected immediately
/// and [onChanged] is called when the user interacts with the toggle.
  ToggleController? controller;
/// The child widget to display inside the toggle button.
///
/// Typically contains text, icons, or a combination of both. The child
/// receives the visual styling and interaction behavior of the toggle button.
  Widget child;
/// Visual styling for the toggle button.
///
/// Defines the appearance, colors, padding, and other visual characteristics
/// of the toggle. Defaults to ghost button style with subtle appearance changes
/// between toggled and untoggled states.
  ButtonStyle style;
/// Creates a [ControlledToggle] widget.
///
/// Parameters:
/// - [controller] (ToggleController?, optional): External state controller.
/// - [initialValue] (bool?, optional): Initial state for uncontrolled mode.
/// - [onChanged] (`ValueChanged<bool>?`, optional): State change callback.
/// - [enabled] (bool, default: true): Whether the toggle is interactive.
/// - [child] (Widget, required): Content to display in the toggle button.
/// - [style] (ButtonStyle, default: ButtonStyle.ghost()): Visual styling.
///
/// Example:
/// ```dart
/// ControlledToggle(
///   initialValue: false,
///   onChanged: (value) => print('Toggled: $value'),
///   enabled: true,
///   style: ButtonStyle.secondary(),
///   child: Text('Toggle Me'),
/// );
/// ```
  const ControlledToggle({super.key, this.controller, this.initialValue, this.onChanged, this.enabled = true, required this.child, this.style = const ButtonStyle.ghost()});
  Widget build(BuildContext context);
}
/// Simple toggle button with stateful on/off behavior.
///
/// A basic toggle button widget that maintains its own internal state for
/// on/off toggling. Provides a simplified interface compared to [ControlledToggle]
/// for cases where external state management is not required.
///
/// ## Features
///
/// - **Stateful toggling**: Built-in state management for simple use cases
/// - **Ghost button styling**: Default ghost button appearance
/// - **Form integration**: Automatic form field registration with boolean values
/// - **Accessibility**: Full screen reader and keyboard support
/// - **Custom styling**: Configurable button style and appearance
///
/// The widget automatically cycles between true/false states when pressed
/// and calls the [onChanged] callback with the new state.
///
/// Example:
/// ```dart
/// bool isEnabled = false;
///
/// Toggle(
///   value: isEnabled,
///   onChanged: (enabled) => setState(() => isEnabled = enabled),
///   child: Text('Enable notifications'),
/// );
/// ```
class Toggle extends StatefulWidget {
/// The current toggle state (on/off).
  bool value;
/// Called when the toggle state changes.
///
/// If `null`, the toggle is considered disabled and won't respond to user input.
  ValueChanged<bool>? onChanged;
/// The widget displayed inside the toggle button.
  Widget child;
/// The visual style for the button.
///
/// Defaults to ghost style for a subtle appearance.
  ButtonStyle style;
/// Whether the toggle button is enabled.
///
/// If `null`, the button is enabled only when [onChanged] is not `null`.
  bool? enabled;
/// Creates a [Toggle].
///
/// The toggle button maintains its own state and calls [onChanged] when
/// the state changes. Uses ghost button styling by default.
///
/// Parameters:
/// - [value] (bool, required): current toggle state
/// - [onChanged] (`ValueChanged<bool>?`, optional): callback when state changes
/// - [child] (Widget, required): content displayed inside the button
/// - [enabled] (bool?, optional): whether button is interactive
/// - [style] (ButtonStyle, default: ghost): button styling
///
/// Example:
/// ```dart
/// Toggle(
///   value: isToggled,
///   onChanged: (value) => setState(() => isToggled = value),
///   child: Row(
///     children: [
///       Icon(Icons.notifications),
///       Text('Notifications'),
///     ],
///   ),
/// )
/// ```
  const Toggle({super.key, required this.value, this.onChanged, required this.child, this.enabled, this.style = const ButtonStyle.ghost()});
  ToggleState createState();
}
/// State class for [Toggle] that manages the toggle behavior and form integration.
///
/// This state class handles:
/// - Maintaining widget states (selected, pressed, hovered, etc.)
/// - Form value integration via [FormValueSupplier]
/// - Updating the selected state based on the toggle value
class ToggleState extends State<Toggle> with FormValueSupplier<bool, Toggle> {
/// Controller for managing widget interaction states.
  WidgetStatesController statesController;
  void initState();
  void didUpdateWidget(Toggle oldWidget);
  void didReplaceFormValue(bool value);
  Widget build(BuildContext context);
}
/// A button that changes style based on its selected state.
///
/// [SelectedButton] provides a stateful button that displays different styles
/// when selected versus unselected. It supports all standard button gestures
/// including tap, long press, and hover interactions.
///
/// ## Overview
///
/// Use [SelectedButton] when you need a button that visually indicates selection
/// state, such as in tab bars, segmented controls, or toggle groups. The button
/// automatically switches between [style] (unselected) and [selectedStyle] (selected)
/// based on the [value] parameter.
///
/// ## Example
///
/// ```dart
/// SelectedButton(
///   value: isSelected,
///   onChanged: (selected) => setState(() => isSelected = selected),
///   style: const ButtonStyle.ghost(),
///   selectedStyle: const ButtonStyle.secondary(),
///   child: Text('Option A'),
/// )
/// ```
class SelectedButton extends StatefulWidget {
/// The current selection state of the button.
  bool value;
/// Called when the selection state changes.
///
/// If `null`, the button is disabled.
  ValueChanged<bool>? onChanged;
/// The widget displayed inside the button.
  Widget child;
/// The button style when not selected.
///
/// Defaults to ghost style.
  AbstractButtonStyle style;
/// The button style when selected.
///
/// Defaults to secondary style.
  AbstractButtonStyle selectedStyle;
/// Whether the button is enabled.
///
/// If `null`, enabled state is determined by whether [onChanged] is non-null.
  bool? enabled;
/// The alignment of the child within the button.
  AlignmentGeometry? alignment;
/// The margin alignment for the button.
  AlignmentGeometry? marginAlignment;
/// Whether to disable style transition animations.
///
/// Defaults to `false`. When `true`, style changes are instant.
  bool disableTransition;
/// Called when the hover state changes.
  ValueChanged<bool>? onHover;
/// Called when the focus state changes.
  ValueChanged<bool>? onFocus;
/// Whether to enable haptic/audio feedback.
  bool? enableFeedback;
/// Called when a primary tap down event occurs.
  GestureTapDownCallback? onTapDown;
/// Called when a primary tap up event occurs.
  GestureTapUpCallback? onTapUp;
/// Called when a primary tap is cancelled.
  GestureTapCancelCallback? onTapCancel;
/// Called when a secondary tap down event occurs.
  GestureTapDownCallback? onSecondaryTapDown;
/// Called when a secondary tap up event occurs.
  GestureTapUpCallback? onSecondaryTapUp;
/// Called when a secondary tap is cancelled.
  GestureTapCancelCallback? onSecondaryTapCancel;
/// Called when a tertiary tap down event occurs.
  GestureTapDownCallback? onTertiaryTapDown;
/// Called when a tertiary tap up event occurs.
  GestureTapUpCallback? onTertiaryTapUp;
/// Called when a tertiary tap is cancelled.
  GestureTapCancelCallback? onTertiaryTapCancel;
/// Called when a long press starts.
  GestureLongPressStartCallback? onLongPressStart;
/// Called when a long press is released.
  GestureLongPressUpCallback? onLongPressUp;
/// Called when a long press moves.
  GestureLongPressMoveUpdateCallback? onLongPressMoveUpdate;
/// Called when a long press ends.
  GestureLongPressEndCallback? onLongPressEnd;
/// Called when a secondary long press completes.
  GestureLongPressUpCallback? onSecondaryLongPress;
/// Called when a tertiary long press completes.
  GestureLongPressUpCallback? onTertiaryLongPress;
/// Whether to disable the hover effect.
///
/// Defaults to `false`.
  bool disableHoverEffect;
/// Optional controller for programmatic state management.
  WidgetStatesController? statesController;
/// Called when the button is pressed (tapped).
  VoidCallback? onPressed;
/// Creates a [SelectedButton] widget.
///
/// A button that toggles between selected and unselected states, applying
/// different styles based on the current [value].
///
/// Parameters:
/// - [value] (required): The current selection state (`true` for selected).
/// - [onChanged]: Callback invoked when the selection state changes. If `null`, the button is disabled.
/// - [child] (required): The widget displayed inside the button.
/// - [enabled]: Whether the button is enabled. Defaults to checking if [onChanged] is non-null.
/// - [style]: Style applied when unselected. Defaults to [ButtonStyle.ghost].
/// - [selectedStyle]: Style applied when selected. Defaults to [ButtonStyle.secondary].
/// - [alignment]: Alignment of the child within the button.
/// - [marginAlignment]: Margin alignment for the button.
/// - [disableTransition]: If `true`, disables style transition animations. Defaults to `false`.
/// - [onHover]: Called when the hover state changes.
/// - [onFocus]: Called when the focus state changes.
/// - [enableFeedback]: Whether to enable haptic/audio feedback.
/// - [onTapDown], [onTapUp], [onTapCancel]: Primary tap gesture callbacks.
/// - [onSecondaryTapDown], [onSecondaryTapUp], [onSecondaryTapCancel]: Secondary tap gesture callbacks.
/// - [onTertiaryTapDown], [onTertiaryTapUp], [onTertiaryTapCancel]: Tertiary tap gesture callbacks.
/// - [onLongPressStart], [onLongPressUp], [onLongPressMoveUpdate], [onLongPressEnd]: Long press gesture callbacks.
/// - [onSecondaryLongPress], [onTertiaryLongPress]: Secondary and tertiary long press callbacks.
/// - [disableHoverEffect]: If `true`, disables the hover effect. Defaults to `false`.
/// - [statesController]: Optional controller for programmatic state management.
/// - [onPressed]: Called when the button is tapped.
///
/// Example:
/// ```dart
/// SelectedButton(
///   value: isSelected,
///   onChanged: (selected) => setState(() => isSelected = selected),
///   child: Text('Toggle Me'),
/// )
/// ```
  const SelectedButton({super.key, required this.value, this.onChanged, required this.child, this.enabled, this.style = const ButtonStyle.ghost(), this.selectedStyle = const ButtonStyle.secondary(), this.alignment, this.marginAlignment, this.disableTransition = false, this.onHover, this.onFocus, this.enableFeedback, this.onTapDown, this.onTapUp, this.onTapCancel, this.onSecondaryTapDown, this.onSecondaryTapUp, this.onSecondaryTapCancel, this.onTertiaryTapDown, this.onTertiaryTapUp, this.onTertiaryTapCancel, this.onLongPressStart, this.onLongPressUp, this.onLongPressMoveUpdate, this.onLongPressEnd, this.onSecondaryLongPress, this.onTertiaryLongPress, this.disableHoverEffect = false, this.statesController, this.onPressed});
  SelectedButtonState createState();
}
/// State class for [SelectedButton] managing selection and interaction states.
///
/// Handles widget state controller lifecycle and synchronizes the selected state
/// with the button's value.
class SelectedButtonState extends State<SelectedButton> {
/// The controller managing widget states (selected, hovered, focused, etc.).
///
/// This controller is either provided via [SelectedButton.statesController]
/// or created automatically. It tracks and manages the button's interactive
/// states and updates them based on user interactions and the selection value.
  WidgetStatesController statesController;
  void initState();
  void didUpdateWidget(SelectedButton oldWidget);
  Widget build(BuildContext context);
}
/// A versatile, customizable button widget with comprehensive styling and interaction support.
///
/// [Button] is the foundational interactive widget in the shadcn_flutter design system,
/// providing a consistent and accessible button implementation with extensive customization
/// options. It supports multiple visual variants, sizes, shapes, and interaction patterns
/// while maintaining design system consistency.
///
/// ## Key Features
/// - **Multiple Variants**: Primary, secondary, outline, ghost, link, text, destructive, and more
/// - **Flexible Sizing**: From extra small to extra large with custom scaling
/// - **Shape Options**: Rectangle and circle shapes with customizable borders
/// - **Rich Interactions**: Hover, focus, press, and long press support
/// - **Accessibility**: Full keyboard navigation and screen reader support
/// - **Theming**: Deep integration with the design system theme
/// - **Form Integration**: Works seamlessly with form validation and state management
///
/// ## Visual Variants
/// The button supports various visual styles through named constructors:
/// - [Button.primary]: Prominent primary actions with filled background
/// - [Button.secondary]: Secondary actions with muted background
/// - [Button.outline]: Actions with outline border and transparent background
/// - [Button.ghost]: Subtle actions with minimal visual weight
/// - [Button.link]: Text-only actions that appear as links
/// - [Button.text]: Plain text actions with hover effects
/// - [Button.destructive]: Dangerous actions with destructive styling
/// - [Button.card]: Card-like appearance for container buttons
///
/// ## Layout and Content
/// Buttons can contain text, icons, or a combination of both using [leading] and [trailing]
/// widgets. The [child] widget is automatically aligned and sized according to the button's
/// style and density settings.
///
/// ## Interaction Handling
/// The button provides comprehensive gesture support including tap, long press, secondary
/// clicks, and tertiary clicks. All interactions respect the [enabled] state and provide
/// appropriate visual and haptic feedback.
///
/// Example:
/// ```dart
/// Button.primary(
///   onPressed: () => print('Primary action'),
///   leading: Icon(Icons.add),
///   trailing: Icon(Icons.arrow_forward),
///   child: Text('Create New'),
/// );
/// ```
class Button extends StatefulWidget {
/// Whether the button is interactive.
///
/// If null, the button is enabled when [onPressed] is not null. When false,
/// the button appears disabled and doesn't respond to user input or fire callbacks.
  bool? enabled;
/// Whether to disable visual state transition animations.
///
/// When true, the button immediately snaps between visual states instead of
/// smoothly animating. Useful for performance optimization in lists or when
/// animations would be distracting.
  bool disableTransition;
/// Widget displayed to the left of the main child content.
///
/// Commonly used for icons that provide additional context about the button's
/// action. Automatically spaced from the [child] with appropriate gaps.
  Widget? leading;
/// Widget displayed to the right of the main child content.
///
/// Often used for icons indicating direction (arrows) or additional actions.
/// Automatically spaced from the [child] with appropriate gaps.
  Widget? trailing;
/// Custom gap between [leading] and [child].
///
/// When null, defaults to the scaled density gap. Set to override the
/// default spacing between the leading widget and the main content.
  double? leadingGap;
/// Custom gap between [child] and [trailing].
///
/// When null, defaults to the scaled density gap. Set to override the
/// default spacing between the main content and the trailing widget.
  double? trailingGap;
/// The primary content displayed in the button.
///
/// Typically contains text, icons, or other widgets that describe the button's
/// action. Automatically aligned according to [alignment] and styled according
/// to the button's [style].
  Widget child;
/// Callback invoked when the button is pressed.
///
/// The primary interaction callback for the button. When null, the button becomes
/// disabled unless [enabled] is explicitly set to true. The button automatically
/// handles loading states, disabled states, and provides haptic feedback.
  VoidCallback? onPressed;
/// Focus node for keyboard navigation and focus management.
///
/// If null, a focus node is automatically created. Useful for controlling focus
/// programmatically or integrating with form focus traversal.
  FocusNode? focusNode;
/// Alignment of the child content within the button.
///
/// Controls how the [child] is positioned within the button's bounds. Defaults
/// to center alignment for most button types. When [leading] or [trailing] are
/// provided, defaults to start alignment.
  AlignmentGeometry? alignment;
/// Visual styling configuration for the button.
///
/// Defines the button's appearance including colors, padding, borders, and text
/// styles. The [AbstractButtonStyle] provides state-aware styling that responds
/// to hover, press, focus, and disabled states.
  AbstractButtonStyle style;
/// Callback invoked when the button's hover state changes.
///
/// Called with true when the pointer enters the button area and false when it
/// leaves. Useful for implementing custom hover effects or updating external state.
  ValueChanged<bool>? onHover;
/// Callback invoked when the button's focus state changes.
///
/// Called with true when the button gains focus and false when it loses focus.
/// Useful for accessibility features or coordinating focus with other widgets.
  ValueChanged<bool>? onFocus;
/// Whether to enable haptic feedback on press.
///
/// If null, haptic feedback is automatically enabled on mobile platforms.
/// When true, provides tactile feedback when the button is pressed. When false,
/// no haptic feedback is provided regardless of platform.
  bool? enableFeedback;
/// Callback invoked when a tap down gesture begins.
///
/// Provides the position and details of the initial touch/click. Useful for
/// implementing custom press animations or tracking interaction start points.
  GestureTapDownCallback? onTapDown;
/// Callback invoked when a tap up gesture completes.
///
/// Called after a successful tap gesture, providing the position details.
/// Note that [onPressed] is typically preferred for button actions.
  GestureTapUpCallback? onTapUp;
/// Callback invoked when a tap gesture is canceled.
///
/// Called when a tap gesture starts but is interrupted before completion,
/// such as when the pointer moves outside the button area.
  GestureTapCancelCallback? onTapCancel;
/// Callback invoked when a secondary button (right-click) tap down begins.
///
/// Useful for implementing context menus or alternative actions.
  GestureTapDownCallback? onSecondaryTapDown;
/// Callback invoked when a secondary button tap up completes.
  GestureTapUpCallback? onSecondaryTapUp;
/// Callback invoked when a secondary button tap is canceled.
  GestureTapCancelCallback? onSecondaryTapCancel;
/// Callback invoked when a tertiary button (middle-click) tap down begins.
  GestureTapDownCallback? onTertiaryTapDown;
/// Callback invoked when a tertiary button tap up completes.
  GestureTapUpCallback? onTertiaryTapUp;
/// Callback invoked when a tertiary button tap is canceled.
  GestureTapCancelCallback? onTertiaryTapCancel;
/// Callback invoked when a long press gesture begins.
///
/// Provides the position where the long press started. Useful for implementing
/// press-and-hold actions or showing additional options.
  GestureLongPressStartCallback? onLongPressStart;
/// Callback invoked when a long press gesture completes.
  GestureLongPressUpCallback? onLongPressUp;
/// Callback invoked when a long press gesture moves.
///
/// Provides position updates during an active long press. Useful for
/// implementing drag-from-long-press behaviors.
  GestureLongPressMoveUpdateCallback? onLongPressMoveUpdate;
/// Callback invoked when a long press gesture ends.
  GestureLongPressEndCallback? onLongPressEnd;
/// Callback invoked when a secondary button long press completes.
  GestureLongPressUpCallback? onSecondaryLongPress;
/// Callback invoked when a tertiary button long press completes.
  GestureLongPressUpCallback? onTertiaryLongPress;
/// Whether to disable hover visual effects.
///
/// When true, the button doesn't show visual changes on hover, though [onHover]
/// callbacks are still called. Useful for custom hover implementations.
  bool disableHoverEffect;
/// Controller for managing button widget states externally.
///
/// Allows external control over hover, pressed, focused, and other widget states.
/// Useful for implementing custom state logic or coordinating with other widgets.
  WidgetStatesController? statesController;
/// Alignment for the button's margin within its allocated space.
///
/// Controls how the button positions itself within its parent's constraints
/// when the button is smaller than the available space.
  AlignmentGeometry? marginAlignment;
/// Whether to disable the focus outline.
///
/// When true, removes the visual focus indicator that appears when the button
/// is focused via keyboard navigation. Use carefully as this affects accessibility.
  bool disableFocusOutline;
/// Creates a [Button] with custom styling.
///
/// This is the base constructor that allows complete customization of the button's
/// appearance and behavior through the [style] parameter. For common use cases,
/// consider using the named constructors like [Button.primary] or [Button.secondary].
///
/// Parameters:
/// - [statesController] (WidgetStatesController?, optional): External state management.
/// - [leading] (Widget?, optional): Widget displayed before the main content.
/// - [trailing] (Widget?, optional): Widget displayed after the main content.
/// - [child] (Widget, required): Main content of the button.
/// - [onPressed] (VoidCallback?, optional): Primary action callback.
/// - [focusNode] (FocusNode?, optional): Focus management node.
/// - [alignment] (AlignmentGeometry?, optional): Content alignment within button.
/// - [style] (AbstractButtonStyle, required): Visual styling configuration.
/// - [enabled] (bool?, optional): Whether button responds to interactions.
/// - [disableTransition] (bool, default: false): Whether to disable state animations.
/// - [onFocus] (`ValueChanged<bool>?`, optional): Focus state change callback.
/// - [onHover] (`ValueChanged<bool>?`, optional): Hover state change callback.
/// - [disableHoverEffect] (bool, default: false): Whether to disable hover visuals.
/// - [enableFeedback] (bool?, optional): Whether to provide haptic feedback.
/// - [marginAlignment] (AlignmentGeometry?, optional): Margin positioning.
/// - [disableFocusOutline] (bool, default: false): Whether to hide focus outline.
///
/// Example:
/// ```dart
/// Button(
///   style: ButtonStyle.primary(),
///   leading: Icon(Icons.save),
///   onPressed: () => saveDocument(),
///   child: Text('Save Document'),
/// );
/// ```
  const Button({super.key, this.statesController, this.leading, this.trailing, this.leadingGap, this.trailingGap, required this.child, this.onPressed, this.focusNode, this.alignment, required this.style, this.enabled, this.disableTransition = false, this.onFocus, this.onHover, this.disableHoverEffect = false, this.enableFeedback, this.onTapDown, this.onTapUp, this.onTapCancel, this.onSecondaryTapDown, this.onSecondaryTapUp, this.onSecondaryTapCancel, this.onTertiaryTapDown, this.onTertiaryTapUp, this.onTertiaryTapCancel, this.onLongPressStart, this.onLongPressUp, this.onLongPressMoveUpdate, this.onLongPressEnd, this.onSecondaryLongPress, this.onTertiaryLongPress, this.marginAlignment, this.disableFocusOutline = false});
/// Creates a primary button with prominent styling for main actions.
///
/// Primary buttons use a filled background with high contrast text, making them
/// suitable for the most important action on a screen or in a section. They have
/// the highest visual weight and should be used sparingly.
///
/// The button uses the primary color from the theme and provides clear visual
/// feedback for hover, focus, and press states.
///
/// Parameters: Same as [Button] constructor, with [style] preset to [ButtonVariance.primary].
///
/// Example:
/// ```dart
/// Button.primary(
///   onPressed: () => submitForm(),
///   child: Text('Submit'),
/// );
/// ```
  const Button.primary({super.key, this.statesController, this.leading, this.trailing, this.leadingGap, this.trailingGap, required this.child, this.onPressed, this.focusNode, this.alignment, this.enabled, this.style = ButtonVariance.primary, this.disableTransition = false, this.onFocus, this.onHover, this.disableHoverEffect = false, this.enableFeedback, this.onTapDown, this.onTapUp, this.onTapCancel, this.onSecondaryTapDown, this.onSecondaryTapUp, this.onSecondaryTapCancel, this.onTertiaryTapDown, this.onTertiaryTapUp, this.onTertiaryTapCancel, this.onLongPressStart, this.onLongPressUp, this.onLongPressMoveUpdate, this.onLongPressEnd, this.onSecondaryLongPress, this.onTertiaryLongPress, this.marginAlignment, this.disableFocusOutline = false});
/// Creates a secondary button with muted styling for supporting actions.
///
/// Secondary buttons use a subtle background color with medium contrast text,
/// making them suitable for actions that are important but not primary. They have
/// less visual weight than primary buttons and can be used more frequently.
///
/// Example:
/// ```dart
/// Button.secondary(
///   onPressed: () => cancelAction(),
///   child: Text('Cancel'),
/// );
/// ```
  const Button.secondary({super.key, this.statesController, this.leading, this.trailing, this.leadingGap, this.trailingGap, required this.child, this.onPressed, this.focusNode, this.alignment, this.enabled, this.style = ButtonVariance.secondary, this.disableTransition = false, this.onFocus, this.onHover, this.disableHoverEffect = false, this.enableFeedback, this.onTapDown, this.onTapUp, this.onTapCancel, this.onSecondaryTapDown, this.onSecondaryTapUp, this.onSecondaryTapCancel, this.onTertiaryTapDown, this.onTertiaryTapUp, this.onTertiaryTapCancel, this.onLongPressStart, this.onLongPressUp, this.onLongPressMoveUpdate, this.onLongPressEnd, this.onSecondaryLongPress, this.onTertiaryLongPress, this.marginAlignment, this.disableFocusOutline = false});
/// Creates an outline button with a border and transparent background.
///
/// Outline buttons feature a visible border and transparent background, providing
/// a minimal yet distinct appearance. They're ideal for secondary actions that need
/// to stand out more than ghost buttons but less than filled buttons. The outline
/// style works well in layouts where visual hierarchy matters.
///
/// Example:
/// ```dart
/// Button.outline(
///   onPressed: () => showMore(),
///   child: Text('Learn More'),
/// );
/// ```
  const Button.outline({super.key, this.statesController, this.leading, this.trailing, this.leadingGap, this.trailingGap, required this.child, this.onPressed, this.focusNode, this.alignment, this.enabled, this.style = ButtonVariance.outline, this.disableTransition = false, this.onFocus, this.onHover, this.disableHoverEffect = false, this.enableFeedback, this.onTapDown, this.onTapUp, this.onTapCancel, this.onSecondaryTapDown, this.onSecondaryTapUp, this.onSecondaryTapCancel, this.onTertiaryTapDown, this.onTertiaryTapUp, this.onTertiaryTapCancel, this.onLongPressStart, this.onLongPressUp, this.onLongPressMoveUpdate, this.onLongPressEnd, this.onSecondaryLongPress, this.onTertiaryLongPress, this.marginAlignment, this.disableFocusOutline = false});
/// Creates a ghost button with minimal styling for subtle actions.
///
/// Ghost buttons have no background by default and only show subtle hover effects.
/// They're perfect for actions that need to be available but shouldn't draw attention
/// away from more important content.
///
/// Example:
/// ```dart
/// Button.ghost(
///   onPressed: () => showHelp(),
///   leading: Icon(Icons.help_outline),
///   child: Text('Help'),
/// );
/// ```
  const Button.ghost({super.key, this.statesController, this.leading, this.trailing, this.leadingGap, this.trailingGap, required this.child, this.onPressed, this.focusNode, this.alignment, this.enabled, this.style = ButtonVariance.ghost, this.disableTransition = false, this.onFocus, this.onHover, this.disableHoverEffect = false, this.enableFeedback, this.onTapDown, this.onTapUp, this.onTapCancel, this.onSecondaryTapDown, this.onSecondaryTapUp, this.onSecondaryTapCancel, this.onTertiaryTapDown, this.onTertiaryTapUp, this.onTertiaryTapCancel, this.onLongPressStart, this.onLongPressUp, this.onLongPressMoveUpdate, this.onLongPressEnd, this.onSecondaryLongPress, this.onTertiaryLongPress, this.marginAlignment, this.disableFocusOutline = false});
/// Creates a link-styled button with underline decoration.
///
/// Link buttons appear as inline text links, typically underlined on hover,
/// making them suitable for navigation or inline actions within text. They have
/// minimal visual presence and work well for tertiary actions or embedded links.
///
/// Example:
/// ```dart
/// Button.link(
///   onPressed: () => openUrl(),
///   child: Text('View Documentation'),
/// );
/// ```
  const Button.link({super.key, this.statesController, this.leading, this.trailing, this.leadingGap, this.trailingGap, required this.child, this.onPressed, this.focusNode, this.alignment, this.enabled, this.style = ButtonVariance.link, this.disableTransition = false, this.onFocus, this.onHover, this.disableHoverEffect = false, this.enableFeedback, this.onTapDown, this.onTapUp, this.onTapCancel, this.onSecondaryTapDown, this.onSecondaryTapUp, this.onSecondaryTapCancel, this.onTertiaryTapDown, this.onTertiaryTapUp, this.onTertiaryTapCancel, this.onLongPressStart, this.onLongPressUp, this.onLongPressMoveUpdate, this.onLongPressEnd, this.onSecondaryLongPress, this.onTertiaryLongPress, this.marginAlignment, this.disableFocusOutline = false});
/// Creates a text-only button with no background or border.
///
/// Text buttons display only their text content without any background fill or
/// border decoration. They're the most minimal button style, useful for actions
/// that should be accessible but not visually prominent, such as "Skip" or "Not now".
///
/// Example:
/// ```dart
/// Button.text(
///   onPressed: () => skipStep(),
///   child: Text('Skip'),
/// );
/// ```
  const Button.text({super.key, this.statesController, this.leading, this.trailing, this.leadingGap, this.trailingGap, required this.child, this.onPressed, this.focusNode, this.alignment, this.enabled, this.style = ButtonVariance.text, this.disableTransition = false, this.onFocus, this.onHover, this.disableHoverEffect = false, this.enableFeedback, this.onTapDown, this.onTapUp, this.onTapCancel, this.onSecondaryTapDown, this.onSecondaryTapUp, this.onSecondaryTapCancel, this.onTertiaryTapDown, this.onTertiaryTapUp, this.onTertiaryTapCancel, this.onLongPressStart, this.onLongPressUp, this.onLongPressMoveUpdate, this.onLongPressEnd, this.onSecondaryLongPress, this.onTertiaryLongPress, this.marginAlignment, this.disableFocusOutline = false});
/// Creates a destructive button for actions that delete or destroy data.
///
/// Destructive buttons use red/warning colors to clearly indicate that the action
/// will remove, delete, or otherwise negatively affect user data. They should be
/// used sparingly and typically require confirmation dialogs.
///
/// Example:
/// ```dart
/// Button.destructive(
///   onPressed: () => deleteItem(),
///   leading: Icon(Icons.delete),
///   child: Text('Delete'),
/// );
/// ```
  const Button.destructive({super.key, this.statesController, this.leading, this.trailing, this.leadingGap, this.trailingGap, required this.child, this.onPressed, this.focusNode, this.alignment, this.enabled, this.style = ButtonVariance.destructive, this.disableTransition = false, this.onFocus, this.onHover, this.disableHoverEffect = false, this.enableFeedback, this.onTapDown, this.onTapUp, this.onTapCancel, this.onSecondaryTapDown, this.onSecondaryTapUp, this.onSecondaryTapCancel, this.onTertiaryTapDown, this.onTertiaryTapUp, this.onTertiaryTapCancel, this.onLongPressStart, this.onLongPressUp, this.onLongPressMoveUpdate, this.onLongPressEnd, this.onSecondaryLongPress, this.onTertiaryLongPress, this.marginAlignment, this.disableFocusOutline = false});
/// Creates a fixed-style button with consistent dimensions.
///
/// Fixed buttons maintain specific dimensions regardless of content, making them
/// ideal for grids, toolbars, or layouts where uniform button sizing is required.
/// They're commonly used in icon-heavy interfaces or when precise spacing matters.
///
/// Example:
/// ```dart
/// Button.fixed(
///   onPressed: () => performAction(),
///   child: Icon(Icons.add),
/// );
/// ```
  const Button.fixed({super.key, this.statesController, this.leading, this.trailing, this.leadingGap, this.trailingGap, required this.child, this.onPressed, this.focusNode, this.alignment, this.enabled, this.style = ButtonVariance.fixed, this.disableTransition = false, this.onFocus, this.onHover, this.disableHoverEffect = false, this.enableFeedback, this.onTapDown, this.onTapUp, this.onTapCancel, this.onSecondaryTapDown, this.onSecondaryTapUp, this.onSecondaryTapCancel, this.onTertiaryTapDown, this.onTertiaryTapUp, this.onTertiaryTapCancel, this.onLongPressStart, this.onLongPressUp, this.onLongPressMoveUpdate, this.onLongPressEnd, this.onSecondaryLongPress, this.onTertiaryLongPress, this.marginAlignment, this.disableFocusOutline = false});
/// Creates a card-style button with elevated appearance.
///
/// Card buttons feature subtle shadows and borders to create a card-like elevated
/// appearance. They work well in content-heavy layouts where buttons need to stand
/// out from surrounding content, such as feature cards or call-to-action sections.
///
/// Example:
/// ```dart
/// Button.card(
///   onPressed: () => selectOption(),
///   child: Column(
///     children: [
///       Icon(Icons.star),
///       Text('Premium'),
///     ],
///   ),
/// );
/// ```
  const Button.card({super.key, this.statesController, this.leading, this.trailing, this.leadingGap, this.trailingGap, required this.child, this.onPressed, this.focusNode, this.alignment, this.enabled, this.style = ButtonVariance.card, this.disableTransition = false, this.onFocus, this.onHover, this.disableHoverEffect = false, this.enableFeedback, this.onTapDown, this.onTapUp, this.onTapCancel, this.onSecondaryTapDown, this.onSecondaryTapUp, this.onSecondaryTapCancel, this.onTertiaryTapDown, this.onTertiaryTapUp, this.onTertiaryTapCancel, this.onLongPressStart, this.onLongPressUp, this.onLongPressMoveUpdate, this.onLongPressEnd, this.onSecondaryLongPress, this.onTertiaryLongPress, this.marginAlignment, this.disableFocusOutline = false});
  ButtonState createState();
}
/// State class for [Button] widgets managing interactive state and rendering.
///
/// [ButtonState] handles the button's lifecycle, manages the [WidgetStatesController]
/// for tracking interactive states (pressed, hovered, focused, disabled), and
/// coordinates with the button's style system to apply appropriate visual changes
/// based on the current state.
///
/// This class is generic, allowing it to manage state for various button types
/// (primary, secondary, outline, etc.) through the type parameter [T].
///
/// The state class automatically:
/// - Creates or uses a provided [WidgetStatesController]
/// - Updates the disabled state based on [onPressed] availability
/// - Manages focus and hover interactions
/// - Applies style transitions and animations
class ButtonState<T extends Button> extends State<T> {
  void initState();
  void didChangeDependencies();
  void didUpdateWidget(T oldWidget);
  Widget build(BuildContext context);
}
/// Defines the relative size scaling for button components.
///
/// [ButtonSize] controls the overall scale of buttons, affecting text size,
/// icon size, and proportional padding. The scaling factor is applied to
/// all dimensional properties to maintain visual consistency.
///
/// Example:
/// ```dart
/// Button.primary(
///   style: ButtonStyle.primary().copyWith(size: ButtonSize.large),
///   child: Text('Large Button'),
/// );
/// ```
class ButtonSize {
/// The scaling factor applied to button dimensions.
///
/// A value of 1.0 represents normal size, values less than 1.0 create smaller
/// buttons, and values greater than 1.0 create larger buttons.
  double scale;
/// Creates a [ButtonSize] with the specified scaling factor.
  const ButtonSize(this.scale);
/// Standard button size (scale: 1.0).
  static const ButtonSize normal = ButtonSize(1);
/// Extra small button size (scale: 0.5).
  static const ButtonSize xSmall = ButtonSize(1 / 2);
/// Small button size (scale: 0.75).
  static const ButtonSize small = ButtonSize(3 / 4);
/// Large button size (scale: 2.0).
  static const ButtonSize large = ButtonSize(2);
/// Extra large button size (scale: 3.0).
  static const ButtonSize xLarge = ButtonSize(3);
}
/// Defines the padding density for button components.
///
/// [ButtonDensity] controls how much internal padding buttons have, affecting
/// their overall size and touch target area. Different density levels are
/// appropriate for different use cases and layout constraints.
///
/// Example:
/// ```dart
/// Button.primary(
///   style: ButtonStyle.primary().copyWith(density: ButtonDensity.compact),
///   child: Text('Compact Button'),
/// );
/// ```
class ButtonDensity {
/// Function that modifies base padding to achieve the desired density.
  DensityModifier modifier;
/// Creates a [ButtonDensity] with the specified padding modifier.
  const ButtonDensity(this.modifier);
/// Standard padding density (no modification).
  static const ButtonDensity normal = ButtonDensity(_densityNormal);
/// Increased padding for more comfortable touch targets.
  static const ButtonDensity comfortable = ButtonDensity(_densityComfortable);
/// Square padding suitable for icon-only buttons.
  static const ButtonDensity icon = ButtonDensity(_densityIcon);
/// Comfortable square padding for icon-only buttons.
  static const ButtonDensity iconComfortable = ButtonDensity(_densityIconComfortable);
/// Dense square padding for compact icon buttons.
  static const ButtonDensity iconDense = ButtonDensity(_densityIconDense);
/// Reduced padding for tighter layouts (50% of normal).
  static const ButtonDensity dense = ButtonDensity(_densityDense);
/// Minimal padding for very compact layouts (zero padding).
  static const ButtonDensity compact = ButtonDensity(_densityCompact);
}
/// Defines the shape style for button components.
///
/// [ButtonShape] determines the border radius and overall shape of buttons,
/// allowing for rectangular buttons with rounded corners or fully circular buttons.
enum ButtonShape { rectangle, circle }
/// Abstract interface defining the style properties for button components.
///
/// [AbstractButtonStyle] specifies the contract for button styling, requiring
/// implementations to provide state-dependent values for decoration, cursor,
/// padding, text style, icon theme, and margin. This abstraction allows for
/// flexible button theming while maintaining a consistent API.
///
/// All properties return [ButtonStateProperty] functions that resolve values
/// based on the button's current interactive state (hovered, pressed, focused, etc.).
///
/// Implementations include [ButtonStyle] and [ButtonVariance], which provide
/// concrete styling configurations for different button types.
abstract class AbstractButtonStyle {
/// Returns the decoration (background, border, shadows) based on button state.
  ButtonStateProperty<Decoration> get decoration;
/// Returns the mouse cursor appearance based on button state.
  ButtonStateProperty<MouseCursor> get mouseCursor;
/// Returns the internal padding based on button state.
  ButtonStateProperty<EdgeInsetsGeometry> get padding;
/// Returns the text style based on button state.
  ButtonStateProperty<TextStyle> get textStyle;
/// Returns the icon theme based on button state.
  ButtonStateProperty<IconThemeData> get iconTheme;
/// Returns the external margin based on button state.
  ButtonStateProperty<EdgeInsetsGeometry> get margin;
}
/// Configurable button style combining variance, size, density, and shape.
///
/// [ButtonStyle] implements [AbstractButtonStyle] and provides a composable way
/// to create button styles by combining a base variance (primary, secondary, outline,
/// etc.) with size, density, and shape modifiers. This allows for flexible button
/// customization while maintaining consistency.
///
/// The class provides named constructors for common button variants (primary,
/// secondary, outline, etc.) and can be further customized with size and density options.
///
/// Example:
/// ```dart
/// // Create a large primary button
/// const ButtonStyle.primary(
///   size: ButtonSize.large,
///   density: ButtonDensity.comfortable,
/// )
///
/// // Create a small outline button with circular shape
/// const ButtonStyle.outline(
///   size: ButtonSize.small,
///   shape: ButtonShape.circle,
/// )
/// ```
class ButtonStyle implements AbstractButtonStyle {
/// The base style variance (primary, secondary, outline, etc.).
  AbstractButtonStyle variance;
/// The size configuration affecting padding and minimum dimensions.
  ButtonSize size;
/// The density configuration affecting spacing and compactness.
  ButtonDensity density;
/// The shape configuration (rectangle or circle).
  ButtonShape shape;
/// Creates a custom [ButtonStyle] with the specified variance and modifiers.
///
/// Parameters:
/// - [variance] (required): The base button style variant
/// - [size]: The button size. Defaults to [ButtonSize.normal]
/// - [density]: The button density. Defaults to [ButtonDensity.normal]
/// - [shape]: The button shape. Defaults to [ButtonShape.rectangle]
  const ButtonStyle({required this.variance, this.size = ButtonSize.normal, this.density = ButtonDensity.normal, this.shape = ButtonShape.rectangle});
/// Creates a primary button style with prominent filled appearance.
///
/// Primary buttons use the theme's primary color with high contrast, making them
/// ideal for the main action on a screen.
  const ButtonStyle.primary({this.size = ButtonSize.normal, this.density = ButtonDensity.normal, this.shape = ButtonShape.rectangle});
/// Creates a secondary button style with muted appearance.
///
/// Secondary buttons have less visual prominence than primary buttons, suitable
/// for supporting or alternative actions.
  const ButtonStyle.secondary({this.size = ButtonSize.normal, this.density = ButtonDensity.normal, this.shape = ButtonShape.rectangle});
/// Creates an outline button style with border and no background.
///
/// Outline buttons feature a border with transparent background, providing a
/// clear but subtle appearance for secondary actions.
  const ButtonStyle.outline({this.size = ButtonSize.normal, this.density = ButtonDensity.normal, this.shape = ButtonShape.rectangle});
/// Creates a ghost button style with minimal visual presence.
///
/// Ghost buttons have no background or border, only showing on hover, making
/// them ideal for tertiary actions.
  const ButtonStyle.ghost({this.size = ButtonSize.normal, this.density = ButtonDensity.normal, this.shape = ButtonShape.rectangle});
/// Creates a link button style resembling a text hyperlink.
///
/// Link buttons appear as inline links with underline decoration, typically
/// used for navigation or inline actions.
  const ButtonStyle.link({this.size = ButtonSize.normal, this.density = ButtonDensity.normal, this.shape = ButtonShape.rectangle});
/// Creates a text-only button style with no background or border.
///
/// Text buttons display only their text content, making them the most minimal
/// button style for unobtrusive actions.
  const ButtonStyle.text({this.size = ButtonSize.normal, this.density = ButtonDensity.normal, this.shape = ButtonShape.rectangle});
/// Creates a destructive button style for delete/remove actions.
///
/// Destructive buttons use warning colors (typically red) to indicate actions
/// that remove or delete data.
  const ButtonStyle.destructive({this.size = ButtonSize.normal, this.density = ButtonDensity.normal, this.shape = ButtonShape.rectangle});
/// Creates a fixed-size button style with consistent dimensions.
///
/// Fixed buttons maintain specific dimensions regardless of content, useful
/// for icon buttons or grid layouts.
  const ButtonStyle.fixed({this.size = ButtonSize.normal, this.density = ButtonDensity.normal, this.shape = ButtonShape.rectangle});
/// Creates a menu button style for dropdown menu triggers.
///
/// Menu buttons are designed for triggering dropdown menus, with appropriate
/// spacing and styling for menu contexts.
  const ButtonStyle.menu({this.size = ButtonSize.normal, this.density = ButtonDensity.normal, this.shape = ButtonShape.rectangle});
/// Creates a menubar button style for menubar items.
///
/// Menubar buttons are optimized for horizontal menu bars with appropriate
/// padding and hover effects.
  const ButtonStyle.menubar({this.size = ButtonSize.normal, this.density = ButtonDensity.normal, this.shape = ButtonShape.rectangle});
/// Creates a muted button style with subdued appearance.
///
/// Muted buttons use low-contrast colors for minimal visual impact while
/// remaining functional.
  const ButtonStyle.muted({this.size = ButtonSize.normal, this.density = ButtonDensity.normal, this.shape = ButtonShape.rectangle});
/// Creates a primary icon button style with compact icon density.
///
/// Icon buttons are optimized for displaying icons without text, using
/// [ButtonDensity.icon] for appropriate spacing.
  const ButtonStyle.primaryIcon({this.size = ButtonSize.normal, this.density = ButtonDensity.icon, this.shape = ButtonShape.rectangle});
/// Creates a secondary icon button style with compact icon density.
  const ButtonStyle.secondaryIcon({this.size = ButtonSize.normal, this.density = ButtonDensity.icon, this.shape = ButtonShape.rectangle});
/// Creates an outline icon button style with compact icon density.
  const ButtonStyle.outlineIcon({this.size = ButtonSize.normal, this.density = ButtonDensity.icon, this.shape = ButtonShape.rectangle});
/// Creates a ghost icon button style with compact icon density.
  const ButtonStyle.ghostIcon({this.size = ButtonSize.normal, this.density = ButtonDensity.icon, this.shape = ButtonShape.rectangle});
/// Creates a link icon button style with compact icon density.
  const ButtonStyle.linkIcon({this.size = ButtonSize.normal, this.density = ButtonDensity.icon, this.shape = ButtonShape.rectangle});
/// Creates a text icon button style with compact icon density.
  const ButtonStyle.textIcon({this.size = ButtonSize.normal, this.density = ButtonDensity.icon, this.shape = ButtonShape.rectangle});
/// Creates a destructive icon button style with compact icon density.
  const ButtonStyle.destructiveIcon({this.size = ButtonSize.normal, this.density = ButtonDensity.icon, this.shape = ButtonShape.rectangle});
/// Creates a fixed icon button style with compact icon density.
  const ButtonStyle.fixedIcon({this.size = ButtonSize.normal, this.density = ButtonDensity.icon, this.shape = ButtonShape.rectangle});
/// Creates a card button style with elevated appearance.
///
/// Card buttons feature subtle shadows and borders creating an elevated,
/// card-like appearance suitable for content-heavy layouts.
  const ButtonStyle.card({this.size = ButtonSize.normal, this.density = ButtonDensity.normal, this.shape = ButtonShape.rectangle});
  ButtonStateProperty<Decoration> get decoration;
  ButtonStateProperty<MouseCursor> get mouseCursor;
  ButtonStateProperty<EdgeInsetsGeometry> get padding;
  ButtonStateProperty<TextStyle> get textStyle;
  ButtonStateProperty<IconThemeData> get iconTheme;
  ButtonStateProperty<EdgeInsetsGeometry> get margin;
}
/// Abstract base class for button theme customization.
///
/// [ButtonTheme] provides optional style property delegates that can override
/// or modify the default button styling. Subclasses implement specific button
/// variants (primary, secondary, outline, etc.) allowing theme-level customization
/// of button appearances throughout an application.
///
/// Each property is a [ButtonStatePropertyDelegate] that receives the context,
/// current states, and the default value, allowing for context-aware and
/// state-dependent style modifications.
///
/// Implementations include [PrimaryButtonTheme], [SecondaryButtonTheme],
/// [OutlineButtonTheme], and others for each button variant.
abstract class ButtonTheme extends ComponentThemeData {
/// Optional decoration override (background, border, shadows).
  ButtonStatePropertyDelegate<Decoration>? decoration;
/// Optional mouse cursor override.
  ButtonStatePropertyDelegate<MouseCursor>? mouseCursor;
/// Optional padding override.
  ButtonStatePropertyDelegate<EdgeInsetsGeometry>? padding;
/// Optional text style override.
  ButtonStatePropertyDelegate<TextStyle>? textStyle;
/// Optional icon theme override.
  ButtonStatePropertyDelegate<IconThemeData>? iconTheme;
/// Optional margin override.
  ButtonStatePropertyDelegate<EdgeInsetsGeometry>? margin;
/// Creates a [ButtonTheme] with optional style property delegates.
///
/// All parameters are optional, allowing selective override of specific
/// style properties while leaving others to use default values.
  const ButtonTheme({this.decoration, this.mouseCursor, this.padding, this.textStyle, this.iconTheme, this.margin});
  bool operator ==(Object other);
  int get hashCode;
  String toString();
}
/// Theme-aware button style that integrates with the component theme system.
///
/// [ComponentThemeButtonStyle] implements [AbstractButtonStyle] and provides
/// automatic theme integration by looking up theme overrides from the widget tree's
/// [ComponentTheme]. If a theme override is found, it's applied; otherwise, the
/// fallback style is used.
///
/// This enables global button style customization through the theme system while
/// maintaining type-safe access to specific button theme types.
///
/// Example:
/// ```dart
/// const ComponentThemeButtonStyle<PrimaryButtonTheme>(
///   fallback: ButtonVariance.primary,
/// )
/// ```
class ComponentThemeButtonStyle<T extends ButtonTheme> implements AbstractButtonStyle {
/// The fallback style used when no theme override is found.
  AbstractButtonStyle fallback;
/// Creates a [ComponentThemeButtonStyle] with the specified fallback style.
///
/// Parameters:
/// - [fallback] (required): The default style used when theme override is not available.
  const ComponentThemeButtonStyle({required this.fallback});
/// Looks up the button theme of type [T] from the component theme.
///
/// Returns the theme instance if found in the widget tree, or `null` if not present.
  T? find(BuildContext context);
  ButtonStateProperty<Decoration> get decoration;
  ButtonStateProperty<IconThemeData> get iconTheme;
  ButtonStateProperty<EdgeInsetsGeometry> get margin;
  ButtonStateProperty<MouseCursor> get mouseCursor;
  ButtonStateProperty<EdgeInsetsGeometry> get padding;
  ButtonStateProperty<TextStyle> get textStyle;
}
/// Extension methods for [ShapeDecoration] providing copyWith functionality.
///
/// Adds a `copyWith` method to [ShapeDecoration] for creating modified copies
/// with selectively updated properties, similar to the pattern used in Flutter
/// for other decoration types.
extension ShapeDecorationExtension on ShapeDecoration {
/// Creates a copy of this [ShapeDecoration] with specified properties replaced.
///
/// Parameters:
/// - [shape]: Replacement shape border
/// - [color]: Replacement fill color
/// - [gradient]: Replacement gradient
/// - [shadows]: Replacement shadow list
/// - [image]: Replacement decoration image
///
/// Returns a new [ShapeDecoration] with the specified properties updated
/// and all other properties copied from the original.
  ShapeDecoration copyWith({ShapeBorder? shape, Color? color, Gradient? gradient, List<BoxShadow>? shadows, DecorationImage? image});
}
/// Extension methods for [Decoration] providing type-safe copyWith operations.
///
/// Adds convenience methods to [Decoration] for creating modified copies when
/// the decoration is either a [BoxDecoration] or [ShapeDecoration]. These methods
/// handle type checking and provide appropriate defaults when the decoration
/// doesn't match the expected type.
extension DecorationExtension on Decoration {
/// Creates a [BoxDecoration] copy with specified properties replaced.
///
/// If this decoration is a [BoxDecoration], creates a modified copy.
/// Otherwise, creates a new [BoxDecoration] with the provided properties.
///
/// Parameters:
/// - [color]: Replacement or new background color
/// - [image]: Replacement or new decoration image
/// - [border]: Replacement or new border
/// - [borderRadius]: Replacement or new border radius
/// - [boxShadow]: Replacement or new shadow list
/// - [gradient]: Replacement or new gradient
/// - [shape]: Replacement or new box shape
/// - [backgroundBlendMode]: Replacement or new blend mode
///
/// Returns a [BoxDecoration] with the specified properties.
  BoxDecoration copyWithIfBoxDecoration({Color? color, DecorationImage? image, BoxBorder? border, BorderRadiusGeometry? borderRadius, List<BoxShadow>? boxShadow, Gradient? gradient, BoxShape? shape, BlendMode? backgroundBlendMode});
/// Creates a [ShapeDecoration] copy with specified properties replaced.
///
/// If this decoration is a [ShapeDecoration], creates a modified copy.
/// Otherwise, creates a new [ShapeDecoration] with the provided properties.
///
/// Parameters:
/// - [shape]: Replacement or new shape border
/// - [color]: Replacement or new fill color
/// - [gradient]: Replacement or new gradient
/// - [shadows]: Replacement or new shadow list
/// - [image]: Replacement or new decoration image
///
/// Returns a [ShapeDecoration] with the specified properties.
  ShapeDecoration copyWithIfShapeDecoration({ShapeBorder? shape, Color? color, Gradient? gradient, List<BoxShadow>? shadows, DecorationImage? image});
}
/// Theme configuration for primary button styling.
///
/// [PrimaryButtonTheme] extends [ButtonTheme] to provide theme-level customization
/// for primary buttons. It can be registered in the component theme system to
/// override default primary button styles throughout the application.
///
/// Example:
/// ```dart
/// PrimaryButtonTheme(
///   decoration: (context, states, defaultValue) {
///     // Customize primary button decoration
///     return customDecoration;
///   },
/// )
/// ```
class PrimaryButtonTheme extends ButtonTheme {
/// Creates a [PrimaryButtonTheme] with optional style property delegates.
  const PrimaryButtonTheme({super.decoration, super.mouseCursor, super.padding, super.textStyle, super.iconTheme, super.margin});
/// Creates a copy of this theme with selectively replaced properties.
  PrimaryButtonTheme copyWith({ValueGetter<ButtonStatePropertyDelegate<Decoration>?>? decoration, ValueGetter<ButtonStatePropertyDelegate<MouseCursor>?>? mouseCursor, ValueGetter<ButtonStatePropertyDelegate<EdgeInsetsGeometry>?>? padding, ValueGetter<ButtonStatePropertyDelegate<TextStyle>?>? textStyle, ValueGetter<ButtonStatePropertyDelegate<IconThemeData>?>? iconTheme, ValueGetter<ButtonStatePropertyDelegate<EdgeInsetsGeometry>?>? margin});
}
/// Theme configuration for secondary button styling.
///
/// Provides theme-level customization for secondary buttons through the component
/// theme system. Secondary buttons have muted styling suitable for supporting actions.
class SecondaryButtonTheme extends ButtonTheme {
/// Creates a [SecondaryButtonTheme] with optional style property delegates.
  const SecondaryButtonTheme({super.decoration, super.mouseCursor, super.padding, super.textStyle, super.iconTheme, super.margin});
/// Creates a copy of this theme with selectively replaced properties.
  SecondaryButtonTheme copyWith({ValueGetter<ButtonStatePropertyDelegate<Decoration>?>? decoration, ValueGetter<ButtonStatePropertyDelegate<MouseCursor>?>? mouseCursor, ValueGetter<ButtonStatePropertyDelegate<EdgeInsetsGeometry>?>? padding, ValueGetter<ButtonStatePropertyDelegate<TextStyle>?>? textStyle, ValueGetter<ButtonStatePropertyDelegate<IconThemeData>?>? iconTheme, ValueGetter<ButtonStatePropertyDelegate<EdgeInsetsGeometry>?>? margin});
}
/// Theme configuration for outline button styling.
///
/// Provides theme-level customization for outline buttons through the component
/// theme system. Outline buttons feature borders with transparent backgrounds.
class OutlineButtonTheme extends ButtonTheme {
/// Creates an [OutlineButtonTheme] with optional style property delegates.
  const OutlineButtonTheme({super.decoration, super.mouseCursor, super.padding, super.textStyle, super.iconTheme, super.margin});
/// Creates a copy of this theme with selectively replaced properties.
  OutlineButtonTheme copyWith({ValueGetter<ButtonStatePropertyDelegate<Decoration>?>? decoration, ValueGetter<ButtonStatePropertyDelegate<MouseCursor>?>? mouseCursor, ValueGetter<ButtonStatePropertyDelegate<EdgeInsetsGeometry>?>? padding, ValueGetter<ButtonStatePropertyDelegate<TextStyle>?>? textStyle, ValueGetter<ButtonStatePropertyDelegate<IconThemeData>?>? iconTheme, ValueGetter<ButtonStatePropertyDelegate<EdgeInsetsGeometry>?>? margin});
}
/// Theme configuration for ghost button styling.
///
/// Provides theme-level customization for ghost buttons. Ghost buttons have minimal
/// visual presence with no background or border by default.
class GhostButtonTheme extends ButtonTheme {
/// Creates a [GhostButtonTheme] with optional style property delegates.
  const GhostButtonTheme({super.decoration, super.mouseCursor, super.padding, super.textStyle, super.iconTheme, super.margin});
/// Creates a copy of this theme with selectively replaced properties.
  GhostButtonTheme copyWith({ValueGetter<ButtonStatePropertyDelegate<Decoration>?>? decoration, ValueGetter<ButtonStatePropertyDelegate<MouseCursor>?>? mouseCursor, ValueGetter<ButtonStatePropertyDelegate<EdgeInsetsGeometry>?>? padding, ValueGetter<ButtonStatePropertyDelegate<TextStyle>?>? textStyle, ValueGetter<ButtonStatePropertyDelegate<IconThemeData>?>? iconTheme, ValueGetter<ButtonStatePropertyDelegate<EdgeInsetsGeometry>?>? margin});
}
/// Theme configuration for link button styling.
///
/// Provides theme-level customization for link buttons. Link buttons appear as
/// inline hyperlinks with underline decoration.
class LinkButtonTheme extends ButtonTheme {
/// Creates a [LinkButtonTheme] with optional style property delegates.
  const LinkButtonTheme({super.decoration, super.mouseCursor, super.padding, super.textStyle, super.iconTheme, super.margin});
/// Creates a copy of this theme with selectively replaced properties.
  LinkButtonTheme copyWith({ValueGetter<ButtonStatePropertyDelegate<Decoration>?>? decoration, ValueGetter<ButtonStatePropertyDelegate<MouseCursor>?>? mouseCursor, ValueGetter<ButtonStatePropertyDelegate<EdgeInsetsGeometry>?>? padding, ValueGetter<ButtonStatePropertyDelegate<TextStyle>?>? textStyle, ValueGetter<ButtonStatePropertyDelegate<IconThemeData>?>? iconTheme, ValueGetter<ButtonStatePropertyDelegate<EdgeInsetsGeometry>?>? margin});
}
/// Theme configuration for text button styling.
///
/// Provides theme-level customization for text buttons. Text buttons display only
/// their text content without background or border decoration.
class TextButtonTheme extends ButtonTheme {
/// Creates a [TextButtonTheme] with optional style property delegates.
  const TextButtonTheme({super.decoration, super.mouseCursor, super.padding, super.textStyle, super.iconTheme, super.margin});
/// Creates a copy of this theme with selectively replaced properties.
  TextButtonTheme copyWith({ValueGetter<ButtonStatePropertyDelegate<Decoration>?>? decoration, ValueGetter<ButtonStatePropertyDelegate<MouseCursor>?>? mouseCursor, ValueGetter<ButtonStatePropertyDelegate<EdgeInsetsGeometry>?>? padding, ValueGetter<ButtonStatePropertyDelegate<TextStyle>?>? textStyle, ValueGetter<ButtonStatePropertyDelegate<IconThemeData>?>? iconTheme, ValueGetter<ButtonStatePropertyDelegate<EdgeInsetsGeometry>?>? margin});
}
/// Theme configuration for destructive button styling.
///
/// Provides theme-level customization for destructive buttons. Destructive buttons
/// use warning colors (typically red) for actions that delete or remove data.
class DestructiveButtonTheme extends ButtonTheme {
/// Creates a [DestructiveButtonTheme] with optional style property delegates.
  const DestructiveButtonTheme({super.decoration, super.mouseCursor, super.padding, super.textStyle, super.iconTheme, super.margin});
/// Creates a copy of this theme with selectively replaced properties.
  DestructiveButtonTheme copyWith({ValueGetter<ButtonStatePropertyDelegate<Decoration>?>? decoration, ValueGetter<ButtonStatePropertyDelegate<MouseCursor>?>? mouseCursor, ValueGetter<ButtonStatePropertyDelegate<EdgeInsetsGeometry>?>? padding, ValueGetter<ButtonStatePropertyDelegate<TextStyle>?>? textStyle, ValueGetter<ButtonStatePropertyDelegate<IconThemeData>?>? iconTheme, ValueGetter<ButtonStatePropertyDelegate<EdgeInsetsGeometry>?>? margin});
}
/// Theme configuration for fixed button styling.
///
/// Provides theme-level customization for fixed buttons. Fixed buttons maintain
/// consistent dimensions regardless of content.
class FixedButtonTheme extends ButtonTheme {
/// Creates a [FixedButtonTheme] with optional style property delegates.
  const FixedButtonTheme({super.decoration, super.mouseCursor, super.padding, super.textStyle, super.iconTheme, super.margin});
/// Creates a copy of this theme with selectively replaced properties.
  FixedButtonTheme copyWith({ValueGetter<ButtonStatePropertyDelegate<Decoration>?>? decoration, ValueGetter<ButtonStatePropertyDelegate<MouseCursor>?>? mouseCursor, ValueGetter<ButtonStatePropertyDelegate<EdgeInsetsGeometry>?>? padding, ValueGetter<ButtonStatePropertyDelegate<TextStyle>?>? textStyle, ValueGetter<ButtonStatePropertyDelegate<IconThemeData>?>? iconTheme, ValueGetter<ButtonStatePropertyDelegate<EdgeInsetsGeometry>?>? margin});
}
/// Theme configuration for menu button styling.
///
/// Provides theme-level customization for menu buttons. Menu buttons are designed
/// for triggering dropdown menus with appropriate spacing and styling.
class MenuButtonTheme extends ButtonTheme {
/// Creates a [MenuButtonTheme] with optional style property delegates.
  const MenuButtonTheme({super.decoration, super.mouseCursor, super.padding, super.textStyle, super.iconTheme, super.margin});
/// Creates a copy of this theme with selectively replaced properties.
  MenuButtonTheme copyWith({ValueGetter<ButtonStatePropertyDelegate<Decoration>?>? decoration, ValueGetter<ButtonStatePropertyDelegate<MouseCursor>?>? mouseCursor, ValueGetter<ButtonStatePropertyDelegate<EdgeInsetsGeometry>?>? padding, ValueGetter<ButtonStatePropertyDelegate<TextStyle>?>? textStyle, ValueGetter<ButtonStatePropertyDelegate<IconThemeData>?>? iconTheme, ValueGetter<ButtonStatePropertyDelegate<EdgeInsetsGeometry>?>? margin});
}
/// Theme configuration for menubar button styling.
///
/// Provides theme-level customization for menubar buttons. Menubar buttons are
/// optimized for horizontal menu bars with appropriate padding and hover effects.
class MenubarButtonTheme extends ButtonTheme {
/// Creates a [MenubarButtonTheme] with optional style property delegates.
  const MenubarButtonTheme({super.decoration, super.mouseCursor, super.padding, super.textStyle, super.iconTheme, super.margin});
/// Creates a copy of this theme with selectively replaced properties.
  MenubarButtonTheme copyWith({ValueGetter<ButtonStatePropertyDelegate<Decoration>?>? decoration, ValueGetter<ButtonStatePropertyDelegate<MouseCursor>?>? mouseCursor, ValueGetter<ButtonStatePropertyDelegate<EdgeInsetsGeometry>?>? padding, ValueGetter<ButtonStatePropertyDelegate<TextStyle>?>? textStyle, ValueGetter<ButtonStatePropertyDelegate<IconThemeData>?>? iconTheme, ValueGetter<ButtonStatePropertyDelegate<EdgeInsetsGeometry>?>? margin});
}
/// Theme configuration for muted button styling.
///
/// Provides theme-level customization for muted buttons. Muted buttons use
/// low-contrast colors for minimal visual impact while remaining functional.
class MutedButtonTheme extends ButtonTheme {
/// Creates a [MutedButtonTheme] with optional style property delegates.
  const MutedButtonTheme({super.decoration, super.mouseCursor, super.padding, super.textStyle, super.iconTheme, super.margin});
/// Creates a copy of this theme with selectively replaced properties.
  MutedButtonTheme copyWith({ValueGetter<ButtonStatePropertyDelegate<Decoration>?>? decoration, ValueGetter<ButtonStatePropertyDelegate<MouseCursor>?>? mouseCursor, ValueGetter<ButtonStatePropertyDelegate<EdgeInsetsGeometry>?>? padding, ValueGetter<ButtonStatePropertyDelegate<TextStyle>?>? textStyle, ValueGetter<ButtonStatePropertyDelegate<IconThemeData>?>? iconTheme, ValueGetter<ButtonStatePropertyDelegate<EdgeInsetsGeometry>?>? margin});
}
/// Theme configuration for card button styling.
///
/// Provides theme-level customization for card buttons. Card buttons feature
/// subtle shadows and borders creating an elevated, card-like appearance.
class CardButtonTheme extends ButtonTheme {
/// Creates a [CardButtonTheme] with optional style property delegates.
  const CardButtonTheme({super.decoration, super.mouseCursor, super.padding, super.textStyle, super.iconTheme, super.margin});
/// Creates a copy of this theme with selectively replaced properties.
  CardButtonTheme copyWith({ValueGetter<ButtonStatePropertyDelegate<Decoration>?>? decoration, ValueGetter<ButtonStatePropertyDelegate<MouseCursor>?>? mouseCursor, ValueGetter<ButtonStatePropertyDelegate<EdgeInsetsGeometry>?>? padding, ValueGetter<ButtonStatePropertyDelegate<TextStyle>?>? textStyle, ValueGetter<ButtonStatePropertyDelegate<IconThemeData>?>? iconTheme, ValueGetter<ButtonStatePropertyDelegate<EdgeInsetsGeometry>?>? margin});
}
/// Implementation of [AbstractButtonStyle] providing concrete button style variants.
///
/// [ButtonVariance] implements [AbstractButtonStyle] with state property functions
/// and provides static constants for all standard button variants (primary, secondary,
/// outline, etc.). Each variant is wrapped in a [ComponentThemeButtonStyle] to enable
/// theme-level customization.
///
/// The static variance constants serve as the base styles used by [ButtonStyle]'s
/// named constructors and can be used directly when creating custom button styles.
///
/// Example:
/// ```dart
/// // Use a variant directly
/// Button(
///   style: ButtonVariance.primary,
///   child: Text('Click Me'),
/// )
/// ```
class ButtonVariance implements AbstractButtonStyle {
/// Primary button variant with prominent filled appearance.
///
/// Features high-contrast styling suitable for the main action on a screen.
  static const AbstractButtonStyle primary = ComponentThemeButtonStyle<PrimaryButtonTheme>(fallback: ButtonVariance(decoration: _buttonPrimaryDecoration, mouseCursor: _buttonMouseCursor, padding: _buttonPadding, textStyle: _buttonPrimaryTextStyle, iconTheme: _buttonPrimaryIconTheme, margin: _buttonZeroMargin));
/// Secondary button variant with muted appearance.
///
/// Features subtle styling suitable for supporting or alternative actions.
  static const AbstractButtonStyle secondary = ComponentThemeButtonStyle<SecondaryButtonTheme>(fallback: ButtonVariance(decoration: _buttonSecondaryDecoration, mouseCursor: _buttonMouseCursor, padding: _buttonPadding, textStyle: _buttonSecondaryTextStyle, iconTheme: _buttonSecondaryIconTheme, margin: _buttonZeroMargin));
/// Outline button variant with border and transparent background.
///
/// Features a visible border without filled background, suitable for secondary actions.
  static const AbstractButtonStyle outline = ComponentThemeButtonStyle<OutlineButtonTheme>(fallback: ButtonVariance(decoration: _buttonOutlineDecoration, mouseCursor: _buttonMouseCursor, padding: _buttonPadding, textStyle: _buttonOutlineTextStyle, iconTheme: _buttonOutlineIconTheme, margin: _buttonZeroMargin));
/// Ghost button variant with minimal visual presence.
///
/// Features no background or border by default, only showing on hover.
  static const AbstractButtonStyle ghost = ComponentThemeButtonStyle<GhostButtonTheme>(fallback: ButtonVariance(decoration: _buttonGhostDecoration, mouseCursor: _buttonMouseCursor, padding: _buttonPadding, textStyle: _buttonGhostTextStyle, iconTheme: _buttonGhostIconTheme, margin: _buttonZeroMargin));
/// Link button variant resembling a text hyperlink.
///
/// Features inline link styling with underline decoration.
  static const AbstractButtonStyle link = ComponentThemeButtonStyle<LinkButtonTheme>(fallback: ButtonVariance(decoration: _buttonLinkDecoration, mouseCursor: _buttonMouseCursor, padding: _buttonPadding, textStyle: _buttonLinkTextStyle, iconTheme: _buttonLinkIconTheme, margin: _buttonZeroMargin));
/// Text button variant with only text content.
///
/// Features minimal styling with no background or border decoration.
  static const AbstractButtonStyle text = ComponentThemeButtonStyle<TextButtonTheme>(fallback: ButtonVariance(decoration: _buttonTextDecoration, mouseCursor: _buttonMouseCursor, padding: _buttonPadding, textStyle: _buttonTextTextStyle, iconTheme: _buttonTextIconTheme, margin: _buttonZeroMargin));
/// Destructive button variant for delete/remove actions.
///
/// Features warning colors (typically red) to indicate data-destructive actions.
  static const AbstractButtonStyle destructive = ComponentThemeButtonStyle<DestructiveButtonTheme>(fallback: ButtonVariance(decoration: _buttonDestructiveDecoration, mouseCursor: _buttonMouseCursor, padding: _buttonPadding, textStyle: _buttonDestructiveTextStyle, iconTheme: _buttonDestructiveIconTheme, margin: _buttonZeroMargin));
/// Fixed button variant with consistent dimensions.
///
/// Features fixed sizing regardless of content, suitable for icon buttons.
  static const AbstractButtonStyle fixed = ComponentThemeButtonStyle<FixedButtonTheme>(fallback: ButtonVariance(decoration: _buttonTextDecoration, mouseCursor: _buttonMouseCursor, padding: _buttonPadding, textStyle: _buttonStaticTextStyle, iconTheme: _buttonStaticIconTheme, margin: _buttonZeroMargin));
/// Menu button variant for dropdown menu triggers.
///
/// Features appropriate spacing and styling for menu contexts.
  static const AbstractButtonStyle menu = ComponentThemeButtonStyle<MenuButtonTheme>(fallback: ButtonVariance(decoration: _buttonMenuDecoration, mouseCursor: _buttonMouseCursor, padding: _buttonMenuPadding, textStyle: _buttonMenuTextStyle, iconTheme: _buttonMenuIconTheme, margin: _buttonZeroMargin));
/// Menubar button variant for horizontal menu bars.
///
/// Features optimized padding and styling for menubar contexts.
  static const AbstractButtonStyle menubar = ComponentThemeButtonStyle<MenubarButtonTheme>(fallback: ButtonVariance(decoration: _buttonMenuDecoration, mouseCursor: _buttonMouseCursor, padding: _buttonMenubarPadding, textStyle: _buttonMenuTextStyle, iconTheme: _buttonMenuIconTheme, margin: _buttonZeroMargin));
/// Muted button variant with subdued appearance.
///
/// Features low-contrast styling for minimal visual impact.
  static const AbstractButtonStyle muted = ComponentThemeButtonStyle<MutedButtonTheme>(fallback: ButtonVariance(decoration: _buttonTextDecoration, mouseCursor: _buttonMouseCursor, padding: _buttonPadding, textStyle: _buttonMutedTextStyle, iconTheme: _buttonMutedIconTheme, margin: _buttonZeroMargin));
/// Card button variant with elevated appearance.
///
/// Features subtle shadows and borders creating a card-like elevated look.
  static const AbstractButtonStyle card = ComponentThemeButtonStyle<CardButtonTheme>(fallback: ButtonVariance(decoration: _buttonCardDecoration, mouseCursor: _buttonMouseCursor, padding: _buttonCardPadding, textStyle: _buttonCardTextStyle, iconTheme: _buttonCardIconTheme, margin: _buttonZeroMargin));
  ButtonStateProperty<Decoration> decoration;
  ButtonStateProperty<MouseCursor> mouseCursor;
  ButtonStateProperty<EdgeInsetsGeometry> padding;
  ButtonStateProperty<TextStyle> textStyle;
  ButtonStateProperty<IconThemeData> iconTheme;
  ButtonStateProperty<EdgeInsetsGeometry> margin;
/// Creates a custom [ButtonVariance] with the specified style properties.
///
/// All parameters are required [ButtonStateProperty] functions that resolve
/// values based on the button's current state.
  const ButtonVariance({required this.decoration, required this.mouseCursor, required this.padding, required this.textStyle, required this.iconTheme, required this.margin});
  bool operator ==(Object other);
  int get hashCode;
  String toString();
}
/// A button state property delegate that always returns the same value.
///
/// [ButtonStylePropertyAll] implements a [ButtonStatePropertyDelegate] that
/// ignores the context, states, and default value parameters, always returning
/// its stored [value]. This is useful for creating static style properties that
/// don't change based on button state.
///
/// Example:
/// ```dart
/// final alwaysRedDecoration = ButtonStylePropertyAll<Decoration>(
///   BoxDecoration(color: Colors.red),
/// );
/// ```
class ButtonStylePropertyAll<T> {
/// The constant value to return regardless of state.
  T value;
/// Creates a [ButtonStylePropertyAll] with the specified constant value.
  const ButtonStylePropertyAll(this.value);
/// Returns the stored [value], ignoring all parameters.
///
/// This method signature matches [ButtonStatePropertyDelegate] for compatibility,
/// but the [context], [states], and [value] parameters are unused.
  T call(BuildContext context, Set<WidgetState> states, T value);
  bool operator ==(Object other);
  int get hashCode;
  String toString();
}
/// Extension methods on [AbstractButtonStyle] for convenient style modifications.
///
/// Provides utility methods to create modified copies of button styles with
/// selective property changes. These methods enable fluent style customization
/// without manually implementing [ButtonVariance] instances.
extension ButtonStyleExtension on AbstractButtonStyle {
/// Creates a copy of this style with selectively replaced properties.
///
/// Each parameter is a [ButtonStatePropertyDelegate] that can modify or
/// replace the corresponding style property. If all parameters are `null`,
/// returns the original style unchanged for efficiency.
///
/// Example:
/// ```dart
/// final customStyle = ButtonVariance.primary.copyWith(
///   decoration: (context, states, defaultDecoration) {
///     // Custom decoration logic
///     return myCustomDecoration;
///   },
/// );
/// ```
  AbstractButtonStyle copyWith({ButtonStatePropertyDelegate<Decoration>? decoration, ButtonStatePropertyDelegate<MouseCursor>? mouseCursor, ButtonStatePropertyDelegate<EdgeInsetsGeometry>? padding, ButtonStatePropertyDelegate<TextStyle>? textStyle, ButtonStatePropertyDelegate<IconThemeData>? iconTheme, ButtonStatePropertyDelegate<EdgeInsetsGeometry>? margin});
/// Creates a copy with custom background colors for different states.
///
/// Modifies the decoration to apply state-specific background colors.
/// Only works with [BoxDecoration]; other decoration types are returned unchanged.
///
/// Parameters:
/// - [color]: Background color for normal state
/// - [hoverColor]: Background color when hovered
/// - [focusColor]: Background color when focused
/// - [disabledColor]: Background color when disabled
///
/// Example:
/// ```dart
/// final style = ButtonVariance.primary.withBackgroundColor(
///   color: Colors.blue,
///   hoverColor: Colors.blue.shade700,
/// );
/// ```
  AbstractButtonStyle withBackgroundColor({Color? color, Color? hoverColor, Color? focusColor, Color? disabledColor});
/// Creates a copy with custom foreground colors for different states.
///
/// Modifies both text style and icon theme to apply state-specific foreground
/// colors for text and icons.
///
/// Parameters:
/// - [color]: Foreground color for normal state
/// - [hoverColor]: Foreground color when hovered
/// - [focusColor]: Foreground color when focused
/// - [disabledColor]: Foreground color when disabled
///
/// Example:
/// ```dart
/// final style = ButtonVariance.outline.withForegroundColor(
///   color: Colors.black,
///   disabledColor: Colors.grey,
/// );
/// ```
  AbstractButtonStyle withForegroundColor({Color? color, Color? hoverColor, Color? focusColor, Color? disabledColor});
/// Creates a copy with custom borders for different states.
///
/// Modifies the decoration to apply state-specific borders.
/// Only works with [BoxDecoration]; other decoration types are returned unchanged.
///
/// Parameters:
/// - [border]: Border for normal state
/// - [hoverBorder]: Border when hovered
/// - [focusBorder]: Border when focused
/// - [disabledBorder]: Border when disabled
///
/// Example:
/// ```dart
/// final style = ButtonVariance.outline.withBorder(
///   border: Border.all(color: Colors.blue),
///   hoverBorder: Border.all(color: Colors.blue.shade700, width: 2),
/// );
/// ```
  AbstractButtonStyle withBorder({Border? border, Border? hoverBorder, Border? focusBorder, Border? disabledBorder});
/// Creates a copy with custom border radius for different states.
///
/// Modifies the decoration to apply state-specific border radius.
/// Only works with [BoxDecoration]; other decoration types are returned unchanged.
///
/// Parameters:
/// - [borderRadius]: Border radius for normal state
/// - [hoverBorderRadius]: Border radius when hovered
/// - [focusBorderRadius]: Border radius when focused
/// - [disabledBorderRadius]: Border radius when disabled
///
/// Example:
/// ```dart
/// final style = ButtonVariance.primary.withBorderRadius(
///   borderRadius: BorderRadius.circular(8),
///   hoverBorderRadius: BorderRadius.circular(12),
/// );
/// ```
  AbstractButtonStyle withBorderRadius({BorderRadiusGeometry? borderRadius, BorderRadiusGeometry? hoverBorderRadius, BorderRadiusGeometry? focusBorderRadius, BorderRadiusGeometry? disabledBorderRadius});
/// Creates a copy with custom padding for different states.
///
/// Modifies the padding to apply state-specific values.
///
/// Parameters:
/// - [padding]: Padding for normal state
/// - [hoverPadding]: Padding when hovered
/// - [focusPadding]: Padding when focused
/// - [disabledPadding]: Padding when disabled
  AbstractButtonStyle withPadding({EdgeInsetsGeometry? padding, EdgeInsetsGeometry? hoverPadding, EdgeInsetsGeometry? focusPadding, EdgeInsetsGeometry? disabledPadding});
}
/// Convenience widget for creating a primary button.
///
/// [PrimaryButton] is a simplified wrapper around [Button] that automatically
/// applies the primary button style. It provides a cleaner API for the common
/// case of creating primary buttons without manually specifying the style.
///
/// This widget exposes all the same properties as [Button] but defaults to
/// [ButtonStyle.primary] for consistent styling.
///
/// Example:
/// ```dart
/// PrimaryButton(
///   onPressed: () => submitForm(),
///   leading: Icon(Icons.check),
///   child: Text('Submit'),
/// )
/// ```
class PrimaryButton extends StatelessWidget {
/// The widget displayed as the button's main content.
  Widget child;
/// Called when the button is pressed. If `null`, the button is disabled.
  VoidCallback? onPressed;
/// Whether the button is enabled. Overrides the `onPressed` check if provided.
  bool? enabled;
/// Widget displayed before the [child].
  Widget? leading;
/// Widget displayed after the [child].
  Widget? trailing;
/// Alignment of the button's content.
  AlignmentGeometry? alignment;
/// Size variant of the button (defaults to [ButtonSize.normal]).
  ButtonSize size;
/// Density variant affecting spacing (defaults to [ButtonDensity.normal]).
  ButtonDensity density;
/// Shape of the button (defaults to [ButtonShape.rectangle]).
  ButtonShape shape;
/// Focus node for keyboard focus management.
  FocusNode? focusNode;
/// Whether to disable style transition animations (defaults to `false`).
  bool disableTransition;
/// Called when hover state changes.
  ValueChanged<bool>? onHover;
/// Called when focus state changes.
  ValueChanged<bool>? onFocus;
/// Whether to enable haptic/audio feedback.
  bool? enableFeedback;
/// Called when primary tap down occurs.
  GestureTapDownCallback? onTapDown;
/// Called when primary tap up occurs.
  GestureTapUpCallback? onTapUp;
/// Called when primary tap is cancelled.
  GestureTapCancelCallback? onTapCancel;
/// Called when secondary tap down occurs.
  GestureTapDownCallback? onSecondaryTapDown;
/// Called when secondary tap up occurs.
  GestureTapUpCallback? onSecondaryTapUp;
/// Called when secondary tap is cancelled.
  GestureTapCancelCallback? onSecondaryTapCancel;
/// Called when tertiary tap down occurs.
  GestureTapDownCallback? onTertiaryTapDown;
/// Called when tertiary tap up occurs.
  GestureTapUpCallback? onTertiaryTapUp;
/// Called when tertiary tap is cancelled.
  GestureTapCancelCallback? onTertiaryTapCancel;
/// Called when long press starts.
  GestureLongPressStartCallback? onLongPressStart;
/// Called when long press is released.
  GestureLongPressUpCallback? onLongPressUp;
/// Called when long press moves.
  GestureLongPressMoveUpdateCallback? onLongPressMoveUpdate;
/// Called when long press ends.
  GestureLongPressEndCallback? onLongPressEnd;
/// Called when secondary long press completes.
  GestureLongPressUpCallback? onSecondaryLongPress;
/// Called when tertiary long press completes.
  GestureLongPressUpCallback? onTertiaryLongPress;
/// Creates a primary button with the specified properties.
  const PrimaryButton({super.key, required this.child, this.onPressed, this.enabled, this.leading, this.trailing, this.alignment, this.size = ButtonSize.normal, this.density = ButtonDensity.normal, this.shape = ButtonShape.rectangle, this.focusNode, this.disableTransition = false, this.onHover, this.onFocus, this.enableFeedback, this.onTapDown, this.onTapUp, this.onTapCancel, this.onSecondaryTapDown, this.onSecondaryTapUp, this.onSecondaryTapCancel, this.onTertiaryTapDown, this.onTertiaryTapUp, this.onTertiaryTapCancel, this.onLongPressStart, this.onLongPressUp, this.onLongPressMoveUpdate, this.onLongPressEnd, this.onSecondaryLongPress, this.onTertiaryLongPress});
  Widget build(BuildContext context);
}
/// Convenience widget for creating a secondary button.
///
/// A simplified wrapper around [Button.secondary] with the same properties
/// as [PrimaryButton] but using secondary button styling for supporting actions.
class SecondaryButton extends StatelessWidget {
/// The widget to display as the button's content.
  Widget child;
/// Called when the button is pressed. If `null`, the button is disabled.
  VoidCallback? onPressed;
/// Whether the button is enabled. Overrides the `onPressed` check if provided.
  bool? enabled;
/// Widget displayed before the [child].
  Widget? leading;
/// Widget displayed after the [child].
  Widget? trailing;
/// Alignment of the button's content.
  AlignmentGeometry? alignment;
/// Size variant of the button (defaults to [ButtonSize.normal]).
  ButtonSize size;
/// Density variant affecting spacing (defaults to [ButtonDensity.normal]).
  ButtonDensity density;
/// Shape of the button (defaults to [ButtonShape.rectangle]).
  ButtonShape shape;
/// Focus node for keyboard focus management.
  FocusNode? focusNode;
/// Whether to disable style transition animations (defaults to `false`).
  bool disableTransition;
/// Called when hover state changes.
  ValueChanged<bool>? onHover;
/// Called when focus state changes.
  ValueChanged<bool>? onFocus;
/// Whether to enable haptic/audio feedback.
  bool? enableFeedback;
/// Called when primary tap down occurs.
  GestureTapDownCallback? onTapDown;
/// Called when primary tap up occurs.
  GestureTapUpCallback? onTapUp;
/// Called when primary tap is cancelled.
  GestureTapCancelCallback? onTapCancel;
/// Called when secondary tap down occurs.
  GestureTapDownCallback? onSecondaryTapDown;
/// Called when secondary tap up occurs.
  GestureTapUpCallback? onSecondaryTapUp;
/// Called when secondary tap is cancelled.
  GestureTapCancelCallback? onSecondaryTapCancel;
/// Called when tertiary tap down occurs.
  GestureTapDownCallback? onTertiaryTapDown;
/// Called when tertiary tap up occurs.
  GestureTapUpCallback? onTertiaryTapUp;
/// Called when tertiary tap is cancelled.
  GestureTapCancelCallback? onTertiaryTapCancel;
/// Called when long press starts.
  GestureLongPressStartCallback? onLongPressStart;
/// Called when long press is released.
  GestureLongPressUpCallback? onLongPressUp;
/// Called when long press moves.
  GestureLongPressMoveUpdateCallback? onLongPressMoveUpdate;
/// Called when long press ends.
  GestureLongPressEndCallback? onLongPressEnd;
/// Called when secondary long press completes.
  GestureLongPressUpCallback? onSecondaryLongPress;
/// Called when tertiary long press completes.
  GestureLongPressUpCallback? onTertiaryLongPress;
/// Creates a secondary button with the specified properties.
  const SecondaryButton({super.key, required this.child, this.onPressed, this.enabled, this.leading, this.trailing, this.alignment, this.size = ButtonSize.normal, this.density = ButtonDensity.normal, this.shape = ButtonShape.rectangle, this.focusNode, this.disableTransition = false, this.onHover, this.onFocus, this.enableFeedback, this.onTapDown, this.onTapUp, this.onTapCancel, this.onSecondaryTapDown, this.onSecondaryTapUp, this.onSecondaryTapCancel, this.onTertiaryTapDown, this.onTertiaryTapUp, this.onTertiaryTapCancel, this.onLongPressStart, this.onLongPressUp, this.onLongPressMoveUpdate, this.onLongPressEnd, this.onSecondaryLongPress, this.onTertiaryLongPress});
  Widget build(BuildContext context);
}
/// Convenience widget for creating an outline button.
///
/// A simplified wrapper around [Button.outline] with the same properties
/// as [PrimaryButton] but using outline button styling with a visible border.
class OutlineButton extends StatelessWidget {
/// The widget to display as the button's content.
  Widget child;
/// Called when the button is pressed. If `null`, the button is disabled.
  VoidCallback? onPressed;
/// Whether the button is enabled. Overrides the `onPressed` check if provided.
  bool? enabled;
/// Widget displayed before the [child].
  Widget? leading;
/// Widget displayed after the [child].
  Widget? trailing;
/// Alignment of the button's content.
  AlignmentGeometry? alignment;
/// Size variant of the button (defaults to [ButtonSize.normal]).
  ButtonSize size;
/// Density variant affecting spacing (defaults to [ButtonDensity.normal]).
  ButtonDensity density;
/// Shape of the button (defaults to [ButtonShape.rectangle]).
  ButtonShape shape;
/// Focus node for keyboard focus management.
  FocusNode? focusNode;
/// Whether to disable style transition animations (defaults to `false`).
  bool disableTransition;
/// Called when hover state changes.
  ValueChanged<bool>? onHover;
/// Called when focus state changes.
  ValueChanged<bool>? onFocus;
/// Whether to enable haptic/audio feedback.
  bool? enableFeedback;
/// Called when primary tap down occurs.
  GestureTapDownCallback? onTapDown;
/// Called when primary tap up occurs.
  GestureTapUpCallback? onTapUp;
/// Called when primary tap is cancelled.
  GestureTapCancelCallback? onTapCancel;
/// Called when secondary tap down occurs.
  GestureTapDownCallback? onSecondaryTapDown;
/// Called when secondary tap up occurs.
  GestureTapUpCallback? onSecondaryTapUp;
/// Called when secondary tap is cancelled.
  GestureTapCancelCallback? onSecondaryTapCancel;
/// Called when tertiary tap down occurs.
  GestureTapDownCallback? onTertiaryTapDown;
/// Called when tertiary tap up occurs.
  GestureTapUpCallback? onTertiaryTapUp;
/// Called when tertiary tap is cancelled.
  GestureTapCancelCallback? onTertiaryTapCancel;
/// Called when long press starts.
  GestureLongPressStartCallback? onLongPressStart;
/// Called when long press is released.
  GestureLongPressUpCallback? onLongPressUp;
/// Called when long press moves.
  GestureLongPressMoveUpdateCallback? onLongPressMoveUpdate;
/// Called when long press ends.
  GestureLongPressEndCallback? onLongPressEnd;
/// Called when secondary long press completes.
  GestureLongPressUpCallback? onSecondaryLongPress;
/// Called when tertiary long press completes.
  GestureLongPressUpCallback? onTertiaryLongPress;
/// Creates an outline button with the specified properties.
  const OutlineButton({super.key, required this.child, this.onPressed, this.enabled, this.leading, this.trailing, this.alignment, this.size = ButtonSize.normal, this.density = ButtonDensity.normal, this.shape = ButtonShape.rectangle, this.focusNode, this.disableTransition = false, this.onHover, this.onFocus, this.enableFeedback, this.onTapDown, this.onTapUp, this.onTapCancel, this.onSecondaryTapDown, this.onSecondaryTapUp, this.onSecondaryTapCancel, this.onTertiaryTapDown, this.onTertiaryTapUp, this.onTertiaryTapCancel, this.onLongPressStart, this.onLongPressUp, this.onLongPressMoveUpdate, this.onLongPressEnd, this.onSecondaryLongPress, this.onTertiaryLongPress});
  Widget build(BuildContext context);
}
/// Convenience widget for creating a ghost button.
///
/// A simplified wrapper around [Button.ghost] with the same properties
/// as [PrimaryButton] but using ghost button styling with minimal visual presence.
class GhostButton extends StatelessWidget {
/// The widget to display as the button's content.
  Widget child;
/// Called when the button is pressed. If `null`, the button is disabled.
  VoidCallback? onPressed;
/// Whether the button is enabled. Overrides the `onPressed` check if provided.
  bool? enabled;
/// Widget displayed before the [child].
  Widget? leading;
/// Widget displayed after the [child].
  Widget? trailing;
/// Alignment of the button's content.
  AlignmentGeometry? alignment;
/// Size variant of the button (defaults to [ButtonSize.normal]).
  ButtonSize size;
/// Density variant affecting spacing (defaults to [ButtonDensity.normal]).
  ButtonDensity density;
/// Shape of the button (defaults to [ButtonShape.rectangle]).
  ButtonShape shape;
/// Focus node for keyboard focus management.
  FocusNode? focusNode;
/// Whether to disable style transition animations (defaults to `false`).
  bool disableTransition;
/// Called when hover state changes.
  ValueChanged<bool>? onHover;
/// Called when focus state changes.
  ValueChanged<bool>? onFocus;
/// Whether to enable haptic/audio feedback.
  bool? enableFeedback;
/// Called when primary tap down occurs.
  GestureTapDownCallback? onTapDown;
/// Called when primary tap up occurs.
  GestureTapUpCallback? onTapUp;
/// Called when primary tap is cancelled.
  GestureTapCancelCallback? onTapCancel;
/// Called when secondary tap down occurs.
  GestureTapDownCallback? onSecondaryTapDown;
/// Called when secondary tap up occurs.
  GestureTapUpCallback? onSecondaryTapUp;
/// Called when secondary tap is cancelled.
  GestureTapCancelCallback? onSecondaryTapCancel;
/// Called when tertiary tap down occurs.
  GestureTapDownCallback? onTertiaryTapDown;
/// Called when tertiary tap up occurs.
  GestureTapUpCallback? onTertiaryTapUp;
/// Called when tertiary tap is cancelled.
  GestureTapCancelCallback? onTertiaryTapCancel;
/// Called when long press starts.
  GestureLongPressStartCallback? onLongPressStart;
/// Called when long press is released.
  GestureLongPressUpCallback? onLongPressUp;
/// Called when long press moves.
  GestureLongPressMoveUpdateCallback? onLongPressMoveUpdate;
/// Called when long press ends.
  GestureLongPressEndCallback? onLongPressEnd;
/// Called when secondary long press completes.
  GestureLongPressUpCallback? onSecondaryLongPress;
/// Called when tertiary long press completes.
  GestureLongPressUpCallback? onTertiaryLongPress;
/// Creates a ghost button with the specified properties.
  const GhostButton({super.key, required this.child, this.onPressed, this.enabled, this.leading, this.trailing, this.alignment, this.size = ButtonSize.normal, this.density = ButtonDensity.normal, this.shape = ButtonShape.rectangle, this.focusNode, this.disableTransition = false, this.onHover, this.onFocus, this.enableFeedback, this.onTapDown, this.onTapUp, this.onTapCancel, this.onSecondaryTapDown, this.onSecondaryTapUp, this.onSecondaryTapCancel, this.onTertiaryTapDown, this.onTertiaryTapUp, this.onTertiaryTapCancel, this.onLongPressStart, this.onLongPressUp, this.onLongPressMoveUpdate, this.onLongPressEnd, this.onSecondaryLongPress, this.onTertiaryLongPress});
  Widget build(BuildContext context);
}
/// Convenience widget for creating a link button.
///
/// A simplified wrapper around [Button.link] with the same properties
/// as [PrimaryButton] but using link button styling that resembles a hyperlink.
class LinkButton extends StatelessWidget {
/// The widget to display as the button's content.
  Widget child;
/// Called when the button is pressed. If `null`, the button is disabled.
  VoidCallback? onPressed;
/// Whether the button is enabled. Overrides the `onPressed` check if provided.
  bool? enabled;
/// Widget displayed before the [child].
  Widget? leading;
/// Widget displayed after the [child].
  Widget? trailing;
/// Alignment of the button's content.
  AlignmentGeometry? alignment;
/// Size variant of the button (defaults to [ButtonSize.normal]).
  ButtonSize size;
/// Density variant affecting spacing (defaults to [ButtonDensity.normal]).
  ButtonDensity density;
/// Shape of the button (defaults to [ButtonShape.rectangle]).
  ButtonShape shape;
/// Focus node for keyboard focus management.
  FocusNode? focusNode;
/// Whether to disable style transition animations (defaults to `false`).
  bool disableTransition;
/// Called when hover state changes.
  ValueChanged<bool>? onHover;
/// Called when focus state changes.
  ValueChanged<bool>? onFocus;
/// Whether to enable haptic/audio feedback.
  bool? enableFeedback;
/// Called when primary tap down occurs.
  GestureTapDownCallback? onTapDown;
/// Called when primary tap up occurs.
  GestureTapUpCallback? onTapUp;
/// Called when primary tap is cancelled.
  GestureTapCancelCallback? onTapCancel;
/// Called when secondary tap down occurs.
  GestureTapDownCallback? onSecondaryTapDown;
/// Called when secondary tap up occurs.
  GestureTapUpCallback? onSecondaryTapUp;
/// Called when secondary tap is cancelled.
  GestureTapCancelCallback? onSecondaryTapCancel;
/// Called when tertiary tap down occurs.
  GestureTapDownCallback? onTertiaryTapDown;
/// Called when tertiary tap up occurs.
  GestureTapUpCallback? onTertiaryTapUp;
/// Called when tertiary tap is cancelled.
  GestureTapCancelCallback? onTertiaryTapCancel;
/// Called when long press starts.
  GestureLongPressStartCallback? onLongPressStart;
/// Called when long press is released.
  GestureLongPressUpCallback? onLongPressUp;
/// Called when long press moves.
  GestureLongPressMoveUpdateCallback? onLongPressMoveUpdate;
/// Called when long press ends.
  GestureLongPressEndCallback? onLongPressEnd;
/// Called when secondary long press completes.
  GestureLongPressUpCallback? onSecondaryLongPress;
/// Called when tertiary long press completes.
  GestureLongPressUpCallback? onTertiaryLongPress;
/// Creates a link button with the specified properties.
  const LinkButton({super.key, required this.child, this.onPressed, this.enabled, this.leading, this.trailing, this.alignment, this.size = ButtonSize.normal, this.density = ButtonDensity.normal, this.shape = ButtonShape.rectangle, this.focusNode, this.disableTransition = false, this.onHover, this.onFocus, this.enableFeedback, this.onTapDown, this.onTapUp, this.onTapCancel, this.onSecondaryTapDown, this.onSecondaryTapUp, this.onSecondaryTapCancel, this.onTertiaryTapDown, this.onTertiaryTapUp, this.onTertiaryTapCancel, this.onLongPressStart, this.onLongPressUp, this.onLongPressMoveUpdate, this.onLongPressEnd, this.onSecondaryLongPress, this.onTertiaryLongPress});
  Widget build(BuildContext context);
}
/// Convenience widget for creating a text button.
///
/// A simplified wrapper around [Button.text] with the same properties
/// as [PrimaryButton] but using text button styling with minimal styling.
class TextButton extends StatelessWidget {
/// The widget to display as the button's content.
  Widget child;
/// Called when the button is pressed. If `null`, the button is disabled.
  VoidCallback? onPressed;
/// Whether the button is enabled. Overrides the `onPressed` check if provided.
  bool? enabled;
/// Widget displayed before the [child].
  Widget? leading;
/// Widget displayed after the [child].
  Widget? trailing;
/// Alignment of the button's content.
  AlignmentGeometry? alignment;
/// Size variant of the button (defaults to [ButtonSize.normal]).
  ButtonSize size;
/// Density variant affecting spacing (defaults to [ButtonDensity.normal]).
  ButtonDensity density;
/// Shape of the button (defaults to [ButtonShape.rectangle]).
  ButtonShape shape;
/// Focus node for keyboard focus management.
  FocusNode? focusNode;
/// Whether to disable style transition animations (defaults to `false`).
  bool disableTransition;
/// Called when hover state changes.
  ValueChanged<bool>? onHover;
/// Called when focus state changes.
  ValueChanged<bool>? onFocus;
/// Whether to enable haptic/audio feedback.
  bool? enableFeedback;
/// Called when primary tap down occurs.
  GestureTapDownCallback? onTapDown;
/// Called when primary tap up occurs.
  GestureTapUpCallback? onTapUp;
/// Called when primary tap is cancelled.
  GestureTapCancelCallback? onTapCancel;
/// Called when secondary tap down occurs.
  GestureTapDownCallback? onSecondaryTapDown;
/// Called when secondary tap up occurs.
  GestureTapUpCallback? onSecondaryTapUp;
/// Called when secondary tap is cancelled.
  GestureTapCancelCallback? onSecondaryTapCancel;
/// Called when tertiary tap down occurs.
  GestureTapDownCallback? onTertiaryTapDown;
/// Called when tertiary tap up occurs.
  GestureTapUpCallback? onTertiaryTapUp;
/// Called when tertiary tap is cancelled.
  GestureTapCancelCallback? onTertiaryTapCancel;
/// Called when long press starts.
  GestureLongPressStartCallback? onLongPressStart;
/// Called when long press is released.
  GestureLongPressUpCallback? onLongPressUp;
/// Called when long press moves.
  GestureLongPressMoveUpdateCallback? onLongPressMoveUpdate;
/// Called when long press ends.
  GestureLongPressEndCallback? onLongPressEnd;
/// Called when secondary long press completes.
  GestureLongPressUpCallback? onSecondaryLongPress;
/// Called when tertiary long press completes.
  GestureLongPressUpCallback? onTertiaryLongPress;
/// Creates a text button with the specified properties.
  const TextButton({super.key, required this.child, this.onPressed, this.enabled, this.leading, this.trailing, this.alignment, this.size = ButtonSize.normal, this.density = ButtonDensity.normal, this.shape = ButtonShape.rectangle, this.focusNode, this.disableTransition = false, this.onHover, this.onFocus, this.enableFeedback, this.onTapDown, this.onTapUp, this.onTapCancel, this.onSecondaryTapDown, this.onSecondaryTapUp, this.onSecondaryTapCancel, this.onTertiaryTapDown, this.onTertiaryTapUp, this.onTertiaryTapCancel, this.onLongPressStart, this.onLongPressUp, this.onLongPressMoveUpdate, this.onLongPressEnd, this.onSecondaryLongPress, this.onTertiaryLongPress});
  Widget build(BuildContext context);
}
/// Convenience widget for creating a destructive button.
///
/// A simplified wrapper around [Button.destructive] with the same properties
/// as [PrimaryButton] but using destructive button styling for dangerous actions.
class DestructiveButton extends StatelessWidget {
/// The widget to display as the button's content.
  Widget child;
/// Called when the button is pressed. If `null`, the button is disabled.
  VoidCallback? onPressed;
/// Whether the button is enabled. Overrides the `onPressed` check if provided.
  bool? enabled;
/// Widget displayed before the [child].
  Widget? leading;
/// Widget displayed after the [child].
  Widget? trailing;
/// Alignment of the button's content.
  AlignmentGeometry? alignment;
/// Size variant of the button (defaults to [ButtonSize.normal]).
  ButtonSize size;
/// Density variant affecting spacing (defaults to [ButtonDensity.normal]).
  ButtonDensity density;
/// Shape of the button (defaults to [ButtonShape.rectangle]).
  ButtonShape shape;
/// Focus node for keyboard focus management.
  FocusNode? focusNode;
/// Whether to disable style transition animations (defaults to `false`).
  bool disableTransition;
/// Called when hover state changes.
  ValueChanged<bool>? onHover;
/// Called when focus state changes.
  ValueChanged<bool>? onFocus;
/// Whether to enable haptic/audio feedback.
  bool? enableFeedback;
/// Called when primary tap down occurs.
  GestureTapDownCallback? onTapDown;
/// Called when primary tap up occurs.
  GestureTapUpCallback? onTapUp;
/// Called when primary tap is cancelled.
  GestureTapCancelCallback? onTapCancel;
/// Called when secondary tap down occurs.
  GestureTapDownCallback? onSecondaryTapDown;
/// Called when secondary tap up occurs.
  GestureTapUpCallback? onSecondaryTapUp;
/// Called when secondary tap is cancelled.
  GestureTapCancelCallback? onSecondaryTapCancel;
/// Called when tertiary tap down occurs.
  GestureTapDownCallback? onTertiaryTapDown;
/// Called when tertiary tap up occurs.
  GestureTapUpCallback? onTertiaryTapUp;
/// Called when tertiary tap is cancelled.
  GestureTapCancelCallback? onTertiaryTapCancel;
/// Called when long press starts.
  GestureLongPressStartCallback? onLongPressStart;
/// Called when long press is released.
  GestureLongPressUpCallback? onLongPressUp;
/// Called when long press moves.
  GestureLongPressMoveUpdateCallback? onLongPressMoveUpdate;
/// Called when long press ends.
  GestureLongPressEndCallback? onLongPressEnd;
/// Called when secondary long press completes.
  GestureLongPressUpCallback? onSecondaryLongPress;
/// Called when tertiary long press completes.
  GestureLongPressUpCallback? onTertiaryLongPress;
/// Creates a destructive button with the specified properties.
  const DestructiveButton({super.key, required this.child, this.onPressed, this.enabled, this.leading, this.trailing, this.alignment, this.size = ButtonSize.normal, this.density = ButtonDensity.normal, this.shape = ButtonShape.rectangle, this.focusNode, this.disableTransition = false, this.onHover, this.onFocus, this.enableFeedback, this.onTapDown, this.onTapUp, this.onTapCancel, this.onSecondaryTapDown, this.onSecondaryTapUp, this.onSecondaryTapCancel, this.onTertiaryTapDown, this.onTertiaryTapUp, this.onTertiaryTapCancel, this.onLongPressStart, this.onLongPressUp, this.onLongPressMoveUpdate, this.onLongPressEnd, this.onSecondaryLongPress, this.onTertiaryLongPress});
  Widget build(BuildContext context);
}
/// Convenience widget for creating a tab button.
///
/// A simplified wrapper around [Button] with the same properties
/// as [PrimaryButton] but using tab button styling for tabbed navigation.
class TabButton extends StatelessWidget {
/// The widget to display as the button's content.
  Widget child;
/// Called when the button is pressed. If `null`, the button is disabled.
  VoidCallback? onPressed;
/// Whether the button is enabled. Overrides the `onPressed` check if provided.
  bool? enabled;
/// Widget displayed before the [child].
  Widget? leading;
/// Widget displayed after the [child].
  Widget? trailing;
/// Alignment of the button's content.
  AlignmentGeometry? alignment;
/// Size variant of the button (defaults to [ButtonSize.normal]).
  ButtonSize size;
/// Density variant affecting spacing (defaults to [ButtonDensity.normal]).
  ButtonDensity density;
/// Shape of the button (defaults to [ButtonShape.rectangle]).
  ButtonShape shape;
/// Focus node for keyboard focus management.
  FocusNode? focusNode;
/// Whether to disable style transition animations (defaults to `false`).
  bool disableTransition;
/// Called when hover state changes.
  ValueChanged<bool>? onHover;
/// Called when focus state changes.
  ValueChanged<bool>? onFocus;
/// Whether to enable haptic/audio feedback.
  bool? enableFeedback;
/// Called when primary tap down occurs.
  GestureTapDownCallback? onTapDown;
/// Called when primary tap up occurs.
  GestureTapUpCallback? onTapUp;
/// Called when primary tap is cancelled.
  GestureTapCancelCallback? onTapCancel;
/// Called when secondary tap down occurs.
  GestureTapDownCallback? onSecondaryTapDown;
/// Called when secondary tap up occurs.
  GestureTapUpCallback? onSecondaryTapUp;
/// Called when secondary tap is cancelled.
  GestureTapCancelCallback? onSecondaryTapCancel;
/// Called when tertiary tap down occurs.
  GestureTapDownCallback? onTertiaryTapDown;
/// Called when tertiary tap up occurs.
  GestureTapUpCallback? onTertiaryTapUp;
/// Called when tertiary tap is cancelled.
  GestureTapCancelCallback? onTertiaryTapCancel;
/// Called when long press starts.
  GestureLongPressStartCallback? onLongPressStart;
/// Called when long press is released.
  GestureLongPressUpCallback? onLongPressUp;
/// Called when long press moves.
  GestureLongPressMoveUpdateCallback? onLongPressMoveUpdate;
/// Called when long press ends.
  GestureLongPressEndCallback? onLongPressEnd;
/// Called when secondary long press completes.
  GestureLongPressUpCallback? onSecondaryLongPress;
/// Called when tertiary long press completes.
  GestureLongPressUpCallback? onTertiaryLongPress;
/// Creates a tab button with the specified properties.
  const TabButton({super.key, required this.child, this.onPressed, this.enabled, this.leading, this.trailing, this.alignment, this.size = ButtonSize.normal, this.density = ButtonDensity.normal, this.shape = ButtonShape.rectangle, this.focusNode, this.disableTransition = false, this.onHover, this.onFocus, this.enableFeedback, this.onTapDown, this.onTapUp, this.onTapCancel, this.onSecondaryTapDown, this.onSecondaryTapUp, this.onSecondaryTapCancel, this.onTertiaryTapDown, this.onTertiaryTapUp, this.onTertiaryTapCancel, this.onLongPressStart, this.onLongPressUp, this.onLongPressMoveUpdate, this.onLongPressEnd, this.onSecondaryLongPress, this.onTertiaryLongPress});
  Widget build(BuildContext context);
}
/// A button styled as a card with elevated appearance and extensive gesture support.
///
/// Provides an alternative button presentation that resembles a card with
/// elevated styling, typically used for prominent actions or content sections
/// that need to stand out from the background. The card styling provides
/// visual depth and emphasis compared to standard button variants.
///
/// Supports the full range of button features including leading/trailing widgets,
/// focus management, gesture handling, and accessibility features. The card
/// appearance is defined by [ButtonStyle.card] with customizable size,
/// density, and shape properties.
///
/// The component handles complex gesture interactions including primary,
/// secondary, and tertiary taps, long presses, hover states, and focus
/// management, making it suitable for rich interactive experiences.
///
/// Example:
/// ```dart
/// CardButton(
///   leading: Icon(Icons.dashboard),
///   trailing: Icon(Icons.arrow_forward),
///   size: ButtonSize.large,
///   onPressed: () => Navigator.pushNamed(context, '/dashboard'),
///   child: Column(
///     children: [
///       Text('Dashboard', style: TextStyle(fontWeight: FontWeight.bold)),
///       Text('View analytics and reports'),
///     ],
///   ),
/// )
/// ```
class CardButton extends StatelessWidget {
/// The primary content displayed within the card button.
///
/// Typically contains text, icons, or complex layouts that represent
/// the button's purpose. The content is styled with card appearance
/// and elevated visual treatment.
  Widget child;
/// Callback invoked when the button is pressed.
///
/// Called when the user taps or clicks the button. If null,
/// the button is disabled and does not respond to interactions.
  VoidCallback? onPressed;
/// Whether this button is enabled and accepts user input.
///
/// When false, the button is displayed in a disabled state and
/// ignores user interactions. When null, enabled state is determined
/// by whether [onPressed] is provided.
  bool? enabled;
/// Optional widget displayed before the main content.
///
/// Commonly used for icons that visually represent the button's action.
/// Positioned to the left of the content in LTR layouts.
  Widget? leading;
/// Optional widget displayed after the main content.
///
/// Often used for indicators, chevrons, or secondary actions.
/// Positioned to the right of the content in LTR layouts.
  Widget? trailing;
/// Alignment of content within the button.
///
/// Controls how the button's content is positioned within its bounds.
/// Defaults to center alignment if not specified.
  AlignmentGeometry? alignment;
/// Size variant for the button appearance.
///
/// Controls padding, font size, and overall dimensions. Available
/// sizes include small, normal, large, and extra large variants.
  ButtonSize size;
/// Density setting affecting button compactness.
///
/// Controls spacing and padding to create more or less compact
/// appearance. Useful for dense interfaces or accessibility needs.
  ButtonDensity density;
/// Shape configuration for the button's appearance.
///
/// Defines border radius and corner styling. Options include
/// rectangle, rounded corners, and circular shapes.
  ButtonShape shape;
/// Focus node for keyboard navigation and accessibility.
///
/// Manages focus state for the button. If not provided, a focus
/// node is created automatically by the underlying button system.
  FocusNode? focusNode;
/// Whether to disable visual transition animations.
///
/// When true, the button skips animation effects for state changes.
/// Useful for performance optimization or accessibility preferences.
  bool disableTransition;
/// Callback invoked when hover state changes.
///
/// Called with true when the mouse enters the button area,
/// and false when it exits. Useful for custom hover effects.
  ValueChanged<bool>? onHover;
/// Callback invoked when focus state changes.
///
/// Called with true when the button gains focus, and false
/// when it loses focus. Supports keyboard navigation patterns.
  ValueChanged<bool>? onFocus;
/// Whether to enable haptic/audio feedback.
  bool? enableFeedback;
/// Called when primary tap down occurs.
  GestureTapDownCallback? onTapDown;
/// Called when primary tap up occurs.
  GestureTapUpCallback? onTapUp;
/// Called when primary tap is cancelled.
  GestureTapCancelCallback? onTapCancel;
/// Called when secondary tap down occurs.
  GestureTapDownCallback? onSecondaryTapDown;
/// Called when secondary tap up occurs.
  GestureTapUpCallback? onSecondaryTapUp;
/// Called when secondary tap is cancelled.
  GestureTapCancelCallback? onSecondaryTapCancel;
/// Called when tertiary tap down occurs.
  GestureTapDownCallback? onTertiaryTapDown;
/// Called when tertiary tap up occurs.
  GestureTapUpCallback? onTertiaryTapUp;
/// Called when tertiary tap is cancelled.
  GestureTapCancelCallback? onTertiaryTapCancel;
/// Called when long press starts.
  GestureLongPressStartCallback? onLongPressStart;
/// Called when long press is released.
  GestureLongPressUpCallback? onLongPressUp;
/// Called when long press moves.
  GestureLongPressMoveUpdateCallback? onLongPressMoveUpdate;
/// Called when long press ends.
  GestureLongPressEndCallback? onLongPressEnd;
/// Called when secondary long press completes.
  GestureLongPressUpCallback? onSecondaryLongPress;
/// Called when tertiary long press completes.
  GestureLongPressUpCallback? onTertiaryLongPress;
/// Creates a [CardButton] with card-styled appearance and comprehensive interaction support.
///
/// The [child] parameter is required and provides the button's main content.
/// The button uses card styling with elevated appearance for visual prominence.
/// Extensive gesture support enables complex interactions beyond simple taps.
///
/// Parameters include standard button properties (onPressed, enabled, leading,
/// trailing) along with size, density, and shape customization options.
/// Gesture callbacks support primary, secondary, tertiary taps and long presses.
///
/// Parameters:
/// - [child] (Widget, required): The main content displayed in the button
/// - [onPressed] (VoidCallback?, optional): Primary action when button is pressed
/// - [enabled] (bool?, optional): Whether button accepts input (null uses onPressed)
/// - [size] (ButtonSize, default: normal): Size variant for button dimensions
/// - [density] (ButtonDensity, default: normal): Spacing density setting
/// - [shape] (ButtonShape, default: rectangle): Border radius and corner styling
///
/// Example:
/// ```dart
/// CardButton(
///   size: ButtonSize.large,
///   leading: Icon(Icons.star),
///   onPressed: () => _handleFavorite(),
///   child: Text('Add to Favorites'),
/// )
/// ```
  const CardButton({super.key, required this.child, this.onPressed, this.enabled, this.leading, this.trailing, this.alignment, this.size = ButtonSize.normal, this.density = ButtonDensity.normal, this.shape = ButtonShape.rectangle, this.focusNode, this.disableTransition = false, this.onHover, this.onFocus, this.enableFeedback, this.onTapDown, this.onTapUp, this.onTapCancel, this.onSecondaryTapDown, this.onSecondaryTapUp, this.onSecondaryTapCancel, this.onTertiaryTapDown, this.onTertiaryTapUp, this.onTertiaryTapCancel, this.onLongPressStart, this.onLongPressUp, this.onLongPressMoveUpdate, this.onLongPressEnd, this.onSecondaryLongPress, this.onTertiaryLongPress});
  Widget build(BuildContext context);
}
/// Icon-only button widget with support for multiple visual styles.
///
/// [IconButton] is optimized for displaying buttons with icon content,
/// using icon-specific density and sizing by default. Supports various
/// button styles through named constructors or the [variance] parameter.
class IconButton extends StatelessWidget {
/// The icon widget to display in the button.
  Widget icon;
/// Called when the button is pressed. If `null`, the button is disabled.
  VoidCallback? onPressed;
/// Whether the button is enabled. Overrides the `onPressed` check if provided.
  bool? enabled;
/// Widget displayed before the [icon].
  Widget? leading;
/// Widget displayed after the [icon].
  Widget? trailing;
/// Alignment of the button's content.
  AlignmentGeometry? alignment;
/// Size variant of the button (defaults to [ButtonSize.normal]).
  ButtonSize size;
/// Density variant affecting spacing (defaults to [ButtonDensity.icon]).
  ButtonDensity density;
/// Shape of the button (defaults to [ButtonShape.rectangle]).
  ButtonShape shape;
/// Focus node for keyboard focus management.
  FocusNode? focusNode;
/// Whether to disable style transition animations (defaults to `false`).
  bool disableTransition;
/// Called when hover state changes.
  ValueChanged<bool>? onHover;
/// Called when focus state changes.
  ValueChanged<bool>? onFocus;
/// Whether to enable haptic/audio feedback.
  bool? enableFeedback;
/// Called when primary tap down occurs.
  GestureTapDownCallback? onTapDown;
/// Called when primary tap up occurs.
  GestureTapUpCallback? onTapUp;
/// Called when primary tap is cancelled.
  GestureTapCancelCallback? onTapCancel;
/// Called when secondary tap down occurs.
  GestureTapDownCallback? onSecondaryTapDown;
/// Called when secondary tap up occurs.
  GestureTapUpCallback? onSecondaryTapUp;
/// Called when secondary tap is cancelled.
  GestureTapCancelCallback? onSecondaryTapCancel;
/// Called when tertiary tap down occurs.
  GestureTapDownCallback? onTertiaryTapDown;
/// Called when tertiary tap up occurs.
  GestureTapUpCallback? onTertiaryTapUp;
/// Called when tertiary tap is cancelled.
  GestureTapCancelCallback? onTertiaryTapCancel;
/// Called when long press starts.
  GestureLongPressStartCallback? onLongPressStart;
/// Called when long press is released.
  GestureLongPressUpCallback? onLongPressUp;
/// Called when long press moves.
  GestureLongPressMoveUpdateCallback? onLongPressMoveUpdate;
/// Called when long press ends.
  GestureLongPressEndCallback? onLongPressEnd;
/// Called when secondary long press completes.
  GestureLongPressUpCallback? onSecondaryLongPress;
/// Called when tertiary long press completes.
  GestureLongPressUpCallback? onTertiaryLongPress;
/// The button style variant to apply.
  AbstractButtonStyle variance;
/// Creates an icon button with the specified style variance.
  const IconButton({super.key, required this.icon, required this.variance, this.onPressed, this.enabled, this.leading, this.trailing, this.alignment, this.size = ButtonSize.normal, this.density = ButtonDensity.icon, this.shape = ButtonShape.rectangle, this.focusNode, this.disableTransition = false, this.onHover, this.onFocus, this.enableFeedback, this.onTapDown, this.onTapUp, this.onTapCancel, this.onSecondaryTapDown, this.onSecondaryTapUp, this.onSecondaryTapCancel, this.onTertiaryTapDown, this.onTertiaryTapUp, this.onTertiaryTapCancel, this.onLongPressStart, this.onLongPressUp, this.onLongPressMoveUpdate, this.onLongPressEnd, this.onSecondaryLongPress, this.onTertiaryLongPress});
/// Creates an icon button with primary styling.
  const IconButton.primary({super.key, required this.icon, this.onPressed, this.enabled, this.leading, this.trailing, this.alignment, this.size = ButtonSize.normal, this.focusNode, this.disableTransition = false, this.onHover, this.onFocus, this.enableFeedback, this.onTapDown, this.onTapUp, this.onTapCancel, this.onSecondaryTapDown, this.onSecondaryTapUp, this.onSecondaryTapCancel, this.onTertiaryTapDown, this.onTertiaryTapUp, this.onTertiaryTapCancel, this.onLongPressStart, this.onLongPressUp, this.onLongPressMoveUpdate, this.onLongPressEnd, this.onSecondaryLongPress, this.onTertiaryLongPress, this.variance = ButtonVariance.primary, this.density = ButtonDensity.icon, this.shape = ButtonShape.rectangle});
/// Creates an icon button with secondary styling.
  const IconButton.secondary({super.key, required this.icon, this.onPressed, this.enabled, this.leading, this.trailing, this.alignment, this.size = ButtonSize.normal, this.focusNode, this.disableTransition = false, this.onHover, this.onFocus, this.enableFeedback, this.onTapDown, this.onTapUp, this.onTapCancel, this.onSecondaryTapDown, this.onSecondaryTapUp, this.onSecondaryTapCancel, this.onTertiaryTapDown, this.onTertiaryTapUp, this.onTertiaryTapCancel, this.onLongPressStart, this.onLongPressUp, this.onLongPressMoveUpdate, this.onLongPressEnd, this.onSecondaryLongPress, this.onTertiaryLongPress, this.variance = ButtonVariance.secondary, this.density = ButtonDensity.icon, this.shape = ButtonShape.rectangle});
/// Creates an icon button with outline styling.
  const IconButton.outline({super.key, required this.icon, this.onPressed, this.enabled, this.leading, this.trailing, this.alignment, this.size = ButtonSize.normal, this.focusNode, this.disableTransition = false, this.onHover, this.onFocus, this.enableFeedback, this.onTapDown, this.onTapUp, this.onTapCancel, this.onSecondaryTapDown, this.onSecondaryTapUp, this.onSecondaryTapCancel, this.onTertiaryTapDown, this.onTertiaryTapUp, this.onTertiaryTapCancel, this.onLongPressStart, this.onLongPressUp, this.onLongPressMoveUpdate, this.onLongPressEnd, this.onSecondaryLongPress, this.onTertiaryLongPress, this.variance = ButtonVariance.outline, this.density = ButtonDensity.icon, this.shape = ButtonShape.rectangle});
/// Creates an icon button with ghost styling.
  const IconButton.ghost({super.key, required this.icon, this.onPressed, this.enabled, this.leading, this.trailing, this.alignment, this.size = ButtonSize.normal, this.focusNode, this.disableTransition = false, this.onHover, this.onFocus, this.enableFeedback, this.onTapDown, this.onTapUp, this.onTapCancel, this.onSecondaryTapDown, this.onSecondaryTapUp, this.onSecondaryTapCancel, this.onTertiaryTapDown, this.onTertiaryTapUp, this.onTertiaryTapCancel, this.onLongPressStart, this.onLongPressUp, this.onLongPressMoveUpdate, this.onLongPressEnd, this.onSecondaryLongPress, this.onTertiaryLongPress, this.variance = ButtonVariance.ghost, this.density = ButtonDensity.icon, this.shape = ButtonShape.rectangle});
/// Creates an icon button with link styling.
  const IconButton.link({super.key, required this.icon, this.onPressed, this.enabled, this.leading, this.trailing, this.alignment, this.size = ButtonSize.normal, this.focusNode, this.disableTransition = false, this.onHover, this.onFocus, this.enableFeedback, this.onTapDown, this.onTapUp, this.onTapCancel, this.onSecondaryTapDown, this.onSecondaryTapUp, this.onSecondaryTapCancel, this.onTertiaryTapDown, this.onTertiaryTapUp, this.onTertiaryTapCancel, this.onLongPressStart, this.onLongPressUp, this.onLongPressMoveUpdate, this.onLongPressEnd, this.onSecondaryLongPress, this.onTertiaryLongPress, this.variance = ButtonVariance.link, this.density = ButtonDensity.icon, this.shape = ButtonShape.rectangle});
/// Creates an icon button with text styling.
  const IconButton.text({super.key, required this.icon, this.onPressed, this.enabled, this.leading, this.trailing, this.alignment, this.size = ButtonSize.normal, this.focusNode, this.disableTransition = false, this.onHover, this.onFocus, this.enableFeedback, this.onTapDown, this.onTapUp, this.onTapCancel, this.onSecondaryTapDown, this.onSecondaryTapUp, this.onSecondaryTapCancel, this.onTertiaryTapDown, this.onTertiaryTapUp, this.onTertiaryTapCancel, this.onLongPressStart, this.onLongPressUp, this.onLongPressMoveUpdate, this.onLongPressEnd, this.onSecondaryLongPress, this.onTertiaryLongPress, this.variance = ButtonVariance.text, this.density = ButtonDensity.icon, this.shape = ButtonShape.rectangle});
/// Creates an icon button with destructive styling.
  const IconButton.destructive({super.key, required this.icon, this.onPressed, this.enabled, this.leading, this.trailing, this.alignment, this.size = ButtonSize.normal, this.focusNode, this.disableTransition = false, this.onHover, this.onFocus, this.enableFeedback, this.onTapDown, this.onTapUp, this.onTapCancel, this.onSecondaryTapDown, this.onSecondaryTapUp, this.onSecondaryTapCancel, this.onTertiaryTapDown, this.onTertiaryTapUp, this.onTertiaryTapCancel, this.onLongPressStart, this.onLongPressUp, this.onLongPressMoveUpdate, this.onLongPressEnd, this.onSecondaryLongPress, this.onTertiaryLongPress, this.variance = ButtonVariance.destructive, this.density = ButtonDensity.icon, this.shape = ButtonShape.rectangle});
  Widget build(BuildContext context);
}
/// Widget for locally overriding button styles within a subtree.
///
/// [ButtonStyleOverride] allows selective customization of button style properties
/// for all descendant buttons without replacing the entire button style. It provides
/// style property delegates that can intercept and modify the default values.
///
/// The widget supports two modes:
/// - **Replace mode** (default): Applies overrides directly
/// - **Inherit mode**: Chains with parent overrides, allowing nested customization
///
/// Example:
/// ```dart
/// ButtonStyleOverride(
///   decoration: (context, states, defaultDecoration) {
///     // Customize decoration for all buttons in this subtree
///     return BoxDecoration(color: Colors.red);
///   },
///   child: Column(
///     children: [
///       PrimaryButton(child: Text('Red Button')),
///       SecondaryButton(child: Text('Also Red')),
///     ],
///   ),
/// )
/// ```
class ButtonStyleOverride extends StatelessWidget {
/// Whether to inherit and chain with parent overrides.
///
/// When `true`, this override's delegates receive the parent override's result
/// as their default value, allowing nested style modifications. When `false`,
/// parent overrides are ignored.
  bool inherit;
/// Optional decoration override delegate.
  ButtonStatePropertyDelegate<Decoration>? decoration;
/// Optional mouse cursor override delegate.
  ButtonStatePropertyDelegate<MouseCursor>? mouseCursor;
/// Optional padding override delegate.
  ButtonStatePropertyDelegate<EdgeInsetsGeometry>? padding;
/// Optional text style override delegate.
  ButtonStatePropertyDelegate<TextStyle>? textStyle;
/// Optional icon theme override delegate.
  ButtonStatePropertyDelegate<IconThemeData>? iconTheme;
/// Optional margin override delegate.
  ButtonStatePropertyDelegate<EdgeInsetsGeometry>? margin;
/// The widget subtree where overrides apply.
  Widget child;
/// Creates a button style override in replace mode.
///
/// Overrides apply to all descendant buttons, ignoring parent overrides.
  const ButtonStyleOverride({super.key, this.decoration, this.mouseCursor, this.padding, this.textStyle, this.iconTheme, this.margin, required this.child});
/// Creates a button style override in inherit mode.
///
/// Overrides chain with parent overrides, allowing nested customization where
/// each level can modify the result of the previous level.
  const ButtonStyleOverride.inherit({super.key, this.decoration, this.mouseCursor, this.padding, this.textStyle, this.iconTheme, this.margin, required this.child});
  Widget build(BuildContext context);
}
/// Data class holding button style override delegates.
///
/// [ButtonStyleOverrideData] is used internally by [ButtonStyleOverride] to pass
/// style override delegates through the widget tree via the [Data] inherited widget
/// system. It stores optional delegates for each button style property.
///
/// This class is typically not used directly by application code; instead, use
/// [ButtonStyleOverride] widget to apply style overrides.
class ButtonStyleOverrideData {
/// Optional decoration override delegate.
  ButtonStatePropertyDelegate<Decoration>? decoration;
/// Optional mouse cursor override delegate.
  ButtonStatePropertyDelegate<MouseCursor>? mouseCursor;
/// Optional padding override delegate.
  ButtonStatePropertyDelegate<EdgeInsetsGeometry>? padding;
/// Optional text style override delegate.
  ButtonStatePropertyDelegate<TextStyle>? textStyle;
/// Optional icon theme override delegate.
  ButtonStatePropertyDelegate<IconThemeData>? iconTheme;
/// Optional margin override delegate.
  ButtonStatePropertyDelegate<EdgeInsetsGeometry>? margin;
/// Creates button style override data with the specified delegates.
  const ButtonStyleOverrideData({this.decoration, this.mouseCursor, this.padding, this.textStyle, this.iconTheme, this.margin});
  bool operator ==(Object other);
  int get hashCode;
  String toString();
}
/// A widget that groups multiple buttons together with connected borders.
///
/// [ButtonGroup] visually connects a series of related buttons by removing
/// the borders between adjacent buttons and maintaining consistent styling.
/// This creates a segmented appearance where the buttons appear as a single
/// cohesive unit.
///
/// The group can be oriented horizontally or vertically, and automatically
/// handles border radius adjustments so that only the first and last buttons
/// in the group have rounded corners on their outer edges.
///
/// Commonly used for:
/// - Toggle button groups (like text formatting options)
/// - Related action sets (like alignment controls)
/// - Pagination controls
/// - View switchers
///
/// Example:
/// ```dart
/// ButtonGroup(
///   direction: Axis.horizontal,
///   children: [
///     Button.secondary(
///       onPressed: () => align('left'),
///       child: Icon(Icons.format_align_left),
///     ),
///     Button.secondary(
///       onPressed: () => align('center'),
///       child: Icon(Icons.format_align_center),
///     ),
///     Button.secondary(
///       onPressed: () => align('right'),
///       child: Icon(Icons.format_align_right),
///     ),
///   ],
/// );
/// ```
class ButtonGroup extends StatelessWidget {
/// The layout direction for the button group.
///
/// [Axis.horizontal] arranges buttons in a row, removing vertical borders
/// between adjacent buttons. [Axis.vertical] arranges buttons in a column,
/// removing horizontal borders between adjacent buttons.
  Axis direction;
/// The list of button widgets to group together.
///
/// Each widget should typically be a [Button] or similar interactive widget.
/// The group automatically applies border modifications to create the
/// connected appearance.
  List<Widget> children;
/// Whether the button group should be shrink-wrapped or expanded.
///
/// When true, the group will expand to fill available space in the
/// cross axis. When false, the group will size itself based on its
/// children's intrinsic size.
  bool expands;
/// Creates a [ButtonGroup] that arranges buttons with connected borders.
///
/// Parameters:
/// - [direction] (Axis, default: Axis.horizontal): Layout direction for the buttons.
/// - [children] (`List<Widget>`, required): The buttons to group together.
///
/// The group automatically handles:
/// - Border radius adjustments for first/middle/last buttons
/// - Proper sizing with [IntrinsicHeight] or [IntrinsicWidth]
/// - Stretch alignment for consistent button heights/widths
///
/// Example:
/// ```dart
/// ButtonGroup(
///   direction: Axis.vertical,
///   children: [
///     Button.outline(child: Text('Option 1')),
///     Button.outline(child: Text('Option 2')),
///     Button.outline(child: Text('Option 3')),
///   ],
/// );
/// ```
  const ButtonGroup({super.key, this.direction = Axis.horizontal, this.expands = false, required this.children});
/// Creates a horizontal button group.
///
/// A convenience constructor equivalent to `ButtonGroup(direction: Axis.horizontal)`.
/// Arranges buttons in a row with connected borders.
  const ButtonGroup.horizontal({super.key, this.expands = false, required this.children});
/// Creates a vertical button group.
///
/// A convenience constructor equivalent to `ButtonGroup(direction: Axis.vertical)`.
/// Arranges buttons in a column with connected borders.
  const ButtonGroup.vertical({super.key, this.expands = false, required this.children});
  Widget build(BuildContext context);
}
/// Data class defining border radius multipliers for grouped buttons.
///
/// [ButtonGroupData] specifies which corners of a button should have reduced
/// border radius when part of a [ButtonGroup]. Values of 0.0 remove the radius
/// entirely (for internal buttons), while 1.0 preserves the full radius (for
/// end buttons).
///
/// This class uses directional values (start/end) to support RTL layouts properly.
/// The static constants provide common configurations for different positions
/// within a button group.
///
/// Example:
/// ```dart
/// // First button in horizontal group - preserve left radius, remove right
/// ButtonGroupData.horizontal(end: 0.0)
///
/// // Middle button - remove all radius
/// ButtonGroupData.zero
///
/// // Last button in horizontal group - remove left radius, preserve right
/// ButtonGroupData.horizontal(start: 0.0)
/// ```
class ButtonGroupData {
/// No modification - full border radius on all corners.
  static const ButtonGroupData none = ButtonGroupData.all(1.0);
/// Zero radius - removes border radius from all corners.
  static const ButtonGroupData zero = ButtonGroupData.all(0.0);
/// Horizontal start position - full start radius, no end radius.
  static const ButtonGroupData horizontalStart = ButtonGroupData.horizontal(end: 0.0);
/// Horizontal end position - no start radius, full end radius.
  static const ButtonGroupData horizontalEnd = ButtonGroupData.horizontal(start: 0.0);
/// Vertical top position - full top radius, no bottom radius.
  static const ButtonGroupData verticalTop = ButtonGroupData.vertical(bottom: 0.0);
/// Vertical bottom position - no top radius, full bottom radius.
  static const ButtonGroupData verticalBottom = ButtonGroupData.vertical(top: 0.0);
/// Border radius multiplier for top-start corner (0.0 to 1.0).
  double topStartValue;
/// Border radius multiplier for top-end corner (0.0 to 1.0).
  double topEndValue;
/// Border radius multiplier for bottom-start corner (0.0 to 1.0).
  double bottomStartValue;
/// Border radius multiplier for bottom-end corner (0.0 to 1.0).
  double bottomEndValue;
/// Creates button group data with individual corner multipliers.
  const ButtonGroupData({required this.topStartValue, required this.topEndValue, required this.bottomStartValue, required this.bottomEndValue});
/// Creates horizontal group data with start and end multipliers.
///
/// Both top and bottom on each side use the same value.
  const ButtonGroupData.horizontal({double start = 1.0, double end = 1.0});
/// Creates vertical group data with top and bottom multipliers.
///
/// Both start and end on each side use the same value.
  const ButtonGroupData.vertical({double top = 1.0, double bottom = 1.0});
/// Creates group data with the same multiplier for all corners.
  const ButtonGroupData.all(double value);
/// Creates group data for a button at [index] in a horizontal group of [length] buttons.
///
/// Returns:
/// - [horizontalStart] for the first button (index 0)
/// - [zero] for middle buttons
/// - [horizontalEnd] for the last button
/// - [none] if group has only one button
  factory ButtonGroupData.horizontalIndex(int index, int length);
/// Creates group data for a button at [index] in a vertical group of [length] buttons.
///
/// Returns:
/// - [verticalTop] for the first button (index 0)
/// - [zero] for middle buttons
/// - [verticalBottom] for the last button
/// - [none] if group has only one button
  factory ButtonGroupData.verticalIndex(int index, int length);
/// Applies corner multipliers to a border radius.
///
/// Multiplies each corner's radius by the corresponding corner value,
/// properly handling text direction for start/end mapping to left/right.
///
/// Parameters:
/// - [borderRadius]: The base border radius to modify
/// - [textDirection]: Text direction for resolving start/end to left/right
///
/// Returns a new [BorderRadiusGeometry] with modified corner radii.
  BorderRadiusGeometry applyToBorderRadius(BorderRadiusGeometry borderRadius, TextDirection textDirection);
/// Combines this group data with another by multiplying corresponding corner values.
///
/// Useful for nesting button groups or applying multiple grouping effects.
/// Each corner value is multiplied: result = this.value * other.value.
///
/// Example:
/// ```dart
/// final half = ButtonGroupData.all(0.5);
/// final end = ButtonGroupData.horizontal(start: 0.0);
/// final combined = half.applyToButtonGroupData(end);
/// // combined has: topStart=0, bottomStart=0, topEnd=0.5, bottomEnd=0.5
/// ```
  ButtonGroupData applyToButtonGroupData(ButtonGroupData other);
  String toString();
  bool operator ==(Object other);
  int get hashCode;
}
/// Theme configuration for hover-related widgets and behaviors.
///
/// [HoverTheme] provides configurable durations and behaviors for hover
/// interactions throughout the application. It can be registered in the
/// component theme system to customize hover behavior globally.
///
/// Example:
/// ```dart
/// HoverTheme(
///   debounceDuration: Duration(milliseconds: 100),
///   hitTestBehavior: HitTestBehavior.opaque,
/// )
/// ```
class HoverTheme extends ComponentThemeData {
/// Debounce duration for repeated hover events.
///
/// When set, hover callbacks are throttled to fire at most once per this duration.
  Duration? debounceDuration;
/// Hit test behavior for hover detection.
///
/// Determines how the widget participates in hit testing for mouse events.
  HitTestBehavior? hitTestBehavior;
/// Wait duration before showing hover feedback (e.g., tooltips).
///
/// Delays the appearance of hover-triggered UI to avoid flashing on quick passes.
  Duration? waitDuration;
/// Minimum duration to keep hover feedback visible once shown.
///
/// Prevents hover UI from disappearing too quickly.
  Duration? minDuration;
/// Duration for hover feedback show animations.
  Duration? showDuration;
/// Creates a [HoverTheme] with optional configuration values.
  const HoverTheme({this.debounceDuration, this.hitTestBehavior, this.waitDuration, this.minDuration, this.showDuration});
/// Creates a copy of this theme with selectively replaced properties.
///
/// Parameters are [ValueGetter] functions to allow setting values to `null`.
  HoverTheme copyWith({ValueGetter<Duration?>? debounceDuration, ValueGetter<HitTestBehavior?>? hitTestBehavior, ValueGetter<Duration?>? waitDuration, ValueGetter<Duration?>? minDuration, ValueGetter<Duration?>? showDuration});
  bool operator ==(Object other);
  int get hashCode;
}
/// A widget that tracks mouse hover state and triggers callbacks.
///
/// [HoverActivity] monitors when the mouse cursor enters, hovers over, and exits
/// its child widget, calling appropriate callbacks. The [onHover] callback can be
/// called repeatedly while hovering if [debounceDuration] is set.
///
/// Example:
/// ```dart
/// HoverActivity(
///   debounceDuration: Duration(milliseconds: 500),
///   onEnter: () => print('Mouse entered'),
///   onHover: () => print('Still hovering'),
///   onExit: () => print('Mouse exited'),
///   child: Container(
///     width: 100,
///     height: 100,
///     color: Colors.blue,
///   ),
/// )
/// ```
class HoverActivity extends StatefulWidget {
/// The widget to track for hover events.
  Widget child;
/// Called periodically while hovering, at intervals of [debounceDuration].
///
/// If [debounceDuration] is `null`, this is called only once on initial hover.
  VoidCallback? onHover;
/// Called when the mouse cursor exits the widget bounds.
  VoidCallback? onExit;
/// Called when the mouse cursor first enters the widget bounds.
  VoidCallback? onEnter;
/// Interval for repeated [onHover] callbacks while the cursor remains over the widget.
///
/// If `null`, [onHover] is called only once when hover begins.
  Duration? debounceDuration;
/// Hit test behavior determining how this widget participates in pointer event handling.
  HitTestBehavior? hitTestBehavior;
/// Creates a [HoverActivity] widget.
  const HoverActivity({super.key, required this.child, this.onHover, this.onExit, this.onEnter, this.hitTestBehavior, this.debounceDuration});
  State<HoverActivity> createState();
}
/// A widget that manages hover state with configurable timing behavior.
///
/// [Hover] provides sophisticated hover detection with delays and minimum durations
/// to prevent flickering when the cursor quickly passes over the widget. It calls
/// [onHover] with `true` when hover activates and `false` when it deactivates.
///
/// Unlike [HoverActivity], this widget implements smart timing:
/// - [waitDuration]: Delay before activating hover
/// - [minDuration]: Minimum time to keep hover active once triggered
/// - [showDuration]: Total duration for hover state
///
/// Example:
/// ```dart
/// Hover(
///   waitDuration: Duration(milliseconds: 500),
///   minDuration: Duration(milliseconds: 200),
///   onHover: (hovered) {
///     print(hovered ? 'Hover activated' : 'Hover deactivated');
///   },
///   child: Container(
///     width: 100,
///     height: 100,
///     color: Colors.blue,
///   ),
/// )
/// ```
class Hover extends StatefulWidget {
/// The widget to track for hover events.
  Widget child;
/// Called with `true` when hover activates, `false` when it deactivates.
///
/// Activation respects [waitDuration] delay, and deactivation respects [minDuration].
  void Function(bool hovered) onHover;
/// Delay before activating hover after cursor enters.
///
/// Prevents accidental activation from quick cursor passes. Defaults to 500ms.
  Duration? waitDuration;
/// Minimum duration to keep hover active once triggered.
///
/// Prevents flickering when cursor quickly moves over the widget. Defaults to 0ms.
  Duration? minDuration;
/// Total duration for hover state before auto-deactivation.
  Duration? showDuration;
/// Hit test behavior for pointer event handling.
  HitTestBehavior? hitTestBehavior;
/// Creates a [Hover] widget with timing configuration.
  const Hover({super.key, required this.child, required this.onHover, this.waitDuration, this.minDuration, this.showDuration, this.hitTestBehavior});
  State<Hover> createState();
}
/// Theme configuration for [Scrollbar].
class ScrollbarTheme extends ComponentThemeData {
/// Color of the scrollbar thumb.
  Color? color;
/// Thickness of the scrollbar thumb.
  double? thickness;
/// Radius of the scrollbar thumb.
  Radius? radius;
/// Creates a [ScrollbarTheme].
  const ScrollbarTheme({this.color, this.thickness, this.radius});
/// Creates a copy of this theme with the given values replaced.
  ScrollbarTheme copyWith({ValueGetter<Color?>? color, ValueGetter<double?>? thickness, ValueGetter<Radius?>? radius});
  bool operator ==(Object other);
  int get hashCode;
}
/// A customizable scrollbar widget for shadcn_flutter.
///
/// [Scrollbar] provides a themeable scrollbar that can be attached to any
/// scrollable widget. It supports both vertical and horizontal orientations,
/// configurable appearance, and interactive dragging.
///
/// Example:
/// ```dart
/// Scrollbar(
///   controller: scrollController,
///   thumbVisibility: true,
///   thickness: 8,
///   child: ListView.builder(
///     controller: scrollController,
///     itemCount: 100,
///     itemBuilder: (context, index) => ListTile(title: Text('Item $index')),
///   ),
/// )
/// ```
class Scrollbar extends StatelessWidget {
/// Creates a [Scrollbar] widget.
///
/// Parameters:
/// - [child] (Widget, required): The scrollable widget to attach the scrollbar to
/// - [controller] (ScrollController?, optional): Controller for the scrollable content
/// - [thumbVisibility] (bool?, optional): Whether the scrollbar thumb is always visible
/// - [trackVisibility] (bool?, optional): Whether the scrollbar track is always visible
/// - [thickness] (double?, optional): Thickness of the scrollbar
/// - [radius] (Radius?, optional): Border radius for the scrollbar thumb
/// - [color] (Color?, optional): Color of the scrollbar thumb
/// - [interactive] (bool?, optional): Whether the scrollbar can be dragged
/// - [notificationPredicate] (ScrollNotificationPredicate?, optional): Predicate for scroll notifications
/// - [scrollbarOrientation] (ScrollbarOrientation?, optional): Orientation of the scrollbar
  const Scrollbar({super.key, required this.child, this.controller, this.thumbVisibility, this.trackVisibility, this.thickness, this.radius, this.color, this.notificationPredicate, this.interactive, this.scrollbarOrientation});
/// The scrollable widget to attach the scrollbar to.
  Widget child;
/// Optional scroll controller for the scrollable content.
///
/// If not provided, the scrollbar will use the nearest [Scrollable]'s controller.
  ScrollController? controller;
/// Whether the scrollbar thumb is always visible.
///
/// When `true`, the thumb remains visible even when not scrolling.
/// When `false` or `null`, the thumb fades out after scrolling stops.
  bool? thumbVisibility;
/// Whether the scrollbar track is always visible.
///
/// When `true`, the track (background) remains visible.
/// When `false` or `null`, only the thumb is shown.
  bool? trackVisibility;
/// The thickness of the scrollbar in logical pixels.
  double? thickness;
/// The border radius of the scrollbar thumb.
  Radius? radius;
/// The color of the scrollbar thumb.
  Color? color;
/// Whether the scrollbar can be dragged to scroll.
///
/// When `true`, users can click and drag the scrollbar thumb to scroll.
  bool? interactive;
/// Predicate to determine which scroll notifications trigger scrollbar updates.
  ScrollNotificationPredicate? notificationPredicate;
/// The orientation of the scrollbar (vertical or horizontal).
  ScrollbarOrientation? scrollbarOrientation;
  Widget build(BuildContext context);
}
/// An abstract class that defines values for different Tracker levels.
///
/// [TrackerLevel] provides a standardized way to represent different status
/// or priority levels in tracker components. Each level defines both a visual
/// color and descriptive name for consistent representation across the UI.
///
/// ## Predefined Levels
/// The class includes several predefined levels for common use cases:
/// - [fine]: Green color, typically for healthy/good states
/// - [warning]: Orange color, for cautionary states requiring attention
/// - [critical]: Red color, for urgent states requiring immediate action
/// - [unknown]: Gray color, for undefined or unavailable states
///
/// ## Custom Levels
/// Custom tracker levels can be implemented by extending this abstract class
/// and providing [color] and [name] implementations.
///
/// Example:
/// ```dart
/// // Using predefined levels
/// TrackerData(
///   level: TrackerLevel.critical,
///   tooltip: Text('System Alert'),
/// );
///
/// // Creating custom level
/// class CustomLevel implements TrackerLevel {
///   @override
///   Color get color => Colors.purple;
///
///   @override
///   String get name => 'Custom';
/// }
/// ```
abstract class TrackerLevel {
/// Default values for the fine level.
///
/// [color] is set to `Colors.green`
/// [name] is set to `"Fine"`
  static const TrackerLevel fine = _SimpleTrackerLevel(Colors.green, 'Fine');
/// Default values for the warning level.
///
/// [color] is set to `Colors.orange`
/// [name] is set to `"Warning"`
  static const TrackerLevel warning = _SimpleTrackerLevel(Colors.orange, 'Warning');
/// Default values for the critical level.
///
/// [color] is set to `Colors.red`
/// [name] is set to `"Critical"`
  static const TrackerLevel critical = _SimpleTrackerLevel(Colors.red, 'Critical');
/// Default values for the unknown level.
///
/// [color] is set to `Colors.gray`
/// [name] is set to `"Unknown"`
  static const TrackerLevel unknown = _SimpleTrackerLevel(Colors.gray, 'Unknown');
/// Gets the color for the specified [TrackerLevel].
///
/// Returns the [Color] associated with this tracker level, used for
/// visual representation in the tracker component.
  Color get color;
/// Gets the name for the specified [TrackerLevel].
///
/// Returns a [String] description of this tracker level, typically
/// used in tooltips or accessibility labels.
  String get name;
}
/// A data container for individual tracker segments.
///
/// [TrackerData] encapsulates the information needed to display a single
/// segment within a [Tracker] widget. Each segment represents a data point
/// with an associated status level and contextual information.
///
/// ## Components
/// - **Tooltip**: Interactive content displayed on hover for additional context
/// - **Level**: Status level determining the visual appearance and meaning
///
/// ## Usage
/// Tracker data is typically created from application data models and
/// transformed into visual representations for status monitoring dashboards,
/// progress indicators, or health monitoring interfaces.
///
/// Example:
/// ```dart
/// TrackerData(
///   level: TrackerLevel.warning,
///   tooltip: Column(
///     mainAxisSize: MainAxisSize.min,
///     children: [
///       Text('Server Load'),
///       Text('75% - Warning Level'),
///       Text('Last Updated: 2 min ago'),
///     ],
///   ),
/// );
/// ```
class TrackerData {
/// The tooltip content displayed on hover.
///
/// Type: `Widget`. Interactive content shown when the user hovers over
/// this tracker segment. Can contain text, icons, or complex layouts
/// providing additional context about the data point.
  Widget tooltip;
/// The status level determining visual appearance.
///
/// Type: `TrackerLevel`. Defines the color and semantic meaning of this
/// tracker segment. Used to determine the background color and accessibility
/// information for the segment.
  TrackerLevel level;
/// Creates a new [TrackerData] instance.
///
/// Combines a tooltip for user interaction with a status level for
/// visual representation in tracker components.
///
/// Parameters:
/// - [tooltip] (Widget, required): Interactive content for hover display
/// - [level] (TrackerLevel, required): Status level for visual styling
///
/// Example:
/// ```dart
/// TrackerData(
///   tooltip: Text('CPU Usage: 45%'),
///   level: TrackerLevel.fine,
/// );
/// ```
  const TrackerData({required this.tooltip, required this.level});
}
/// Theme configuration for [Tracker] components.
///
/// [TrackerTheme] provides styling options for tracker components including
/// corner radius, spacing between segments, and segment height. It enables
/// consistent tracker styling across an application while allowing customization.
///
/// Used with [ComponentTheme] to apply theme values throughout the widget tree.
///
/// Example:
/// ```dart
/// ComponentTheme<TrackerTheme>(
///   data: TrackerTheme(
///     radius: 8.0,
///     gap: 2.0,
///     itemHeight: 40.0,
///   ),
///   child: MyTrackerWidget(),
/// );
/// ```
class TrackerTheme extends ComponentThemeData {
/// Corner radius for the tracker container in logical pixels.
///
/// Type: `double?`. Controls the rounding of tracker corners. If null,
/// defaults to theme.radiusMd for consistent corner styling.
  double? radius;
/// Gap between individual tracker segments in logical pixels.
///
/// Type: `double?`. Spacing between adjacent tracker segments. If null,
/// defaults to theme.scaling * 2 for proportional spacing.
  double? gap;
/// Height of individual tracker segments in logical pixels.
///
/// Type: `double?`. Controls the vertical size of tracker segments.
/// If null, defaults to 32 logical pixels.
  double? itemHeight;
/// Creates a [TrackerTheme].
///
/// All parameters are optional and will fall back to theme defaults
/// when not provided.
///
/// Parameters:
/// - [radius] (double?, optional): Corner radius in pixels
/// - [gap] (double?, optional): Spacing between segments in pixels
/// - [itemHeight] (double?, optional): Height of segments in pixels
///
/// Example:
/// ```dart
/// TrackerTheme(
///   radius: 12.0,
///   gap: 4.0,
///   itemHeight: 48.0,
/// );
/// ```
  const TrackerTheme({this.radius, this.gap, this.itemHeight});
/// Creates a copy of this theme with the given values replaced.
///
/// Returns a new [TrackerTheme] instance with the same values as this
/// theme, except for any parameters that are explicitly provided. Use
/// [ValueGetter] functions to specify new values.
///
/// Example:
/// ```dart
/// final newTheme = originalTheme.copyWith(
///   radius: () => 16.0,
///   itemHeight: () => 56.0,
/// );
/// ```
  TrackerTheme copyWith({ValueGetter<double?>? radius, ValueGetter<double?>? gap, ValueGetter<double?>? itemHeight});
  bool operator ==(Object other);
  int get hashCode;
  String toString();
}
/// A widget that displays a tracker.
///
/// This widget displays a row of tracker levels with tooltips.
/// The row contains a tracker level for each tracker in the [data] list.
/// A horizontal status tracking widget with interactive tooltips.
///
/// [Tracker] provides a visual representation of status data as colored segments
/// in a horizontal layout. Each segment represents a data point with an associated
/// status level and interactive tooltip. It's commonly used for monitoring
/// dashboards, progress indicators, and status overviews.
///
/// ## Key Features
/// - **Status Visualization**: Color-coded segments based on [TrackerLevel]
/// - **Interactive Tooltips**: Hover-activated tooltips with custom content
/// - **Flexible Sizing**: Segments automatically expand to fill available width
/// - **Theming**: Comprehensive styling via [TrackerTheme]
/// - **Rounded Corners**: Configurable corner radius for modern appearance
///
/// ## Layout Behavior
/// The tracker displays segments as equally-sized horizontal sections that
/// expand to fill the available width. Gaps between segments and overall
/// styling can be controlled through the theme system.
///
/// ## Use Cases
/// - Server status monitoring (healthy, warning, critical states)
/// - Progress tracking across multiple stages
/// - Resource utilization indicators
/// - Quality metrics visualization
/// - Timeline status representation
///
/// Example:
/// ```dart
/// Tracker(
///   data: [
///     TrackerData(
///       level: TrackerLevel.fine,
///       tooltip: Text('Database: Healthy\n95% uptime'),
///     ),
///     TrackerData(
///       level: TrackerLevel.warning,
///       tooltip: Text('API: Warning\nHigh response time'),
///     ),
///     TrackerData(
///       level: TrackerLevel.critical,
///       tooltip: Text('Cache: Critical\nMemory usage: 98%'),
///     ),
///   ],
/// );
/// ```
class Tracker extends StatelessWidget {
/// List of data points to display as tracker segments.
///
/// Type: `List<TrackerData>`. Each data point contains a status level
/// for visual styling and tooltip content for user interaction. The
/// segments are displayed in the order provided, each taking equal
/// horizontal space.
  List<TrackerData> data;
/// Creates a [Tracker] widget.
///
/// Displays status data as interactive, color-coded horizontal segments
/// with hover tooltips for additional context.
///
/// Parameters:
/// - [data] (`List<TrackerData>`, required): Status data points to display
///
/// Example:
/// ```dart
/// Tracker(
///   data: [
///     TrackerData(
///       level: TrackerLevel.fine,
///       tooltip: Text('System OK'),
///     ),
///     TrackerData(
///       level: TrackerLevel.warning,
///       tooltip: Text('Minor Issues'),
///     ),
///   ],
/// );
/// ```
  const Tracker({super.key, required this.data});
  Widget build(BuildContext context);
}
/// {@template selectable_text_theme}
/// Theme data for [SelectableText] to customize cursor and selection behavior.
/// {@endtemplate}
class SelectableTextTheme extends ComponentThemeData {
/// Width of the text cursor in logical pixels.
///
/// If `null`, uses the default cursor width from the platform or theme.
  double? cursorWidth;
/// Height of the text cursor in logical pixels.
///
/// If `null`, the cursor height matches the line height of the text.
  double? cursorHeight;
/// Corner radius of the text cursor.
///
/// If `null`, the cursor has square corners (no rounding).
  Radius? cursorRadius;
/// Color of the text cursor.
///
/// If `null`, uses the theme's primary color or platform default.
  Color? cursorColor;
/// How tall the selection highlight boxes should be.
///
/// Determines vertical sizing behavior for text selection highlights.
/// If `null`, uses platform or theme defaults.
  ui.BoxHeightStyle? selectionHeightStyle;
/// How wide the selection highlight boxes should be.
///
/// Determines horizontal sizing behavior for text selection highlights.
/// If `null`, uses platform or theme defaults.
  ui.BoxWidthStyle? selectionWidthStyle;
/// Whether to enable interactive text selection (e.g., selecting with mouse/touch).
///
/// When `true`, users can select text by dragging. When `false`, text
/// selection gestures are disabled. If `null`, uses platform defaults.
  bool? enableInteractiveSelection;
/// {@macro selectable_text_theme}
  const SelectableTextTheme({this.cursorWidth, this.cursorHeight, this.cursorRadius, this.cursorColor, this.selectionHeightStyle, this.selectionWidthStyle, this.enableInteractiveSelection});
/// Creates a copy of this theme with optionally replaced values.
///
/// Uses [ValueGetter] functions to allow nullable value replacement.
/// Properties not provided retain their current values.
///
/// Parameters:
/// - [cursorWidth]: Optional getter for new cursor width
/// - [cursorHeight]: Optional getter for new cursor height
/// - [cursorRadius]: Optional getter for new cursor radius
/// - [cursorColor]: Optional getter for new cursor color
/// - [selectionHeightStyle]: Optional getter for new selection height style
/// - [selectionWidthStyle]: Optional getter for new selection width style
/// - [enableInteractiveSelection]: Optional getter for new interactive selection state
///
/// Returns a new [SelectableTextTheme] with updated values.
  SelectableTextTheme copyWith({ValueGetter<double?>? cursorWidth, ValueGetter<double?>? cursorHeight, ValueGetter<Radius?>? cursorRadius, ValueGetter<Color?>? cursorColor, ValueGetter<ui.BoxHeightStyle?>? selectionHeightStyle, ValueGetter<ui.BoxWidthStyle?>? selectionWidthStyle, ValueGetter<bool?>? enableInteractiveSelection});
  int get hashCode;
  bool operator ==(Object other);
  String toString();
}
/// A text widget that supports text selection by users.
///
/// Displays text (plain or styled) that users can select, copy, and interact with.
/// Provides cursor display, selection highlighting, and context menu support for
/// rich text interaction experiences.
///
/// Features:
/// - **Text Selection**: Click and drag to select text portions
/// - **Copy Support**: Built-in copy functionality via context menu
/// - **Cursor Display**: Optional cursor for indicating selection position
/// - **Rich Text**: Supports styled text via [TextSpan] (use `.rich` constructor)
/// - **Customizable**: Full control over cursor, selection, and interaction behavior
///
/// Usage Patterns:
///
/// **Basic Selectable Text**:
/// ```dart
/// SelectableText(
///   'Select this text!',
///   style: TextStyle(fontSize: 16),
/// )
/// ```
///
/// **Rich Text Selection**:
/// ```dart
/// SelectableText.rich(
///   TextSpan(
///     children: [
///       TextSpan(text: 'Bold ', style: TextStyle(fontWeight: FontWeight.bold)),
///       TextSpan(text: 'and normal text'),
///     ],
///   ),
/// )
/// ```
///
/// **Custom Cursor**:
/// ```dart
/// SelectableText(
///   'Text with custom cursor',
///   showCursor: true,
///   cursorColor: Colors.blue,
///   cursorWidth: 3.0,
/// )
/// ```
///
/// See also:
/// - [Text] for non-selectable text display
/// - [TextField] for editable text input
/// - [SelectableTextTheme] for theming selection appearance
class SelectableText extends StatelessWidget {
/// Creates selectable text from a plain string.
///
/// The [data] parameter is the text to display. All other parameters
/// are optional and control various aspects of text rendering and selection.
///
/// Parameters:
/// - [data]: The text string to display (required)
/// - [focusNode]: Focus node for keyboard interaction
/// - [style]: Text style for the content
/// - [strutStyle]: Strut style for line height
/// - [textAlign]: How to align text horizontally
/// - [textDirection]: Text direction (LTR or RTL)
/// - [textScaler]: Text scaling factor
/// - [showCursor]: Whether to show the cursor (defaults to `false`)
/// - [autofocus]: Auto-focus on mount (defaults to `false`)
/// - [minLines]: Minimum number of lines to occupy
/// - [maxLines]: Maximum number of lines before scrolling
/// - [cursorWidth]: Width of cursor (defaults to 2.0)
/// - [cursorHeight]: Height of cursor (null = line height)
/// - [cursorRadius]: Cursor corner radius
/// - [cursorColor]: Cursor color
/// - [selectionHeightStyle]: Selection box height behavior
/// - [selectionWidthStyle]: Selection box width behavior
/// - [dragStartBehavior]: When to start drag gestures
/// - [enableInteractiveSelection]: Enable selection (defaults to `true`)
/// - [selectionControls]: Custom selection toolbar controls
/// - [onTap]: Callback when text is tapped
/// - [scrollPhysics]: Scroll behavior physics
/// - [semanticsLabel]: Semantic label for accessibility
/// - [textHeightBehavior]: How to handle line heights
/// - [textWidthBasis]: Basis for measuring text width
/// - [onSelectionChanged]: Callback when selection changes
/// - [useNativeContextMenu]: Use platform context menu (defaults to `false`)
/// - [contextMenuBuilder]: Custom context menu builder
/// - [magnifierConfiguration]: Text magnifier configuration
  const SelectableText(String this.data, {super.key, this.focusNode, this.style, this.strutStyle, this.textAlign, this.textDirection, this.textScaler, this.showCursor = false, this.autofocus = false, this.minLines, this.maxLines, this.cursorWidth = 2.0, this.cursorHeight, this.cursorRadius, this.cursorColor, this.selectionHeightStyle = ui.BoxHeightStyle.tight, this.selectionWidthStyle = ui.BoxWidthStyle.tight, this.dragStartBehavior = DragStartBehavior.start, this.enableInteractiveSelection = true, this.selectionControls, this.onTap, this.scrollPhysics, this.semanticsLabel, this.textHeightBehavior, this.textWidthBasis, this.onSelectionChanged, this.useNativeContextMenu = false, this.contextMenuBuilder = _defaultContextMenuBuilder, this.magnifierConfiguration});
/// Creates selectable text from a [TextSpan] for styled/rich text.
///
/// Use this constructor when you need to display text with multiple styles,
/// inline widgets, or complex formatting. The [textSpan] can contain nested
/// spans with different styles, colors, and even tap handlers.
///
/// Parameters are identical to the default constructor, except:
/// - [textSpan]: The styled text span tree to display (required)
/// - [data] is not available (use [textSpan] instead)
///
/// Example:
/// ```dart
/// SelectableText.rich(
///   TextSpan(
///     text: 'Visit our ',
///     children: [
///       TextSpan(
///         text: 'website',
///         style: TextStyle(color: Colors.blue, decoration: TextDecoration.underline),
///       ),
///       TextSpan(text: ' for more info'),
///     ],
///   ),
/// )
/// ```
  const SelectableText.rich(TextSpan this.textSpan, {super.key, this.focusNode, this.style, this.strutStyle, this.textAlign, this.textDirection, this.textScaler, this.showCursor = false, this.autofocus = false, this.minLines, this.maxLines, this.cursorWidth = 2.0, this.cursorHeight, this.cursorRadius, this.cursorColor, this.selectionHeightStyle = ui.BoxHeightStyle.tight, this.selectionWidthStyle = ui.BoxWidthStyle.tight, this.dragStartBehavior = DragStartBehavior.start, this.enableInteractiveSelection = true, this.selectionControls, this.onTap, this.scrollPhysics, this.semanticsLabel, this.textHeightBehavior, this.textWidthBasis, this.onSelectionChanged, this.useNativeContextMenu = false, this.contextMenuBuilder = _defaultContextMenuBuilder, this.magnifierConfiguration});
/// The plain text string to display.
///
/// Either [data] or [textSpan] must be non-null, but not both.
/// Used when constructing with the default constructor.
  String? data;
/// The styled text span to display.
///
/// Either [data] or [textSpan] must be non-null, but not both.
/// Used when constructing with the [SelectableText.rich] constructor.
  TextSpan? textSpan;
/// Focus node for managing keyboard focus.
///
/// If `null`, a focus node is created internally.
  FocusNode? focusNode;
/// Whether to use the platform's native context menu.
///
/// When `true`, uses the operating system's built-in context menu.
/// When `false`, uses Flutter's custom context menu.
  bool useNativeContextMenu;
/// The text style to apply to the text.
///
/// If `null`, uses the default text style from the theme.
  TextStyle? style;
/// {@macro flutter.widgets.editableText.strutStyle}
  StrutStyle? strutStyle;
/// {@macro flutter.widgets.editableText.textAlign}
  TextAlign? textAlign;
/// {@macro flutter.widgets.editableText.textDirection}
  TextDirection? textDirection;
/// {@macro flutter.painting.textPainter.textScaler}
  TextScaler? textScaler;
/// {@macro flutter.widgets.editableText.autofocus}
  bool autofocus;
/// {@macro flutter.widgets.editableText.minLines}
  int? minLines;
/// {@macro flutter.widgets.editableText.maxLines}
  int? maxLines;
/// {@macro flutter.widgets.editableText.showCursor}
  bool showCursor;
/// {@macro flutter.widgets.editableText.cursorWidth}
  double cursorWidth;
/// {@macro flutter.widgets.editableText.cursorHeight}
  double? cursorHeight;
/// {@macro flutter.widgets.editableText.cursorRadius}
  Radius? cursorRadius;
/// Color of the text cursor.
///
/// If null, defaults to the theme's cursor color.
  Color? cursorColor;
/// Defines the height of text selection boxes.
///
/// See [ui.BoxHeightStyle] for available options.
  ui.BoxHeightStyle selectionHeightStyle;
/// Defines the width of text selection boxes.
///
/// See [ui.BoxWidthStyle] for available options.
  ui.BoxWidthStyle selectionWidthStyle;
/// {@macro flutter.widgets.editableText.enableInteractiveSelection}
  bool enableInteractiveSelection;
/// {@macro flutter.widgets.editableText.selectionControls}
  TextSelectionControls? selectionControls;
/// {@macro flutter.widgets.scrollable.dragStartBehavior}
  DragStartBehavior dragStartBehavior;
/// {@macro flutter.widgets.editableText.selectionEnabled}
  bool get selectionEnabled;
/// Called when the user taps on this selectable text.
///
/// The selectable text builds a [GestureDetector] to handle input events like tap,
/// to trigger focus requests, to move the caret, adjust the selection, etc.
/// Handling some of those events by wrapping the selectable text with a competing
/// GestureDetector is problematic.
///
/// To unconditionally handle taps, without interfering with the selectable text's
/// internal gesture detector, provide this callback.
///
/// To be notified when the text field gains or loses the focus, provide a
/// [focusNode] and add a listener to that.
///
/// To listen to arbitrary pointer events without competing with the
/// selectable text's internal gesture detector, use a [Listener].
  GestureTapCallback? onTap;
/// {@macro flutter.widgets.editableText.scrollPhysics}
  ScrollPhysics? scrollPhysics;
/// {@macro flutter.widgets.Text.semanticsLabel}
  String? semanticsLabel;
/// {@macro dart.ui.textHeightBehavior}
  TextHeightBehavior? textHeightBehavior;
/// {@macro flutter.painting.textPainter.textWidthBasis}
  TextWidthBasis? textWidthBasis;
/// {@macro flutter.widgets.editableText.onSelectionChanged}
  SelectionChangedCallback? onSelectionChanged;
/// {@macro flutter.widgets.EditableText.contextMenuBuilder}
  EditableTextContextMenuBuilder? contextMenuBuilder;
/// The configuration for the magnifier used when the text is selected.
///
/// By default, builds a [CupertinoTextMagnifier] on iOS and [TextMagnifier]
/// on Android, and builds nothing on all other platforms. To suppress the
/// magnifier, consider passing [TextMagnifierConfiguration.disabled].
///
/// {@macro flutter.widgets.magnifier.intro}
  TextMagnifierConfiguration? magnifierConfiguration;
  Widget build(BuildContext context);
}
/// Abstract base class for text modifier widgets.
///
/// Text modifiers provide a fluent API for applying text styles and
/// transformations. They extend [Widget] and can be called as functions
/// to apply additional style properties.
///
/// Use the [TextExtension] methods to create and chain text modifiers.
abstract class TextModifier extends Widget {
/// Creates a [TextModifier].
  const TextModifier({super.key});
/// Applies additional text style properties to this modifier.
///
/// All parameters are optional and can be used to override or extend
/// the current text styling.
///
/// Parameters:
/// - [color] (`Color?`, optional): Text color.
/// - [backgroundColor] (`Color?`, optional): Background color for text.
/// - [fontSize] (`double?`, optional): Font size in logical pixels.
/// - [fontWeight] (`FontWeight?`, optional): Font weight (e.g., bold, normal).
/// - [fontStyle] (`FontStyle?`, optional): Font style (e.g., italic, normal).
/// - [letterSpacing] (`double?`, optional): Space between letters.
/// - [wordSpacing] (`double?`, optional): Space between words.
/// - [textBaseline] (`TextBaseline?`, optional): Text baseline alignment.
/// - [height] (`double?`, optional): Line height multiplier.
/// - [leadingDistribution] (`TextLeadingDistribution?`, optional): How to distribute line height.
/// - [locale] (`Locale?`, optional): Locale for font selection.
/// - [foreground] (`Paint?`, optional): Custom foreground paint.
/// - [background] (`Paint?`, optional): Custom background paint.
/// - [shadows] (`List<Shadow>?`, optional): Text shadows.
/// - [fontFeatures] (`List<FontFeature>?`, optional): OpenType font features.
/// - [fontVariations] (`List<FontVariation>?`, optional): Font variations.
/// - [decoration] (`TextDecoration?`, optional): Text decoration (underline, etc.).
/// - [decorationColor] (`Color?`, optional): Decoration color.
/// - [decorationStyle] (`TextDecorationStyle?`, optional): Decoration style.
/// - [decorationThickness] (`double?`, optional): Decoration thickness.
/// - [debugLabel] (`String?`, optional): Debug label for text style.
/// - [fontFamily] (`String?`, optional): Font family name.
/// - [fontFamilyFallback] (`List<String>?`, optional): Fallback font families.
/// - [package] (`String?`, optional): Package containing the font.
/// - [overflow] (`TextOverflow?`, optional): How to handle text overflow.
///
/// Returns: `Widget` ‚Äî the modified text widget.
  Widget call({Color? color, Color? backgroundColor, double? fontSize, FontWeight? fontWeight, FontStyle? fontStyle, double? letterSpacing, double? wordSpacing, TextBaseline? textBaseline, double? height, TextLeadingDistribution? leadingDistribution, Locale? locale, Paint? foreground, Paint? background, List<Shadow>? shadows, List<FontFeature>? fontFeatures, List<FontVariation>? fontVariations, TextDecoration? decoration, Color? decorationColor, TextDecorationStyle? decorationStyle, double? decorationThickness, String? debugLabel, String? fontFamily, List<String>? fontFamilyFallback, String? package, TextOverflow? overflow});
}
/// Extension providing text styling modifiers for widgets.
///
/// This extension adds a fluent API for applying text styles to widgets.
/// Each property returns a [TextModifier] that can be further chained.
///
/// Example:
/// ```dart
/// Text('Hello').sans.large.bold.muted
/// ```
extension TextExtension on Widget {
/// Applies sans-serif font family.
  TextModifier get sans;
/// Applies monospace font family.
  TextModifier get mono;
/// Applies extra-small font size.
  TextModifier get xSmall;
/// Applies small font size.
  TextModifier get small;
/// Applies base (default) font size.
  TextModifier get base;
/// Applies large font size.
  TextModifier get large;
/// Applies extra-large font size.
  TextModifier get xLarge;
/// Applies 2x large font size.
  TextModifier get x2Large;
/// Applies 3x large font size.
  TextModifier get x3Large;
/// Applies 4x large font size.
  TextModifier get x4Large;
/// Applies 5x large font size.
  TextModifier get x5Large;
/// Applies 6x large font size.
  TextModifier get x6Large;
/// Applies 7x large font size.
  TextModifier get x7Large;
/// Applies 8x large font size.
  TextModifier get x8Large;
/// Applies 9x large font size.
  TextModifier get x9Large;
/// Applies thin font weight (100).
  TextModifier get thin;
/// Applies extra-light font weight (200).
  TextModifier get extraLight;
/// Applies light font weight (300).
  TextModifier get light;
/// Applies normal font weight (400).
  TextModifier get normal;
/// Applies medium font weight (500).
  TextModifier get medium;
/// Applies semi-bold font weight (600).
  TextModifier get semiBold;
/// Applies bold font weight (700).
  TextModifier get bold;
/// Applies extra-bold font weight (800).
  TextModifier get extraBold;
/// Applies black font weight (900).
  TextModifier get black;
/// Applies italic font style.
  TextModifier get italic;
/// Applies underline text decoration.
  TextModifier get underline;
/// Applies muted foreground color.
  TextModifier get muted;
/// Applies primary foreground color.
  TextModifier get primaryForeground;
/// Applies secondary foreground color.
  TextModifier get secondaryForeground;
/// Applies heading 1 style.
  TextModifier get h1;
/// Applies heading 2 style with bottom border.
  TextModifier get h2;
/// Applies heading 3 style.
  TextModifier get h3;
/// Applies heading 4 style.
  TextModifier get h4;
/// Applies paragraph style with top spacing.
  TextModifier get p;
/// Applies paragraph style for the first paragraph (no top spacing).
  TextModifier get firstP;
/// Applies block quote style with left border.
  TextModifier get blockQuote;
/// Applies list item style with bullet point.
///
/// Automatically adds a bullet point and indents nested list items.
  TextModifier get li;
/// Applies inline code style with background and padding.
  TextModifier get inlineCode;
/// Applies lead paragraph style with muted color.
  TextModifier get lead;
/// Applies large text style.
  TextModifier get textLarge;
/// Applies small text style.
  TextModifier get textSmall;
/// Applies muted text style with muted color.
  TextModifier get textMuted;
/// Constrains text to a single line without wrapping.
  TextModifier get singleLine;
/// Applies ellipsis overflow to text.
  TextModifier get ellipsis;
/// Centers text horizontally.
  TextModifier get textCenter;
/// Right-aligns text.
  TextModifier get textRight;
/// Left-aligns text.
  TextModifier get textLeft;
/// Justifies text alignment.
  TextModifier get textJustify;
/// Aligns text to the start (left in LTR, right in RTL).
  TextModifier get textStart;
/// Aligns text to the end (right in LTR, left in RTL).
  TextModifier get textEnd;
/// Applies primary foreground color modifier.
  TextModifier get modify;
/// Applies standard foreground color.
  TextModifier get foreground;
/// Appends an inline span to the current text widget.
///
/// Allows chaining multiple text spans together. Works with [Text],
/// [SelectableText], and [RichText] widgets.
///
/// Parameters:
/// - [span] (`InlineSpan`, required): The span to append.
///
/// Returns: `Widget` ‚Äî a rich text widget with the appended span.
///
/// Example:
/// ```dart
/// Text('Hello ').then(TextSpan(text: 'World'))
/// ```
  Widget then(InlineSpan span);
/// Appends a text span to the current text widget.
///
/// Convenience method for appending plain text.
///
/// Parameters:
/// - [text] (`String`, required): Text to append.
///
/// Returns: `Widget` ‚Äî a rich text widget with the appended text.
///
/// Example:
/// ```dart
/// Text('Hello ').thenText('World')
/// ```
  Widget thenText(String text);
/// Appends inline code to the current text widget.
///
/// The appended text is styled as inline code with background.
///
/// Parameters:
/// - [text] (`String`, required): Code text to append.
///
/// Returns: `Widget` ‚Äî a rich text widget with the appended code.
///
/// Example:
/// ```dart
/// Text('Use ').thenInlineCode('myFunction()')
/// ```
  Widget thenInlineCode(String text);
/// Appends a button widget to the current text widget.
///
/// Creates an inline button within the text flow.
///
/// Parameters:
/// - [onPressed] (`VoidCallback`, required): Button press handler.
/// - [child] (`Widget`, required): Button content.
///
/// Returns: `Widget` ‚Äî a rich text widget with the appended button.
///
/// Example:
/// ```dart
/// Text('Click ').thenButton(
///   onPressed: () => print('clicked'),
///   child: Text('here'),
/// )
/// ```
  Widget thenButton({required VoidCallback onPressed, required Widget child});
}
/// Creates a bullet widget for list items based on depth.
///
/// Returns different bullet styles for different nesting levels:
/// - Depth 0: Filled circle
/// - Depth 1: Hollow circle (stroke only)
/// - Depth 2+: Filled square
///
/// Parameters:
/// - [context] (`BuildContext`, required): Build context for theme access.
/// - [depth] (`int`, required): Nesting depth (0 = top level).
/// - [size] (`double`, required): Size of the bullet in logical pixels.
///
/// Returns: `Widget` ‚Äî a centered bullet widget.
///
/// Example:
/// ```dart
/// getBullet(context, 0, 6.0) // Filled circle bullet
/// ```
Widget getBullet(BuildContext context, int depth, double size);
/// Data class for tracking unordered list nesting depth.
///
/// Used internally by the list item modifier to handle bullet points
/// and indentation for nested lists.
class UnorderedListData {
/// The nesting depth of the list (0 = top level).
  int depth;
/// Creates an [UnorderedListData].
///
/// Parameters:
/// - [depth] (`int`, default: 0): Nesting depth.
  const UnorderedListData({this.depth = 0});
}
/// A widget that wraps text with customizable styling and layout.
///
/// [WrappedText] provides a declarative way to apply text styles and
/// transformations using builder functions. It implements [TextModifier]
/// and is the foundation for the fluent text styling API.
///
/// All style properties are computed dynamically using builder functions
/// that receive the current [BuildContext] and [ThemeData], enabling
/// theme-aware and responsive text styling.
class WrappedText extends StatelessWidget implements TextModifier {
/// The child widget to wrap with styling.
  Widget child;
/// Builder for the text style.
  WrappedTextDataBuilder<TextStyle?>? style;
/// Builder for text alignment.
  WrappedTextDataBuilder<TextAlign?>? textAlign;
/// Builder for soft wrap behavior.
  WrappedTextDataBuilder<bool?>? softWrap;
/// Builder for text overflow handling.
  WrappedTextDataBuilder<TextOverflow?>? overflow;
/// Builder for maximum number of lines.
  WrappedTextDataBuilder<int?>? maxLines;
/// Builder for text width basis.
  WrappedTextDataBuilder<TextWidthBasis?>? textWidthBasis;
/// Optional wrapper function to add container widgets around the child.
  WidgetTextWrapper? wrapper;
/// Creates a [WrappedText].
///
/// All styling parameters are optional and use builder functions for
/// dynamic, theme-aware styling.
///
/// Parameters:
/// - [child] (`Widget`, required): Widget to apply styling to.
/// - [style] (`WrappedTextDataBuilder<TextStyle?>?`, optional): Text style builder.
/// - [textAlign] (`WrappedTextDataBuilder<TextAlign?>?`, optional): Text alignment builder.
/// - [softWrap] (`WrappedTextDataBuilder<bool?>?`, optional): Soft wrap builder.
/// - [overflow] (`WrappedTextDataBuilder<TextOverflow?>?`, optional): Overflow handling builder.
/// - [maxLines] (`WrappedTextDataBuilder<int?>?`, optional): Max lines builder.
/// - [textWidthBasis] (`WrappedTextDataBuilder<TextWidthBasis?>?`, optional): Text width basis builder.
/// - [wrapper] (`WidgetTextWrapper?`, optional): Container wrapper function.
  const WrappedText({super.key, required this.child, this.style, this.textAlign, this.softWrap, this.overflow, this.maxLines, this.textWidthBasis, this.wrapper});
  Widget call({Color? color, Color? backgroundColor, double? fontSize, FontWeight? fontWeight, FontStyle? fontStyle, double? letterSpacing, double? wordSpacing, TextBaseline? textBaseline, double? height, TextLeadingDistribution? leadingDistribution, Locale? locale, Paint? foreground, Paint? background, List<Shadow>? shadows, List<FontFeature>? fontFeatures, List<FontVariation>? fontVariations, TextDecoration? decoration, Color? decorationColor, TextDecorationStyle? decorationStyle, double? decorationThickness, String? debugLabel, String? fontFamily, List<String>? fontFamilyFallback, String? package, TextOverflow? overflow});
  Widget build(BuildContext context);
/// Creates a copy of this [WrappedText] with modified properties.
///
/// Each parameter is a builder function that, if provided, will
/// replace the corresponding property in the new instance.
/// If a parameter is `null`, the existing property value is retained.
///
/// Parameters:
/// - [style] (`ValueGetter<WrappedTextDataBuilder<TextStyle>?>?`, optional): New style builder.
/// - [textAlign] (`ValueGetter<WrappedTextDataBuilder<TextAlign>?>?`, optional): New text alignment builder.
/// - [softWrap] (`ValueGetter<WrappedTextDataBuilder<bool>?>?`, optional): New soft wrap builder.
/// - [overflow] (`ValueGetter<WrappedTextDataBuilder<TextOverflow>?>?`, optional): New overflow handling builder.
/// - [maxLines] (`ValueGetter<WrappedTextDataBuilder<int>?>?`, optional): New max lines builder.
/// - [textWidthBasis] (`ValueGetter<WrappedTextDataBuilder<TextWidthBasis>?>?`, optional): New text width basis builder.
/// - [wrapper] (`ValueGetter<WidgetTextWrapper?>?`, optional): New container wrapper function.
/// - [child] (`ValueGetter<Widget>?`, optional): New child widget.
  WrappedText copyWith({ValueGetter<WrappedTextDataBuilder<TextStyle>?>? style, ValueGetter<WrappedTextDataBuilder<TextAlign>?>? textAlign, ValueGetter<WrappedTextDataBuilder<bool>?>? softWrap, ValueGetter<WrappedTextDataBuilder<TextOverflow>?>? overflow, ValueGetter<WrappedTextDataBuilder<int>?>? maxLines, ValueGetter<WrappedTextDataBuilder<TextWidthBasis>?>? textWidthBasis, ValueGetter<WidgetTextWrapper?>? wrapper, ValueGetter<Widget>? child});
/// Creates a copy of this [WrappedText] with an updated style.
///
/// The provided [style] builder is merged with the existing style.
///
/// Parameters:
/// - [style] (`WrappedTextDataBuilder<TextStyle>`, required): New style builder to merge.
  WrappedText copyWithStyle(WrappedTextDataBuilder<TextStyle> style);
}
/// Extension on [Widget] providing convenient icon theme utilities.
///
/// Provides methods to wrap icons with predefined size and color themes,
/// making it easy to apply consistent styling to icon widgets throughout
/// an application.
extension IconExtension on Widget {
/// Wraps the icon with extra-extra-extra-extra small size theme.
  WrappedIcon get iconX4Small;
/// Wraps the icon with extra-extra-extra small size theme.
  WrappedIcon get iconX3Small;
/// Wraps the icon with extra-extra small size theme.
  WrappedIcon get iconX2Small;
/// Wraps the icon with extra small size theme.
  WrappedIcon get iconXSmall;
/// Wraps the icon with small size theme.
  WrappedIcon get iconSmall;
/// Wraps the icon with medium size theme.
  WrappedIcon get iconMedium;
/// Wraps the icon with large size theme.
  WrappedIcon get iconLarge;
/// Wraps the icon with extra large size theme.
  WrappedIcon get iconXLarge;
/// Wraps the icon with extra-extra large size theme.
  WrappedIcon get iconX2Large;
/// Wraps the icon with extra-extra-extra large size theme.
  WrappedIcon get iconX3Large;
/// Wraps the icon with extra-extra-extra-extra large size theme.
  WrappedIcon get iconX4Large;
/// Wraps the icon with muted foreground color.
///
/// Applies a subdued color suitable for secondary or less prominent icons.
  WrappedIcon get iconMutedForeground;
/// Wraps the icon with destructive foreground color.
///
/// Deprecated: Use alternative color scheme methods instead.
  WrappedIcon get iconDestructiveForeground;
/// Wraps the icon with primary foreground color.
///
/// Typically used for icons on primary-colored backgrounds.
  WrappedIcon get iconPrimaryForeground;
/// Wraps the icon with primary color.
///
/// Applies the theme's primary accent color to the icon.
  WrappedIcon get iconPrimary;
/// Wraps the icon with secondary color.
///
/// Applies the theme's secondary accent color to the icon.
  WrappedIcon get iconSecondary;
/// Wraps the icon with secondary foreground color.
///
/// Typically used for icons on secondary-colored backgrounds.
  WrappedIcon get iconSecondaryForeground;
}
/// A widget that wraps an icon with custom theme data.
///
/// Applies icon theme styling to a child icon widget using a builder
/// function that can access the current context and theme. Useful for
/// applying dynamic icon styles based on theme values.
///
/// Example:
/// ```dart
/// WrappedIcon(
///   data: (context, theme) => IconThemeData(
///     size: 24,
///     color: theme.colorScheme.primary,
///   ),
///   child: Icon(Icons.star),
/// )
/// ```
class WrappedIcon extends StatelessWidget {
/// Builder function that creates the icon theme data.
  WrappedIconDataBuilder<IconThemeData> data;
/// The child icon widget to apply the theme to.
  Widget child;
/// Creates a [WrappedIcon].
///
/// Parameters:
/// - [data] (`WrappedIconDataBuilder<IconThemeData>`, required): Theme builder.
/// - [child] (`Widget`, required): Icon widget to wrap.
  const WrappedIcon({super.key, required this.data, required this.child});
/// Returns this widget (callable syntax support).
///
/// Allows using the wrapped icon as a callable function.
  Widget call();
  Widget build(BuildContext context);
/// Creates a copy of this wrapped icon with modified icon theme data.
///
/// Parameters:
/// - [data] (`WrappedIconDataBuilder<IconThemeData>?`, optional): New icon theme data builder.
///
/// Returns: A new [WrappedIcon] with merged theme data.
  WrappedIcon copyWith({WrappedIconDataBuilder<IconThemeData>? data});
}
/// A widget that displays multiple dots, commonly used for loading indicators or menus.
///
/// Creates a customizable row or column of circular dots that can be used as a
/// "more" indicator, loading animation, or menu icon. The number, size, color,
/// and spacing of dots can be configured.
///
/// Example:
/// ```dart
/// // Horizontal three-dot menu icon
/// MoreDots(
///   count: 3,
///   direction: Axis.horizontal,
///   spacing: 4,
/// )
///
/// // Vertical loading indicator
/// MoreDots(
///   count: 5,
///   direction: Axis.vertical,
///   color: Colors.blue,
/// )
/// ```
class MoreDots extends StatelessWidget {
/// The layout direction of the dots.
///
/// Can be [Axis.horizontal] for a row or [Axis.vertical] for a column.
/// Defaults to horizontal.
  Axis direction;
/// The number of dots to display.
///
/// Defaults to `3`.
  int count;
/// The size (diameter) of each dot.
///
/// If `null`, calculates size based on the text style font size (20% of font size).
  double? size;
/// The color of the dots.
///
/// If `null`, uses the current text color from the theme.
  Color? color;
/// The spacing between dots.
///
/// Defaults to `2`.
  double spacing;
/// Padding around the entire dots group.
///
/// If `null`, no padding is applied.
  EdgeInsetsGeometry? padding;
/// Creates a [MoreDots].
///
/// Parameters:
/// - [direction] (`Axis`, default: `Axis.horizontal`): Layout direction.
/// - [count] (`int`, default: `3`): Number of dots.
/// - [size] (`double?`, optional): Dot diameter.
/// - [color] (`Color?`, optional): Dot color.
/// - [spacing] (`double`, default: `2`): Space between dots.
/// - [padding] (`EdgeInsetsGeometry?`, optional): Outer padding.
  const MoreDots({super.key, this.direction = Axis.horizontal, this.count = 3, this.size, this.color, this.spacing = 2, this.padding});
  Widget build(BuildContext context);
}
/// Theme configuration for [FadeScroll].
class FadeScrollTheme extends ComponentThemeData {
/// The distance from the start before fading begins.
  double? startOffset;
/// The distance from the end before fading begins.
  double? endOffset;
/// The gradient colors used for the fade.
  List<Color>? gradient;
/// Creates a [FadeScrollTheme].
  const FadeScrollTheme({this.startOffset, this.endOffset, this.gradient});
/// Creates a copy of this theme but with the given fields replaced.
  FadeScrollTheme copyWith({ValueGetter<double?>? startOffset, ValueGetter<double?>? endOffset, ValueGetter<List<Color>?>? gradient});
  bool operator ==(Object other);
  int get hashCode;
}
/// A widget that applies fade effects at the edges of scrollable content.
///
/// Adds gradient fade overlays to the start and end of scrollable content,
/// creating a visual cue that there's more content to scroll.
class FadeScroll extends StatelessWidget {
/// The offset from the start where the fade begins.
  double? startOffset;
/// The offset from the end where the fade begins.
  double? endOffset;
/// The cross-axis offset for the start fade.
  double startCrossOffset;
/// The cross-axis offset for the end fade.
  double endCrossOffset;
/// The scrollable child widget.
  Widget child;
/// The scroll controller to monitor for scroll position.
  ScrollController controller;
/// The gradient colors for the fade effect.
  List<Color>? gradient;
/// Creates a fade scroll widget.
  const FadeScroll({super.key, this.startOffset, this.endOffset, required this.child, required this.controller, this.gradient, this.startCrossOffset = 0, this.endCrossOffset = 0});
  Widget build(BuildContext context);
}
/// Size constraint for the carousel.
abstract class CarouselSizeConstraint {
/// Creates a carousel size constraint.
  const CarouselSizeConstraint();
/// Creates a fixed carousel size constraint.
  factory CarouselSizeConstraint.fixed(double size);
/// Creates a fractional carousel size constraint.
  factory CarouselSizeConstraint.fractional(double fraction);
}
/// A fixed carousel size constraint.
class CarouselFixedConstraint extends CarouselSizeConstraint {
/// The size of the constraint.
  double size;
/// Creates a fixed carousel size constraint.
  const CarouselFixedConstraint(this.size);
}
/// A fractional carousel size constraint.
class CarouselFractionalConstraint extends CarouselSizeConstraint {
/// The fraction of the constraint.
  double fraction;
/// Creates a fractional carousel size constraint.
  const CarouselFractionalConstraint(this.fraction);
}
/// A carousel layout.
abstract class CarouselTransition {
/// Creates a carousel layout.
  const CarouselTransition();
/// Creates a sliding carousel layout.
  factory CarouselTransition.sliding({double gap});
/// Creates a fading carousel layout.
  factory CarouselTransition.fading();
/// Layouts the carousel items.
/// * [context] is the build context.
/// * [progress] is the progress of the carousel.
/// * [constraints] is the constraints of the carousel.
/// * [alignment] is the alignment of the carousel.
/// * [direction] is the direction of the carousel.
/// * [sizeConstraint] is the size constraint of the carousel.
/// * [progressedIndex] is the progressed index of the carousel.
/// * [itemCount] is the item count of the carousel.
/// * [itemBuilder] is the item builder of the carousel.
/// * [wrap] is whether the carousel should wrap.
/// * [reverse] is whether the carousel should reverse.
  List<Widget> layout(BuildContext context, {required double progress, required BoxConstraints constraints, required CarouselAlignment alignment, required Axis direction, required CarouselSizeConstraint sizeConstraint, required double progressedIndex, required int? itemCount, required CarouselItemBuilder itemBuilder, required bool wrap, required bool reverse});
}
/// A sliding carousel transition.
class SlidingCarouselTransition extends CarouselTransition {
/// The gap between the carousel items.
  double gap;
/// Creates a sliding carousel transition.
  const SlidingCarouselTransition({this.gap = 0});
  List<Widget> layout(BuildContext context, {required double progress, required BoxConstraints constraints, required CarouselAlignment alignment, required Axis direction, required CarouselSizeConstraint sizeConstraint, required double progressedIndex, required int? itemCount, required CarouselItemBuilder itemBuilder, required bool wrap, required bool reverse});
}
/// A fading carousel transition.
class FadingCarouselTransition extends CarouselTransition {
/// Creates a fading carousel transition.
  const FadingCarouselTransition();
  List<Widget> layout(BuildContext context, {required double progress, required BoxConstraints constraints, required CarouselAlignment alignment, required Axis direction, required CarouselSizeConstraint sizeConstraint, required double progressedIndex, required int? itemCount, required CarouselItemBuilder itemBuilder, required bool wrap, required bool reverse});
}
/// A controller for the carousel.
class CarouselController extends Listenable {
/// Whether the carousel should animate.
  bool get shouldAnimate;
/// The current value of the controller.
  double get value;
/// Jumps to the next item.
  void next();
/// Jumps to the previous item.
  void previous();
/// Animates to the next item.
  void animateNext(Duration duration, [Curve curve = Curves.easeInOut]);
/// Animates to the previous item.
  void animatePrevious(Duration duration, [Curve curve = Curves.easeInOut]);
/// Snaps the current value to the nearest integer.
  void snap();
/// Animates the current value to the nearest integer.
  void animateSnap(Duration duration, [Curve curve = Curves.easeInOut]);
/// Jumps to the specified value.
  void jumpTo(double value);
/// Animates to the specified value.
  void animateTo(double value, Duration duration, [Curve curve = Curves.linear]);
/// Animates to the specified value.
  double getCurrentIndex(int? itemCount);
/// Animates to the specified value.
  void tick(Duration delta);
  void addListener(VoidCallback listener);
  void removeListener(VoidCallback listener);
/// Disposes the controller.
  void dispose();
}
/// CarouselAlignment is used to align the carousel items.
enum CarouselAlignment { start, center, end }
/// Theme data for [Carousel].
class CarouselTheme extends ComponentThemeData {
/// The alignment of carousel items.
  CarouselAlignment? alignment;
/// The scroll direction (horizontal or vertical).
  Axis? direction;
/// Whether to wrap around to the beginning after reaching the end.
  bool? wrap;
/// Whether to pause autoplay on hover.
  bool? pauseOnHover;
/// The duration between automatic slides.
  Duration? autoplaySpeed;
/// Whether the carousel can be dragged.
  bool? draggable;
/// The transition animation speed.
  Duration? speed;
/// The transition animation curve.
  Curve? curve;
/// Creates a carousel theme.
  const CarouselTheme({this.alignment, this.direction, this.wrap, this.pauseOnHover, this.autoplaySpeed, this.draggable, this.speed, this.curve});
/// Creates a copy of this theme with the given fields replaced.
  CarouselTheme copyWith({ValueGetter<CarouselAlignment?>? alignment, ValueGetter<Axis?>? direction, ValueGetter<bool?>? wrap, ValueGetter<bool?>? pauseOnHover, ValueGetter<Duration?>? autoplaySpeed, ValueGetter<bool?>? draggable, ValueGetter<Duration?>? speed, ValueGetter<Curve?>? curve});
  bool operator ==(Object other);
  int get hashCode;
}
/// Interactive carousel widget with automatic transitions and customizable layouts.
///
/// A high-level carousel widget that displays a sequence of items with smooth
/// transitions between them. Supports automatic progression, manual navigation,
/// multiple transition types, and extensive customization options.
///
/// ## Features
///
/// - **Multiple transition types**: Sliding and fading transitions with customizable timing
/// - **Automatic progression**: Optional auto-play with configurable duration per item
/// - **Manual navigation**: Programmatic control through [CarouselController]
/// - **Flexible sizing**: Fixed or fractional size constraints for responsive layouts
/// - **Interactive controls**: Pause on hover, wrap-around navigation, and touch gestures
/// - **Flexible alignment**: Multiple alignment options for different layout needs
/// - **Directional support**: Horizontal or vertical carousel orientation
///
/// ## Usage Patterns
///
/// **Basic automatic carousel:**
/// ```dart
/// Carousel(
///   itemCount: images.length,
///   duration: Duration(seconds: 3),
///   itemBuilder: (context, index) => Image.asset(images[index]),
///   transition: CarouselTransition.sliding(gap: 16),
/// )
/// ```
///
/// **Controlled carousel with custom navigation:**
/// ```dart
/// final controller = CarouselController();
///
/// Carousel(
///   controller: controller,
///   itemCount: products.length,
///   itemBuilder: (context, index) => ProductCard(products[index]),
///   transition: CarouselTransition.fading(),
///   pauseOnHover: true,
/// )
/// ```
class Carousel extends StatefulWidget {
/// The carousel transition.
  CarouselTransition transition;
/// The item builder.
  Widget Function(BuildContext context, int index) itemBuilder;
/// The duration of the carousel.
  Duration? duration;
/// The duration builder of the carousel.
  Duration? Function(int index)? durationBuilder;
/// The item count of the carousel.
  int? itemCount;
/// The carousel controller.
  CarouselController? controller;
/// The carousel alignment.
  CarouselAlignment alignment;
/// The carousel direction.
  Axis direction;
/// Whether the carousel should wrap.
  bool wrap;
/// Whether the carousel should pause on hover.
  bool pauseOnHover;
/// Whether the carousel should wait the item duration on start.
  bool waitOnStart;
/// The autoplay speed of the carousel.
  Duration? autoplaySpeed;
/// Whether the carousel should autoplay in reverse.
  bool autoplayReverse;
/// Whether the carousel is draggable.
  bool draggable;
/// Whether the carousel is reverse in layout direction.
  bool reverse;
/// The size constraint of the carousel.
  CarouselSizeConstraint sizeConstraint;
/// The speed of the carousel.
  Duration speed;
/// The curve of the carousel.
  Curve curve;
/// The index change callback.
  ValueChanged<int>? onIndexChanged;
/// Whether to disable overhead scrolling.
  bool disableOverheadScrolling;
/// Whether to disable dragging velocity.
  bool disableDraggingVelocity;
/// Creates a carousel.
  const Carousel({super.key, required this.itemBuilder, this.itemCount, this.controller, this.alignment = CarouselAlignment.center, this.direction = Axis.horizontal, this.wrap = true, this.pauseOnHover = true, this.autoplaySpeed, this.waitOnStart = false, this.draggable = true, this.reverse = false, this.autoplayReverse = false, this.sizeConstraint = const CarouselFractionalConstraint(1), this.speed = const Duration(milliseconds: 200), this.curve = Curves.easeInOut, this.duration, this.durationBuilder, this.onIndexChanged, this.disableOverheadScrolling = true, this.disableDraggingVelocity = false, required this.transition});
  State<Carousel> createState();
}
/// A dot indicator for the carousel.
class CarouselDotIndicator extends StatelessWidget {
/// The item count of the carousel.
  int itemCount;
/// The carousel controller.
  CarouselController controller;
/// The speed of the value change.
  Duration speed;
/// The curve of the value change.
  Curve curve;
/// Creates a dot indicator for the carousel.
  const CarouselDotIndicator({super.key, required this.itemCount, required this.controller, this.speed = const Duration(milliseconds: 200), this.curve = Curves.easeInOut});
  Widget build(BuildContext context);
}
/// Theme for keyboard shortcut displays.
class KeyboardShortcutTheme extends ComponentThemeData {
/// Spacing between keys.
  double? spacing;
/// Padding inside each key display.
  EdgeInsetsGeometry? keyPadding;
/// Shadow applied to key displays.
  List<BoxShadow>? keyShadow;
/// Creates a [KeyboardShortcutTheme].
  const KeyboardShortcutTheme({this.spacing, this.keyPadding, this.keyShadow});
/// Creates a copy with the given values replaced.
  KeyboardShortcutTheme copyWith({ValueGetter<double?>? spacing, ValueGetter<EdgeInsetsGeometry?>? keyPadding, ValueGetter<List<BoxShadow>?>? keyShadow});
  bool operator ==(Object other);
  int get hashCode;
}
/// Handle for accessing keyboard shortcut display builders.
///
/// Wraps a keyboard shortcut display builder function to provide
/// a consistent API for building key displays.
class KeyboardShortcutDisplayHandle {
/// Creates a handle with the specified builder.
  const KeyboardShortcutDisplayHandle(this._builder);
/// Builds a display widget for the specified keyboard key.
  Widget buildKeyboardDisplay(BuildContext context, LogicalKeyboardKey key);
}
/// Widget that provides keyboard shortcut display customization.
///
/// Allows customization of how keyboard shortcuts are displayed
/// throughout the widget tree using a builder function.
class KeyboardShortcutDisplayMapper extends StatefulWidget {
/// The builder function for creating key displays.
  KeyboardShortcutDisplayBuilder builder;
/// The child widget that will have access to this mapper.
  Widget child;
/// Creates a keyboard shortcut display mapper.
  const KeyboardShortcutDisplayMapper({super.key, this.builder = _defaultBuilder, required this.child});
  State<KeyboardShortcutDisplayMapper> createState();
}
/// A widget that displays keyboard shortcuts in a visually appealing format.
///
/// Renders keyboard key combinations as styled keyboard key representations,
/// typically used in tooltips, help text, or UI elements that need to
/// communicate keyboard shortcuts to users. The display automatically
/// formats keys with appropriate spacing and visual styling.
///
/// Supports both direct key specification through a list of [LogicalKeyboardKey]
/// objects and automatic conversion from [ShortcutActivator] instances.
/// Keys are displayed as individual key representations with configurable
/// spacing between them.
///
/// The component integrates with the keyboard shortcut theming system
/// and adapts its appearance based on the current theme and scaling settings.
/// Visual styling matches platform conventions for keyboard key representations.
///
/// Example:
/// ```dart
/// KeyboardDisplay(
///   keys: [
///     LogicalKeyboardKey.controlLeft,
///     LogicalKeyboardKey.keyS,
///   ],
///   spacing: 4.0,
/// )
/// ```
class KeyboardDisplay extends StatelessWidget {
/// Spacing between individual keyboard key displays.
///
/// Controls the horizontal gap between adjacent key representations.
/// When null, uses theme-appropriate default spacing.
  double? spacing;
/// Creates a [KeyboardDisplay] from a list of keyboard keys.
///
/// Displays the specified keyboard keys as styled key representations
/// with appropriate spacing. This constructor allows direct control
/// over which keys are displayed.
///
/// Parameters:
/// - [keys] (`List<LogicalKeyboardKey>`, required): Keys to display
/// - [spacing] (double?, optional): Gap between key displays
///
/// Example:
/// ```dart
/// KeyboardDisplay(
///   keys: [LogicalKeyboardKey.alt, LogicalKeyboardKey.tab],
///   spacing: 6.0,
/// )
/// ```
  const KeyboardDisplay({super.key, required List<LogicalKeyboardKey> keys, this.spacing});
/// Creates a [KeyboardDisplay] from a shortcut activator.
///
/// Automatically extracts the keyboard keys from the provided
/// [ShortcutActivator] and displays them as styled key representations.
/// This constructor is convenient when working with Flutter's shortcut system.
///
/// Parameters:
/// - [activator] (ShortcutActivator, required): Shortcut to extract keys from
/// - [spacing] (double?, optional): Gap between key displays
///
/// Example:
/// ```dart
/// KeyboardDisplay.fromActivator(
///   activator: SingleActivator(LogicalKeyboardKey.keyS, control: true),
///   spacing: 4.0,
/// )
/// ```
  const KeyboardDisplay.fromActivator({super.key, required ShortcutActivator activator, this.spacing});
  Widget build(BuildContext context);
}
/// A widget that displays a single keyboard key in a styled format.
///
/// Renders an individual keyboard key as a styled representation that
/// resembles a physical keyboard key. Used internally by [KeyboardDisplay]
/// but can also be used standalone for displaying individual keys.
///
/// The key display automatically formats the key label based on the
/// [LogicalKeyboardKey] and applies appropriate styling including
/// padding, shadows, and theme-consistent appearance.
///
/// Example:
/// ```dart
/// KeyboardKeyDisplay(
///   keyboardKey: LogicalKeyboardKey.controlLeft,
///   padding: EdgeInsets.symmetric(horizontal: 8, vertical: 4),
/// )
/// ```
class KeyboardKeyDisplay extends StatelessWidget {
/// The keyboard key to display.
///
/// Specifies which keyboard key should be rendered. The display
/// automatically formats the key label and applies appropriate styling.
  LogicalKeyboardKey keyboardKey;
/// Internal padding applied within the key display.
///
/// Controls spacing around the key label text. When null,
/// uses theme-appropriate default padding for key displays.
  EdgeInsetsGeometry? padding;
/// Box shadows applied to the key display for depth effect.
///
/// Creates visual depth to simulate the appearance of physical
/// keyboard keys. When null, uses theme default shadows.
  List<BoxShadow>? boxShadow;
/// Creates a [KeyboardKeyDisplay] for the specified keyboard key.
///
/// The [keyboardKey] parameter is required and determines which
/// key is displayed. Visual appearance can be customized through
/// the optional padding and shadow parameters.
///
/// Parameters:
/// - [keyboardKey] (LogicalKeyboardKey, required): Key to display
/// - [padding] (EdgeInsetsGeometry?, optional): Internal padding
/// - [boxShadow] (`List<BoxShadow>?`, optional): Shadow effects
///
/// Example:
/// ```dart
/// KeyboardKeyDisplay(
///   keyboardKey: LogicalKeyboardKey.escape,
///   padding: EdgeInsets.all(6),
/// )
/// ```
  const KeyboardKeyDisplay({super.key, required this.keyboardKey, this.padding, this.boxShadow});
  Widget build(BuildContext context);
}
/// Converts a [ShortcutActivator] into a list of logical keyboard keys.
///
/// Extracts modifier keys (control, alt, meta, shift) and the primary key from
/// a shortcut activator, returning them as a list of `List<LogicalKeyboardKey>`.
///
/// Parameters:
/// - [activator] (`ShortcutActivator`, required): The shortcut to convert.
///
/// Returns: `List<LogicalKeyboardKey>` ‚Äî all keys involved in the shortcut.
///
/// Supports [CharacterActivator] and [SingleActivator] types.
List<LogicalKeyboardKey> shortcutActivatorToKeySet(ShortcutActivator activator);
/// Immutable properties for divider appearance.
///
/// [DividerProperties] stores the visual characteristics of a divider,
/// including color, thickness, and indentation. This class is used for
/// theme interpolation and default value management.
///
/// All properties are required and non-nullable.
class DividerProperties {
/// The color of the divider line.
  Color color;
/// The thickness of the divider line in logical pixels.
  double thickness;
/// The amount of empty space to the leading edge of the divider.
  double indent;
/// The amount of empty space to the trailing edge of the divider.
  double endIndent;
/// Creates divider properties with the specified values.
  const DividerProperties({required this.color, required this.thickness, required this.indent, required this.endIndent});
/// Linearly interpolates between two [DividerProperties] objects.
///
/// Used for smooth theme transitions. Parameter [t] should be between 0.0 and 1.0,
/// where 0.0 returns [a] and 1.0 returns [b].
  static DividerProperties lerp(DividerProperties a, DividerProperties b, double t);
}
/// Theme data for customizing [Divider] widget appearance.
///
/// This class defines the visual properties that can be applied to
/// [Divider] widgets, including line color, dimensions, spacing, and
/// child padding. These properties can be set at the theme level
/// to provide consistent styling across the application.
class DividerTheme extends ComponentThemeData {
/// Color of the divider line.
  Color? color;
/// Height of the divider widget.
  double? height;
/// Thickness of the divider line.
  double? thickness;
/// Empty space to the leading edge of the divider.
  double? indent;
/// Empty space to the trailing edge of the divider.
  double? endIndent;
/// Padding around the [Divider.child].
  EdgeInsetsGeometry? padding;
/// Alignment of [Divider.child] along the divider axis.
  AxisAlignmentGeometry? childAlignment;
/// Creates a [DividerTheme].
  const DividerTheme({this.color, this.height, this.thickness, this.indent, this.endIndent, this.padding, this.childAlignment});
/// Creates a copy of this theme but with the given fields replaced by the
/// new values.
  DividerTheme copyWith({ValueGetter<Color?>? color, ValueGetter<double?>? height, ValueGetter<double?>? thickness, ValueGetter<double?>? indent, ValueGetter<double?>? endIndent, ValueGetter<EdgeInsetsGeometry?>? padding, ValueGetter<AxisAlignmentGeometry?>? childAlignment});
  bool operator ==(Object other);
  int get hashCode;
}
/// A horizontal line widget used to visually separate content sections.
///
/// [Divider] creates a thin horizontal line that spans the available width,
/// optionally with indentation from either end. It's commonly used to separate
/// content sections, list items, or create visual breaks in layouts. The divider
/// can optionally contain a child widget (such as text) that appears centered
/// on the divider line.
///
/// Key features:
/// - Horizontal line spanning available width
/// - Configurable thickness and color
/// - Optional indentation from start and end
/// - Support for child widgets (text, icons, etc.)
/// - Customizable padding around child content
/// - Theme integration for consistent styling
/// - Implements PreferredSizeWidget for flexible layout
///
/// The divider automatically adapts to the current theme's border color
/// and can be customized through individual properties or theme configuration.
/// When a child is provided, the divider line is broken to accommodate the
/// child content with appropriate padding.
///
/// Common use cases:
/// - Separating sections in forms or settings screens
/// - Creating breaks between list items
/// - Dividing content areas in complex layouts
/// - Adding labeled dividers with text or icons
///
/// Example:
/// ```dart
/// Column(
///   children: [
///     Text('Section 1'),
///     Divider(),
///     Text('Section 2'),
///     Divider(
///       child: Text('OR', style: TextStyle(color: Colors.grey)),
///       thickness: 2,
///       indent: 20,
///       endIndent: 20,
///     ),
///     Text('Section 3'),
///   ],
/// );
/// ```
class Divider extends StatelessWidget implements PreferredSizeWidget {
/// The color of the divider line.
  Color? color;
/// The total height of the divider (including padding).
  double? height;
/// The thickness of the divider line.
  double? thickness;
/// The amount of empty space before the divider line starts.
  double? indent;
/// The amount of empty space after the divider line ends.
  double? endIndent;
/// Optional child widget to display alongside the divider (e.g., text label).
  Widget? child;
/// Padding around the divider content.
  EdgeInsetsGeometry? padding;
/// Alignment of the [child] along the divider axis.
  AxisAlignmentGeometry? childAlignment;
/// Creates a horizontal divider.
  const Divider({super.key, this.color, this.height, this.thickness, this.indent, this.endIndent, this.child, this.padding, this.childAlignment});
  Size get preferredSize;
  Widget build(BuildContext context);
}
/// Custom painter for drawing horizontal divider lines.
///
/// Renders a horizontal line with specified color, thickness, and indents.
class DividerPainter extends CustomPainter {
/// The color of the divider line.
  Color color;
/// The thickness of the divider line.
  double thickness;
/// The indent from the start edge.
  double indent;
/// The indent from the end edge.
  double endIndent;
/// Creates a divider painter with the specified properties.
  DividerPainter({required this.color, required this.thickness, required this.indent, required this.endIndent});
  void paint(Canvas canvas, Size size);
  bool shouldRepaint(covariant DividerPainter oldDelegate);
}
/// Custom painter for drawing vertical divider lines.
///
/// Renders a vertical line with specified color, thickness, and indents.
class VerticalDividerPainter extends CustomPainter {
/// The color of the divider line.
  Color color;
/// The thickness of the divider line.
  double thickness;
/// The indent from the top edge.
  double indent;
/// The indent from the bottom edge.
  double endIndent;
/// Creates a vertical divider painter with the specified properties.
  const VerticalDividerPainter({required this.color, required this.thickness, required this.indent, required this.endIndent});
  void paint(Canvas canvas, Size size);
  bool shouldRepaint(covariant VerticalDividerPainter oldDelegate);
}
/// A vertical line used to separate content in a layout.
///
/// Similar to [Divider] but renders vertically, useful for separating
/// content in horizontal layouts like rows or navigation panels.
class VerticalDivider extends StatelessWidget implements PreferredSizeWidget {
/// The color of the divider line.
  Color? color;
/// The total width of the divider (including padding).
  double? width;
/// The thickness of the divider line.
  double? thickness;
/// The amount of empty space before the divider line starts.
  double? indent;
/// The amount of empty space after the divider line ends.
  double? endIndent;
/// Optional child widget to display alongside the divider.
  Widget? child;
/// Padding around the divider content.
  EdgeInsetsGeometry? padding;
/// Alignment of the [child] along the divider axis.
  AxisAlignmentGeometry? childAlignment;
/// Creates a vertical divider.
  const VerticalDivider({super.key, this.color, this.width, this.thickness, this.indent, this.endIndent, this.child, this.padding = const EdgeInsets.symmetric(vertical: 8), this.childAlignment});
  Size get preferredSize;
  Widget build(BuildContext context);
}
/// Theme configuration for [LinearProgressIndicator] components.
///
/// Provides comprehensive visual styling properties for linear progress indicators
/// including colors, sizing, border radius, and visual effects. These properties
/// integrate with the design system and can be overridden at the widget level.
///
/// The theme supports advanced features like spark effects for enhanced visual
/// feedback and animation control for performance optimization scenarios.
class LinearProgressIndicatorTheme extends ComponentThemeData {
/// The primary color of the progress indicator fill.
///
/// Type: `Color?`. If null, uses theme's primary color. Applied to the
/// filled portion that represents completion progress.
  Color? color;
/// The background color behind the progress indicator.
///
/// Type: `Color?`. If null, uses a semi-transparent version of the primary color.
/// Visible in the unfilled portion of the progress track.
  Color? backgroundColor;
/// The minimum height of the progress indicator.
///
/// Type: `double?`. If null, defaults to 2.0 scaled by theme scaling factor.
/// Ensures adequate visual presence while maintaining sleek appearance.
  double? minHeight;
/// The border radius of the progress indicator container.
///
/// Type: `BorderRadiusGeometry?`. If null, uses BorderRadius.zero for sharp edges.
/// Applied to both the track and progress fill for consistent styling.
  BorderRadiusGeometry? borderRadius;
/// Whether to display spark effects at the progress head.
///
/// Type: `bool?`. If null, defaults to false. When enabled, shows a
/// radial gradient spark effect at the leading edge of the progress fill.
  bool? showSparks;
/// Whether to disable smooth progress animations.
///
/// Type: `bool?`. If null, defaults to false. When true, progress changes
/// instantly without transitions for performance optimization.
  bool? disableAnimation;
/// Creates a [LinearProgressIndicatorTheme].
///
/// All parameters are optional and can be null to use intelligent defaults
/// based on the current theme configuration and design system values.
///
/// Example:
/// ```dart
/// const LinearProgressIndicatorTheme(
///   color: Colors.blue,
///   backgroundColor: Colors.grey,
///   minHeight: 4.0,
///   borderRadius: BorderRadius.circular(2.0),
///   showSparks: true,
/// );
/// ```
  const LinearProgressIndicatorTheme({this.color, this.backgroundColor, this.minHeight, this.borderRadius, this.showSparks, this.disableAnimation});
/// Returns a copy of this theme with the given fields replaced.
  LinearProgressIndicatorTheme copyWith({ValueGetter<Color?>? color, ValueGetter<Color?>? backgroundColor, ValueGetter<double?>? minHeight, ValueGetter<BorderRadiusGeometry?>? borderRadius, ValueGetter<bool?>? showSparks, ValueGetter<bool?>? disableAnimation});
  bool operator ==(Object other);
  int get hashCode;
}
/// A sophisticated linear progress indicator with advanced visual effects.
///
/// The LinearProgressIndicator provides both determinate and indeterminate progress
/// visualization with enhanced features including optional spark effects, smooth
/// animations, and comprehensive theming support. Built with custom painting for
/// precise control over visual presentation and performance.
///
/// For determinate progress, displays completion as a horizontal bar that fills
/// from left to right. For indeterminate progress (when value is null), shows
/// a continuous animation with two overlapping progress segments that move across
/// the track in a coordinated pattern.
///
/// Key features:
/// - Determinate and indeterminate progress modes
/// - Optional spark effects with radial gradient animation
/// - Smooth animated transitions with disable option
/// - RTL (right-to-left) text direction support
/// - Custom painting for optimal rendering performance
/// - Comprehensive theming via [LinearProgressIndicatorTheme]
/// - Responsive sizing with theme scaling integration
///
/// The indeterminate animation uses precisely timed curves to create a natural,
/// material design compliant motion pattern that communicates ongoing activity
/// without specific completion timing.
///
/// Example:
/// ```dart
/// LinearProgressIndicator(
///   value: 0.7,
///   showSparks: true,
///   color: Colors.blue,
///   minHeight: 6.0,
/// );
/// ```
class LinearProgressIndicator extends StatelessWidget {
/// The progress completion value between 0.0 and 1.0.
///
/// Type: `double?`. If null, displays indeterminate animation with dual
/// moving progress segments. When provided, shows determinate progress.
  double? value;
/// The background color of the progress track.
///
/// Type: `Color?`. If null, uses theme background color or semi-transparent
/// version of progress color. Overrides theme configuration.
  Color? backgroundColor;
/// The minimum height of the progress indicator.
///
/// Type: `double?`. If null, uses theme minimum height or 2.0 scaled
/// by theme scaling factor. Overrides theme configuration.
  double? minHeight;
/// The primary color of the progress fill.
///
/// Type: `Color?`. If null, uses theme primary color. Applied to both
/// progress segments in indeterminate mode. Overrides theme configuration.
  Color? color;
/// The border radius of the progress container.
///
/// Type: `BorderRadiusGeometry?`. If null, uses BorderRadius.zero.
/// Applied via [ClipRRect] to both track and progress elements.
  BorderRadiusGeometry? borderRadius;
/// Whether to display spark effects at the progress head.
///
/// Type: `bool?`. If null, defaults to false. Shows radial gradient
/// spark effect at the leading edge for enhanced visual feedback.
  bool? showSparks;
/// Whether to disable smooth progress animations.
///
/// Type: `bool?`. If null, defaults to false. When true, disables
/// [AnimatedValueBuilder] for instant progress changes.
  bool? disableAnimation;
/// Creates a [LinearProgressIndicator].
///
/// The component automatically handles both determinate and indeterminate modes
/// based on whether [value] is provided. Theming and visual effects can be
/// customized through individual parameters or via [LinearProgressIndicatorTheme].
///
/// Parameters:
/// - [value] (double?, optional): Progress completion (0.0-1.0) or null for indeterminate
/// - [backgroundColor] (Color?, optional): Track background color override
/// - [minHeight] (double?, optional): Minimum indicator height override
/// - [color] (Color?, optional): Progress fill color override
/// - [borderRadius] (BorderRadiusGeometry?, optional): Container border radius override
/// - [showSparks] (bool?, optional): Whether to show spark effects
/// - [disableAnimation] (bool?, optional): Whether to disable smooth transitions
///
/// Example:
/// ```dart
/// LinearProgressIndicator(
///   value: 0.4,
///   color: Colors.green,
///   backgroundColor: Colors.grey.shade300,
///   minHeight: 8.0,
///   showSparks: true,
/// );
/// ```
  const LinearProgressIndicator({super.key, this.value, this.backgroundColor, this.minHeight, this.color, this.borderRadius, this.showSparks, this.disableAnimation});
  Widget build(BuildContext context);
}
/// Theme configuration for [DotIndicator] and its dot items.
class DotIndicatorTheme extends ComponentThemeData {
/// Spacing between dots.
  double? spacing;
/// Padding around the dots container.
  EdgeInsetsGeometry? padding;
/// Builder for individual dots.
  DotBuilder? dotBuilder;
/// Size of each dot.
  double? size;
/// Border radius of dots.
  double? borderRadius;
/// Color of the active dot.
  Color? activeColor;
/// Color of the inactive dot.
  Color? inactiveColor;
/// Border color of the inactive dot.
  Color? inactiveBorderColor;
/// Border width of the inactive dot.
  double? inactiveBorderWidth;
/// Creates a [DotIndicatorTheme].
  const DotIndicatorTheme({this.spacing, this.padding, this.dotBuilder, this.size, this.borderRadius, this.activeColor, this.inactiveColor, this.inactiveBorderColor, this.inactiveBorderWidth});
/// Creates a copy of this theme but with the given fields replaced.
  DotIndicatorTheme copyWith({ValueGetter<double?>? spacing, ValueGetter<EdgeInsetsGeometry?>? padding, ValueGetter<DotBuilder?>? dotBuilder, ValueGetter<double?>? size, ValueGetter<double?>? borderRadius, ValueGetter<Color?>? activeColor, ValueGetter<Color?>? inactiveColor, ValueGetter<Color?>? inactiveBorderColor, ValueGetter<double?>? inactiveBorderWidth});
  bool operator ==(Object other);
  int get hashCode;
}
/// Navigation indicator with customizable dots showing current position in a sequence.
///
/// A visual indicator widget that displays a series of dots representing items
/// in a sequence, with one dot highlighted to show the current position.
/// Commonly used with carousels, page views, and stepper interfaces.
///
/// ## Features
///
/// - **Position indication**: Clear visual representation of current position
/// - **Interactive navigation**: Optional tap-to-navigate functionality
/// - **Flexible orientation**: Horizontal or vertical dot arrangement
/// - **Custom dot builders**: Complete control over dot appearance and behavior
/// - **Responsive spacing**: Automatic scaling with theme configuration
/// - **Accessibility support**: Screen reader friendly with semantic information
///
/// The indicator automatically highlights the dot at the current index and
/// can optionally respond to taps to change the active position.
///
/// Example:
/// ```dart
/// DotIndicator(
///   index: currentPage,
///   length: totalPages,
///   onChanged: (newIndex) => pageController.animateToPage(newIndex),
///   direction: Axis.horizontal,
///   spacing: 12.0,
/// );
/// ```
class DotIndicator extends StatelessWidget {
/// The current active index (0-based).
  int index;
/// The total number of dots to display.
  int length;
/// Callback invoked when a dot is tapped.
  ValueChanged<int>? onChanged;
/// Spacing between dots.
  double? spacing;
/// The direction of the dot layout (horizontal or vertical).
  Axis direction;
/// Padding around the dots container.
  EdgeInsetsGeometry? padding;
/// Custom builder for individual dots.
  DotBuilder? dotBuilder;
/// Creates a [DotIndicator].
///
/// The indicator shows [length] dots with the dot at [index] highlighted
/// as active. When [onChanged] is provided, tapping dots triggers navigation.
///
/// Parameters:
/// - [index] (int, required): current active dot position (0-based)
/// - [length] (int, required): total number of dots to display
/// - [onChanged] (`ValueChanged<int>?`, optional): callback when dot is tapped
/// - [spacing] (double?, optional): override spacing between dots
/// - [direction] (Axis, default: horizontal): layout direction of dots
/// - [padding] (EdgeInsetsGeometry?, optional): padding around dot container
/// - [dotBuilder] (DotBuilder?, optional): custom builder for dot widgets
///
/// Example:
/// ```dart
/// DotIndicator(
///   index: 1,
///   length: 5,
///   onChanged: (index) => print('Navigate to $index'),
///   direction: Axis.horizontal,
///   dotBuilder: (context, index, active) => Container(
///     width: active ? 16 : 8,
///     height: 8,
///     decoration: BoxDecoration(
///       color: active ? Colors.blue : Colors.grey,
///       borderRadius: BorderRadius.circular(4),
///     ),
///   ),
/// )
/// ```
  const DotIndicator({super.key, required this.index, required this.length, this.onChanged, this.spacing, this.direction = Axis.horizontal, this.padding, this.dotBuilder});
  Widget build(BuildContext context);
}
/// A basic dot item widget with customizable appearance.
///
/// Used as a base component for creating custom dot indicators.
class DotItem extends StatelessWidget {
/// The size of the dot.
  double? size;
/// The color of the dot.
  Color? color;
/// The border radius of the dot.
  double? borderRadius;
/// The border color of the dot.
  Color? borderColor;
/// The border width of the dot.
  double? borderWidth;
/// Creates a dot item with the specified properties.
  const DotItem({super.key, this.size, this.color, this.borderRadius, this.borderColor, this.borderWidth});
  Widget build(BuildContext context);
}
/// An active dot item widget representing the current position.
///
/// Styled to highlight the currently active item in a dot indicator.
class ActiveDotItem extends StatelessWidget {
/// The size of the dot.
  double? size;
/// The color of the dot.
  Color? color;
/// The border radius of the dot.
  double? borderRadius;
/// The border color of the dot.
  Color? borderColor;
/// The border width of the dot.
  double? borderWidth;
/// Creates an active dot item with the specified properties.
  const ActiveDotItem({super.key, this.size, this.color, this.borderRadius, this.borderColor, this.borderWidth});
  Widget build(BuildContext context);
}
/// An inactive dot item widget representing non-current positions.
///
/// Styled to indicate inactive items in a dot indicator with
/// optional border styling.
class InactiveDotItem extends StatelessWidget {
/// The size of the dot.
  double? size;
/// The color of the dot.
  Color? color;
/// The border radius of the dot.
  double? borderRadius;
/// The border color of the dot.
  Color? borderColor;
/// The border width of the dot.
  double? borderWidth;
/// Creates an inactive dot item with the specified properties.
  const InactiveDotItem({super.key, this.size, this.color, this.borderRadius, this.borderColor, this.borderWidth});
  Widget build(BuildContext context);
}
/// Theme configuration for [Progress] components.
///
/// Provides visual styling properties for progress indicators including colors,
/// border radius, and sizing constraints. These properties can be overridden
/// at the widget level or applied globally via [ComponentTheme].
///
/// The theme integrates seamlessly with the design system by leveraging
/// theme scaling factors and color schemes for consistent visual presentation.
class ProgressTheme extends ComponentThemeData {
/// The foreground color of the progress indicator.
///
/// Type: `Color?`. If null, uses the default progress color from theme.
/// Applied to the filled portion that shows completion progress.
  Color? color;
/// The background color behind the progress indicator.
///
/// Type: `Color?`. If null, uses a semi-transparent version of the progress color.
/// Visible in the unfilled portion of the progress track.
  Color? backgroundColor;
/// The border radius of the progress indicator container.
///
/// Type: `BorderRadiusGeometry?`. If null, uses theme's small border radius.
/// Applied to both the track and the progress fill for consistent styling.
  BorderRadiusGeometry? borderRadius;
/// The minimum height of the progress indicator.
///
/// Type: `double?`. If null, defaults to 8.0 scaled by theme scaling factor.
/// Ensures adequate visual presence while maintaining proportional sizing.
  double? minHeight;
/// Creates a [ProgressTheme].
///
/// All parameters are optional and can be null to use default values
/// derived from the current theme configuration.
///
/// Example:
/// ```dart
/// const ProgressTheme(
///   color: Colors.blue,
///   backgroundColor: Colors.grey,
///   borderRadius: BorderRadius.circular(4.0),
///   minHeight: 6.0,
/// );
/// ```
  const ProgressTheme({this.color, this.backgroundColor, this.borderRadius, this.minHeight});
/// Creates a copy of this theme but with the given fields replaced with the new values.
  ProgressTheme copyWith({ValueGetter<Color?>? color, ValueGetter<Color?>? backgroundColor, ValueGetter<BorderRadiusGeometry?>? borderRadius, ValueGetter<double?>? minHeight});
  bool operator ==(Object other);
  int get hashCode;
}
/// A linear progress indicator that visually represents task completion.
///
/// The Progress widget displays completion status as a horizontal bar that fills
/// from left to right based on the current progress value. Supports both
/// determinate progress (with specific values) and indeterminate progress
/// (continuous animation when value is null).
///
/// Built on top of [LinearProgressIndicator], this component provides enhanced
/// theming capabilities and integrates seamlessly with the design system.
/// Progress values are automatically normalized between configurable min/max
/// bounds with built-in validation to ensure values remain within range.
///
/// Key features:
/// - Flexible progress range with custom min/max values
/// - Automatic value normalization and validation
/// - Smooth animations with optional animation disable
/// - Comprehensive theming support via [ProgressTheme]
/// - Responsive scaling based on theme configuration
/// - Indeterminate progress support for unknown durations
///
/// Example:
/// ```dart
/// Progress(
///   progress: 0.65,
///   color: Colors.blue,
///   backgroundColor: Colors.grey.shade300,
/// );
/// ```
class Progress extends StatelessWidget {
/// The current progress value within the specified range.
///
/// Type: `double?`. If null, displays indeterminate progress animation.
/// Must be between [min] and [max] values when provided. The widget
/// automatically normalizes this value for display.
  double? progress;
/// The minimum value of the progress range.
///
/// Type: `double`, default: `0.0`. Defines the starting point for
/// progress calculation. Must be less than [max].
  double min;
/// The maximum value of the progress range.
///
/// Type: `double`, default: `1.0`. Defines the completion point for
/// progress calculation. Must be greater than [min].
  double max;
/// Whether to disable progress fill animations.
///
/// Type: `bool`, default: `false`. When true, progress changes immediately
/// without smooth transitions. Useful for performance optimization.
  bool disableAnimation;
/// The color of the progress indicator fill.
///
/// Type: `Color?`. If null, uses the theme's progress color or
/// the color specified in [ProgressTheme]. Overrides theme values.
  Color? color;
/// The background color of the progress track.
///
/// Type: `Color?`. If null, uses the theme's background color or
/// a semi-transparent version of the progress color. Overrides theme values.
  Color? backgroundColor;
/// The normalized progress value between 0.0 and 1.0.
///
/// Type: `double?`. Returns null when [progress] is null (indeterminate).
/// Automatically calculated by normalizing [progress] within the [min]-[max] range.
///
/// Formula: `(progress - min) / (max - min)`
  double? get normalizedValue;
/// Creates a [Progress] indicator.
///
/// The progress value must be between [min] and [max] when provided.
/// If progress is null, the indicator shows indeterminate animation.
///
/// Parameters:
/// - [progress] (double?, optional): Current progress value or null for indeterminate
/// - [min] (double, default: 0.0): Minimum progress value
/// - [max] (double, default: 1.0): Maximum progress value
/// - [disableAnimation] (bool, default: false): Whether to disable smooth transitions
/// - [color] (Color?, optional): Progress fill color override
/// - [backgroundColor] (Color?, optional): Progress track color override
///
/// Throws:
/// - [AssertionError] if progress is not between min and max values.
///
/// Example:
/// ```dart
/// Progress(
///   progress: 75,
///   min: 0,
///   max: 100,
///   color: Colors.green,
/// );
/// ```
  const Progress({super.key, this.progress, this.min = 0.0, this.max = 1.0, this.disableAnimation = false, this.color, this.backgroundColor});
  Widget build(BuildContext context);
}
/// Theme configuration for [NumberTicker] widgets.
///
/// Provides default styling values that can be overridden on individual
/// [NumberTicker] instances. This allows for consistent styling across
/// multiple number tickers in an application while still permitting
/// per-instance customization when needed.
///
/// Used with [ComponentTheme] to provide theme values throughout the widget tree.
///
/// Example:
/// ```dart
/// ComponentTheme<NumberTickerTheme>(
///   data: NumberTickerTheme(
///     duration: Duration(milliseconds: 800),
///     curve: Curves.bounceOut,
///     style: TextStyle(fontSize: 24, fontWeight: FontWeight.bold),
///   ),
///   child: MyApp(),
/// );
/// ```
class NumberTickerTheme extends ComponentThemeData {
/// The default animation duration for number transitions.
///
/// If null, individual [NumberTicker] widgets will use their own duration
/// or fall back to the default value of 500 milliseconds.
  Duration? duration;
/// The default animation curve for number transitions.
///
/// If null, individual [NumberTicker] widgets will use their own curve
/// or fall back to [Curves.easeInOut].
  Curve? curve;
/// The default text style for formatted number display.
///
/// Only used when [NumberTicker] is constructed with a [formatter] function.
/// If null, the default system text style is used.
  TextStyle? style;
/// Creates a [NumberTickerTheme] with the specified styling options.
///
/// Parameters:
/// - [duration] (Duration?, optional): Default animation duration for transitions.
/// - [curve] (Curve?, optional): Default easing curve for animations.
/// - [style] (TextStyle?, optional): Default text style for formatted display.
///
/// All parameters are optional and will fall back to widget-level defaults
/// or system defaults when not specified.
  const NumberTickerTheme({this.duration, this.curve, this.style});
/// Creates a copy of this theme with the given values replaced.
///
/// Uses [ValueGetter] functions to allow conditional updates where
/// null getters preserve the original value.
///
/// Parameters:
/// - [duration] (`ValueGetter<Duration?>?`, optional): New duration value.
/// - [curve] (`ValueGetter<Curve?>?`, optional): New curve value.
/// - [style] (`ValueGetter<TextStyle?>?`, optional): New text style value.
///
/// Example:
/// ```dart
/// final newTheme = originalTheme.copyWith(
///   duration: () => Duration(seconds: 1),
///   style: () => TextStyle(color: Colors.blue),
/// );
/// ```
  NumberTickerTheme copyWith({ValueGetter<Duration?>? duration, ValueGetter<Curve?>? curve, ValueGetter<TextStyle?>? style});
  bool operator ==(Object other);
  int get hashCode;
}
/// A widget that smoothly animates between numeric values with customizable display.
///
/// [NumberTicker] provides animated transitions when numeric values change,
/// making it ideal for displaying counters, statistics, prices, or any numeric
/// data that changes over time. It offers two construction modes:
///
/// - Default constructor: Uses a formatter function to display numbers as text
/// - [NumberTicker.builder]: Provides a custom builder for complete control
///
/// The animation automatically starts when the [number] value changes, smoothly
/// interpolating between the previous and new values. If [initialNumber] is
/// provided, the widget will animate from that value on first display.
///
/// Supports theming via [NumberTickerTheme] for consistent styling across
/// multiple instances while allowing per-widget customization.
///
/// Example:
/// ```dart
/// NumberTicker(
///   number: _counter,
///   formatter: (num value) => '\$${value.toStringAsFixed(2)}',
///   duration: Duration(milliseconds: 600),
///   style: TextStyle(fontSize: 24, fontWeight: FontWeight.bold),
/// );
/// ```
class NumberTicker extends StatelessWidget {
/// The initial number value to start animation from.
///
/// If null, no initial animation occurs and the widget starts directly
/// with the [number] value. When provided, causes an animation from this
/// initial value to [number] on first build.
  num? initialNumber;
/// The target number value to animate to and display.
///
/// When this changes, triggers a smooth animation from the current displayed
/// value to this new target value. Supports any numeric type (int, double).
  num number;
/// Custom builder function for complete display control.
///
/// Used only with [NumberTicker.builder] constructor. Receives the current
/// animated numeric value and optional child widget. Allows for complex
/// custom presentations beyond simple text formatting.
  NumberTickerBuilder? builder;
/// Optional child widget passed to custom builders.
///
/// Available only when using [NumberTicker.builder]. Passed through to
/// the builder function for optimization when part of the display remains constant.
  Widget? child;
/// Function to format numbers into display strings.
///
/// Used only with default constructor. Called with the current animated
/// numeric value and must return a string representation for display.
/// Enables custom formatting like currency, percentages, or localization.
  NumberTickerFormatted? formatter;
/// Override duration for this widget's animations.
///
/// If null, uses the duration from [NumberTickerTheme] or defaults to
/// 500 milliseconds. Controls how long transitions take when [number] changes.
  Duration? duration;
/// Override animation curve for this widget.
///
/// If null, uses the curve from [NumberTickerTheme] or defaults to
/// [Curves.easeInOut]. Controls the timing function of number transitions.
  Curve? curve;
/// Override text style for formatted number display.
///
/// Only used with default constructor. If null, uses the style from
/// [NumberTickerTheme] or system default. Has no effect when using builder.
  TextStyle? style;
/// Creates a [NumberTicker] with custom builder for complete display control.
///
/// This constructor provides maximum flexibility by allowing you to define
/// exactly how the animated number should be presented. The builder receives
/// the current interpolated numeric value and can construct any widget tree.
///
/// Parameters:
/// - [initialNumber] (num?, optional): Starting value for first animation.
/// - [number] (num, required): Target value to animate to and display.
/// - [builder] (NumberTickerBuilder, required): Custom display builder function.
/// - [child] (Widget?, optional): Optional child passed to builder for optimization.
/// - [duration] (Duration?, optional): Override animation duration.
/// - [curve] (Curve?, optional): Override animation curve.
///
/// Example:
/// ```dart
/// NumberTicker.builder(
///   number: _score,
///   duration: Duration(milliseconds: 400),
///   builder: (context, value, child) {
///     return Container(
///       padding: EdgeInsets.all(8),
///       decoration: BoxDecoration(
///         color: Colors.green,
///         borderRadius: BorderRadius.circular(8),
///       ),
///       child: Text(
///         '${value.toInt()} points',
///         style: TextStyle(color: Colors.white, fontSize: 18),
///       ),
///     );
///   },
/// );
/// ```
  const NumberTicker.builder({super.key, this.initialNumber, required this.number, required this.builder, this.child, this.duration, this.curve});
/// Creates a [NumberTicker] with formatted text display.
///
/// This is the standard constructor that displays animated numbers as text
/// using a formatting function. The formatter receives the current numeric
/// value and must return a string representation for display.
///
/// Parameters:
/// - [initialNumber] (num?, optional): Starting value for first animation.
/// - [number] (num, required): Target value to animate to and display.
/// - [formatter] (NumberTickerFormatted, required): Function to format numbers as strings.
/// - [duration] (Duration?, optional): Override animation duration.
/// - [curve] (Curve?, optional): Override animation curve.
/// - [style] (TextStyle?, optional): Override text styling.
///
/// Example:
/// ```dart
/// NumberTicker(
///   initialNumber: 0,
///   number: 1234.56,
///   formatter: (value) => NumberFormat.currency(
///     locale: 'en_US',
///     symbol: '\$',
///   ).format(value),
///   duration: Duration(milliseconds: 750),
///   style: TextStyle(fontSize: 20, fontWeight: FontWeight.w600),
/// );
/// ```
  const NumberTicker({super.key, this.initialNumber, required this.number, required this.formatter, this.duration, this.curve, this.style});
  Widget build(BuildContext context);
}
/// Defines a character set for [FlipperCharacter] and [TextFlipper].
class FlipperCharset {
/// Digits 0‚Äì9.
  static const FlipperCharset numbers = FlipperCharset('0123456789');
/// Uppercase Latin letters.
  static const FlipperCharset uppercase = FlipperCharset('ABCDEFGHIJKLMNOPQRSTUVWXYZ');
/// Lowercase Latin letters.
  static const FlipperCharset lowercase = FlipperCharset('abcdefghijklmnopqrstuvwxyz');
/// Uppercase and lowercase Latin letters.
  static const FlipperCharset letters = FlipperCharset('ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz');
/// Alphanumeric characters.
  static const FlipperCharset alphanumeric = FlipperCharset('ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789');
/// Common symbol characters.
  static const FlipperCharset symbols = FlipperCharset('!@#\$%^&*()-_=+[]{}|;:\'",.<>?/`~');
/// Letters, numbers, and symbols.
  static const FlipperCharset all = FlipperCharset('ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789!@#\$%^&*()-_=+[]{}|;:\'",.<>?/`~');
/// The characters available to flip through.
  String characters;
/// Creates a [FlipperCharset] from a string of characters.
  const FlipperCharset(this.characters);
/// Combines two [FlipperCharset] instances into one.
  FlipperCharset operator +(FlipperCharset other);
  String toString();
  bool operator ==(Object other);
  int get hashCode;
}
/// Animates a single character by flipping through [FlipperCharset].
class FlipperCharacter extends StatelessWidget {
/// The character set used for flipping.
  FlipperCharset charset;
/// The target character to display.
  String character;
/// Duration of the flip animation.
  Duration duration;
/// Curve used for the flip animation.
  Curve curve;
/// Creates a [FlipperCharacter].
  const FlipperCharacter({super.key, required this.charset, required this.character, required this.duration, required this.curve});
  Widget build(BuildContext context);
}
/// Animates a string by flipping each character.
class TextFlipper extends StatelessWidget {
/// The character set used for each character flip.
  FlipperCharset charset;
/// The text to animate.
  String text;
/// Duration of the flip animation for each character.
  Duration duration;
/// Curve used for the flip animation.
  Curve curve;
/// Creates a [TextFlipper].
  const TextFlipper({super.key, this.charset = FlipperCharset.all, required this.text, this.duration = const Duration(milliseconds: 500), this.curve = Curves.easeInOut});
  Widget build(BuildContext context);
}
/// Theme configuration for skeleton loading effects.
///
/// Provides styling properties for skeleton loading animations including pulse
/// timing, colors, and animation behavior. These properties integrate with the
/// shadcn design system and work with the underlying Skeletonizer package.
///
/// The theme enables consistent skeleton styling across the application while
/// allowing for customization of animation characteristics and visual appearance.
class SkeletonTheme extends ComponentThemeData {
/// The duration of one complete pulse animation cycle.
///
/// Type: `Duration?`. If null, defaults to 1 second for a natural breathing
/// effect. Controls the speed of the fade in/out pulse animation.
  Duration? duration;
/// The starting color of the pulse animation.
///
/// Type: `Color?`. If null, uses primary color with 5% opacity from theme.
/// Represents the lightest state of the skeleton shimmer effect.
  Color? fromColor;
/// The ending color of the pulse animation.
///
/// Type: `Color?`. If null, uses primary color with 10% opacity from theme.
/// Represents the darkest state of the skeleton shimmer effect.
  Color? toColor;
/// Whether to enable smooth transitions when switching between skeleton states.
///
/// Type: `bool?`. If null, defaults to true. When enabled, provides smooth
/// fade transitions when toggling skeleton visibility on/off.
  bool? enableSwitchAnimation;
/// Creates a [SkeletonTheme].
///
/// All parameters are optional and can be null to use intelligent defaults
/// that integrate with the current theme's color scheme and design system.
///
/// Example:
/// ```dart
/// const SkeletonTheme(
///   duration: Duration(milliseconds: 800),
///   fromColor: Colors.grey.withOpacity(0.1),
///   toColor: Colors.grey.withOpacity(0.2),
///   enableSwitchAnimation: true,
/// );
/// ```
  const SkeletonTheme({this.duration, this.fromColor, this.toColor, this.enableSwitchAnimation});
/// Returns a copy of this theme with the given fields replaced.
  SkeletonTheme copyWith({ValueGetter<Duration?>? duration, ValueGetter<Color?>? fromColor, ValueGetter<Color?>? toColor, ValueGetter<bool?>? enableSwitchAnimation});
  bool operator ==(Object other);
  int get hashCode;
}
/// A configuration layer that provides Skeletonizer setup with theme integration.
///
/// ShadcnSkeletonizerConfigLayer acts as a bridge between the shadcn theme system
/// and the underlying Skeletonizer package, ensuring skeleton loading effects
/// are consistent with the overall design system. This widget wraps content
/// with properly configured skeleton animation settings.
///
/// The component automatically resolves theme values from [SkeletonTheme] and
/// applies appropriate defaults based on the current theme's color scheme and
/// scaling factors. It creates a [SkeletonizerConfig] with [PulseEffect] for
/// smooth, accessible loading animations.
///
/// This is typically used internally by skeleton extension methods and should
/// rarely be instantiated directly by application code.
///
/// Example:
/// ```dart
/// ShadcnSkeletonizerConfigLayer(
///   theme: Theme.of(context),
///   child: YourContentWidget(),
/// );
/// ```
class ShadcnSkeletonizerConfigLayer extends StatelessWidget {
/// The theme data used for skeleton configuration.
///
/// Type: `ThemeData`, required. Provides color scheme, scaling factors,
/// and other design system values for skeleton appearance calculation.
  ThemeData theme;
/// The child widget to wrap with skeleton configuration.
///
/// Type: `Widget`, required. The content that will have skeleton
/// configuration available through the widget tree.
  Widget child;
/// Override duration for the pulse animation cycle.
///
/// Type: `Duration?`. If provided, overrides theme and default duration
/// values for this specific configuration layer.
  Duration? duration;
/// Override starting color for the pulse animation.
///
/// Type: `Color?`. If provided, overrides theme and default color
/// values for the lightest pulse state.
  Color? fromColor;
/// Override ending color for the pulse animation.
///
/// Type: `Color?`. If provided, overrides theme and default color
/// values for the darkest pulse state.
  Color? toColor;
/// Override switch animation behavior.
///
/// Type: `bool?`. If provided, overrides theme and default animation
/// behavior when toggling skeleton visibility.
  bool? enableSwitchAnimation;
/// Creates a [ShadcnSkeletonizerConfigLayer].
///
/// The [theme] and [child] parameters are required for proper skeleton
/// configuration and content wrapping. Override parameters allow for
/// fine-tuned control of skeleton appearance at the layer level.
///
/// Parameters:
/// - [theme] (ThemeData, required): Theme for skeleton configuration calculation
/// - [child] (Widget, required): Content to wrap with skeleton configuration
/// - [duration] (Duration?, optional): Pulse animation duration override
/// - [fromColor] (Color?, optional): Pulse start color override
/// - [toColor] (Color?, optional): Pulse end color override
/// - [enableSwitchAnimation] (bool?, optional): Switch animation behavior override
///
/// Example:
/// ```dart
/// ShadcnSkeletonizerConfigLayer(
///   theme: Theme.of(context),
///   duration: Duration(milliseconds: 1200),
///   child: MyContentWidget(),
/// );
/// ```
  const ShadcnSkeletonizerConfigLayer({super.key, required this.theme, required this.child, this.duration, this.fromColor, this.toColor, this.enableSwitchAnimation});
  Widget build(BuildContext context);
}
/// Extension methods for adding skeleton loading effects to any widget.
///
/// SkeletonExtension provides convenient methods to transform regular widgets
/// into skeleton loading states with proper animation and theming integration.
/// These methods work with the underlying Skeletonizer package while ensuring
/// consistency with the shadcn design system.
///
/// The extension handles common use cases including content loading, image
/// placeholders, form field loading, and complex layout skeletonization.
/// Different skeleton modes (sliver, leaf, unite, replace) provide flexibility
/// for various UI patterns and performance requirements.
///
/// Methods automatically detect certain widget types (Avatar, Image) and apply
/// appropriate skeleton handling to avoid common rendering issues.
extension SkeletonExtension on Widget {
/// Converts the widget to a skeleton suitable for sliver layouts.
///
/// Creates a [Skeletonizer] wrapper that works within [CustomScrollView]
/// and other sliver-based layouts. The [ignoreContainers] parameter is
/// set to false for consistent skeleton appearance in scroll contexts.
///
/// Parameters:
/// - [enabled] (bool, default: true): Whether skeleton effect is active
///
/// Returns:
/// A [Skeletonizer] widget configured for sliver layout compatibility.
///
/// Example:
/// ```dart
/// ListView.builder(
///   itemBuilder: (context, index) => ListTile(
///     title: Text('Item $index'),
///   ).asSkeletonSliver(enabled: isLoading),
/// );
/// ```
  Widget asSkeletonSliver({bool enabled = true});
/// Converts the widget to a skeleton with advanced configuration options.
///
/// Provides comprehensive skeleton transformation with multiple modes and
/// automatic handling of problematic widget types. Supports [AsyncSnapshot]
/// integration for automatic skeleton state management based on data loading.
///
/// Special handling:
/// - Avatar and Image widgets use [Skeleton.leaf] to avoid rendering issues
/// - [snapshot] parameter automatically enables/disables based on data state
/// - Various skeleton modes (leaf, unite, replace) for different use cases
///
/// Parameters:
/// - [enabled] (bool, default: true): Whether skeleton effect is active
/// - [leaf] (bool, default: false): Use leaf mode for simple widgets
/// - [replacement] (Widget?, optional): Custom replacement widget in replace mode
/// - [unite] (bool, default: false): Use unite mode for complex layouts
/// - [snapshot] (AsyncSnapshot?, optional): Auto-enable based on data loading state
///
/// Returns:
/// A skeleton-wrapped widget with appropriate configuration for the specified mode.
///
/// Example:
/// ```dart
/// FutureBuilder<String>(
///   future: loadData(),
///   builder: (context, snapshot) => Text(snapshot.data ?? 'Loading...').asSkeleton(
///     snapshot: snapshot,
///   ),
/// );
/// ```
  Widget asSkeleton({bool enabled = true, bool leaf = false, Widget? replacement, bool unite = false, AsyncSnapshot? snapshot});
/// Excludes the widget from skeleton effects in its parent skeleton context.
///
/// Wraps the widget with [Skeleton.ignore] to prevent skeleton transformation
/// even when placed within a skeleton-enabled parent. Useful for preserving
/// interactive elements or dynamic content within skeleton layouts.
///
/// Returns:
/// A [Skeleton.ignore] wrapper that prevents skeleton effects on this widget.
///
/// Example:
/// ```dart
/// Column(children: [
///   Text('Loading content...'),
///   Button(
///     onPressed: () {},
///     child: Text('Cancel'),
///   ).ignoreSkeleton(), // Button remains interactive
/// ]).asSkeleton();
/// ```
  Widget ignoreSkeleton();
/// Controls whether the widget should be preserved in skeleton mode.
///
/// Wraps the widget with [Skeleton.keep] to conditionally preserve the
/// original widget appearance when skeleton effects are active. When [exclude]
/// is true, the widget maintains its normal appearance instead of being skeletonized.
///
/// Parameters:
/// - [exclude] (bool, default: true): Whether to exclude from skeleton effects
///
/// Returns:
/// A [Skeleton.keep] wrapper that conditionally preserves the widget's appearance.
///
/// Example:
/// ```dart
/// Row(children: [
///   Text('Data: $value'),
///   Icon(Icons.star).excludeSkeleton(exclude: isImportant),
/// ]).asSkeleton();
/// ```
  Widget excludeSkeleton({bool exclude = true});
}
/// Theme for [Chip].
class ChipTheme extends ComponentThemeData {
/// The padding inside the chip.
  EdgeInsetsGeometry? padding;
/// The default [Button] style of the chip.
  AbstractButtonStyle? style;
/// Creates a [ChipTheme].
  const ChipTheme({this.padding, this.style});
/// Creates a copy of this theme with the given values replaced.
  ChipTheme copyWith({ValueGetter<EdgeInsetsGeometry?>? padding, ValueGetter<AbstractButtonStyle?>? style});
  bool operator ==(Object other);
  int get hashCode;
}
/// Specialized button component designed for use within chips.
///
/// A compact button widget optimized for use as leading or trailing elements
/// within [Chip] widgets. Provides consistent styling and behavior for
/// interactive chip elements like close buttons or action triggers.
///
/// Example:
/// ```dart
/// ChipButton(
///   onPressed: () => removeItem(item),
///   child: Icon(Icons.close, size: 14),
/// );
/// ```
class ChipButton extends StatelessWidget {
/// The widget to display as the button content.
  Widget child;
/// Callback invoked when the button is pressed.
  VoidCallback? onPressed;
/// Creates a chip button with the specified child and callback.
  const ChipButton({super.key, required this.child, this.onPressed});
  Widget build(BuildContext context);
}
/// Compact interactive element for tags, labels, and selections.
///
/// A versatile chip widget that combines button functionality with a compact
/// form factor. Ideal for representing tags, categories, filters, or selected
/// items in a space-efficient manner with optional interactive elements.
///
/// ## Features
///
/// - **Compact design**: Space-efficient layout perfect for tags and labels
/// - **Interactive elements**: Optional leading and trailing widgets (icons, buttons)
/// - **Customizable styling**: Flexible button styling with theme integration
/// - **Touch feedback**: Optional press handling with visual feedback
/// - **Accessibility**: Full screen reader support and keyboard navigation
/// - **Consistent theming**: Integrated with the component theme system
///
/// The chip renders as a rounded button with optional leading and trailing
/// elements, making it perfect for filter tags, contact chips, or selection
/// indicators.
///
/// Example:
/// ```dart
/// Chip(
///   leading: Icon(Icons.star),
///   child: Text('Favorites'),
///   trailing: ChipButton(
///     onPressed: () => removeFilter('favorites'),
///     child: Icon(Icons.close),
///   ),
///   onPressed: () => toggleFilter('favorites'),
///   style: ButtonStyle.secondary(),
/// );
/// ```
class Chip extends StatelessWidget {
/// The main content of the chip.
  Widget child;
/// Optional widget displayed before the child.
  Widget? leading;
/// Optional widget displayed after the child.
  Widget? trailing;
/// Callback invoked when the chip is pressed.
  VoidCallback? onPressed;
/// Custom button style for the chip.
  AbstractButtonStyle? style;
/// Creates a [Chip].
///
/// The chip displays [child] content with optional [leading] and [trailing]
/// widgets. When [onPressed] is provided, the entire chip becomes interactive.
///
/// Parameters:
/// - [child] (Widget, required): main content displayed in the chip center
/// - [leading] (Widget?, optional): widget displayed before the main content
/// - [trailing] (Widget?, optional): widget displayed after the main content
/// - [onPressed] (VoidCallback?, optional): callback when chip is pressed
/// - [style] (AbstractButtonStyle?, optional): override chip button styling
///
/// Example:
/// ```dart
/// Chip(
///   leading: Avatar(user: currentUser),
///   child: Text(currentUser.name),
///   trailing: ChipButton(
///     onPressed: () => removeUser(currentUser),
///     child: Icon(Icons.close, size: 16),
///   ),
///   style: ButtonStyle.primary(),
/// )
/// ```
  const Chip({super.key, required this.child, this.leading, this.trailing, this.onPressed, this.style});
  Widget build(BuildContext context);
}
/// Theme configuration for [CircularProgressIndicator] components.
///
/// Provides visual styling properties for circular progress indicators including
/// colors, sizing, and stroke characteristics. These properties integrate with
/// the design system and can be overridden at the widget level.
///
/// All theme values respect the current theme's scaling factor and color scheme
/// for consistent visual presentation across different screen densities and themes.
class CircularProgressIndicatorTheme extends ComponentThemeData {
/// The primary color of the progress indicator arc.
///
/// Type: `Color?`. If null, uses theme's primary color or background color
/// when [onSurface] is true. Applied to the filled portion of the circular track.
  Color? color;
/// The background color of the progress indicator track.
///
/// Type: `Color?`. If null, uses a semi-transparent version of the primary color.
/// Visible in the unfilled portion of the circular track.
  Color? backgroundColor;
/// The diameter size of the circular progress indicator.
///
/// Type: `double?`. If null, derives size from current icon theme size minus padding.
/// Determines the overall dimensions of the circular progress display.
  double? size;
/// The width of the progress indicator stroke.
///
/// Type: `double?`. If null, calculates as size/12 for proportional appearance.
/// Controls the thickness of both the progress arc and background track.
  double? strokeWidth;
/// Creates a [CircularProgressIndicatorTheme].
///
/// All parameters are optional and can be null to use intelligent defaults
/// based on the current theme configuration and icon context.
///
/// Example:
/// ```dart
/// const CircularProgressIndicatorTheme(
///   color: Colors.blue,
///   backgroundColor: Colors.grey,
///   size: 32.0,
///   strokeWidth: 3.0,
/// );
/// ```
  const CircularProgressIndicatorTheme({this.color, this.backgroundColor, this.size, this.strokeWidth});
/// Creates a copy of this theme with the given fields replaced.
  CircularProgressIndicatorTheme copyWith({ValueGetter<Color?>? color, ValueGetter<Color?>? backgroundColor, ValueGetter<double?>? size, ValueGetter<double?>? strokeWidth});
  bool operator ==(Object other);
  int get hashCode;
}
/// A circular progress indicator that displays task completion as a rotating arc.
///
/// The CircularProgressIndicator provides both determinate and indeterminate
/// progress visualization in a compact circular format. When a specific progress
/// value is provided, it shows completion as a filled arc. When value is null,
/// it displays a continuous spinning animation.
///
/// Built as a wrapper around Flutter's native CircularProgressIndicator with
/// enhanced theming capabilities and integration with the shadcn design system.
/// Automatically adapts sizing based on the current [IconTheme] context while
/// providing manual size override options.
///
/// Key features:
/// - Determinate and indeterminate progress modes
/// - Automatic sizing based on icon context with manual overrides
/// - Smooth value animations with configurable duration
/// - Surface mode for display on colored backgrounds
/// - Comprehensive theming via [CircularProgressIndicatorTheme]
/// - Performance-optimized rendering with [RepaintBoundary]
///
/// The component intelligently calculates default colors and sizing based on
/// the current theme and icon context, ensuring consistent visual integration.
///
/// Example:
/// ```dart
/// CircularProgressIndicator(
///   value: 0.75,
///   size: 32.0,
///   color: Colors.blue,
/// );
/// ```
class CircularProgressIndicator extends StatelessWidget {
/// The progress completion value between 0.0 and 1.0.
///
/// Type: `double?`. If null, displays indeterminate spinning animation.
/// When provided, shows progress as a filled arc from 0% to value*100%.
  double? value;
/// The explicit diameter size of the progress indicator.
///
/// Type: `double?`. If null, derives size from current icon theme size
/// minus theme scaling padding. Overrides theme and automatic sizing.
  double? size;
/// The primary color of the progress arc.
///
/// Type: `Color?`. If null, uses theme color or background color when
/// [onSurface] is true. Overrides theme configuration.
  Color? color;
/// The background color of the progress track.
///
/// Type: `Color?`. If null, uses a semi-transparent version of the
/// primary color. Overrides theme configuration.
  Color? backgroundColor;
/// The width of the progress stroke line.
///
/// Type: `double?`. If null, calculates proportionally as size/12.
/// Controls the thickness of both progress and background arcs.
  double? strokeWidth;
/// The duration for smooth progress value transitions.
///
/// Type: `Duration`, default: [kDefaultDuration]. Only applied when
/// [animated] is true and [value] is provided for determinate progress.
  Duration duration;
/// Whether to animate progress value changes.
///
/// Type: `bool`, default: `true`. When false, progress changes instantly.
/// When true with determinate value, uses [AnimatedValueBuilder] for smooth transitions.
  bool animated;
/// Whether the indicator is displayed on a colored surface.
///
/// Type: `bool`, default: `false`. When true, uses background color instead
/// of primary color for better visibility on colored backgrounds.
  bool onSurface;
/// Creates a [CircularProgressIndicator].
///
/// The component automatically handles both determinate and indeterminate modes
/// based on whether [value] is provided. Size and colors adapt intelligently
/// based on theme context unless explicitly overridden.
///
/// Parameters:
/// - [value] (double?, optional): Progress completion (0.0-1.0) or null for indeterminate
/// - [size] (double?, optional): Explicit diameter size override
/// - [color] (Color?, optional): Primary progress arc color override
/// - [backgroundColor] (Color?, optional): Background track color override
/// - [strokeWidth] (double?, optional): Progress stroke thickness override
/// - [duration] (Duration, default: kDefaultDuration): Animation duration for value changes
/// - [animated] (bool, default: true): Whether to animate progress transitions
/// - [onSurface] (bool, default: false): Whether displayed on colored background
///
/// Example:
/// ```dart
/// CircularProgressIndicator(
///   value: 0.6,
///   size: 24.0,
///   strokeWidth: 2.0,
///   animated: true,
/// );
/// ```
  const CircularProgressIndicator({super.key, this.value, this.size, this.color, this.backgroundColor, this.strokeWidth, this.duration = kDefaultDuration, this.animated = true, this.onSurface = false});
  Widget build(BuildContext context);
}
/// Theme data for customizing badge widget appearance across different styles.
///
/// This class defines the visual properties that can be applied to various
/// badge types including [PrimaryBadge], [SecondaryBadge], [OutlineBadge],
/// and [DestructiveBadge]. Each badge style can have its own button styling
/// configuration to provide consistent appearance across the application.
class BadgeTheme extends ComponentThemeData {
/// Style for [PrimaryBadge].
  AbstractButtonStyle? primaryStyle;
/// Style for [SecondaryBadge].
  AbstractButtonStyle? secondaryStyle;
/// Style for [OutlineBadge].
  AbstractButtonStyle? outlineStyle;
/// Style for [DestructiveBadge].
  AbstractButtonStyle? destructiveStyle;
/// Creates a [BadgeTheme].
  const BadgeTheme({this.primaryStyle, this.secondaryStyle, this.outlineStyle, this.destructiveStyle});
/// Returns a copy of this theme with the given fields replaced.
  BadgeTheme copyWith({ValueGetter<AbstractButtonStyle?>? primaryStyle, ValueGetter<AbstractButtonStyle?>? secondaryStyle, ValueGetter<AbstractButtonStyle?>? outlineStyle, ValueGetter<AbstractButtonStyle?>? destructiveStyle});
  bool operator ==(Object other);
  int get hashCode;
}
/// A primary style badge widget for highlighting important information or status.
///
/// [PrimaryBadge] displays content in a prominent badge format using the primary
/// color scheme. It's designed for high-importance status indicators, labels,
/// and interactive elements that need to draw attention. The badge supports
/// leading and trailing widgets for icons or additional content.
///
/// Key features:
/// - Primary color styling with emphasis and contrast
/// - Optional tap handling for interactive badges
/// - Support for leading and trailing widgets (icons, counters, etc.)
/// - Customizable button styling through theme integration
/// - Compact size optimized for badge display
/// - Consistent visual hierarchy with other badge variants
///
/// The badge uses button-like styling but in a compact form factor suitable
/// for status displays, labels, and small interactive elements. It integrates
/// with the theme system to maintain visual consistency.
///
/// Common use cases:
/// - Status indicators (active, new, featured)
/// - Notification counts and alerts
/// - Category labels and tags
/// - Interactive filter chips
/// - Achievement or ranking displays
///
/// Example:
/// ```dart
/// PrimaryBadge(
///   child: Text('NEW'),
///   leading: Icon(Icons.star, size: 16),
///   onPressed: () => _showNewItems(),
/// );
///
/// // Non-interactive status badge
/// PrimaryBadge(
///   child: Text('5'),
///   trailing: Icon(Icons.notifications, size: 14),
/// );
/// ```
class PrimaryBadge extends StatelessWidget {
/// The main content of the badge.
  Widget child;
/// Optional callback when the badge is pressed, making it interactive.
///
/// If `null`, the badge is non-interactive.
  VoidCallback? onPressed;
/// Optional widget displayed before the child content.
  Widget? leading;
/// Optional widget displayed after the child content.
  Widget? trailing;
/// Optional custom style override for the badge.
///
/// If `null`, uses theme's primary badge style or default primary styling.
  AbstractButtonStyle? style;
/// Creates a primary badge.
  const PrimaryBadge({super.key, required this.child, this.onPressed, this.leading, this.trailing, this.style});
  Widget build(BuildContext context);
}
/// A secondary-styled badge for displaying labels, counts, or status indicators.
///
/// Similar to [PrimaryBadge] but with secondary (muted) styling suitable for
/// less prominent information.
class SecondaryBadge extends StatelessWidget {
/// The main content of the badge.
  Widget child;
/// Optional callback when the badge is pressed.
  VoidCallback? onPressed;
/// Optional widget displayed before the child content.
  Widget? leading;
/// Optional widget displayed after the child content.
  Widget? trailing;
/// Optional custom style override for the badge.
  AbstractButtonStyle? style;
/// Creates a secondary badge with the specified child content.
  const SecondaryBadge({super.key, required this.child, this.onPressed, this.leading, this.trailing, this.style});
  Widget build(BuildContext context);
}
/// An outline-styled badge for displaying labels, counts, or status indicators.
///
/// Uses outline styling with a visible border and no background fill,
/// suitable for less visually prominent badge elements.
class OutlineBadge extends StatelessWidget {
/// The main content of the badge.
  Widget child;
/// Optional callback when the badge is pressed.
  VoidCallback? onPressed;
/// Optional widget displayed before the child content.
  Widget? leading;
/// Optional widget displayed after the child content.
  Widget? trailing;
/// Optional custom style override for the badge.
  AbstractButtonStyle? style;
/// Creates an outline badge with the specified child content.
  const OutlineBadge({super.key, required this.child, this.onPressed, this.leading, this.trailing, this.style});
  Widget build(BuildContext context);
}
/// A destructive-styled badge for displaying warnings or dangerous actions.
///
/// Uses destructive (typically red) styling to indicate dangerous, destructive,
/// or critical information that requires user attention.
class DestructiveBadge extends StatelessWidget {
/// The main content of the badge.
  Widget child;
/// Optional callback when the badge is pressed.
  VoidCallback? onPressed;
/// Optional widget displayed before the child content.
  Widget? leading;
/// Optional widget displayed after the child content.
  Widget? trailing;
/// Optional custom style override for the badge.
  AbstractButtonStyle? style;
/// Creates a destructive badge with the specified child content.
  const DestructiveBadge({super.key, required this.child, this.onPressed, this.leading, this.trailing, this.style});
  Widget build(BuildContext context);
}
/// A widget that constrains the width of its child based on a factor and aligns it.
///
/// This widget is used by [ChatBubble] to limit the width of the bubble relative to
/// the available width and to align it within that space.
///
/// Parameters:
/// - [widthFactor] (`double`, required): The fraction of the available width that the child should occupy.
/// - [alignment] (`AxisAlignmentGeometry`, required): The alignment of the child within the available space.
/// - [child] (`Widget`, required): The widget below this widget in the tree.
class ChatConstrainedBox extends SingleChildRenderObjectWidget {
/// The fraction of the available width that the child should occupy.
  double widthFactor;
/// The alignment of the child within the available space.
  AxisAlignmentGeometry alignment;
/// Creates a [ChatConstrainedBox].
  const ChatConstrainedBox({required this.widthFactor, required this.alignment, required super.child, super.key});
  RenderChatConstrainedBox createRenderObject(BuildContext context);
  void updateRenderObject(BuildContext context, RenderChatConstrainedBox renderObject);
}
/// A render object that constrains the width of its child and aligns it.
///
/// This render object implements the layout logic for [ChatConstrainedBox].
class RenderChatConstrainedBox extends RenderShiftedBox {
/// Creates a [RenderChatConstrainedBox].
///
/// Parameters:
/// - [widthFactor] (`double`, required): The fraction of the available width that the child should occupy.
/// - [alignment] (`AxisAlignment`, required): The alignment of the child within the available space.
/// - [child] (`RenderBox?`, optional): The child render object.
  RenderChatConstrainedBox({required double widthFactor, required AxisAlignment alignment, RenderBox? child});
/// The fraction of the available width that the child should occupy.
  double get widthFactor;
/// The alignment of the child within the available space.
  AxisAlignment get alignment;
/// Sets the width factor.
  set widthFactor(double value);
/// Sets the alignment.
  set alignment(AxisAlignment value);
  void performLayout();
  Size computeDryLayout(covariant BoxConstraints constraints);
  double computeMaxIntrinsicHeight(double width);
  double computeMinIntrinsicHeight(double width);
}
/// Defines the theme for a [ChatGroup].
class ChatGroupTheme extends ComponentThemeData {
/// The spacing between chat bubbles in the group.
  double? spacing;
/// The alignment of the avatar relative to the chat bubbles.
  AxisAlignmentGeometry? avatarAlignment;
/// The spacing between the avatar and the chat bubbles.
  double? avatarSpacing;
/// Creates a [ChatGroupTheme].
///
/// Parameters:
/// - [spacing] (`double?`, optional): The spacing between chat bubbles in the group.
/// - [avatarAlignment] (`AxisAlignmentGeometry?`, optional): The alignment of the avatar relative to the chat bubbles.
/// - [avatarSpacing] (`double?`, optional): The spacing between the avatar and the chat bubbles.
  const ChatGroupTheme({this.spacing, this.avatarAlignment, this.avatarSpacing});
/// Creates a copy of this theme with the given fields replaced with the new values.
///
/// Parameters:
/// - [spacing] (`ValueGetter<double?>?`, optional): New spacing value.
/// - [avatarAlignment] (`ValueGetter<AxisAlignmentGeometry?>?`, optional): New avatar alignment value.
/// - [avatarSpacing] (`ValueGetter<double?>?`, optional): New avatar spacing value.
///
/// Returns:
/// A new [ChatGroupTheme] with the specified values updated.
  ChatGroupTheme copyWith({ValueGetter<double?>? spacing, ValueGetter<AxisAlignmentGeometry?>? avatarAlignment, ValueGetter<double?>? avatarSpacing});
  String toString();
  bool operator ==(Object other);
  int get hashCode;
}
/// Defines the theme for [ChatBubble]s.
class ChatTheme extends ComponentThemeData {
/// The background color of the chat bubble.
  Color? color;
/// The alignment of the chat bubble.
  AxisAlignmentGeometry? alignment;
/// The type of the chat bubble (e.g., plain, tailed).
  ChatBubbleType? type;
/// The border radius of the chat bubble.
  BorderRadiusGeometry? borderRadius;
/// The padding inside the chat bubble.
  EdgeInsetsGeometry? padding;
/// The border of the chat bubble.
  BorderSide? border;
/// The width factor of the chat bubble.
  double? widthFactor;
/// Creates a [ChatTheme].
///
/// Parameters:
/// - [color] (`Color?`, optional): The background color of the chat bubble.
/// - [alignment] (`AxisAlignmentGeometry?`, optional): The alignment of the chat bubble.
/// - [type] (`ChatBubbleType?`, optional): The type of the chat bubble (e.g., plain, tailed).
/// - [borderRadius] (`BorderRadiusGeometry?`, optional): The border radius of the chat bubble.
/// - [padding] (`EdgeInsetsGeometry?`, optional): The padding inside the chat bubble.
/// - [border] (`BorderSide?`, optional): The border of the chat bubble.
/// - [widthFactor] (`double?`, optional): The width factor of the chat bubble.
  const ChatTheme({this.color, this.alignment, this.type, this.borderRadius, this.padding, this.border, this.widthFactor});
/// Creates a copy of this theme with the given fields replaced with the new values.
///
/// Parameters:
/// - [color] (`ValueGetter<Color?>?`, optional): New color value.
/// - [alignment] (`ValueGetter<AxisAlignmentGeometry?>?`, optional): New alignment value.
/// - [type] (`ValueGetter<ChatBubbleType?>?`, optional): New type value.
/// - [borderRadius] (`ValueGetter<BorderRadiusGeometry?>?`, optional): New border radius value.
/// - [padding] (`ValueGetter<EdgeInsetsGeometry?>?`, optional): New padding value.
/// - [border] (`ValueGetter<BorderSide?>?`, optional): New border value.
///
/// Returns:
/// A new [ChatTheme] with the specified values updated.
  ChatTheme copyWith({ValueGetter<Color?>? color, ValueGetter<AxisAlignmentGeometry?>? alignment, ValueGetter<ChatBubbleType?>? type, ValueGetter<BorderRadiusGeometry?>? borderRadius, ValueGetter<EdgeInsetsGeometry?>? padding, ValueGetter<BorderSide?>? border, ValueGetter<double?>? widthFactor});
  String toString();
  bool operator ==(Object other);
  int get hashCode;
}
/// A widget that groups multiple [ChatBubble]s together.
///
/// This widget handles the layout and styling of a group of chat bubbles,
/// including avatar positioning and spacing.
///
/// Example:
/// ```dart
/// ChatGroup(
///   avatarPrefix: Avatar(child: Text('A')),
///   children: [
///     ChatBubble(child: Text('Hello')),
///     ChatBubble(child: Text('How are you?')),
///   ],
/// )
/// ```
class ChatGroup extends StatelessWidget {
/// The widget to display before the chat bubbles (e.g., an avatar).
  Widget? avatarPrefix;
/// The widget to display after the chat bubbles.
  Widget? avatarSuffix;
/// The list of chat bubbles to display.
  List<Widget> children;
/// The alignment of the chat bubbles within the group.
  AxisAlignmentGeometry? alignment;
/// The background color of the chat bubbles.
  Color? color;
/// The type of the chat bubbles.
  ChatBubbleType? type;
/// The border radius of the chat bubbles.
  BorderRadiusGeometry? borderRadius;
/// The padding inside the chat bubbles.
  EdgeInsetsGeometry? padding;
/// The border of the chat bubbles.
  BorderSide? border;
/// The spacing between chat bubbles.
  double? spacing;
/// The alignment of the avatar.
  AxisAlignmentGeometry? avatarAlignment;
/// The spacing between the avatar and the chat bubbles.
  double? avatarSpacing;
/// Creates a [ChatGroup].
///
/// Parameters:
/// - [children] (`List<Widget>`, required): The list of chat bubbles to display.
/// - [alignment] (`AxisAlignmentGeometry?`, optional): The alignment of the chat bubbles within the group.
/// - [color] (`Color?`, optional): The background color of the chat bubbles.
/// - [type] (`ChatBubbleType?`, optional): The type of the chat bubbles.
/// - [borderRadius] (`BorderRadiusGeometry?`, optional): The border radius of the chat bubbles.
/// - [padding] (`EdgeInsetsGeometry?`, optional): The padding inside the chat bubbles.
/// - [border] (`BorderSide?`, optional): The border of the chat bubbles.
/// - [spacing] (`double?`, optional): The spacing between chat bubbles.
/// - [avatarPrefix] (`Widget?`, optional): The widget to display before the chat bubbles.
/// - [avatarSuffix] (`Widget?`, optional): The widget to display after the chat bubbles.
/// - [avatarAlignment] (`AxisAlignmentGeometry?`, optional): The alignment of the avatar.
/// - [avatarSpacing] (`double?`, optional): The spacing between the avatar and the chat bubbles.
  const ChatGroup({super.key, required this.children, this.alignment, this.color, this.type, this.borderRadius, this.padding, this.border, this.spacing, this.avatarPrefix, this.avatarSuffix, this.avatarAlignment, this.avatarSpacing});
  Widget build(BuildContext context);
}
/// Defines the type of a [ChatBubble].
///
/// This abstract class allows for different visual styles of chat bubbles,
/// such as plain bubbles or bubbles with tails.
abstract class ChatBubbleType {
/// A plain bubble with no tail.
  static const plain = PlainChatBubbleType();
/// A bubble with an external triangular tail.
  static const tail = TailChatBubbleType();
/// A bubble with one sharp corner instead of rounded.
  static const sharpCorner = SharpCornerChatBubbleType();
/// Creates a [ChatBubbleType].
  const ChatBubbleType();
/// Wraps the child widget with the bubble styling.
///
/// Parameters:
/// - [context] (`BuildContext`, required): The build context.
/// - [child] (`Widget`, required): The child widget to wrap.
/// - [data] (`ChatBubbleData`, required): The data associated with the bubble.
/// - [chat] (`ChatBubble`, required): The chat bubble widget itself.
///
/// Returns:
/// A [Widget] that wraps the child with the bubble styling.
  Widget wrap(BuildContext context, Widget child, ChatBubbleData data, ChatBubble chat);
}
/// Defines the corner of a [ChatBubble] where a tail might be attached.
enum ChatBubbleCorner { topLeft, topRight, bottomLeft, bottomRight }
/// Defines the directional corner of a [ChatBubble].
///
/// This is used to support RTL languages by defining corners in terms of
/// start and end instead of left and right.
enum ChatBubbleCornerDirectional { topStart, topEnd, bottomStart, bottomEnd }
/// A [ChatBubbleType] that makes one corner sharp instead of rounded.
///
/// This style modifies the border radius of one corner to create a pointed
/// corner effect, similar to a speech bubble tail.
class SharpCornerChatBubbleType extends ChatBubbleType {
/// The corner where the tail should be applied.
  ChatBubbleCornerDirectional? corner;
/// The border radius of the bubble.
  BorderRadiusGeometry? borderRadius;
/// The padding inside the bubble.
  EdgeInsetsGeometry? padding;
/// The behavior determining when to show the tail.
  TailBehavior? tailBehavior;
/// Creates a [SharpCornerChatBubbleType].
///
/// Parameters:
/// - [corner] (`ChatBubbleCornerDirectional?`, optional): The corner that should be sharp.
/// - [borderRadius] (`BorderRadiusGeometry?`, optional): The border radius of the bubble.
/// - [padding] (`EdgeInsetsGeometry?`, optional): The padding inside the bubble.
/// - [tailBehavior] (`TailBehavior?`, optional): The behavior determining when to show the sharp corner.
  const SharpCornerChatBubbleType({this.corner, this.borderRadius, this.padding, this.tailBehavior});
/// Creates a copy of this bubble type with the given fields replaced with the new values.
///
/// Parameters:
/// - [corner] (`ValueGetter<ChatBubbleCornerDirectional?>?`, optional): New corner value.
/// - [borderRadius] (`ValueGetter<BorderRadiusGeometry?>?`, optional): New border radius value.
/// - [padding] (`ValueGetter<EdgeInsetsGeometry?>?`, optional): New padding value.
/// - [tailBehavior] (`ValueGetter<TailBehavior?>?`, optional): New tail behavior value.
///
/// Returns:
/// A new [SharpCornerChatBubbleType] with the specified values updated.
  SharpCornerChatBubbleType copyWith({ValueGetter<ChatBubbleCornerDirectional?>? corner, ValueGetter<BorderRadiusGeometry?>? borderRadius, ValueGetter<EdgeInsetsGeometry?>? padding, ValueGetter<TailBehavior?>? tailBehavior});
  Widget wrap(BuildContext context, Widget child, ChatBubbleData data, ChatBubble chat);
}
/// A simple [ChatBubbleType] with no tail.
class PlainChatBubbleType extends ChatBubbleType {
/// The border radius of the bubble.
  BorderRadiusGeometry? borderRadius;
/// The border of the bubble.
  BorderSide? border;
/// The padding inside the bubble.
  EdgeInsetsGeometry? padding;
/// Creates a [PlainChatBubbleType].
///
/// Parameters:
/// - [borderRadius] (`BorderRadiusGeometry?`, optional): The border radius of the bubble.
/// - [border] (`BorderSide?`, optional): The border of the bubble.
/// - [padding] (`EdgeInsetsGeometry?`, optional): The padding inside the bubble.
  const PlainChatBubbleType({this.borderRadius, this.border, this.padding});
  Widget wrap(BuildContext context, Widget child, ChatBubbleData data, ChatBubble chat);
}
/// Defines when a tail should be shown on a [ChatBubble].
abstract class TailBehavior {
/// Shows a tail on the first bubble in a group.
  static const first = _ChatTailBehavior(_first);
/// Shows a tail on the middle bubble in a group.
  static const middle = _ChatTailBehavior(_middle);
/// Shows a tail on the last bubble in a group.
  static const last = _ChatTailBehavior(_last);
/// Determines whether the bubble at the given index should have a tail.
  bool wrapWithTail(ChatBubbleData data);
}
/// Defines the theme for the tail of a [ChatBubble].
class ChatTailTheme extends ComponentThemeData {
/// The position of the tail relative to the bubble.
  AxisDirectional? position;
/// The size of the tail.
  Size? size;
/// The border radius of the bubble when a tail is present.
  BorderRadiusGeometry? borderRadius;
/// The radius of the tail's curve.
  double? tailRadius;
/// The behavior determining when to show the tail.
  TailBehavior? tailBehavior;
/// Creates a [ChatTailTheme].
///
/// Parameters:
/// - [position] (`AxisDirectional?`, optional): The position of the tail relative to the bubble.
/// - [size] (`Size?`, optional): The size of the tail.
/// - [borderRadius] (`BorderRadiusGeometry?`, optional): The border radius of the bubble when a tail is present.
/// - [tailRadius] (`double?`, optional): The radius of the tail's curve.
/// - [tailBehavior] (`TailBehavior?`, optional): The behavior determining when to show the tail.
  const ChatTailTheme({this.position, this.size, this.borderRadius, this.tailRadius, this.tailBehavior});
  String toString();
/// Creates a copy of this theme with the given fields replaced with the new values.
///
/// Parameters:
/// - [position] (`ValueGetter<AxisDirectional>?`, optional): New position value.
/// - [size] (`ValueGetter<Size>?`, optional): New size value.
/// - [borderRadius] (`ValueGetter<BorderRadiusGeometry>?`, optional): New border radius value.
/// - [tailRadius] (`ValueGetter<double>?`, optional): New tail radius value.
/// - [tailBehavior] (`ValueGetter<TailBehavior>?`, optional): New tail behavior value.
///
/// Returns:
/// A new [ChatTailTheme] with the specified values updated.
  ChatTailTheme copyWith({ValueGetter<AxisDirectional>? position, ValueGetter<Size>? size, ValueGetter<BorderRadiusGeometry>? borderRadius, ValueGetter<double>? tailRadius, ValueGetter<TailBehavior>? tailBehavior});
  bool operator ==(Object other);
  int get hashCode;
}
/// A [ChatBubbleType] that draws an external triangular tail.
class TailChatBubbleType extends ChatBubbleType {
/// The alignment of the tail along the bubble's edge.
  AxisAlignmentGeometry? tailAlignment;
/// The position of the tail relative to the bubble.
  AxisDirectional? position;
/// The size of the tail.
  Size? size;
/// The border radius of the bubble.
  BorderRadiusGeometry? borderRadius;
/// The radius of the tail's curve.
  double? tailRadius;
/// The behavior determining when to show the tail.
  TailBehavior? tailBehavior;
/// The padding inside the bubble.
  EdgeInsetsGeometry? padding;
/// Creates a [TailChatBubbleType].
///
/// Parameters:
/// - [tailAlignment] (`AxisAlignmentGeometry?`, optional): The alignment of the tail along the bubble's edge.
/// - [position] (`AxisDirectional?`, optional): The position of the tail relative to the bubble.
/// - [size] (`Size?`, optional): The size of the tail.
/// - [borderRadius] (`BorderRadiusGeometry?`, optional): The border radius of the bubble.
/// - [tailRadius] (`double?`, optional): The radius of the tail's curve.
/// - [tailBehavior] (`TailBehavior?`, optional): The behavior determining when to show the tail.
/// - [padding] (`EdgeInsetsGeometry?`, optional): The padding inside the bubble.
  const TailChatBubbleType({this.tailAlignment, this.position, this.size, this.borderRadius, this.tailRadius, this.tailBehavior, this.padding});
/// Creates a copy of this bubble type with the given fields replaced with the new values.
///
/// Parameters:
/// - [tailAlignment] (`ValueGetter<AxisAlignmentGeometry>?`, optional): New tail alignment value.
/// - [position] (`ValueGetter<AxisDirectional>?`, optional): New position value.
/// - [size] (`ValueGetter<Size>?`, optional): New size value.
/// - [borderRadius] (`ValueGetter<BorderRadiusGeometry>?`, optional): New border radius value.
/// - [tailRadius] (`ValueGetter<double>?`, optional): New tail radius value.
/// - [tailBehavior] (`ValueGetter<TailBehavior>?`, optional): New tail behavior value.
///
/// Returns:
/// A new [TailChatBubbleType] with the specified values updated.
  TailChatBubbleType copyWith({ValueGetter<AxisAlignmentGeometry>? tailAlignment, ValueGetter<AxisDirectional>? position, ValueGetter<Size>? size, ValueGetter<BorderRadiusGeometry>? borderRadius, ValueGetter<double>? tailRadius, ValueGetter<TailBehavior>? tailBehavior});
  Widget wrap(BuildContext context, Widget child, ChatBubbleData data, ChatBubble chat);
}
/// Data associated with a [ChatBubble] within a [ChatGroup].
class ChatBubbleData {
/// The index of the bubble in the group.
  int index;
/// The total number of bubbles in the group.
  int length;
/// Creates a [ChatBubbleData].
///
/// Parameters:
/// - [index] (`int`, required): The index of the bubble in the group.
/// - [length] (`int`, required): The total number of bubbles in the group.
  const ChatBubbleData({required this.index, required this.length});
/// Creates a copy of this data with the given fields replaced with the new values.
///
/// Parameters:
/// - [index] (`int?`, optional): New index value.
/// - [length] (`int?`, optional): New length value.
///
/// Returns:
/// A new [ChatBubbleData] with the specified values updated.
  ChatBubbleData copyWith({int? index, int? length});
  String toString();
  bool operator ==(Object other);
  int get hashCode;
}
/// A widget that displays a single chat message or content.
///
/// This widget renders a chat bubble with customizable styling, including
/// background color, alignment, and tail behavior.
///
/// Example:
/// ```dart
/// ChatBubble(
///   child: Text('Hello World'),
///   alignment: AxisAlignment.right,
///   color: Colors.blue,
/// )
/// ```
class ChatBubble extends StatelessWidget {
/// The content of the chat bubble.
  Widget child;
/// The type of the chat bubble.
  ChatBubbleType? type;
/// The background color of the chat bubble.
  Color? color;
/// The alignment of the chat bubble.
  AxisAlignmentGeometry? alignment;
/// The border of the chat bubble.
  BorderSide? border;
/// The padding inside the chat bubble.
  EdgeInsetsGeometry? padding;
/// The border radius of the chat bubble.
  BorderRadiusGeometry? borderRadius;
/// The width factor of the chat bubble.
  double? widthFactor;
/// Creates a [ChatBubble].
///
/// Parameters:
/// - [child] (`Widget`, required): The content of the chat bubble.
/// - [type] (`ChatBubbleType?`, optional): The type of the chat bubble.
/// - [color] (`Color?`, optional): The background color of the chat bubble.
/// - [alignment] (`AxisAlignmentGeometry?`, optional): The alignment of the chat bubble.
/// - [border] (`BorderSide?`, optional): The border of the chat bubble.
/// - [padding] (`EdgeInsetsGeometry?`, optional): The padding inside the chat bubble.
/// - [borderRadius] (`BorderRadiusGeometry?`, optional): The border radius of the chat bubble.
/// - [widthFactor] (`double?`, optional): The width factor of the chat bubble.
  const ChatBubble({super.key, required this.child, this.type, this.color, this.alignment, this.border, this.padding, this.borderRadius, this.widthFactor});
  Widget build(BuildContext context);
}
/// Theme configuration for [CodeSnippet] components.
///
/// [CodeSnippetTheme] provides styling options for code snippet containers
/// including background colors, borders, padding, and visual appearance.
/// It integrates with the shadcn_flutter theming system to ensure consistent
/// styling across code display components.
///
/// Used with [ComponentTheme] to apply theme values throughout the widget tree.
///
/// Example:
/// ```dart
/// ComponentTheme<CodeSnippetTheme>(
///   data: CodeSnippetTheme(
///     backgroundColor: Colors.grey.shade900,
///     borderColor: Colors.grey.shade700,
///     borderWidth: 1.0,
///     borderRadius: BorderRadius.circular(8.0),
///     padding: EdgeInsets.all(16.0),
///   ),
///   child: MyCodeSnippetWidget(),
/// );
/// ```
class CodeSnippetTheme extends ComponentThemeData {
/// Background color of the code snippet container.
///
/// Type: `Color?`. Used as the background color for the code display area.
/// If null, uses the theme's default muted background color.
  Color? backgroundColor;
/// Border color of the code snippet container.
///
/// Type: `Color?`. Color used for the container border outline.
/// If null, uses the theme's default border color.
  Color? borderColor;
/// Border width of the code snippet container in logical pixels.
///
/// Type: `double?`. Thickness of the border around the code container.
/// If null, uses the theme's default border width.
  double? borderWidth;
/// Border radius for the code snippet container corners.
///
/// Type: `BorderRadiusGeometry?`. Controls corner rounding of the container.
/// If null, uses the theme's default radius for code components.
  BorderRadiusGeometry? borderRadius;
/// Padding for the code content area.
///
/// Type: `EdgeInsetsGeometry?`. Internal spacing around the code text.
/// If null, uses default padding appropriate for code display.
  EdgeInsetsGeometry? padding;
/// Creates a [CodeSnippetTheme].
///
/// All parameters are optional and will fall back to theme defaults
/// when not provided.
///
/// Parameters:
/// - [backgroundColor] (Color?, optional): Container background color
/// - [borderColor] (Color?, optional): Border outline color
/// - [borderWidth] (double?, optional): Border thickness in pixels
/// - [borderRadius] (BorderRadiusGeometry?, optional): Corner radius
/// - [padding] (EdgeInsetsGeometry?, optional): Content padding
///
/// Example:
/// ```dart
/// CodeSnippetTheme(
///   backgroundColor: Colors.black87,
///   borderRadius: BorderRadius.circular(12.0),
///   padding: EdgeInsets.all(20.0),
/// );
/// ```
  const CodeSnippetTheme({this.backgroundColor, this.borderColor, this.borderWidth, this.borderRadius, this.padding});
/// Creates a copy of this theme with the given values replaced.
///
/// Returns a new [CodeSnippetTheme] instance with the same values as this
/// theme, except for any parameters that are explicitly provided. Use
/// [ValueGetter] functions to specify new values.
///
/// Parameters are [ValueGetter] functions that return the new value when called.
/// This allows for conditional value setting and proper null handling.
///
/// Example:
/// ```dart
/// final newTheme = originalTheme.copyWith(
///   backgroundColor: () => Colors.blue.shade50,
///   padding: () => EdgeInsets.all(12.0),
/// );
/// ```
  CodeSnippetTheme copyWith({ValueGetter<Color?>? backgroundColor, ValueGetter<Color?>? borderColor, ValueGetter<double?>? borderWidth, ValueGetter<BorderRadiusGeometry?>? borderRadius, ValueGetter<EdgeInsetsGeometry?>? padding});
  bool operator ==(Object other);
  int get hashCode;
}
/// A syntax-highlighted code display widget with copy functionality.
///
/// [CodeSnippet] provides a professional code display component with automatic
/// syntax highlighting, copy-to-clipboard functionality, and customizable theming.
/// It supports multiple programming languages and provides a smooth user experience
/// with loading states and responsive scrolling.
///
/// ## Supported Languages
/// - **Core Languages**: Dart, JSON, YAML, SQL
/// - **Aliases**: JavaScript/TypeScript (mapped to Dart highlighting)
/// - **Fallback**: Plain text display for unsupported languages
///
/// ## Key Features
/// - **Syntax Highlighting**: Automatic language detection and coloring
/// - **Copy to Clipboard**: Built-in copy button with toast confirmation
/// - **Custom Actions**: Support for additional action buttons
/// - **Responsive Design**: Horizontal and vertical scrolling for long code
/// - **Theme Integration**: Automatic light/dark theme adaptation
/// - **Loading States**: Smooth loading indicators during initialization
///
/// ## Performance
/// The widget uses lazy initialization for syntax highlighters and caches
/// them for improved performance across multiple instances. Language
/// initialization occurs asynchronously to prevent UI blocking.
///
/// Example:
/// ```dart
/// CodeSnippet(
///   code: '''
/// void main() {
///   print('Hello, World!');
/// }
/// ''',
///   mode: 'dart',
///   constraints: BoxConstraints(maxHeight: 200),
///   actions: [
///     IconButton(
///       icon: Icon(Icons.share),
///       onPressed: () => shareCode(),
///     ),
///   ],
/// );
/// ```
class CodeSnippet extends StatefulWidget {
/// Optional constraints for the code display area.
///
/// Type: `BoxConstraints?`. Controls the maximum/minimum size of the
/// scrollable code container. Useful for limiting height in layouts.
  BoxConstraints? constraints;
/// The code widget to display (typically Text or RichText with syntax highlighting).
  Widget code;
/// Additional action widgets displayed in the top-right corner.
///
/// Type: `List<Widget>`. Custom action buttons shown alongside the
/// default copy button. Useful for share, edit, or other operations.
  List<Widget> actions;
/// Creates a [CodeSnippet] widget.
///
/// Displays syntax-highlighted code with automatic language detection,
/// copy functionality, and optional custom actions.
///
/// Parameters:
/// - [code] (String, required): The source code to display
/// - [mode] (String, required): Programming language for highlighting
/// - [constraints] (BoxConstraints?, optional): Size constraints for display area
/// - [actions] (`List<Widget>`, default: []): Additional action buttons
///
/// Example:
/// ```dart
/// CodeSnippet(
///   code: Text('print("Hello, World!");'),
///   mode: 'dart',
///   constraints: BoxConstraints(maxHeight: 150),
/// );
/// ```
  const CodeSnippet({super.key, this.constraints, this.actions = const [], required this.code});
  State<CodeSnippet> createState();
}
/// Theme configuration for spinner widgets.
class SpinnerTheme extends ComponentThemeData {
/// Color of the spinner elements.
  Color? color;
/// Size of the spinner widget.
  double? size;
/// Creates a [SpinnerTheme] with optional color and size.
  const SpinnerTheme({this.color, this.size});
/// Creates a copy of this theme with selectively replaced properties.
  SpinnerTheme copyWith({ValueGetter<Color?>? color, ValueGetter<double?>? size});
  bool operator ==(Object other);
  int get hashCode;
}
/// Base interface for spinner transformations.
///
/// Implementations define how spinner elements are transformed during animation.
abstract class SpinnerTransform {
}
/// Base interface for spinner visual elements.
///
/// Implementations define how to paint individual spinner components like
/// dots, lines, or arcs onto the canvas.
abstract class SpinnerElement {
/// Paints this spinner element onto the canvas.
///
/// Parameters:
/// - [canvas]: The canvas to paint on
/// - [size]: The size of the spinner widget
/// - [transform]: The current transformation matrix for animation
  void paint(Canvas canvas, Size size, Matrix4 transform);
}
/// Abstract base class for all spinner widgets.
///
/// [Spinner] provides common functionality for loading indicators including
/// color and size resolution from theme. Concrete implementations include
/// [CircularSpinner], [DotsSpinner], and others.
abstract class Spinner extends StatelessWidget {
/// Optional color override for the spinner.
///
/// If `null`, uses theme's spinner color or default foreground color.
  Color? color;
/// Optional size override for the spinner in logical pixels.
///
/// If `null`, uses theme's spinner size or a default size.
  double? size;
/// Creates a [Spinner] with optional color and size overrides.
  const Spinner({super.key, this.color, this.size});
/// Resolve spinner color considering theme overrides.
  Color? resolveColor(BuildContext context);
/// Resolve spinner size considering theme overrides and a default value.
  double resolveSize(BuildContext context, double defaultValue);
}
/// Theme configuration for [Avatar] and related avatar components.
///
/// [AvatarTheme] provides styling options for avatar components including size,
/// border radius, colors, and badge positioning. It enables consistent avatar
/// styling across an application while allowing per-instance customization.
///
/// Used with [ComponentTheme] to apply theme values throughout the widget tree.
///
/// Example:
/// ```dart
/// ComponentTheme<AvatarTheme>(
///   data: AvatarTheme(
///     size: 48.0,
///     borderRadius: 8.0,
///     backgroundColor: Colors.grey.shade200,
///     badgeAlignment: Alignment.topRight,
///     textStyle: TextStyle(color: Colors.black, fontWeight: FontWeight.w600),
///   ),
///   child: MyAvatarWidget(),
/// );
/// ```
class AvatarTheme extends ComponentThemeData {
/// Default size for avatar components in logical pixels.
///
/// Controls the width and height of avatar containers. If null, defaults
/// to 40 logical pixels scaled by theme scaling factor.
  double? size;
/// Border radius for avatar corners in logical pixels.
///
/// Creates rounded corners on avatar containers. If null, defaults to
/// theme radius multiplied by avatar size for proportional rounding.
  double? borderRadius;
/// Background color for avatar containers when displaying initials.
///
/// Used as the background color when no image is provided or when image
/// loading fails. If null, uses the muted color from theme color scheme.
  Color? backgroundColor;
/// Alignment of badge relative to the main avatar.
///
/// Controls where badges are positioned when attached to avatars.
/// If null, badges are positioned at a calculated offset based on avatar size.
  AlignmentGeometry? badgeAlignment;
/// Spacing between avatar and badge components.
///
/// Controls the gap between the main avatar and any attached badges.
/// If null, defaults to 4 logical pixels scaled by theme scaling factor.
  double? badgeGap;
/// Text style for avatar initials display.
///
/// Applied to text when displaying user initials in avatar containers.
/// If null, uses bold foreground color from theme.
  TextStyle? textStyle;
/// Creates an [AvatarTheme] with the specified styling options.
///
/// All parameters are optional and will fall back to component defaults
/// when not specified.
///
/// Parameters:
/// - [size] (double?, optional): Default size for avatars.
/// - [borderRadius] (double?, optional): Border radius for avatar corners.
/// - [backgroundColor] (Color?, optional): Background color for initials display.
/// - [badgeAlignment] (AlignmentGeometry?, optional): Badge positioning relative to avatar.
/// - [badgeGap] (double?, optional): Spacing between avatar and badge.
/// - [textStyle] (TextStyle?, optional): Text style for initials.
  const AvatarTheme({this.size, this.borderRadius, this.backgroundColor, this.badgeAlignment, this.badgeGap, this.textStyle});
/// Creates a copy of this theme with the given values replaced.
///
/// Uses [ValueGetter] functions to allow conditional updates where
/// null getters preserve the original value.
///
/// Example:
/// ```dart
/// final newTheme = originalTheme.copyWith(
///   size: () => 60.0,
///   backgroundColor: () => Colors.blue.shade100,
/// );
/// ```
  AvatarTheme copyWith({ValueGetter<double?>? size, ValueGetter<double?>? borderRadius, ValueGetter<Color?>? backgroundColor, ValueGetter<AlignmentGeometry?>? badgeAlignment, ValueGetter<double?>? badgeGap, ValueGetter<TextStyle?>? textStyle});
  bool operator ==(Object other);
  int get hashCode;
}
/// Abstract base class for avatar-related widgets.
///
/// [AvatarWidget] provides a common interface for avatar components, ensuring
/// they expose size and border radius properties that can be used by container
/// components like [AvatarGroup] for proper layout and clipping.
abstract class AvatarWidget extends Widget {
/// Creates an [AvatarWidget] with optional key.
  const AvatarWidget({super.key});
/// Size of the avatar widget in logical pixels.
///
/// Used by container widgets for layout calculations and clipping operations.
  double? get size;
/// Border radius of the avatar widget in logical pixels.
///
/// Used by container widgets for proper clipping and visual effects.
  double? get borderRadius;
}
/// A circular or rounded rectangular widget for displaying user profile images or initials.
///
/// [Avatar] provides a versatile component for representing users in UI interfaces.
/// It can display either an image (from network or other sources) or user initials,
/// with automatic fallback to initials when image loading fails. The avatar supports
/// optional badges for status indicators and integrates seamlessly with [AvatarGroup]
/// for overlapping avatar layouts.
///
/// ## Key Features
/// - **Flexible Content**: Supports both images and text initials
/// - **Automatic Fallback**: Falls back to initials when images fail to load
/// - **Badge Support**: Optional badge overlay for status or notification indicators
/// - **Network Images**: Built-in support for network images with caching
/// - **Theming**: Comprehensive theming via [AvatarTheme]
/// - **Group Integration**: Works with [AvatarGroup] for overlapping layouts
///
/// ## Initials Generation
/// The avatar includes intelligent initials generation via [getInitials]:
/// - For single words: First two characters (e.g., "John" ‚Üí "JO")
/// - For multiple words: First character of first two words (e.g., "John Doe" ‚Üí "JD")
/// - Proper capitalization and fallback handling
///
/// Example:
/// ```dart
/// Avatar(
///   initials: 'JD',
///   size: 48,
///   backgroundColor: Colors.blue.shade100,
///   badge: AvatarBadge(
///     color: Colors.green,
///     size: 12,
///   ),
/// );
/// ```
class Avatar extends StatefulWidget implements AvatarWidget {
/// Generates initials from a user's full name.
///
/// Creates appropriate initials for avatar display from a given name string.
/// Uses intelligent logic to extract meaningful characters:
/// - For single words: First two characters (e.g., "John" ‚Üí "JO")
/// - For multiple words: First character of first two words (e.g., "John Doe" ‚Üí "JD")
/// - Handles edge cases with proper capitalization
///
/// Parameters:
/// - [name] (String): The full name to extract initials from
///
/// Returns:
/// A [String] containing the generated initials, typically 1-2 characters.
///
/// Example:
/// ```dart
/// String initials1 = Avatar.getInitials('John Doe'); // Returns 'JD'
/// String initials2 = Avatar.getInitials('Madonna'); // Returns 'MA'
/// ```
  static String getInitials(String name);
/// User initials or text to display in the avatar.
///
/// Primary fallback content when no image is provided via [provider]
/// or when image loading fails. Should typically contain user's initials
/// or a short representative text.
  String initials;
/// Background color for the avatar when displaying initials.
///
/// Type: `Color?`. Used as the container background color when showing
/// [initials]. If null, defaults to the theme's muted color.
  Color? backgroundColor;
/// Size of the avatar in logical pixels.
///
/// Type: `double?`. Controls both width and height of the avatar container.
/// If null, defaults to theme.scaling * 40 pixels.
  double? size;
/// Border radius for avatar corners in logical pixels.
///
/// Type: `double?`. Creates rounded corners on the avatar container.
/// If null, defaults to theme.radius * size for proportional rounding.
  double? borderRadius;
/// Optional badge widget to overlay on the avatar.
///
/// Type: `AvatarWidget?`. Typically an [AvatarBadge] for status indicators.
/// Positioned according to [badgeAlignment] with [badgeGap] spacing.
  AvatarWidget? badge;
/// Position of the badge relative to the avatar.
///
/// Type: `AlignmentGeometry?`. Controls where the [badge] is positioned.
/// If null, uses a calculated offset based on avatar and badge sizes.
  AlignmentGeometry? badgeAlignment;
/// Spacing between the avatar and badge in logical pixels.
///
/// Type: `double?`. Controls the gap between the avatar edge and badge edge.
/// If null, defaults to theme.scaling * 4 pixels.
  double? badgeGap;
/// Image provider for displaying user photos.
///
/// Type: `ImageProvider?`. Can be any Flutter image provider (NetworkImage,
/// AssetImage, etc.). If null or loading fails, shows [initials] instead.
  ImageProvider? provider;
/// Creates an [Avatar] widget with optional image provider.
///
/// The default constructor creates an avatar that can display either an image
/// (via [provider]) or user initials. If no image provider is specified or
/// image loading fails, the avatar falls back to displaying [initials].
///
/// Parameters:
/// - [initials] (String, required): Text to display when no image is provided
///   or image loading fails. Should typically be user's initials.
/// - [backgroundColor] (Color?, optional): Background color for the initials
///   display. If null, uses theme's muted color.
/// - [size] (double?, optional): Width and height of the avatar in logical
///   pixels. If null, defaults to theme.scaling * 40.
/// - [borderRadius] (double?, optional): Corner radius in logical pixels.
///   If null, defaults to theme.radius * size for proportional rounding.
/// - [badge] (AvatarWidget?, optional): Optional badge overlay for status
///   indicators. Positioned according to [badgeAlignment].
/// - [badgeAlignment] (AlignmentGeometry?, optional): Position of the badge
///   relative to the avatar. If null, uses calculated offset based on sizes.
/// - [badgeGap] (double?, optional): Spacing between avatar and badge.
///   If null, defaults to theme.scaling * 4.
/// - [provider] (ImageProvider?, optional): Image to display. If null or
///   loading fails, shows [initials] instead.
///
/// Example:
/// ```dart
/// Avatar(
///   initials: 'JD',
///   size: 48,
///   backgroundColor: Colors.blue.shade100,
///   badge: AvatarBadge(color: Colors.green),
/// );
/// ```
  const Avatar({super.key, required this.initials, this.backgroundColor, this.size, this.borderRadius, this.badge, this.badgeAlignment, this.badgeGap, this.provider});
/// Creates an [Avatar] with a network image.
///
/// This named constructor automatically configures a [NetworkImage] provider
/// with optional image resizing for memory optimization. Falls back to
/// displaying [initials] if the network image fails to load.
///
/// Parameters:
/// - [initials] (String, required): Fallback text when image loading fails.
/// - [photoUrl] (String, required): URL of the network image to display.
/// - [cacheWidth] (int?, optional): Resize width for memory optimization.
///   If specified, image will be decoded at this width.
/// - [cacheHeight] (int?, optional): Resize height for memory optimization.
///   If specified, image will be decoded at this height.
/// - [backgroundColor] (Color?, optional): Background color for initials fallback.
/// - [size] (double?, optional): Avatar dimensions in logical pixels.
/// - [borderRadius] (double?, optional): Corner radius in logical pixels.
/// - [badge] (AvatarWidget?, optional): Optional badge overlay.
/// - [badgeAlignment] (AlignmentGeometry?, optional): Badge position.
/// - [badgeGap] (double?, optional): Spacing between avatar and badge.
///
/// Example:
/// ```dart
/// Avatar.network(
///   initials: 'JD',
///   photoUrl: 'https://example.com/photo.jpg',
///   cacheWidth: 100,
///   cacheHeight: 100,
/// );
/// ```
  Avatar.network({super.key, required this.initials, this.backgroundColor, this.size, this.borderRadius, this.badge, this.badgeAlignment, this.badgeGap, int? cacheWidth, int? cacheHeight, required String photoUrl});
  State<Avatar> createState();
}
/// A circular badge widget designed to overlay on [Avatar] components.
///
/// [AvatarBadge] provides a small circular indicator typically used to show
/// status information, notifications, or other contextual data on avatars.
/// The badge can contain custom content via [child] or display as a solid
/// colored circle for simple status indicators.
///
/// ## Features
/// - **Status Indicators**: Colored circles for online/offline status
/// - **Custom Content**: Support for icons, text, or other widgets
/// - **Theme Integration**: Uses primary color by default with theme radius
/// - **Size Flexibility**: Configurable dimensions with automatic scaling
///
/// ## Common Use Cases
/// - Online status indicators (green dot)
/// - Notification badges (red circle with count)
/// - Custom status icons (checkmarks, warnings)
///
/// Example:
/// ```dart
/// AvatarBadge(
///   size: 16,
///   color: Colors.green,
///   child: Icon(Icons.check, size: 10, color: Colors.white),
/// );
/// ```
class AvatarBadge extends StatelessWidget implements AvatarWidget {
/// Size of the badge in logical pixels.
///
/// Controls both width and height of the circular badge container.
/// If null, defaults to theme.scaling * 12.
  double? size;
/// Border radius for the badge corners in logical pixels.
///
/// If null, defaults to theme.radius * size for proportional rounding,
/// typically creating a circular badge.
  double? borderRadius;
/// Optional child widget to display inside the badge.
///
/// Can be an icon, text, or other widget. If null, displays as a
/// solid colored circle using [color].
  Widget? child;
/// Background color of the badge.
///
/// If null, defaults to the theme's primary color. Used as the
/// background color for the circular container.
  Color? color;
/// Creates an [AvatarBadge].
///
/// The badge can display either custom content via [child] or function
/// as a simple colored indicator.
///
/// Parameters:
/// - [child] (Widget?, optional): Content to display inside the badge.
///   If null, shows as a solid colored circle.
/// - [size] (double?, optional): Badge dimensions in logical pixels.
///   Defaults to theme.scaling * 12.
/// - [borderRadius] (double?, optional): Corner radius in logical pixels.
///   Defaults to theme.radius * size for circular appearance.
/// - [color] (Color?, optional): Background color. Defaults to theme primary.
///
/// Example:
/// ```dart
/// AvatarBadge(
///   color: Colors.red,
///   child: Text('5', style: TextStyle(color: Colors.white, fontSize: 8)),
/// );
/// ```
  const AvatarBadge({super.key, this.child, this.size, this.borderRadius, this.color});
  Widget build(BuildContext context);
}
/// A widget that arranges multiple [AvatarWidget]s in an overlapping layout.
///
/// [AvatarGroup] creates visually appealing overlapping arrangements of avatars,
/// commonly used to display multiple users or participants in a compact space.
/// It automatically handles clipping and positioning to create smooth overlapping
/// effects with configurable gaps and alignment directions.
///
/// ## Features
/// - **Overlapping Layout**: Automatic positioning with smooth overlapping
/// - **Directional Alignment**: Support for all 8 directional alignments
/// - **Smart Clipping**: Intelligent path clipping preserves rounded corners
/// - **Gap Control**: Configurable spacing between overlapping avatars
/// - **Size Adaptation**: Automatically adapts to different avatar sizes
///
/// ## Layout Behavior
/// The first avatar is positioned normally, while subsequent avatars are
/// positioned and clipped to create the overlapping effect. The [alignment]
/// parameter controls the direction of overlap, and [gap] controls the
/// spacing between avatars.
///
/// ## Factory Constructors
/// Convenient factory methods are provided for common alignment patterns:
/// - [toLeft], [toRight]: Horizontal overlapping
/// - [toStart], [toEnd]: Locale-aware horizontal overlapping
/// - [toTop], [toBottom]: Vertical overlapping
///
/// Example:
/// ```dart
/// AvatarGroup.toRight(
///   children: [
///     Avatar(initials: 'AB'),
///     Avatar(initials: 'CD'),
///     Avatar(initials: 'EF'),
///   ],
///   gap: 8.0,
/// );
/// ```
class AvatarGroup extends StatelessWidget {
/// List of avatar widgets to arrange in overlapping layout.
///
/// The first avatar in the list serves as the base position, with
/// subsequent avatars overlapping according to [alignment].
  List<AvatarWidget> children;
/// Controls the direction and amount of overlap between avatars.
///
/// Uses standard Flutter [AlignmentGeometry] values:
/// - Positive x values move subsequent avatars to the right
/// - Negative x values move subsequent avatars to the left
/// - Similar behavior for y axis with top/bottom movement
  AlignmentGeometry alignment;
/// Spacing between overlapping avatars in logical pixels.
///
/// Controls the gap between the edges of overlapping avatars.
/// If null, defaults to theme.scaling * 4.
  double? gap;
/// Clipping behavior for the avatar stack.
///
/// Controls how avatars are clipped at the group boundaries.
/// If null, defaults to [Clip.none].
  Clip? clipBehavior;
/// Creates an [AvatarGroup] with custom alignment.
///
/// This is the base constructor that allows full control over the
/// overlapping behavior through the [alignment] parameter.
///
/// Parameters:
/// - [alignment] (AlignmentGeometry, required): Direction of overlap
/// - [children] (`List<AvatarWidget>`, required): Avatars to arrange
/// - [gap] (double?, optional): Spacing between avatars
/// - [clipBehavior] (Clip?, optional): Clipping behavior
///
/// Example:
/// ```dart
/// AvatarGroup(
///   alignment: Alignment(0.5, 0),
///   children: [Avatar(initials: 'A'), Avatar(initials: 'B')],
///   gap: 6.0,
/// );
/// ```
  const AvatarGroup({super.key, required this.alignment, required this.children, this.gap, this.clipBehavior});
/// Creates an [AvatarGroup] with left-to-right overlapping.
///
/// Arranges avatars so that subsequent avatars overlap to the left side
/// of previous avatars, creating a rightward flow.
///
/// Parameters:
/// - [children] (`List<AvatarWidget>`, required): Avatars to arrange
/// - [gap] (double?, optional): Spacing between overlapping edges
/// - [offset] (double, default: 0.5): Amount of overlap (0.0 to 1.0)
///
/// Example:
/// ```dart
/// AvatarGroup.toLeft(
///   children: [Avatar(initials: 'A'), Avatar(initials: 'B')],
///   offset: 0.7,
/// );
/// ```
  factory AvatarGroup.toLeft({Key? key, required List<AvatarWidget> children, double? gap, double offset = 0.5});
/// Creates an [AvatarGroup] with right-to-left overlapping.
///
/// Arranges avatars so that subsequent avatars overlap to the right side
/// of previous avatars, creating a leftward flow.
///
/// Parameters:
/// - [children] (`List<AvatarWidget>`, required): Avatars to arrange
/// - [gap] (double?, optional): Spacing between overlapping edges
/// - [offset] (double, default: 0.5): Amount of overlap (0.0 to 1.0)
///
/// Example:
/// ```dart
/// AvatarGroup.toRight(
///   children: [Avatar(initials: 'A'), Avatar(initials: 'B')],
///   gap: 4.0,
/// );
/// ```
  factory AvatarGroup.toRight({Key? key, required List<AvatarWidget> children, double? gap, double offset = 0.5});
/// Creates an [AvatarGroup] with start-to-end overlapping.
///
/// Locale-aware version of [toLeft]. In LTR locales, behaves like [toLeft].
/// In RTL locales, behaves like [toRight].
///
/// Parameters:
/// - [children] (`List<AvatarWidget>`, required): Avatars to arrange
/// - [gap] (double?, optional): Spacing between overlapping edges
/// - [offset] (double, default: 0.5): Amount of overlap (0.0 to 1.0)
///
/// Example:
/// ```dart
/// AvatarGroup.toStart(
///   children: [Avatar(initials: 'A'), Avatar(initials: 'B')],
/// );
/// ```
  factory AvatarGroup.toStart({Key? key, required List<AvatarWidget> children, double? gap, double offset = 0.5});
/// Creates an [AvatarGroup] with end-to-start overlapping.
///
/// Locale-aware version of [toRight]. In LTR locales, behaves like [toRight].
/// In RTL locales, behaves like [toLeft].
///
/// Parameters:
/// - [children] (`List<AvatarWidget>`, required): Avatars to arrange
/// - [gap] (double?, optional): Spacing between overlapping edges
/// - [offset] (double, default: 0.5): Amount of overlap (0.0 to 1.0)
///
/// Example:
/// ```dart
/// AvatarGroup.toEnd(
///   children: [Avatar(initials: 'A'), Avatar(initials: 'B')],
/// );
/// ```
  factory AvatarGroup.toEnd({Key? key, required List<AvatarWidget> children, double? gap, double offset = 0.5});
/// Creates an [AvatarGroup] with top-to-bottom overlapping.
///
/// Arranges avatars so that subsequent avatars overlap toward the top
/// of previous avatars, creating a downward flow.
///
/// Parameters:
/// - [children] (`List<AvatarWidget>`, required): Avatars to arrange
/// - [gap] (double?, optional): Spacing between overlapping edges
/// - [offset] (double, default: 0.5): Amount of overlap (0.0 to 1.0)
///
/// Example:
/// ```dart
/// AvatarGroup.toTop(
///   children: [Avatar(initials: 'A'), Avatar(initials: 'B')],
/// );
/// ```
  factory AvatarGroup.toTop({Key? key, required List<AvatarWidget> children, double? gap, double offset = 0.5});
/// Creates an [AvatarGroup] with bottom-to-top overlapping.
///
/// Arranges avatars so that subsequent avatars overlap toward the bottom
/// of previous avatars, creating an upward flow.
///
/// Parameters:
/// - [children] (`List<AvatarWidget>`, required): Avatars to arrange
/// - [gap] (double?, optional): Spacing between overlapping edges
/// - [offset] (double, default: 0.5): Amount of overlap (0.0 to 1.0)
///
/// Example:
/// ```dart
/// AvatarGroup.toBottom(
///   children: [Avatar(initials: 'A'), Avatar(initials: 'B')],
/// );
/// ```
  factory AvatarGroup.toBottom({Key? key, required List<AvatarWidget> children, double? gap, double offset = 0.5});
  Widget build(BuildContext context);
}
/// Custom clipper for creating overlapping avatar group effects.
///
/// Clips avatars to create a stacked appearance where each avatar partially
/// overlaps the previous one, accounting for border radius and alignment.
class AvatarGroupClipper extends CustomClipper<Path> {
/// The border radius for rounded corners on avatars.
  double borderRadius;
/// The alignment of avatars within the group.
  Alignment alignment;
/// The size of the previous avatar in the stack.
  double previousAvatarSize;
/// The gap between overlapping avatars.
  double gap;
/// Creates an avatar group clipper with the specified parameters.
  const AvatarGroupClipper({required this.borderRadius, required this.alignment, required this.previousAvatarSize, required this.gap});
  Path getClip(Size size);
  bool shouldReclip(covariant AvatarGroupClipper oldClipper);
}
/// Theme configuration for calendar widgets.
///
/// Provides styling options for calendar components, including arrow icon colors
/// for navigation buttons and other visual elements.
class CalendarTheme extends ComponentThemeData {
/// Color of navigation arrow icons.
  Color? arrowIconColor;
/// Creates a [CalendarTheme].
///
/// Parameters:
/// - [arrowIconColor] (`Color?`, optional): Color for navigation arrow icons.
  const CalendarTheme({this.arrowIconColor});
/// Creates a copy of this theme with the given fields replaced.
  CalendarTheme copyWith({ValueGetter<Color?>? arrowIconColor});
  bool operator ==(Object other);
  int get hashCode;
}
/// Defines the different view types available in calendar components.
///
/// Specifies what granularity of time selection is displayed.
enum CalendarViewType { date, month, year }
/// Represents the interactive state of a date in the calendar.
///
/// Controls whether a specific date can be selected or interacted with.
enum DateState { disabled, enabled }
/// Selection modes available for calendar components.
///
/// Determines how users can select dates in calendar widgets.
enum CalendarSelectionMode { none, single, range, multi }
/// A date picker dialog that provides comprehensive date selection capabilities.
///
/// Displays a modal dialog containing a calendar interface with support for
/// different view types (date, month, year), selection modes (single, range, multi),
/// and customizable date states. Includes navigation controls and responsive layouts.
///
/// Features:
/// - Multiple view types: date grid, month grid, year grid
/// - Various selection modes: single date, date range, multiple dates
/// - Navigation arrows with keyboard support
/// - Customizable date state validation
/// - Dual-calendar layout for range selection
/// - Theme integration and localization support
///
/// Example:
/// ```dart
/// DatePickerDialog(
///   initialViewType: CalendarViewType.date,
///   selectionMode: CalendarSelectionMode.single,
///   initialValue: CalendarValue.single(DateTime.now()),
///   onChanged: (value) => print('Selected: $value'),
/// )
/// ```
class DatePickerDialog extends StatefulWidget {
/// The initial view type to display (date, month, or year grid).
  CalendarViewType initialViewType;
/// The initial calendar view position (month/year to display).
  CalendarView? initialView;
/// The selection mode determining how dates can be selected.
  CalendarSelectionMode selectionMode;
/// Alternative view mode for display purposes.
  CalendarSelectionMode? viewMode;
/// The initially selected date value(s).
  CalendarValue? initialValue;
/// Callback invoked when the selected date(s) change.
  ValueChanged<CalendarValue?>? onChanged;
/// Builder function to determine the state of each date.
  DateStateBuilder? stateBuilder;
/// Creates a [DatePickerDialog] with comprehensive date selection options.
///
/// Configures the dialog's initial state, selection behavior, and callbacks
/// for handling date changes and validation.
///
/// Parameters:
/// - [initialViewType] (CalendarViewType, required): Starting view (date/month/year)
/// - [initialView] (CalendarView?, optional): Initial calendar view position
/// - [selectionMode] (CalendarSelectionMode, required): How dates can be selected
/// - [viewMode] (CalendarSelectionMode?, optional): Alternative view mode for display
/// - [initialValue] (CalendarValue?, optional): Pre-selected date(s)
/// - [onChanged] (`ValueChanged<CalendarValue>?`, optional): Called when selection changes
/// - [stateBuilder] (DateStateBuilder?, optional): Custom date state validation
///
/// Example:
/// ```dart
/// DatePickerDialog(
///   initialViewType: CalendarViewType.date,
///   selectionMode: CalendarSelectionMode.range,
///   onChanged: (value) => handleDateChange(value),
///   stateBuilder: (date) => date.isBefore(DateTime.now())
///     ? DateState.disabled
///     : DateState.enabled,
/// )
/// ```
  const DatePickerDialog({super.key, required this.initialViewType, this.initialView, required this.selectionMode, this.viewMode, this.initialValue, this.onChanged, this.stateBuilder});
  State<DatePickerDialog> createState();
}
/// Abstract base class representing calendar selection values.
///
/// Provides a unified interface for different types of calendar selections including
/// single dates, date ranges, and multiple date collections. Handles date lookup
/// operations and conversion between different selection types.
///
/// Subclasses include:
/// - [SingleCalendarValue]: Represents a single selected date
/// - [RangeCalendarValue]: Represents a date range with start and end
/// - [MultiCalendarValue]: Represents multiple individual selected dates
///
/// The class provides factory constructors for easy creation and conversion
/// methods to transform between different selection types as needed.
///
/// Example:
/// ```dart
/// // Create different value types
/// final single = CalendarValue.single(DateTime.now());
/// final range = CalendarValue.range(startDate, endDate);
/// final multi = CalendarValue.multi([date1, date2, date3]);
///
/// // Check if a date is selected
/// final lookup = value.lookup(2024, 3, 15);
/// final isSelected = lookup != CalendarValueLookup.none;
/// ```
abstract class CalendarValue {
/// Looks up whether the specified date is part of this calendar value.
///
/// Returns a [CalendarValueLookup] indicating the relationship of the
/// queried date to this value (none, selected, start, end, or inRange).
  CalendarValueLookup lookup(int year, [int? month = 1, int? day = 1]);
/// Creates a base calendar value.
  const CalendarValue();
/// Factory constructor to create a single date value.
  static SingleCalendarValue single(DateTime date);
/// Factory constructor to create a date range value.
  static RangeCalendarValue range(DateTime start, DateTime end);
/// Factory constructor to create a multi-date value.
  static MultiCalendarValue multi(List<DateTime> dates);
/// Converts this value to a single calendar value.
  SingleCalendarValue toSingle();
/// Converts this value to a range calendar value.
  RangeCalendarValue toRange();
/// Converts this value to a multi calendar value.
  MultiCalendarValue toMulti();
/// Returns the calendar view associated with this value.
  CalendarView get view;
}
/// Calendar value representing a single selected date.
///
/// Encapsulates a single [DateTime] selection and provides lookup functionality
/// to determine if a given date matches the selected date. Used primarily
/// with [CalendarSelectionMode.single].
///
/// Example:
/// ```dart
/// final singleValue = SingleCalendarValue(DateTime(2024, 3, 15));
/// final lookup = singleValue.lookup(2024, 3, 15);
/// print(lookup == CalendarValueLookup.selected); // true
/// ```
class SingleCalendarValue extends CalendarValue {
/// The selected date.
  DateTime date;
/// Creates a single calendar value with the specified date.
  SingleCalendarValue(this.date);
  CalendarValueLookup lookup(int year, [int? month, int? day]);
  CalendarView get view;
  String toString();
  bool operator ==(Object other);
  int get hashCode;
  SingleCalendarValue toSingle();
  RangeCalendarValue toRange();
  MultiCalendarValue toMulti();
}
/// Calendar value representing a date range selection.
///
/// Encapsulates a date range with start and end dates. Provides lookup
/// functionality to determine if a date is the start, end, within the range,
/// or outside. Used with [CalendarSelectionMode.range].
///
/// The range is automatically normalized so start is always before or equal to end.
class RangeCalendarValue extends CalendarValue {
/// The start date of the range (always <= end).
  DateTime start;
/// The end date of the range (always >= start).
  DateTime end;
/// Creates a range calendar value with the specified start and end dates.
///
/// Automatically normalizes the range so [start] is before [end].
  RangeCalendarValue(DateTime start, DateTime end);
  CalendarValueLookup lookup(int year, [int? month, int? day]);
  CalendarView get view;
  String toString();
  bool operator ==(Object other);
  int get hashCode;
  SingleCalendarValue toSingle();
  RangeCalendarValue toRange();
  MultiCalendarValue toMulti();
}
/// Calendar value representing multiple selected dates.
///
/// Encapsulates a list of individually selected dates. Provides lookup
/// functionality to determine if a date is among the selected dates.
/// Used with [CalendarSelectionMode.multi].
class MultiCalendarValue extends CalendarValue {
/// The list of selected dates.
  List<DateTime> dates;
/// Creates a multi calendar value with the specified list of dates.
  MultiCalendarValue(this.dates);
  CalendarValueLookup lookup(int year, [int? month, int? day]);
  CalendarView get view;
  String toString();
  bool operator ==(Object other);
  int get hashCode;
  SingleCalendarValue toSingle();
  RangeCalendarValue toRange();
  MultiCalendarValue toMulti();
}
/// Result type for calendar value lookup operations.
///
/// Indicates the relationship between a queried date and the current calendar selection.
enum CalendarValueLookup { none, selected, start, end, inRange }
/// Represents a specific month and year view in calendar navigation.
///
/// Provides immutable representation of a calendar's current viewing position
/// with navigation methods to move between months and years. Used to control
/// which month/year combination is displayed in calendar grids.
///
/// Key Features:
/// - **Navigation Methods**: [next], [previous], [nextYear], [previousYear]
/// - **Factory Constructors**: [now()], [fromDateTime()]
/// - **Validation**: Ensures month values stay within 1-12 range
/// - **Immutable**: All navigation returns new CalendarView instances
///
/// Example:
/// ```dart
/// // Create views for different dates
/// final current = CalendarView.now();
/// final specific = CalendarView(2024, 3); // March 2024
/// final fromDate = CalendarView.fromDateTime(someDateTime);
///
/// // Navigate between months
/// final nextMonth = current.next;
/// final prevMonth = current.previous;
/// final nextYear = current.nextYear;
/// ```
class CalendarView {
/// The year component of this view.
  int year;
/// The month component of this view (1-12).
  int month;
/// Creates a [CalendarView] for the specified year and month.
///
/// Parameters:
/// - [year] (int): Four-digit year value
/// - [month] (int): Month number (1-12, where 1 = January)
///
/// Throws [AssertionError] if month is not between 1 and 12.
///
/// Example:
/// ```dart
/// final view = CalendarView(2024, 3); // March 2024
/// ```
  CalendarView(this.year, this.month);
/// Creates a [CalendarView] for the current month and year.
///
/// Uses [DateTime.now()] to determine the current date and extracts
/// the year and month components.
///
/// Example:
/// ```dart
/// final currentView = CalendarView.now();
/// ```
  factory CalendarView.now();
/// Creates a [CalendarView] from an existing [DateTime].
///
/// Extracts the year and month components from the provided [DateTime]
/// and creates a corresponding calendar view.
///
/// Parameters:
/// - [dateTime] (DateTime): Date to extract year and month from
///
/// Example:
/// ```dart
/// final birthday = DateTime(1995, 7, 15);
/// final view = CalendarView.fromDateTime(birthday); // July 1995
/// ```
  factory CalendarView.fromDateTime(DateTime dateTime);
/// Returns a view for the next month.
///
/// Advances to the next month, rolling over to January of the next year
/// if the current month is December.
  CalendarView get next;
/// Returns a view for the previous month.
///
/// Moves back to the previous month, rolling back to December of the previous
/// year if the current month is January.
  CalendarView get previous;
/// Returns a view for the next year with the same month.
  CalendarView get nextYear;
/// Returns a view for the previous year with the same month.
  CalendarView get previousYear;
  String toString();
  bool operator ==(Object other);
  int get hashCode;
/// Creates a copy of this view with the given fields replaced.
  CalendarView copyWith({ValueGetter<int>? year, ValueGetter<int>? month});
}
/// Extension methods on [DateTime] for calendar operations.
extension CalendarDateTime on DateTime {
/// Converts this DateTime to a CalendarView.
  CalendarView toCalendarView();
/// Converts this DateTime to a single CalendarValue.
  CalendarValue toCalendarValue();
}
/// A highly customizable calendar widget supporting multiple selection modes.
///
/// Displays a grid-based calendar interface allowing users to view and select dates
/// with comprehensive support for single selection, range selection, and multiple
/// date selection. Includes built-in date validation, state management, and theme integration.
///
/// Key Features:
/// - **Selection Modes**: Single date, date range, multiple dates, or display-only
/// - **Date Validation**: Custom date state builder for enabling/disabling dates
/// - **Interactive Grid**: Touch/click support with visual feedback
/// - **Theme Integration**: Follows shadcn_flutter design system
/// - **Accessibility**: Screen reader and keyboard navigation support
/// - **Customizable Appearance**: Themed colors, spacing, and visual states
///
/// The calendar automatically handles date logic, leap years, month boundaries,
/// and provides consistent visual feedback for different selection states.
///
/// Selection Behavior:
/// - **Single**: Click to select one date, click again to deselect
/// - **Range**: Click start date, then end date to form range
/// - **Multi**: Click multiple dates to build selection set
/// - **None**: Display-only mode with no interaction
///
/// Example:
/// ```dart
/// Calendar(
///   view: CalendarView.now(),
///   selectionMode: CalendarSelectionMode.range,
///   value: CalendarValue.range(startDate, endDate),
///   onChanged: (value) => setState(() => selectedDates = value),
///   stateBuilder: (date) => date.isBefore(DateTime.now())
///     ? DateState.disabled
///     : DateState.enabled,
/// )
/// ```
class Calendar extends StatefulWidget {
/// The current date for highlighting purposes (defaults to DateTime.now()).
  DateTime? now;
/// The currently selected date value(s).
  CalendarValue? value;
/// The month and year view to display in the calendar.
  CalendarView view;
/// The selection mode determining how dates can be selected.
  CalendarSelectionMode selectionMode;
/// Callback invoked when the selected date(s) change.
  ValueChanged<CalendarValue?>? onChanged;
/// Legacy function to determine if a date should be enabled.
  bool Function(DateTime date)? isDateEnabled;
/// Builder function to determine the state of each date.
  DateStateBuilder? stateBuilder;
/// Creates a [Calendar] widget with flexible date selection capabilities.
///
/// Configures the calendar's view, selection behavior, and interaction handling
/// with comprehensive options for customization and validation.
///
/// Parameters:
/// - [view] (CalendarView, required): Month/year to display in calendar grid
/// - [selectionMode] (CalendarSelectionMode, required): How dates can be selected
/// - [now] (DateTime?, optional): Current date for highlighting, defaults to DateTime.now()
/// - [value] (CalendarValue?, optional): Currently selected date(s)
/// - [onChanged] (`ValueChanged<CalendarValue>?`, optional): Called when selection changes
/// - [isDateEnabled] (bool Function(DateTime)?, optional): Legacy date validation function
/// - [stateBuilder] (DateStateBuilder?, optional): Custom date state validation
///
/// The [view] parameter determines which month and year are shown in the calendar grid.
/// Use [CalendarView.now()] for current month or [CalendarView(year, month)] for specific dates.
///
/// The [stateBuilder] takes precedence over [isDateEnabled] when both are provided.
///
/// Example:
/// ```dart
/// Calendar(
///   view: CalendarView(2024, 3), // March 2024
///   selectionMode: CalendarSelectionMode.single,
///   onChanged: (value) => print('Selected: ${value?.toString()}'),
///   stateBuilder: (date) => date.weekday == DateTime.sunday
///     ? DateState.disabled
///     : DateState.enabled,
/// )
/// ```
  const Calendar({super.key, this.now, this.value, required this.view, required this.selectionMode, this.onChanged, this.isDateEnabled, this.stateBuilder});
  State<Calendar> createState();
}
/// A calendar widget that displays months in a year grid.
///
/// Shows a 4x3 grid of months for year selection. Used as part of the calendar
/// navigation when users want to select a different month.
class MonthCalendar extends StatelessWidget {
/// The current calendar view (year to display).
  CalendarView value;
/// Callback invoked when a month is selected.
  ValueChanged<CalendarView> onChanged;
/// The current date for highlighting purposes.
  DateTime? now;
/// The currently selected calendar value.
  CalendarValue? calendarValue;
/// Builder function to determine the state of each month.
  DateStateBuilder? stateBuilder;
/// Creates a month selection calendar.
  const MonthCalendar({super.key, required this.value, required this.onChanged, this.now, this.calendarValue, this.stateBuilder});
  Widget build(BuildContext context);
}
/// A calendar widget that displays years in a grid.
///
/// Shows a 4x4 grid of years for year selection. Used as part of the calendar
/// navigation when users want to select a different year.
class YearCalendar extends StatelessWidget {
/// The starting year for the grid display.
  int yearSelectStart;
/// The currently selected year value.
  int value;
/// Callback invoked when a year is selected.
  ValueChanged<int> onChanged;
/// The current date for highlighting purposes.
  DateTime? now;
/// The currently selected calendar value.
  CalendarValue? calendarValue;
/// Builder function to determine the state of each year.
  DateStateBuilder? stateBuilder;
/// Creates a year selection calendar.
  const YearCalendar({super.key, required this.yearSelectStart, required this.value, required this.onChanged, this.now, this.calendarValue, this.stateBuilder});
  Widget build(BuildContext context);
}
/// Visual states for individual calendar date items.
///
/// Defines the different visual appearances and behaviors that calendar date cells
/// can have based on their selection state and position within ranges.
enum CalendarItemType { none, today, selected, inRange, startRange, endRange, startRangeSelected, endRangeSelected, startRangeSelectedShort, endRangeSelectedShort, inRangeSelectedShort }
/// Individual calendar date cell with interactive behavior and visual states.
///
/// Represents a single date item within a calendar grid, handling touch interactions,
/// visual state management, and theme integration. Supports different visual states
/// for selection, ranges, and special dates like today.
///
/// Key Features:
/// - **Visual States**: Multiple appearance modes based on selection status
/// - **Interactive**: Touch/click handling with callbacks
/// - **Responsive Sizing**: Configurable width/height with theme scaling
/// - **Accessibility**: Screen reader support and focus management
/// - **State Management**: Enabled/disabled states with visual feedback
/// - **Range Support**: Special styling for range start/end/middle positions
///
/// The item automatically applies appropriate button styling based on its [type]
/// and handles edge cases for range visualization at row boundaries.
///
/// Example:
/// ```dart
/// CalendarItem(
///   type: CalendarItemType.selected,
///   indexAtRow: 2,
///   rowCount: 7,
///   state: DateState.enabled,
///   onTap: () => handleDateTap(date),
///   child: Text('15'),
/// )
/// ```
class CalendarItem extends StatelessWidget {
/// The widget to display as the date content.
  Widget child;
/// The visual state type for this calendar item.
  CalendarItemType type;
/// Callback invoked when the item is tapped.
  VoidCallback? onTap;
/// The position of this item in its row (0-indexed).
  int indexAtRow;
/// The total number of items per row.
  int rowCount;
/// Optional fixed width for the item.
  double? width;
/// Optional fixed height for the item.
  double? height;
/// The interaction state of this date (enabled/disabled).
  DateState state;
/// Creates a calendar item with the specified properties.
  const CalendarItem({super.key, required this.child, required this.type, required this.indexAtRow, required this.rowCount, this.onTap, this.width, this.height, required this.state});
  Widget build(BuildContext context);
}
/// Data structure representing a complete calendar month grid.
///
/// Contains all the information needed to render a calendar grid including
/// dates from the current month and overflow dates from adjacent months
/// to fill complete weeks.
class CalendarGridData {
/// The month number (1-12) this grid represents.
  int month;
/// The year this grid represents.
  int year;
/// The list of calendar grid items including current and adjacent month dates.
  List<CalendarGridItem> items;
/// Creates calendar grid data for the specified month and year.
///
/// Automatically calculates and includes dates from previous and next months
/// to fill complete weeks in the grid.
  factory CalendarGridData({required int month, required int year});
  bool operator ==(Object other);
  int get hashCode;
}
/// Individual item within a calendar grid representing a single date cell.
///
/// Contains metadata about a date's position and state within the calendar grid.
class CalendarGridItem {
/// The date this grid item represents.
  DateTime date;
/// The index of this item within its row (0-6 for day of week).
  int indexInRow;
/// The row index in the calendar grid.
  int rowIndex;
/// Whether this date belongs to a different month than the grid's primary month.
  bool fromAnotherMonth;
/// Creates a calendar grid item.
  CalendarGridItem(this.date, this.indexInRow, this.fromAnotherMonth, this.rowIndex);
/// Returns true if this item represents today's date.
  bool get isToday;
  bool operator ==(Object other);
  int get hashCode;
}
/// Widget that renders a calendar grid using provided data.
///
/// Takes calendar grid data and an item builder to render the visual grid
/// of calendar dates. Handles layout and arrangement of dates in a weekly grid.
class CalendarGrid extends StatelessWidget {
/// The grid data containing all calendar items to display.
  CalendarGridData data;
/// Builder function to create widgets for each grid item.
  Widget Function(CalendarGridItem item) itemBuilder;
/// Creates a calendar grid widget.
  const CalendarGrid({super.key, required this.data, required this.itemBuilder});
  Widget build(BuildContext context);
}
/// Theme for [HorizontalResizableDragger] and [VerticalResizableDragger].
class ResizableDraggerTheme extends ComponentThemeData {
/// Background color of the dragger.
  Color? color;
/// Border radius of the dragger.
  double? borderRadius;
/// Width of the dragger.
  double? width;
/// Height of the dragger.
  double? height;
/// Icon size inside the dragger.
  double? iconSize;
/// Icon color inside the dragger.
  Color? iconColor;
/// Creates a [ResizableDraggerTheme].
  const ResizableDraggerTheme({this.color, this.borderRadius, this.width, this.height, this.iconSize, this.iconColor});
/// Creates a copy of this theme with the given fields replaced.
  ResizableDraggerTheme copyWith({ValueGetter<Color?>? color, ValueGetter<double?>? borderRadius, ValueGetter<double?>? width, ValueGetter<double?>? height, ValueGetter<double?>? iconSize, ValueGetter<Color?>? iconColor});
  bool operator ==(Object other);
  int get hashCode;
}
/// A Horizontal dragger that can be used as a divider between resizable panes.
class HorizontalResizableDragger extends StatelessWidget {
/// Creates a [HorizontalResizableDragger].
  const HorizontalResizableDragger({super.key});
  Widget build(BuildContext context);
}
/// A Vertical dragger that can be used as a divider between resizable panes.
class VerticalResizableDragger extends StatelessWidget {
/// Creates a [VerticalResizableDragger].
  const VerticalResizableDragger({super.key});
  Widget build(BuildContext context);
}
/// Represents the position of a panel relative to another panel.
///
/// Used to specify which neighboring panel should be affected when
/// expanding or collapsing a resizable panel.
enum PanelSibling { before, after, both }
/// Mixin for controllers that manage resizable pane sizing.
///
/// Provides methods to resize, collapse, and expand panels programmatically.
/// Implementations include [AbsoluteResizablePaneController] for fixed sizes
/// and [FlexibleResizablePaneController] for flexible/proportional sizes.
mixin ResizablePaneController implements ValueListenable<double> {
/// Resizes the controller to the given [newSize] within the [paneSize] bounds.
  void resize(double newSize, double paneSize);
/// Collapses the panel to its minimum size.
  void collapse();
/// Expands the panel to its maximum or default size.
  void expand();
/// Computes the actual size based on [paneSize] and optional constraints.
  double computeSize(double paneSize, {double? minSize, double? maxSize});
/// Whether the panel is currently collapsed.
  bool get collapsed;
/// Attempts to expand by [size] pixels in the specified [direction].
///
/// Returns `true` if successful, `false` if expansion was blocked.
  bool tryExpandSize(double size, [PanelSibling direction = PanelSibling.both]);
/// Attempts to expand the panel in the specified [direction].
///
/// Returns `true` if successful, `false` if expansion was blocked.
  bool tryExpand([PanelSibling direction = PanelSibling.both]);
/// Attempts to collapse the panel in the specified [direction].
///
/// Returns `true` if successful, `false` if collapse was blocked.
  bool tryCollapse([PanelSibling direction = PanelSibling.both]);
}
/// Controller for resizable panes with absolute (fixed) sizing.
///
/// Manages a panel with a specific pixel size that can be adjusted through
/// dragging or programmatic control. Size is maintained as an absolute value.
///
/// Example:
/// ```dart
/// final controller = AbsoluteResizablePaneController(200);
///
/// ResizablePane(
///   controller: controller,
///   child: Container(color: Colors.blue),
/// )
/// ```
class AbsoluteResizablePaneController extends ChangeNotifier with ResizablePaneController {
/// Creates an [AbsoluteResizablePaneController].
///
/// Parameters:
/// - [_size] (`double`, required): Initial absolute size in pixels.
/// - [collapsed] (`bool`, default: `false`): Initial collapsed state.
  AbsoluteResizablePaneController(this._size, {bool collapsed = false});
  double get value;
  bool get collapsed;
  set size(double value);
  void collapse();
  void expand();
  void resize(double newSize, double paneSize, {double? minSize, double? maxSize});
  double computeSize(double paneSize, {double? minSize, double? maxSize});
}
/// Controller for resizable panes with flexible (proportional) sizing.
///
/// Manages a panel whose size is specified as a flex factor relative to
/// the total available space. Similar to Flutter's [Flexible] widget concept.
///
/// Example:
/// ```dart
/// final controller = FlexibleResizablePaneController(1.0);
///
/// ResizablePane(
///   controller: controller,
///   child: Container(color: Colors.red),
/// )
/// ```
class FlexibleResizablePaneController extends ChangeNotifier with ResizablePaneController {
/// Creates a [FlexibleResizablePaneController].
///
/// Parameters:
/// - [_flex] (`double`, required): Initial flex factor.
/// - [collapsed] (`bool`, default: `false`): Initial collapsed state.
  FlexibleResizablePaneController(this._flex, {bool collapsed = false});
  double get value;
  bool get collapsed;
  set flex(double value);
  void collapse();
  void expand();
  void resize(double newSize, double paneSize, {double? minSize, double? maxSize});
  double computeSize(double paneSize, {double? minSize, double? maxSize});
}
/// A resizable panel that can be part of a [ResizablePanel] layout.
///
/// Represents a single pane in a resizable layout that can be resized by
/// dragging handles between panes. Supports absolute sizing, flex-based sizing,
/// and external controller management.
///
/// Three constructor variants:
/// - Default: Fixed absolute size in pixels
/// - [ResizablePane.flex]: Proportional flex-based sizing
/// - [ResizablePane.controlled]: Externally controlled via [ResizablePaneController]
///
/// Example:
/// ```dart
/// ResizablePanel(
///   children: [
///     ResizablePane(
///       initialSize: 200,
///       minSize: 100,
///       child: Container(color: Colors.blue),
///     ),
///     ResizablePane.flex(
///       initialFlex: 2,
///       child: Container(color: Colors.red),
///     ),
///   ],
/// )
/// ```
class ResizablePane extends StatefulWidget {
/// Optional external controller for managing this pane's size.
  ResizablePaneController? controller;
/// Initial size in pixels (for absolute sizing).
  double? initialSize;
/// Initial flex factor (for flexible sizing).
  double? initialFlex;
/// Minimum size constraint in pixels.
  double? minSize;
/// Maximum size constraint in pixels.
  double? maxSize;
/// Size when collapsed (defaults to 0).
  double? collapsedSize;
/// Child widget to display in this pane.
  Widget child;
/// Callback when resize drag starts.
  ValueChanged<double>? onSizeChangeStart;
/// Callback during resize drag.
  ValueChanged<double>? onSizeChange;
/// Callback when resize drag ends.
  ValueChanged<double>? onSizeChangeEnd;
/// Callback when resize drag is cancelled.
  ValueChanged<double>? onSizeChangeCancel;
/// Whether the pane starts collapsed.
  bool? initialCollapsed;
/// Creates a [ResizablePane] with absolute pixel sizing.
  const ResizablePane({super.key, required double this.initialSize, this.minSize, this.maxSize, this.collapsedSize, required this.child, this.onSizeChangeStart, this.onSizeChange, this.onSizeChangeEnd, this.onSizeChangeCancel, bool this.initialCollapsed = false});
/// Creates a [ResizablePane] with flex-based proportional sizing.
  const ResizablePane.flex({super.key, double this.initialFlex = 1, this.minSize, this.maxSize, this.collapsedSize, required this.child, this.onSizeChangeStart, this.onSizeChange, this.onSizeChangeEnd, this.onSizeChangeCancel, bool this.initialCollapsed = false});
/// Creates a [ResizablePane] controlled by an external [controller].
  const ResizablePane.controlled({super.key, required ResizablePaneController this.controller, this.minSize, this.maxSize, this.collapsedSize, required this.child, this.onSizeChangeStart, this.onSizeChange, this.onSizeChangeEnd, this.onSizeChangeCancel});
  State<ResizablePane> createState();
}
/// A container widget that creates resizable panels separated by interactive dividers.
///
/// This widget provides a flexible layout system where multiple child panes
/// can be resized by the user through draggable dividers. It supports both
/// horizontal and vertical orientations, allowing users to adjust the relative
/// sizes of the contained panels by dragging the separators between them.
///
/// Each [ResizablePane] child can have its own sizing constraints, minimum and
/// maximum sizes, and collapse behavior. The panel automatically manages the
/// distribution of available space and handles user interactions for resizing.
///
/// Example:
/// ```dart
/// ResizablePanel.horizontal(
///   children: [
///     ResizablePane(
///       child: Container(color: Colors.red),
///       minSize: 100,
///       defaultSize: 200,
///     ),
///     ResizablePane(
///       child: Container(color: Colors.blue),
///       flex: 1,
///     ),
///     ResizablePane(
///       child: Container(color: Colors.green),
///       defaultSize: 150,
///       maxSize: 300,
///     ),
///   ],
/// );
/// ```
class ResizablePanel extends StatefulWidget {
/// Default builder for dividers between resizable panes.
///
/// Creates appropriate divider widgets based on the panel orientation:
/// - Horizontal panels get vertical dividers
/// - Vertical panels get horizontal dividers
///
/// This is the default value for [dividerBuilder] when none is specified.
  static Widget? defaultDividerBuilder(BuildContext context);
/// Default builder for interactive drag handles between resizable panes.
///
/// Creates appropriate dragger widgets based on the panel orientation:
/// - Horizontal panels get vertical draggers
/// - Vertical panels get horizontal draggers
///
/// This is the default value for [draggerBuilder] when none is specified.
  static Widget? defaultDraggerBuilder(BuildContext context);
/// The axis along which the panels are arranged and can be resized.
///
/// When [Axis.horizontal], panels are arranged left-to-right with vertical
/// dividers between them. When [Axis.vertical], panels are arranged
/// top-to-bottom with horizontal dividers between them.
  Axis direction;
/// The list of resizable panes that make up this panel.
///
/// Each pane can specify its own sizing constraints, default size, and
/// collapse behavior. At least two panes are typically needed to create
/// a meaningful resizable interface.
  List<ResizablePane> children;
/// Optional builder for creating divider widgets between panes.
///
/// Called to create the visual separator between adjacent panes. If null,
/// uses [defaultDividerBuilder] to create appropriate dividers based on
/// the panel orientation.
  OptionalWidgetBuilder? dividerBuilder;
/// Optional builder for creating interactive drag handles between panes.
///
/// Called to create draggable resize handles between adjacent panes. These
/// handles allow users to adjust pane sizes. If null, no drag handles are
/// displayed but dividers may still be present if [dividerBuilder] is set.
  OptionalWidgetBuilder? draggerBuilder;
/// The thickness of the draggable area between panes.
///
/// Controls the size of the interactive region for resizing. A larger value
/// makes it easier to grab and drag the resize handles, while a smaller
/// value provides a more compact appearance.
  double? draggerThickness;
/// Hides the divider when not hovered or being dragged.
  bool optionalDivider;
/// Creates a horizontal resizable panel with panes arranged left-to-right.
///
/// This is a convenience constructor that sets [direction] to [Axis.horizontal]
/// and provides default builders for dividers and draggers appropriate for
/// horizontal layouts.
///
/// Parameters:
/// - [children] (`List<ResizablePane>`, required): The panes to arrange horizontally
/// - [dividerBuilder] (OptionalWidgetBuilder?, optional): Custom divider builder
/// - [draggerBuilder] (OptionalWidgetBuilder?, optional): Custom dragger builder
/// - [draggerThickness] (double?, optional): Size of the draggable resize area
///
/// Example:
/// ```dart
/// ResizablePanel.horizontal(
///   children: [
///     ResizablePane(child: LeftSidebar(), defaultSize: 200),
///     ResizablePane(child: MainContent(), flex: 1),
///     ResizablePane(child: RightPanel(), defaultSize: 150),
///   ],
/// );
/// ```
  const ResizablePanel.horizontal({super.key, required this.children, this.dividerBuilder = defaultDividerBuilder, this.draggerBuilder, this.draggerThickness, this.optionalDivider = false});
/// Creates a vertical resizable panel with panes arranged top-to-bottom.
///
/// This is a convenience constructor that sets [direction] to [Axis.vertical]
/// and provides default builders for dividers and draggers appropriate for
/// vertical layouts.
///
/// Parameters:
/// - [children] (`List<ResizablePane>`, required): The panes to arrange vertically
/// - [dividerBuilder] (OptionalWidgetBuilder?, optional): Custom divider builder
/// - [draggerBuilder] (OptionalWidgetBuilder?, optional): Custom dragger builder
/// - [draggerThickness] (double?, optional): Size of the draggable resize area
///
/// Example:
/// ```dart
/// ResizablePanel.vertical(
///   children: [
///     ResizablePane(child: Header(), defaultSize: 60),
///     ResizablePane(child: Content(), flex: 1),
///     ResizablePane(child: Footer(), defaultSize: 40),
///   ],
/// );
/// ```
  const ResizablePanel.vertical({super.key, required this.children, this.dividerBuilder = defaultDividerBuilder, this.draggerBuilder, this.draggerThickness, this.optionalDivider = false});
/// Creates a resizable panel with the specified direction and configuration.
///
/// This is the general constructor that allows full customization of the
/// panel orientation and behavior. Use the convenience constructors
/// [ResizablePanel.horizontal] and [ResizablePanel.vertical] for typical use cases.
///
/// Parameters:
/// - [direction] (Axis, required): The axis along which panes are arranged
/// - [children] (`List<ResizablePane>`, required): The panes to arrange
/// - [dividerBuilder] (OptionalWidgetBuilder?, optional): Custom divider builder
/// - [draggerBuilder] (OptionalWidgetBuilder?, optional): Custom dragger builder
/// - [draggerThickness] (double?, optional): Size of the draggable resize area
///
/// Example:
/// ```dart
/// ResizablePanel(
///   direction: Axis.horizontal,
///   draggerThickness: 8.0,
///   children: [...],
///   draggerBuilder: (context) => CustomDragger(),
/// );
/// ```
  const ResizablePanel({super.key, required this.direction, required this.children, this.dividerBuilder = defaultDividerBuilder, this.draggerBuilder, this.draggerThickness, this.optionalDivider = false});
  State<ResizablePanel> createState();
}
/// Data class providing information about a resizable panel's orientation.
///
/// Used internally to pass layout direction information through the widget tree.
class ResizableData {
/// The axis direction of the resizable panel (horizontal or vertical).
  Axis direction;
/// Creates [ResizableData] with the specified [direction].
  ResizableData(this.direction);
}
/// Theme configuration for [Alert] components.
///
/// Provides visual styling properties for alert components including padding,
/// background color, and border color. These properties can be overridden at
/// the widget level or applied globally via [ComponentTheme].
///
/// The theme integrates with the overall design system by using appropriate
/// color schemes and scaling factors from [ThemeData].
class AlertTheme extends ComponentThemeData {
/// The internal padding around the alert content.
///
/// Type: `EdgeInsetsGeometry?`. If null, uses default padding based on scaling.
/// Controls the spacing between the alert border and its content elements.
  EdgeInsetsGeometry? padding;
/// The background color of the alert container.
///
/// Type: `Color?`. If null, uses [ColorScheme.card] from the current theme.
/// Applied to the [OutlinedContainer] that wraps the alert content.
  Color? backgroundColor;
/// The border color of the alert outline.
///
/// Type: `Color?`. If null, uses the default border color from [OutlinedContainer].
/// Defines the visual boundary around the alert.
  Color? borderColor;
/// Creates an [AlertTheme].
///
/// All parameters are optional and can be null to use default values.
///
/// Example:
/// ```dart
/// const AlertTheme(
///   padding: EdgeInsets.all(16.0),
///   backgroundColor: Colors.blue,
///   borderColor: Colors.blueAccent,
/// );
/// ```
  const AlertTheme({this.padding, this.backgroundColor, this.borderColor});
/// Creates a copy of this theme with the given values replaced.
///
/// Uses [ValueGetter] functions to allow conditional replacement of values.
/// If a getter function is null, the original value is preserved.
///
/// Returns:
/// A new [AlertTheme] instance with updated values.
///
/// Example:
/// ```dart
/// final newTheme = theme.copyWith(
///   backgroundColor: () => Colors.red,
/// );
/// ```
  AlertTheme copyWith({ValueGetter<EdgeInsetsGeometry?>? padding, ValueGetter<Color?>? backgroundColor, ValueGetter<Color?>? borderColor});
  bool operator ==(Object other);
  int get hashCode;
}
/// A versatile alert component for displaying important messages or notifications.
///
/// The Alert widget provides a flexible layout for presenting information to users
/// with optional leading icons, title text, content description, and trailing actions.
/// Supports both normal and destructive styling modes for different message types.
///
/// The component uses a [Basic] layout internally and wraps content in an
/// [OutlinedContainer] for consistent visual presentation. Text and icon colors
/// automatically adapt based on the destructive mode and current theme.
///
/// Key features:
/// - Flexible content layout with optional elements
/// - Destructive styling for error/warning messages
/// - Theme integration with customizable styling
/// - Responsive scaling based on theme configuration
/// - Automatic color adaptation for text and icons
///
/// Example:
/// ```dart
/// Alert(
///   leading: Icon(Icons.info),
///   title: Text('Information'),
///   content: Text('This is an informational alert message.'),
///   trailing: IconButton(
///     icon: Icon(Icons.close),
///     onPressed: () {},
///   ),
/// );
/// ```
class Alert extends StatelessWidget {
/// Optional leading widget, typically an icon.
///
/// Type: `Widget?`. Displayed at the start of the alert layout.
/// In destructive mode, inherits the destructive color from the theme.
  Widget? leading;
/// Optional title widget for the alert header.
///
/// Type: `Widget?`. Usually contains the main alert message or heading.
/// Positioned after the leading widget in the layout flow.
  Widget? title;
/// Optional content widget for detailed alert information.
///
/// Type: `Widget?`. Provides additional context or description below the title.
/// Can contain longer text or complex content layouts.
  Widget? content;
/// Optional trailing widget, typically for actions or dismissal.
///
/// Type: `Widget?`. Displayed at the end of the alert layout.
/// Common use cases include close buttons or action controls.
  Widget? trailing;
/// Whether to apply destructive styling to the alert.
///
/// Type: `bool`, default: `false`. When true, applies destructive color
/// scheme to text and icons for error or warning messages.
  bool destructive;
/// Creates an [Alert] with standard styling.
///
/// All content parameters are optional, allowing for flexible layouts
/// from simple text alerts to complex multi-element notifications.
///
/// Parameters:
/// - [leading] (Widget?, optional): Icon or widget at the start
/// - [title] (Widget?, optional): Main heading or message
/// - [content] (Widget?, optional): Detailed description or body
/// - [trailing] (Widget?, optional): Action buttons or dismissal controls
/// - [destructive] (bool, default: false): Whether to use destructive styling
///
/// Example:
/// ```dart
/// Alert(
///   title: Text('Success'),
///   content: Text('Operation completed successfully.'),
/// );
/// ```
  const Alert({super.key, this.leading, this.title, this.content, this.trailing, this.destructive = false});
/// Creates an [Alert] with destructive styling pre-configured.
///
/// This is a convenience constructor that sets [destructive] to true,
/// applying error/warning colors to text and icons automatically.
///
/// Parameters:
/// - [leading] (Widget?, optional): Icon or widget at the start
/// - [title] (Widget?, optional): Main heading or message
/// - [content] (Widget?, optional): Detailed description or body
/// - [trailing] (Widget?, optional): Action buttons or dismissal controls
///
/// Example:
/// ```dart
/// Alert.destructive(
///   leading: Icon(Icons.error),
///   title: Text('Error'),
///   content: Text('Something went wrong. Please try again.'),
/// );
/// ```
  const Alert.destructive({super.key, this.leading, this.title, this.content, this.trailing});
  Widget build(BuildContext context);
}
/// Theme data for customizing [Scaffold] widget appearance.
///
/// This class defines the visual properties that can be applied to
/// [Scaffold] widgets, including background colors for different sections,
/// loading spark behavior, and keyboard avoidance settings. These properties
/// can be set at the theme level to provide consistent styling across the application.
class ScaffoldTheme extends ComponentThemeData {
/// Background color of the scaffold body.
  Color? backgroundColor;
/// Background color of the header section.
  Color? headerBackgroundColor;
/// Background color of the footer section.
  Color? footerBackgroundColor;
/// Whether to show loading sparks by default.
  bool? showLoadingSparks;
/// Whether the scaffold should resize for the onscreen keyboard.
  bool? resizeToAvoidBottomInset;
/// Creates a [ScaffoldTheme].
  const ScaffoldTheme({this.backgroundColor, this.headerBackgroundColor, this.footerBackgroundColor, this.showLoadingSparks, this.resizeToAvoidBottomInset});
/// Creates a copy of this theme with the given fields replaced.
  ScaffoldTheme copyWith({ValueGetter<Color?>? backgroundColor, ValueGetter<Color?>? headerBackgroundColor, ValueGetter<Color?>? footerBackgroundColor, ValueGetter<bool?>? showLoadingSparks, ValueGetter<bool?>? resizeToAvoidBottomInset});
  bool operator ==(Object other);
  int get hashCode;
  String toString();
}
/// A fundamental layout widget that provides the basic structure for screen layouts.
///
/// [Scaffold] serves as the foundation for most screen layouts in the shadcn_flutter
/// design system. It provides a structured approach to organizing content with
/// dedicated areas for headers, main content, and footers. The scaffold manages
/// layout responsibilities, loading states, and provides a consistent framework
/// for building complex interfaces.
///
/// Key features:
/// - Flexible header and footer management with multiple widget support
/// - Main content area with automatic layout management
/// - Loading progress indication with optional sparks animation
/// - Floating header/footer modes for overlay positioning
/// - Independent background color control for each section
/// - Keyboard avoidance behavior for input accessibility
/// - Responsive layout adjustments
/// - Integration with the shadcn_flutter theme system
///
/// Layout structure:
/// - Headers: Optional top section for navigation, titles, toolbars
/// - Main content: Central area containing the primary interface
/// - Footers: Optional bottom section for actions, navigation, status
///
/// The scaffold supports both fixed and floating positioning modes:
/// - Fixed mode: Headers/footers take layout space and push content
/// - Floating mode: Headers/footers overlay content without affecting layout
///
/// Loading states are elegantly handled with:
/// - Progress indication through [loadingProgress]
/// - Optional animated sparks for enhanced visual feedback
/// - Indeterminate loading support for unknown duration tasks
///
/// Example:
/// ```dart
/// Scaffold(
///   headers: [
///     AppBar(title: Text('My App')),
///   ],
///   child: Center(
///     child: Text('Main content area'),
///   ),
///   footers: [
///     BottomNavigationBar(
///       items: [
///         BottomNavigationBarItem(icon: Icon(Icons.home), label: 'Home'),
///         BottomNavigationBarItem(icon: Icon(Icons.search), label: 'Search'),
///       ],
///     ),
///   ],
///   loadingProgress: isLoading ? null : 0.0, // null for indeterminate
///   showLoadingSparks: true,
/// );
/// ```
class Scaffold extends StatefulWidget {
/// Header widgets displayed at the top of the scaffold.
  List<Widget> headers;
/// Footer widgets displayed at the bottom of the scaffold.
  List<Widget> footers;
/// Main content widget.
  Widget child;
/// Loading progress value (0.0 to 1.0).
  double? loadingProgress;
/// Whether loading indicator shows indeterminate progress.
  bool loadingProgressIndeterminate;
/// Whether header floats above content (takes no layout space).
  bool floatingHeader;
/// Whether footer floats above content (takes no layout space).
  bool floatingFooter;
/// Background color for header section.
  Color? headerBackgroundColor;
/// Background color for footer section.
  Color? footerBackgroundColor;
/// Background color for the scaffold.
  Color? backgroundColor;
/// Whether to show loading sparks effect.
  bool? showLoadingSparks;
/// Whether to resize when keyboard appears.
  bool? resizeToAvoidBottomInset;
/// Creates a [Scaffold].
  const Scaffold({super.key, required this.child, this.headers = const [], this.footers = const [], this.loadingProgress, this.loadingProgressIndeterminate = false, this.floatingHeader = false, this.floatingFooter = false, this.backgroundColor, this.headerBackgroundColor, this.footerBackgroundColor, this.showLoadingSparks, this.resizeToAvoidBottomInset});
  State<Scaffold> createState();
}
/// Data class for identifying scaffold bar (header/footer) positioning.
///
/// Provides context about a bar's position within the scaffold layout,
/// including whether it's a header or footer and its index among siblings.
class ScaffoldBarData {
/// Whether this bar is in the header section (vs footer).
  bool isHeader;
/// Zero-based index of this child bar.
  int childIndex;
/// Total number of children in this section.
  int childrenCount;
/// Creates [ScaffoldBarData].
  const ScaffoldBarData({this.isHeader = true, required this.childIndex, required this.childrenCount});
}
/// State class for [Scaffold] widget.
///
/// Manages the scaffold's layout state and provides methods for building
/// header, footer, and body sections with proper theming and constraints.
class ScaffoldState extends State<Scaffold> {
/// Builds the header section of the scaffold.
///
/// Parameters:
/// - [context] (`BuildContext`, required): Build context.
///
/// Returns: Widget tree for the header.
  Widget buildHeader(BuildContext context);
/// Builds the footer section of the scaffold.
///
/// Parameters:
/// - [context] (`BuildContext`, required): Build context.
/// - [viewInsets] (`EdgeInsets`, required): View insets (e.g., keyboard).
///
/// Returns: Widget tree for the footer.
  Widget buildFooter(BuildContext context, EdgeInsets viewInsets);
  Widget build(BuildContext context);
}
/// Storage for scaffold padding values.
///
/// Holds padding values for all four sides of the scaffold content area.
class ScaffoldPaddingStorage {
/// Top padding value.
  double top;
/// Left padding value.
  double left;
/// Right padding value.
  double right;
/// Bottom padding value.
  double bottom;
/// Creates a [ScaffoldPaddingStorage].
///
/// Parameters:
/// - [top] (`double`, required): Top padding.
/// - [left] (`double`, required): Left padding.
/// - [right] (`double`, required): Right padding.
/// - [bottom] (`double`, required): Bottom padding.
  ScaffoldPaddingStorage({required this.top, required this.left, required this.right, required this.bottom});
}
/// Box constraints with additional header and footer height information.
///
/// Extends [BoxConstraints] to include scaffold-specific layout measurements.
class ScaffoldBoxConstraints extends BoxConstraints {
/// Height of the header section.
  double headerHeight;
/// Height of the footer section.
  double footerHeight;
/// Creates [ScaffoldBoxConstraints].
///
/// Parameters:
/// - [headerHeight] (`double`, required): Header height.
/// - [footerHeight] (`double`, required): Footer height.
/// - Additional [BoxConstraints] parameters.
  const ScaffoldBoxConstraints({required this.headerHeight, required this.footerHeight, super.minWidth, super.maxWidth, super.minHeight, super.maxHeight});
/// Creates [ScaffoldBoxConstraints] from existing [BoxConstraints].
///
/// Parameters:
/// - [constraints] (`BoxConstraints`, required): Base constraints.
/// - [headerHeight] (`double`, required): Header height.
/// - [footerHeight] (`double`, required): Footer height.
///
/// Returns: New [ScaffoldBoxConstraints] with scaffold-specific data.
  factory ScaffoldBoxConstraints.fromBoxConstraints({required BoxConstraints constraints, required double headerHeight, required double footerHeight});
  ScaffoldBoxConstraints copyWith({double? headerHeight, double? footerHeight, double? minWidth, double? maxWidth, double? minHeight, double? maxHeight});
  bool operator ==(Object other);
  int get hashCode;
  String toString();
}
/// A customizable application bar component for layout headers.
///
/// Provides a flexible top-level navigation and branding component that
/// typically appears at the top of screens or content areas. The app bar
/// supports leading and trailing widget areas, title content, optional
/// header/subtitle elements, and comprehensive styling customization.
///
/// The component automatically handles safe area considerations, background
/// effects, and responsive layout behaviors. Leading and trailing areas
/// support multiple widgets with configurable spacing, while the center
/// area can contain titles, custom content, or complex layouts.
///
/// Integrates with the theme system for consistent appearance and supports
/// surface blur effects, background customization, and flexible sizing
/// constraints to adapt to various layout requirements.
///
/// Example:
/// ```dart
/// AppBar(
///   leading: [
///     IconButton(icon: Icon(Icons.menu), onPressed: _openDrawer),
///   ],
///   title: Text('My Application'),
///   subtitle: Text('Dashboard'),
///   trailing: [
///     IconButton(icon: Icon(Icons.search), onPressed: _openSearch),
///     IconButton(icon: Icon(Icons.more_vert), onPressed: _showMenu),
///   ],
///   backgroundColor: Colors.blue.shade50,
/// )
/// ```
class AppBar extends StatefulWidget {
/// List of widgets to display in the trailing (right) area of the app bar.
///
/// Typically contains action buttons, menus, or other interactive elements.
/// Items are arranged horizontally with appropriate spacing based on the
/// [trailingGap] setting.
  List<Widget> trailing;
/// List of widgets to display in the leading (left) area of the app bar.
///
/// Commonly includes back buttons, menu buttons, or branding elements.
/// Items are arranged horizontally with spacing controlled by [leadingGap].
  List<Widget> leading;
/// Optional main content widget displayed in the center area.
///
/// When provided, this widget takes precedence over [title], [header],
/// and [subtitle] for the central content area. Useful for custom layouts.
  Widget? child;
/// Primary title text or widget for the app bar.
///
/// Displayed prominently in the center area when [child] is not provided.
/// Should clearly identify the current screen or application section.
  Widget? title;
/// Optional small widget placed above the title.
///
/// Provides additional context or branding above the main title.
/// Typically used for breadcrumbs, status indicators, or secondary labels.
  Widget? header;
/// Optional small widget placed below the title.
///
/// Provides supplementary information below the main title.
/// Commonly used for descriptions, status text, or secondary navigation.
  Widget? subtitle;
/// Whether the trailing area should expand to fill available space.
///
/// When true, the trailing area expands instead of the main content area,
/// useful for toolbars or action-heavy interfaces where trailing content
/// needs maximum space allocation.
  bool trailingExpanded;
/// Alignment of content within the app bar.
///
/// Controls how the central content (title, header, subtitle, or child)
/// is positioned within its available space. Default centers the content.
  AlignmentGeometry alignment;
/// Background color for the app bar surface.
///
/// When null, uses the theme's default app bar background color.
/// The background provides visual separation from underlying content.
  Color? backgroundColor;
/// Spacing between leading widgets.
///
/// Controls the horizontal gap between adjacent widgets in the leading area.
/// When null, uses theme-appropriate default spacing.
  double? leadingGap;
/// Spacing between trailing widgets.
///
/// Controls the horizontal gap between adjacent widgets in the trailing area.
/// When null, uses theme-appropriate default spacing.
  double? trailingGap;
/// Internal padding applied within the app bar.
///
/// Provides space around all app bar content, creating breathing room
/// from the edges and ensuring proper spacing from screen boundaries.
  EdgeInsetsGeometry? padding;
/// Fixed height for the app bar.
///
/// When specified, constrains the app bar to this exact height.
/// When null, the app bar sizes itself based on content and theme defaults.
  double? height;
/// Whether to account for system safe areas (status bar, notch).
///
/// When true, automatically adds padding to avoid system UI intrusions.
/// Typically enabled for top-level app bars in full-screen contexts.
  bool useSafeArea;
/// Blur intensity for surface background effects.
///
/// Controls backdrop blur effects behind the app bar surface.
/// Higher values create more pronounced blur effects.
  double? surfaceBlur;
/// Opacity level for surface background effects.
///
/// Controls transparency of background blur and overlay effects.
/// Values range from 0.0 (transparent) to 1.0 (opaque).
  double? surfaceOpacity;
/// Creates an [AppBar] with the specified content and configuration.
///
/// All parameters are optional with sensible defaults. The app bar
/// automatically handles layout, spacing, and theming while providing
/// extensive customization options for complex interface requirements.
///
/// Content can be provided through individual title/header/subtitle parameters
/// or by using the [child] parameter for complete custom layouts. Leading
/// and trailing areas support multiple widgets with automatic spacing.
///
/// Parameters:
/// - [leading] (`List<Widget>`, default: []): Leading area widgets (left side)
/// - [trailing] (`List<Widget>`, default: []): Trailing area widgets (right side)
/// - [title] (Widget?, optional): Primary title content
/// - [header] (Widget?, optional): Secondary content above title
/// - [subtitle] (Widget?, optional): Secondary content below title
/// - [child] (Widget?, optional): Custom content (overrides title components)
/// - [alignment] (AlignmentGeometry, default: center): Content alignment
/// - [trailingExpanded] (bool, default: false): Whether trailing area expands
/// - [useSafeArea] (bool, default: depends on context): Handle system intrusions
///
/// Example:
/// ```dart
/// AppBar(
///   leading: [BackButton()],
///   title: Text('Settings'),
///   trailing: [
///     IconButton(icon: Icon(Icons.help), onPressed: _showHelp),
///     PopupMenuButton(items: menuItems),
///   ],
///   backgroundColor: Theme.of(context).colorScheme.primaryContainer,
/// )
/// ```
  const AppBar({super.key, this.trailing = const [], this.leading = const [], this.title, this.header, this.subtitle, this.child, this.trailingExpanded = false, this.alignment = Alignment.center, this.padding, this.backgroundColor, this.leadingGap, this.trailingGap, this.height, this.surfaceBlur, this.surfaceOpacity, this.useSafeArea = true});
  State<AppBar> createState();
}
/// Widget that applies header-aware padding to its child.
///
/// Automatically adjusts padding based on scaffold header height.
class ScaffoldHeaderPadding extends SingleChildRenderObjectWidget {
/// Creates [ScaffoldHeaderPadding].
  const ScaffoldHeaderPadding({super.key, super.child});
  RenderObject createRenderObject(BuildContext context);
}
/// Widget that applies footer-aware padding to its child.
///
/// Automatically adjusts padding based on scaffold footer height.
class ScaffoldFooterPadding extends SingleChildRenderObjectWidget {
/// Creates [ScaffoldFooterPadding].
  const ScaffoldFooterPadding({super.key, super.child});
  RenderObject createRenderObject(BuildContext context);
}
/// Abstract base class for defining stage-based layout breakpoints.
///
/// Provides strategies for determining minimum and maximum widths based on
/// container size. Used by [StageContainer] to create responsive layouts
/// that adapt to screen size in discrete steps.
abstract class StageBreakpoint {
/// Creates a constant breakpoint with uniform stepping.
///
/// Parameters:
/// - [breakpoint] (`double`, required): Step size for width calculations.
/// - [minSize] (`double`, default: `0`): Minimum allowed size.
/// - [maxSize] (`double`, default: `double.infinity`): Maximum allowed size.
  factory StageBreakpoint.constant(double breakpoint, {double minSize = 0, double maxSize = double.infinity});
/// Creates staged breakpoints from a list of specific width values.
///
/// Parameters:
/// - [breakpoints] (`List<double>`, required): List of breakpoint widths.
  factory StageBreakpoint.staged(List<double> breakpoints);
/// Default responsive breakpoints (576, 768, 992, 1200, 1400).
///
/// Matches common responsive design breakpoints for mobile, tablet, desktop.
  static const StageBreakpoint defaultBreakpoints = StagedBreakpoint.defaultBreakpoints();
/// Calculates the minimum width for the given container [width].
  double getMinWidth(double width);
/// Calculates the maximum width for the given container [width].
  double getMaxWidth(double width);
/// Minimum allowed size constraint.
  double get minSize;
/// Maximum allowed size constraint.
  double get maxSize;
}
/// A breakpoint that uses constant step increments.
///
/// Divides width into uniform steps based on [breakpoint] value. For example,
/// with breakpoint=100, widths 0-99 map to 0, 100-199 map to 100, etc.
class ConstantBreakpoint implements StageBreakpoint {
/// The step size for width calculations.
  double breakpoint;
  double minSize;
  double maxSize;
/// Creates a [ConstantBreakpoint].
  const ConstantBreakpoint(this.breakpoint, {this.minSize = 0, this.maxSize = double.infinity});
  double getMinWidth(double width);
  double getMaxWidth(double width);
}
/// A breakpoint that uses predefined stage values.
///
/// Maps container widths to the nearest breakpoint value from a list.
/// Commonly used for responsive design with specific breakpoints like
/// mobile (576), tablet (768), desktop (992), etc.
class StagedBreakpoint implements StageBreakpoint {
/// List of breakpoint width values in ascending order.
  List<double> breakpoints;
/// Creates a [StagedBreakpoint] with custom breakpoints.
///
/// Requires at least 2 breakpoints.
  const StagedBreakpoint(this.breakpoints);
/// Creates a [StagedBreakpoint] with default responsive breakpoints.
  const StagedBreakpoint.defaultBreakpoints();
  double getMinWidth(double width);
  double getMaxWidth(double width);
  double get minSize;
  double get maxSize;
}
/// Theme configuration for [StageContainer] responsive behavior.
///
/// Defines default breakpoint strategy and padding for stage containers.
class StageContainerTheme extends ComponentThemeData {
/// The breakpoint strategy to use.
  StageBreakpoint? breakpoint;
/// Default padding for the container.
  EdgeInsets? padding;
/// Creates a [StageContainerTheme].
  const StageContainerTheme({this.breakpoint, this.padding});
/// Creates a copy of this theme with the given fields replaced.
  StageContainerTheme copyWith({ValueGetter<StageBreakpoint?>? breakpoint, ValueGetter<EdgeInsets?>? padding});
  bool operator ==(Object other);
  int get hashCode;
}
/// A responsive container that adapts to screen size using breakpoints.
///
/// Constrains child width based on breakpoint strategy and adds padding.
/// Useful for creating centered, responsive layouts that adapt smoothly
/// across different screen sizes.
///
/// Example:
/// ```dart
/// StageContainer(
///   breakpoint: StageBreakpoint.defaultBreakpoints,
///   padding: EdgeInsets.symmetric(horizontal: 24),
///   builder: (context, padding) {
///     return Container(
///       padding: padding,
///       child: Text('Responsive content'),
///     );
///   },
/// )
/// ```
class StageContainer extends StatelessWidget {
/// The breakpoint strategy for determining container width.
///
/// Defaults to [StageBreakpoint.defaultBreakpoints].
  StageBreakpoint breakpoint;
/// Builder function that receives context and calculated padding.
///
/// The padding parameter accounts for responsive adjustments.
  Widget Function(BuildContext context, EdgeInsets padding) builder;
/// Base padding for the container.
///
/// Defaults to `EdgeInsets.symmetric(horizontal: 72)`.
  EdgeInsets padding;
/// Creates a [StageContainer].
  const StageContainer({super.key, this.breakpoint = StageBreakpoint.defaultBreakpoints, required this.builder, this.padding = const EdgeInsets.symmetric(horizontal: 72)});
  Widget build(BuildContext context);
}
/// A draggable widget that supports drag-and-drop reordering with directional drop zones.
///
/// The Sortable widget enables drag-and-drop interactions with support for four directional
/// drop zones (top, left, right, bottom). It provides customizable callbacks for handling
/// drop events, visual feedback during dragging, and placeholder widgets for smooth
/// reordering animations.
///
/// Features:
/// - Four directional drop zones with individual accept/reject logic
/// - Customizable ghost and placeholder widgets during drag operations
/// - Automatic scroll support when wrapped in ScrollableSortableLayer
/// - Visual feedback with animated placeholders and fallback widgets
/// - Robust drag session management with proper cleanup
///
/// The widget must be wrapped in a [SortableLayer] to function properly. Use
/// [ScrollableSortableLayer] for automatic scrolling during drag operations.
///
/// Example:
/// ```dart
/// SortableLayer(
///   child: Column(
///     children: [
///       Sortable<String>(
///         data: SortableData('Item 1'),
///         onAcceptTop: (data) => reorderAbove(data.data),
///         onAcceptBottom: (data) => reorderBelow(data.data),
///         child: Card(child: Text('Item 1')),
///       ),
///       Sortable<String>(
///         data: SortableData('Item 2'),
///         onAcceptTop: (data) => reorderAbove(data.data),
///         onAcceptBottom: (data) => reorderBelow(data.data),
///         child: Card(child: Text('Item 2')),
///       ),
///     ],
///   ),
/// )
/// ```
class Sortable<T> extends StatefulWidget {
/// Predicate to determine if data can be accepted when dropped above this widget.
///
/// Type: `Predicate<SortableData<T>>?`. If null, drops from the top are not accepted.
/// Called before [onAcceptTop] to validate the drop operation.
  Predicate<SortableData<T>>? canAcceptTop;
/// Predicate to determine if data can be accepted when dropped to the left of this widget.
///
/// Type: `Predicate<SortableData<T>>?`. If null, drops from the left are not accepted.
/// Called before [onAcceptLeft] to validate the drop operation.
  Predicate<SortableData<T>>? canAcceptLeft;
/// Predicate to determine if data can be accepted when dropped to the right of this widget.
///
/// Type: `Predicate<SortableData<T>>?`. If null, drops from the right are not accepted.
/// Called before [onAcceptRight] to validate the drop operation.
  Predicate<SortableData<T>>? canAcceptRight;
/// Predicate to determine if data can be accepted when dropped below this widget.
///
/// Type: `Predicate<SortableData<T>>?`. If null, drops from the bottom are not accepted.
/// Called before [onAcceptBottom] to validate the drop operation.
  Predicate<SortableData<T>>? canAcceptBottom;
/// Callback invoked when data is successfully dropped above this widget.
///
/// Type: `ValueChanged<SortableData<T>>?`. The callback receives the dropped
/// data and should handle the reordering logic. Only called after [canAcceptTop]
/// validation passes.
  ValueChanged<SortableData<T>>? onAcceptTop;
/// Callback invoked when data is successfully dropped to the left of this widget.
///
/// Type: `ValueChanged<SortableData<T>>?`. The callback receives the dropped
/// data and should handle the reordering logic. Only called after [canAcceptLeft]
/// validation passes.
  ValueChanged<SortableData<T>>? onAcceptLeft;
/// Callback invoked when data is successfully dropped to the right of this widget.
///
/// Type: `ValueChanged<SortableData<T>>?`. The callback receives the dropped
/// data and should handle the reordering logic. Only called after [canAcceptRight]
/// validation passes.
  ValueChanged<SortableData<T>>? onAcceptRight;
/// Callback invoked when data is successfully dropped below this widget.
///
/// Type: `ValueChanged<SortableData<T>>?`. The callback receives the dropped
/// data and should handle the reordering logic. Only called after [canAcceptBottom]
/// validation passes.
  ValueChanged<SortableData<T>>? onAcceptBottom;
/// Callback invoked when a drag operation starts on this widget.
///
/// Type: `VoidCallback?`. Called immediately when the user begins dragging
/// this sortable item. Useful for providing haptic feedback or updating UI state.
  VoidCallback? onDragStart;
/// Callback invoked when a drag operation ends successfully.
///
/// Type: `VoidCallback?`. Called when the drag completes with a successful drop.
/// This is called before the appropriate accept callback.
  VoidCallback? onDragEnd;
/// Callback invoked when a drag operation is cancelled.
///
/// Type: `VoidCallback?`. Called when the drag is cancelled without a successful
/// drop, such as when the user releases outside valid drop zones.
  VoidCallback? onDragCancel;
/// The main child widget that will be made sortable.
///
/// Type: `Widget`. This widget is displayed normally and becomes draggable
/// when drag interactions are initiated.
  Widget child;
/// The data associated with this sortable item.
///
/// Type: `SortableData<T>`. Contains the actual data being sorted and provides
/// identity for the drag-and-drop operations.
  SortableData<T> data;
/// Widget displayed in drop zones when this item is being dragged over them.
///
/// Type: `Widget?`. If null, uses [SizedBox.shrink]. This creates visual
/// space in potential drop locations, providing clear feedback about where
/// the item will be placed if dropped.
  Widget? placeholder;
/// Widget displayed while dragging instead of the original child.
///
/// Type: `Widget?`. If null, uses [child]. Typically a semi-transparent
/// or styled version of the child to provide visual feedback during dragging.
  Widget? ghost;
/// Widget displayed in place of the child while it's being dragged.
///
/// Type: `Widget?`. If null, the original child becomes invisible but maintains
/// its space. Used to show an alternative representation at the original location.
  Widget? fallback;
/// Widget displayed when the item is a candidate for dropping.
///
/// Type: `Widget?`. Shows alternative styling when the dragged item hovers
/// over this sortable as a potential drop target.
  Widget? candidateFallback;
/// Whether drag interactions are enabled for this sortable.
///
/// Type: `bool`, default: `true`. When false, the widget cannot be dragged
/// and will not respond to drag gestures.
  bool enabled;
/// How hit-testing behaves for drag gesture recognition.
///
/// Type: `HitTestBehavior`, default: `HitTestBehavior.deferToChild`.
/// Controls how the gesture detector participates in hit testing.
  HitTestBehavior behavior;
/// Callback invoked when a drop operation fails.
///
/// Type: `VoidCallback?`. Called when the user drops outside of any valid
/// drop zones or when drop validation fails.
  VoidCallback? onDropFailed;
/// Creates a [Sortable] widget with drag-and-drop functionality.
///
/// Configures a widget that can be dragged and accepts drops from other
/// sortable items. The widget supports directional drop zones and provides
/// extensive customization for drag interactions and visual feedback.
///
/// Parameters:
/// - [key] (Key?): Widget identifier for the widget tree
/// - [data] (`SortableData<T>`, required): Data associated with this sortable item
/// - [child] (Widget, required): The main widget to make sortable
/// - [enabled] (bool, default: true): Whether drag interactions are enabled
/// - [canAcceptTop] (`Predicate<SortableData<T>>?`, optional): Validation for top drops
/// - [canAcceptLeft] (`Predicate<SortableData<T>>?`, optional): Validation for left drops
/// - [canAcceptRight] (`Predicate<SortableData<T>>?`, optional): Validation for right drops
/// - [canAcceptBottom] (`Predicate<SortableData<T>>?`, optional): Validation for bottom drops
/// - [onAcceptTop] (`ValueChanged<SortableData<T>>?`, optional): Handler for top drops
/// - [onAcceptLeft] (`ValueChanged<SortableData<T>>?`, optional): Handler for left drops
/// - [onAcceptRight] (`ValueChanged<SortableData<T>>?`, optional): Handler for right drops
/// - [onAcceptBottom] (`ValueChanged<SortableData<T>>?`, optional): Handler for bottom drops
/// - [placeholder] (Widget?, default: SizedBox()): Widget shown in drop zones
/// - [ghost] (Widget?, optional): Widget displayed while dragging
/// - [fallback] (Widget?, optional): Widget shown at original position during drag
/// - [candidateFallback] (Widget?, optional): Widget shown when item is drop candidate
/// - [onDragStart] (VoidCallback?, optional): Called when drag starts
/// - [onDragEnd] (VoidCallback?, optional): Called when drag ends successfully
/// - [onDragCancel] (VoidCallback?, optional): Called when drag is cancelled
/// - [behavior] (HitTestBehavior, default: HitTestBehavior.deferToChild): Hit test behavior
/// - [onDropFailed] (VoidCallback?, optional): Called when drop fails
///
/// Example:
/// ```dart
/// Sortable<String>(
///   data: SortableData('item_1'),
///   onAcceptTop: (data) => moveAbove(data.data),
///   onAcceptBottom: (data) => moveBelow(data.data),
///   placeholder: Container(height: 2, color: Colors.blue),
///   child: ListTile(title: Text('Draggable Item')),
/// )
/// ```
  const Sortable({super.key, this.enabled = true, required this.data, this.canAcceptTop, this.canAcceptLeft, this.canAcceptRight, this.canAcceptBottom, this.onAcceptTop, this.onAcceptLeft, this.onAcceptRight, this.onAcceptBottom, this.placeholder = const SizedBox(), this.ghost, this.fallback, this.candidateFallback, this.onDragStart, this.onDragEnd, this.onDragCancel, this.behavior = HitTestBehavior.deferToChild, this.onDropFailed, required this.child});
  State<Sortable<T>> createState();
}
/// A fallback drop zone for sortable items when dropped outside specific sortable widgets.
///
/// SortableDropFallback provides a catch-all drop zone that can accept sortable
/// items when they're dropped outside of any specific sortable widget drop zones.
/// This is useful for implementing deletion zones, creation areas, or general
/// drop handling areas.
///
/// The widget wraps its child with an invisible hit test layer that can detect
/// and accept dropped sortable items based on configurable acceptance criteria.
///
/// Example:
/// ```dart
/// SortableDropFallback<String>(
///   canAccept: (data) => data.data.startsWith('temp_'),
///   onAccept: (data) => deleteItem(data.data),
///   child: Container(
///     height: 100,
///     child: Center(child: Text('Drop here to delete')),
///   ),
/// )
/// ```
class SortableDropFallback<T> extends StatefulWidget {
/// Callback invoked when a sortable item is dropped on this fallback zone.
///
/// Type: `ValueChanged<SortableData<T>>?`. Receives the dropped item's data
/// and should handle the drop operation. Only called if [canAccept] validation
/// passes or is null.
  ValueChanged<SortableData<T>>? onAccept;
/// Predicate to determine if dropped data can be accepted by this fallback zone.
///
/// Type: `Predicate<SortableData<T>>?`. If null, all sortable items are accepted.
/// Return true to accept the drop, false to reject it.
  Predicate<SortableData<T>>? canAccept;
/// The child widget that defines the drop zone area.
///
/// Type: `Widget`. This widget's bounds determine the area where drops can
/// be detected. The child is rendered normally with an invisible overlay
/// for drop detection.
  Widget child;
/// Creates a [SortableDropFallback] drop zone.
///
/// Configures a fallback drop zone that can accept sortable items dropped
/// outside of specific sortable widget drop zones.
///
/// Parameters:
/// - [key] (Key?): Widget identifier for the widget tree
/// - [child] (Widget, required): The widget that defines the drop zone area
/// - [onAccept] (`ValueChanged<SortableData<T>>?`, optional): Handler for accepted drops
/// - [canAccept] (`Predicate<SortableData<T>>?`, optional): Validation for drops
///
/// Example:
/// ```dart
/// SortableDropFallback<String>(
///   canAccept: (data) => data.data.contains('removable'),
///   onAccept: (data) => removeFromList(data.data),
///   child: Icon(Icons.delete, size: 48),
/// )
/// ```
  const SortableDropFallback({super.key, required this.child, this.onAccept, this.canAccept});
  State<SortableDropFallback<T>> createState();
}
/// A dedicated drag handle for initiating sortable drag operations.
///
/// SortableDragHandle provides a specific area within a sortable widget that
/// can be used to initiate drag operations. This is useful when you want to
/// restrict drag initiation to a specific handle area rather than the entire
/// sortable widget.
///
/// The handle automatically detects its parent Sortable widget and delegates
/// drag operations to it. It provides visual feedback with appropriate mouse
/// cursors and can be enabled/disabled independently.
///
/// Features:
/// - Dedicated drag initiation area within sortable widgets
/// - Automatic mouse cursor management (grab/grabbing states)
/// - Independent enable/disable control
/// - Automatic cleanup and lifecycle management
///
/// Example:
/// ```dart
/// Sortable<String>(
///   data: SortableData('item'),
///   child: Row(
///     children: [
///       SortableDragHandle(
///         child: Icon(Icons.drag_handle),
///       ),
///       Expanded(child: Text('Drag me by the handle')),
///     ],
///   ),
/// )
/// ```
class SortableDragHandle extends StatefulWidget {
/// The child widget that serves as the drag handle.
///
/// Type: `Widget`. This widget defines the visual appearance of the drag handle
/// and responds to drag gestures. Commonly an icon like Icons.drag_handle.
  Widget child;
/// Whether the drag handle is enabled for drag operations.
///
/// Type: `bool`, default: `true`. When false, the handle will not respond to
/// drag gestures and shows the default cursor instead of grab cursors.
  bool enabled;
/// How hit-testing behaves for this drag handle.
///
/// Type: `HitTestBehavior?`. Controls how the gesture detector and mouse region
/// participate in hit testing. If null, uses default behavior.
  HitTestBehavior? behavior;
/// The mouse cursor displayed when hovering over the drag handle.
///
/// Type: `MouseCursor?`. If null, uses SystemMouseCursors.grab when enabled,
/// or MouseCursor.defer when disabled. Changes to SystemMouseCursors.grabbing
/// during active drag operations.
  MouseCursor? cursor;
/// Creates a [SortableDragHandle] for initiating drag operations.
///
/// Configures a dedicated drag handle that can initiate drag operations for
/// its parent sortable widget. The handle provides visual feedback and can
/// be independently enabled or disabled.
///
/// Parameters:
/// - [key] (Key?): Widget identifier for the widget tree
/// - [child] (Widget, required): The widget that serves as the drag handle
/// - [enabled] (bool, default: true): Whether drag operations are enabled
/// - [behavior] (HitTestBehavior?, optional): Hit test behavior for gestures
/// - [cursor] (MouseCursor?, optional): Mouse cursor when hovering
///
/// Example:
/// ```dart
/// SortableDragHandle(
///   enabled: isDragEnabled,
///   cursor: SystemMouseCursors.move,
///   child: Container(
///     padding: EdgeInsets.all(8),
///     child: Icon(Icons.drag_indicator),
///   ),
/// )
/// ```
  const SortableDragHandle({super.key, required this.child, this.enabled = true, this.behavior, this.cursor});
  State<SortableDragHandle> createState();
}
/// Immutable data wrapper for sortable items in drag-and-drop operations.
///
/// SortableData wraps the actual data being sorted and provides identity for
/// drag-and-drop operations. Each sortable item must have associated data that
/// uniquely identifies it within the sorting context.
///
/// The class is immutable and uses reference equality for comparison, ensuring
/// that each sortable item maintains its identity throughout drag operations.
/// This is crucial for proper drop validation and handling.
///
/// Type parameter [T] represents the type of data being sorted, which can be
/// any type including primitive types, custom objects, or complex data structures.
///
/// Example:
/// ```dart
/// // Simple string data
/// SortableData<String>('item_1')
///
/// // Complex object data
/// SortableData<TodoItem>(TodoItem(id: 1, title: 'Task 1'))
///
/// // Map data
/// SortableData<Map<String, dynamic>>({'id': 1, 'name': 'Item'})
/// ```
class SortableData<T> {
/// The actual data being wrapped for sorting operations.
///
/// Type: `T`. This is the data that will be passed to drop handlers and
/// validation predicates. Can be any type that represents the sortable item.
  T data;
/// Creates a [SortableData] wrapper for the given data.
///
/// Wraps the provided data in an immutable container that can be used with
/// sortable widgets for drag-and-drop operations.
///
/// Parameters:
/// - [data] (T, required): The data to wrap for sorting operations
///
/// Example:
/// ```dart
/// // Wrapping different data types
/// SortableData('text_item')
/// SortableData(42)
/// SortableData(MyCustomObject(id: 1))
/// ```
  const SortableData(this.data);
  bool operator ==(Object other);
  int get hashCode;
  String toString();
}
/// A layer widget that manages drag-and-drop sessions for sortable widgets.
///
/// SortableLayer is a required wrapper that coordinates drag-and-drop operations
/// between multiple sortable widgets. It provides the infrastructure for managing
/// drag sessions, rendering ghost elements during dragging, and handling drop
/// animations.
///
/// The layer maintains the drag state and provides a rendering context for ghost
/// widgets that follow the cursor during drag operations. It also manages drop
/// animations and cleanup when drag operations complete.
///
/// Features:
/// - Centralized drag session management across multiple sortable widgets
/// - Ghost widget rendering with cursor following during drag operations
/// - Configurable drop animations with custom duration and curves
/// - Boundary locking to constrain drag operations within the layer bounds
/// - Automatic cleanup and state management for drag sessions
///
/// All sortable widgets must be descendants of a SortableLayer to function properly.
/// The layer should be placed at a level that encompasses all related sortable widgets.
///
/// Example:
/// ```dart
/// SortableLayer(
///   lock: true, // Constrain dragging within bounds
///   dropDuration: Duration(milliseconds: 300),
///   dropCurve: Curves.easeOut,
///   child: Column(
///     children: [
///       Sortable(...),
///       Sortable(...),
///       Sortable(...),
///     ],
///   ),
/// )
/// ```
class SortableLayer extends StatefulWidget {
/// The child widget tree containing sortable widgets.
///
/// Type: `Widget`. All sortable widgets must be descendants of this child
/// tree to function properly with the layer.
  Widget child;
/// Whether to lock dragging within the layer's bounds.
///
/// Type: `bool`, default: `false`. When true, dragged items cannot be moved
/// outside the layer's visual bounds, providing spatial constraints.
  bool lock;
/// The clipping behavior for the layer.
///
/// Type: `Clip?`. Controls how content is clipped. If null, uses Clip.hardEdge
/// when [lock] is true, otherwise Clip.none.
  Clip? clipBehavior;
/// Duration for drop animations when drag operations complete.
///
/// Type: `Duration?`. If null, uses the default duration. Set to Duration.zero
/// to disable drop animations entirely.
  Duration? dropDuration;
/// Animation curve for drop transitions.
///
/// Type: `Curve?`. If null, uses Curves.easeInOut. Controls the easing
/// behavior of items animating to their final drop position.
  Curve? dropCurve;
/// Creates a [SortableLayer] to manage drag-and-drop operations.
///
/// Configures the layer that coordinates drag sessions between sortable widgets
/// and provides the rendering context for drag operations.
///
/// Parameters:
/// - [key] (Key?): Widget identifier for the widget tree
/// - [child] (Widget, required): The widget tree containing sortable widgets
/// - [lock] (bool, default: false): Whether to constrain dragging within bounds
/// - [clipBehavior] (Clip?, optional): How to clip the layer content
/// - [dropDuration] (Duration?, optional): Duration for drop animations
/// - [dropCurve] (Curve?, optional): Curve for drop animation easing
///
/// Example:
/// ```dart
/// SortableLayer(
///   lock: true,
///   dropDuration: Duration(milliseconds: 250),
///   dropCurve: Curves.easeInOutCubic,
///   child: ListView(
///     children: sortableItems.map((item) => Sortable(...)).toList(),
///   ),
/// )
/// ```
  const SortableLayer({super.key, this.lock = false, this.clipBehavior, this.dropDuration, this.dropCurve, required this.child});
  State<SortableLayer> createState();
/// Ensures a pending drop operation is completed and dismisses it.
///
/// Finds the sortable layer in the widget tree and ensures that any pending
/// drop operation for the specified data is completed and dismissed. This is
/// useful for programmatically finalizing drop operations.
///
/// Parameters:
/// - [context] (BuildContext): The build context to find the layer from
/// - [data] (Object): The data associated with the drop operation to dismiss
///
/// Example:
/// ```dart
/// // After programmatic reordering
/// SortableLayer.ensureAndDismissDrop(context, sortableData);
/// ```
  static void ensureAndDismissDrop(BuildContext context, Object data);
/// Dismisses any pending drop operations.
///
/// Finds the sortable layer in the widget tree and dismisses any currently
/// pending drop operations. This clears any visual feedback or animations
/// related to incomplete drops.
///
/// Parameters:
/// - [context] (BuildContext): The build context to find the layer from
///
/// Example:
/// ```dart
/// // Clear any pending drops when navigating away
/// SortableLayer.dismissDrop(context);
/// ```
  static void dismissDrop(BuildContext context);
}
/// A sortable layer that provides automatic scrolling during drag operations.
///
/// ScrollableSortableLayer extends the basic sortable functionality with automatic
/// scrolling when dragged items approach the edges of scrollable areas. This provides
/// a smooth user experience when dragging items in long lists or grids that extend
/// beyond the visible area.
///
/// The layer monitors drag positions and automatically scrolls the associated
/// scroll controller when the drag position comes within the configured threshold
/// of the scroll area edges. Scrolling speed is proportional to proximity to edges.
///
/// Features:
/// - Automatic scrolling when dragging near scroll area edges
/// - Configurable scroll threshold distance from edges
/// - Proportional scrolling speed based on proximity
/// - Optional overscroll support for scrolling beyond normal bounds
/// - Integrated with standard Flutter ScrollController
///
/// This layer should wrap scrollable widgets like ListView, GridView, or CustomScrollView
/// that contain sortable items. The scroll controller must be provided to enable
/// automatic scrolling functionality.
///
/// Example:
/// ```dart
/// ScrollController scrollController = ScrollController();
///
/// ScrollableSortableLayer(
///   controller: scrollController,
///   scrollThreshold: 80.0,
///   child: ListView.builder(
///     controller: scrollController,
///     itemBuilder: (context, index) => Sortable(...),
///   ),
/// )
/// ```
class ScrollableSortableLayer extends StatefulWidget {
/// The child widget containing sortable items within a scrollable area.
///
/// Type: `Widget`. Typically a scrollable widget like ListView or GridView
/// that contains sortable items and uses the same controller.
  Widget child;
/// The scroll controller that manages the scrollable area.
///
/// Type: `ScrollController`. Must be the same controller used by the scrollable
/// widget in the child tree. This allows the layer to control scrolling during
/// drag operations.
  ScrollController controller;
/// Distance from scroll area edges that triggers automatic scrolling.
///
/// Type: `double`, default: `50.0`. When a dragged item comes within this
/// distance of the top or bottom edge (for vertical scrolling), automatic
/// scrolling begins. Larger values provide earlier scroll activation.
  double scrollThreshold;
/// Whether to allow scrolling beyond the normal scroll bounds.
///
/// Type: `bool`, default: `false`. When true, drag operations can trigger
/// scrolling past the normal scroll limits, similar to overscroll behavior.
  bool overscroll;
/// Creates a [ScrollableSortableLayer] with automatic scrolling support.
///
/// Configures a sortable layer that provides automatic scrolling when dragged
/// items approach the edges of the scrollable area.
///
/// Parameters:
/// - [key] (Key?): Widget identifier for the widget tree
/// - [child] (Widget, required): The scrollable widget containing sortable items
/// - [controller] (ScrollController, required): The scroll controller to manage
/// - [scrollThreshold] (double, default: 50.0): Distance from edges for scroll trigger
/// - [overscroll] (bool, default: false): Whether to allow overscroll behavior
///
/// Example:
/// ```dart
/// final controller = ScrollController();
///
/// ScrollableSortableLayer(
///   controller: controller,
///   scrollThreshold: 60.0,
///   overscroll: true,
///   child: ListView.builder(
///     controller: controller,
///     itemCount: items.length,
///     itemBuilder: (context, index) => Sortable<Item>(
///       data: SortableData(items[index]),
///       child: ItemWidget(items[index]),
///     ),
///   ),
/// )
/// ```
  const ScrollableSortableLayer({super.key, required this.child, required this.controller, this.scrollThreshold = 50, this.overscroll = false});
  State<ScrollableSortableLayer> createState();
}
/// Theme configuration for [Collapsible], [CollapsibleTrigger], and [CollapsibleContent] widgets.
///
/// [CollapsibleTheme] provides styling options for collapsible components including
/// padding, iconography, and layout alignment. It enables consistent collapsible
/// styling across an application while allowing per-instance customization.
///
/// Used with [ComponentTheme] to apply theme values throughout the widget tree.
///
/// Example:
/// ```dart
/// ComponentTheme<CollapsibleTheme>(
///   data: CollapsibleTheme(
///     padding: 12.0,
///     iconExpanded: Icons.keyboard_arrow_up,
///     iconCollapsed: Icons.keyboard_arrow_down,
///     iconGap: 8.0,
///     crossAxisAlignment: CrossAxisAlignment.start,
///   ),
///   child: MyCollapsibleWidget(),
/// );
/// ```
class CollapsibleTheme extends ComponentThemeData {
/// Horizontal padding applied around [CollapsibleTrigger] content.
///
/// Controls the internal spacing within the trigger area. If null,
/// defaults to 16 logical pixels scaled by theme.
  double? padding;
/// Icon displayed in the trigger when the collapsible is expanded.
///
/// If null, defaults to [Icons.unfold_less].
  IconData? iconExpanded;
/// Icon displayed in the trigger when the collapsible is collapsed.
///
/// If null, defaults to [Icons.unfold_more].
  IconData? iconCollapsed;
/// Cross-axis alignment for children in the [Collapsible] column.
///
/// Controls how children are aligned perpendicular to the main axis.
/// If null, defaults to [CrossAxisAlignment.stretch].
  CrossAxisAlignment? crossAxisAlignment;
/// Main-axis alignment for children in the [Collapsible] column.
///
/// Controls how children are aligned along the main axis.
/// If null, defaults to [MainAxisAlignment.start].
  MainAxisAlignment? mainAxisAlignment;
/// Horizontal spacing between trigger content and expand/collapse icon.
///
/// Controls the gap between the trigger child and the action button.
/// If null, defaults to 16 logical pixels scaled by theme.
  double? iconGap;
/// Creates a [CollapsibleTheme] with the specified styling options.
///
/// All parameters are optional and will fall back to component defaults
/// when not specified.
///
/// Parameters:
/// - [padding] (double?, optional): Horizontal padding for trigger content.
/// - [iconExpanded] (IconData?, optional): Icon shown when expanded.
/// - [iconCollapsed] (IconData?, optional): Icon shown when collapsed.
/// - [crossAxisAlignment] (CrossAxisAlignment?, optional): Cross-axis alignment of children.
/// - [mainAxisAlignment] (MainAxisAlignment?, optional): Main-axis alignment of children.
/// - [iconGap] (double?, optional): Space between trigger content and icon.
  const CollapsibleTheme({this.padding, this.iconExpanded, this.iconCollapsed, this.crossAxisAlignment, this.mainAxisAlignment, this.iconGap});
/// Creates a copy of this theme with the given fields replaced.
///
/// Uses [ValueGetter] functions to allow conditional updates where
/// null getters preserve the original value.
///
/// Example:
/// ```dart
/// final newTheme = originalTheme.copyWith(
///   padding: () => 20.0,
///   iconGap: () => 12.0,
/// );
/// ```
  CollapsibleTheme copyWith({ValueGetter<double?>? padding, ValueGetter<IconData?>? iconExpanded, ValueGetter<IconData?>? iconCollapsed, ValueGetter<CrossAxisAlignment?>? crossAxisAlignment, ValueGetter<MainAxisAlignment?>? mainAxisAlignment, ValueGetter<double?>? iconGap});
  bool operator ==(Object other);
  int get hashCode;
}
/// A container widget that can show or hide its content with a collapsible interface.
///
/// [Collapsible] provides a simple expand/collapse pattern where content can be
/// toggled between visible and hidden states. Unlike [Accordion], multiple
/// collapsible widgets can be expanded simultaneously, making them ideal for
/// independent sections that users might want to view concurrently.
///
/// ## Key Features
/// - **Independent State**: Each collapsible manages its own expansion state
/// - **Flexible Control**: Can be controlled or uncontrolled
/// - **Custom Layout**: Configurable alignment for trigger and content
/// - **Instant Toggle**: Uses visibility toggling rather than animated transitions
/// - **Composable**: Works with [CollapsibleTrigger] and [CollapsibleContent]
///
/// ## Usage Patterns
/// The collapsible can operate in two modes:
/// - **Uncontrolled**: Manages its own state internally
/// - **Controlled**: State managed externally via [onExpansionChanged]
///
/// Example:
/// ```dart
/// Collapsible(
///   isExpanded: false,
///   children: [
///     CollapsibleTrigger(
///       child: Row(
///         children: [
///           Icon(Icons.settings),
///           SizedBox(width: 8),
///           Text('Advanced Settings'),
///         ],
///       ),
///     ),
///     CollapsibleContent(
///       child: Padding(
///         padding: EdgeInsets.all(16),
///         child: Column(
///           children: [
///             CheckboxListTile(title: Text('Option 1'), value: false, onChanged: null),
///             CheckboxListTile(title: Text('Option 2'), value: true, onChanged: null),
///           ],
///         ),
///       ),
///     ),
///   ],
/// );
/// ```
///
/// For more information, visit: https://sunarya-thito.github.io/shadcn_flutter/#/components/collapsible
class Collapsible extends StatefulWidget {
/// The child widgets to display in the collapsible container.
///
/// Typically includes a [CollapsibleTrigger] as the first child, followed by
/// one or more [CollapsibleContent] widgets. The widgets are arranged in
/// a vertical column with configurable alignment.
  List<Widget> children;
/// Initial expansion state when operating in uncontrolled mode.
///
/// If null, defaults to false (collapsed). This value is only used when
/// [onExpansionChanged] is null, indicating uncontrolled mode.
  bool? isExpanded;
/// Callback invoked when the expansion state should change.
///
/// When provided, the collapsible operates in controlled mode and the parent
/// widget is responsible for managing the expansion state. Called with the
/// current expansion state when the user triggers a state change.
  ValueChanged<bool>? onExpansionChanged;
/// Creates a [Collapsible] widget with the specified children.
///
/// Parameters:
/// - [children] (`List<Widget>`, required): Widgets to display in the collapsible container.
/// - [isExpanded] (bool?, optional): Initial expansion state for uncontrolled mode.
/// - [onExpansionChanged] (`ValueChanged<bool>?`, optional): Callback for controlled mode.
///
/// ## Mode Selection
/// - **Uncontrolled Mode**: When [onExpansionChanged] is null, the widget manages
///   its own state using [isExpanded] as the initial value.
/// - **Controlled Mode**: When [onExpansionChanged] is provided, the parent must
///   manage state and update [isExpanded] accordingly.
///
/// Example (Uncontrolled):
/// ```dart
/// Collapsible(
///   isExpanded: true,
///   children: [
///     CollapsibleTrigger(child: Text('Toggle Me')),
///     CollapsibleContent(child: Text('Hidden content')),
///   ],
/// );
/// ```
///
/// Example (Controlled):
/// ```dart
/// bool _expanded = false;
///
/// Collapsible(
///   isExpanded: _expanded,
///   onExpansionChanged: (expanded) => setState(() => _expanded = !_expanded),
///   children: [
///     CollapsibleTrigger(child: Text('Toggle Me')),
///     CollapsibleContent(child: Text('Hidden content')),
///   ],
/// );
/// ```
///
/// For more information, visit: https://sunarya-thito.github.io/shadcn_flutter/#/components/collapsible
  const Collapsible({super.key, required this.children, this.isExpanded, this.onExpansionChanged});
  State<Collapsible> createState();
}
/// State class for [Collapsible] widget.
///
/// Manages the expansion/collapse animation state and handles transitions
/// between expanded and collapsed states.
class CollapsibleState extends State<Collapsible> {
  void initState();
  void didUpdateWidget(covariant Collapsible oldWidget);
  Widget build(BuildContext context);
}
/// Internal data structure for sharing collapsible state between child widgets.
///
/// [CollapsibleStateData] provides a communication mechanism between the
/// [Collapsible] parent and its child widgets like [CollapsibleTrigger] and
/// [CollapsibleContent]. It exposes the current expansion state and a
/// callback for triggering state changes.
class CollapsibleStateData {
/// Callback to trigger expansion state changes.
///
/// When called, triggers the collapsible to toggle its expansion state.
/// This function handles both controlled and uncontrolled modes appropriately.
  VoidCallback handleTap;
/// Current expansion state of the collapsible.
///
/// True when the collapsible is expanded and content should be visible,
/// false when collapsed and content should be hidden.
  bool isExpanded;
/// Creates a [CollapsibleStateData] with the specified state and callback.
///
/// This constructor is used internally by [Collapsible] to share state
/// with its child widgets.
  const CollapsibleStateData({required this.isExpanded, required this.handleTap});
}
/// A trigger widget that controls the expansion state of its parent [Collapsible].
///
/// [CollapsibleTrigger] provides a consistent interface for toggling collapsible
/// content. It automatically displays the appropriate expand/collapse icon and
/// handles user interaction to trigger state changes.
///
/// ## Features
/// - **Automatic Icons**: Shows different icons for expanded/collapsed states
/// - **Integrated Button**: Uses [GhostButton] for consistent interaction styling
/// - **Responsive Layout**: Automatically sizes and spaces content and icon
/// - **Theme Integration**: Respects [CollapsibleTheme] configuration
///
/// The trigger must be used as a direct child of a [Collapsible] widget to
/// function properly, as it relies on inherited state data.
///
/// Example:
/// ```dart
/// CollapsibleTrigger(
///   child: Row(
///     children: [
///       Icon(Icons.folder),
///       SizedBox(width: 8),
///       Text('Project Files'),
///       Spacer(),
///       Badge(child: Text('12')),
///     ],
///   ),
/// );
/// ```
class CollapsibleTrigger extends StatelessWidget {
/// The content widget to display within the trigger.
///
/// Typically contains text, icons, or other UI elements that describe what
/// will be expanded or collapsed. The child is automatically styled and
/// positioned alongside the expand/collapse icon.
  Widget child;
/// Creates a [CollapsibleTrigger] with the specified child content.
///
/// Parameters:
/// - [child] (Widget, required): The content to display in the trigger.
///
/// The trigger automatically provides:
/// - Expand/collapse icon based on current state
/// - Click handling to toggle the parent collapsible
/// - Proper spacing and layout with theme-aware styling
/// - Integration with parent [Collapsible] state
///
/// Example:
/// ```dart
/// CollapsibleTrigger(
///   child: Text('Click to toggle content'),
/// );
/// ```
  const CollapsibleTrigger({super.key, required this.child});
  Widget build(BuildContext context);
}
/// A content widget that shows or hides based on the parent [Collapsible] state.
///
/// [CollapsibleContent] automatically manages its visibility based on the
/// expansion state of its parent [Collapsible]. It uses [Offstage] to
/// completely remove the content from the layout when collapsed, providing
/// efficient performance.
///
/// ## Key Features
/// - **Automatic Visibility**: Shows/hides based on parent expansion state
/// - **Layout Efficiency**: Uses [Offstage] for true layout removal when collapsed
/// - **Optional Control**: Can be configured to ignore collapsible state
/// - **Flexible Content**: Supports any widget as child content
///
/// Example:
/// ```dart
/// CollapsibleContent(
///   child: Container(
///     padding: EdgeInsets.all(16),
///     decoration: BoxDecoration(
///       border: Border.all(color: Colors.grey.shade300),
///       borderRadius: BorderRadius.circular(8),
///     ),
///     child: Column(
///       crossAxisAlignment: CrossAxisAlignment.start,
///       children: [
///         Text('Additional Details'),
///         SizedBox(height: 8),
///         Text('This content is only visible when expanded.'),
///       ],
///     ),
///   ),
/// );
/// ```
class CollapsibleContent extends StatelessWidget {
/// Whether this content should respond to the collapsible state.
///
/// When true (default), the content shows/hides based on the parent
/// [Collapsible] expansion state. When false, the content is always visible
/// regardless of the collapsible state.
  bool collapsible;
/// The widget to show or hide based on expansion state.
///
/// This can be any widget content including text, images, forms, or complex
/// layouts. The child is completely removed from the layout when collapsed.
  Widget child;
/// Creates a [CollapsibleContent] with the specified child widget.
///
/// Parameters:
/// - [collapsible] (bool, default: true): Whether to respond to collapsible state.
/// - [child] (Widget, required): The content widget to show/hide.
///
/// ## Behavior
/// - When [collapsible] is true and parent is collapsed: Content is hidden via [Offstage]
/// - When [collapsible] is true and parent is expanded: Content is visible
/// - When [collapsible] is false: Content is always visible regardless of parent state
///
/// Example:
/// ```dart
/// CollapsibleContent(
///   collapsible: true,
///   child: Padding(
///     padding: EdgeInsets.symmetric(vertical: 16),
///     child: Text('This content can be collapsed'),
///   ),
/// );
/// ```
  const CollapsibleContent({super.key, this.collapsible = true, required this.child});
  Widget build(BuildContext context);
}
/// Provides themed icon container widgets for shadcn_flutter components.
///
/// Includes [IconContainerTheme] and [IconContainer] for styling icons with background, padding, and border radius.
class IconContainerTheme extends ComponentThemeData {
/// Background color for the icon container.
  Color? backgroundColor;
/// Color for the icon inside the container.
  Color? iconColor;
/// Padding inside the icon container.
  EdgeInsetsGeometry? padding;
/// Border radius for the icon container.
  BorderRadius? borderRadius;
/// Creates an [IconContainerTheme].
///
/// Parameters:
/// - [backgroundColor] (`Color?`, optional): Container background color.
/// - [iconColor] (`Color?`, optional): Icon color.
/// - [padding] (`EdgeInsetsGeometry?`, optional): Container padding.
/// - [borderRadius] (`BorderRadius?`, optional): Container border radius.
/// Creates an [IconContainerTheme].
///
/// Parameters:
/// - [backgroundColor] (`Color?`, optional): Container background color.
/// - [iconColor] (`Color?`, optional): Icon color.
/// - [padding] (`EdgeInsetsGeometry?`, optional): Container padding.
/// - [borderRadius] (`BorderRadius?`, optional): Container border radius.
  const IconContainerTheme({this.backgroundColor, this.iconColor, this.padding, this.borderRadius});
/// Returns a copy of this theme with the given fields replaced.
  IconContainerTheme copyWith({ValueGetter<Color?>? backgroundColor, ValueGetter<Color?>? iconColor, ValueGetter<EdgeInsetsGeometry?>? padding, ValueGetter<BorderRadius?>? borderRadius});
  bool operator ==(Object other);
  int get hashCode;
}
/// A container widget for displaying an icon with customizable padding, background, and border radius.
///
/// Use [IconContainer] to wrap an icon and apply theme or custom styling.
///
/// Example:
/// ```dart
/// IconContainer(
///   icon: Icon(Icons.star),
///   backgroundColor: Colors.yellow,
///   borderRadius: BorderRadius.circular(8),
/// )
/// ```
class IconContainer extends StatelessWidget {
/// The icon widget to display.
  Widget icon;
/// Padding inside the container.
  EdgeInsetsGeometry? padding;
/// Border radius for the container.
  BorderRadius? borderRadius;
/// Background color for the container.
  Color? backgroundColor;
/// Color for the icon.
  Color? iconColor;
/// Creates an [IconContainer].
///
/// Parameters:
/// - [icon] (`Widget`, required): Icon widget to display.
/// - [padding] (`EdgeInsetsGeometry?`, optional): Container padding.
/// - [borderRadius] (`BorderRadius?`, optional): Container border radius.
/// - [backgroundColor] (`Color?`, optional): Container background color.
/// - [iconColor] (`Color?`, optional): Icon color.
  const IconContainer({super.key, required this.icon, this.padding, this.borderRadius, this.backgroundColor, this.iconColor});
  Widget build(BuildContext context);
}
/// Theme for [Hidden].
class HiddenTheme extends ComponentThemeData {
/// Direction of the hidden transition.
  Axis? direction;
/// Duration of the animation.
  Duration? duration;
/// Curve of the animation.
  Curve? curve;
/// Whether the widget is reversed.
  bool? reverse;
/// Whether to keep cross axis size when hidden.
  bool? keepCrossAxisSize;
/// Whether to keep main axis size when hidden.
  bool? keepMainAxisSize;
/// Creates a [HiddenTheme].
  const HiddenTheme({this.direction, this.duration, this.curve, this.reverse, this.keepCrossAxisSize, this.keepMainAxisSize});
/// Returns a copy of this theme with the given fields replaced.
  HiddenTheme copyWith({ValueGetter<Axis?>? direction, ValueGetter<Duration?>? duration, ValueGetter<Curve?>? curve, ValueGetter<bool?>? reverse, ValueGetter<bool?>? keepCrossAxisSize, ValueGetter<bool?>? keepMainAxisSize});
  bool operator ==(Object other);
  int get hashCode;
}
/// A widget that conditionally hides its child with optional animation.
///
/// Provides a simple way to show/hide widgets with smooth animations. When
/// hidden, the widget can maintain its size in either axis or collapse
/// completely. Supports slide animations in any direction.
///
/// Example:
/// ```dart
/// Hidden(
///   hidden: !isVisible,
///   direction: Axis.vertical,
///   duration: Duration(milliseconds: 300),
///   child: Container(
///     height: 100,
///     child: Text('Toggle visibility'),
///   ),
/// )
/// ```
class Hidden extends StatelessWidget {
/// Whether the child widget should be hidden.
///
/// When `true`, the child is hidden (optionally animated). When `false`,
/// the child is visible.
  bool hidden;
/// The child widget to show or hide.
  Widget child;
/// The axis along which to animate the hiding.
///
/// If `null`, the widget is hidden without animation.
  Axis? direction;
/// Whether to reverse the hide animation direction.
///
/// When `true`, slides out in the opposite direction.
  bool? reverse;
/// Duration of the hide/show animation.
///
/// If `null`, uses a default duration or hides instantly.
  Duration? duration;
/// Animation curve for the hide/show transition.
///
/// If `null`, uses a default curve.
  Curve? curve;
/// Whether to maintain the widget's cross-axis size when hidden.
///
/// When `true`, preserves width (for vertical slides) or height (for
/// horizontal slides) during the animation.
  bool? keepCrossAxisSize;
/// Whether to maintain the widget's main-axis size when hidden.
///
/// When `true`, preserves the size along the animation axis, creating
/// a fade-out effect instead of a slide.
  bool? keepMainAxisSize;
/// Creates a [Hidden].
///
/// Parameters:
/// - [hidden] (`bool`, required): Whether to hide the child.
/// - [child] (`Widget`, required): Widget to show/hide.
/// - [direction] (`Axis?`, optional): Animation axis.
/// - [duration] (`Duration?`, optional): Animation duration.
/// - [curve] (`Curve?`, optional): Animation curve.
/// - [reverse] (`bool?`, optional): Reverse animation direction.
/// - [keepCrossAxisSize] (`bool?`, optional): Maintain cross-axis size.
/// - [keepMainAxisSize] (`bool?`, optional): Maintain main-axis size.
  const Hidden({super.key, required this.hidden, required this.child, this.direction, this.duration, this.curve, this.reverse, this.keepCrossAxisSize, this.keepMainAxisSize});
  Widget build(BuildContext context);
}
/// Theme configuration for [MediaQueryVisibility].
class MediaQueryVisibilityTheme extends ComponentThemeData {
/// Minimum width at which the child is shown.
  double? minWidth;
/// Maximum width at which the child is shown.
  double? maxWidth;
/// Creates a [MediaQueryVisibilityTheme].
  const MediaQueryVisibilityTheme({this.minWidth, this.maxWidth});
/// Creates a copy of this theme but with the given fields replaced.
  MediaQueryVisibilityTheme copyWith({ValueGetter<double?>? minWidth, ValueGetter<double?>? maxWidth});
  bool operator ==(Object other);
  int get hashCode;
}
/// A widget that conditionally displays children based on media query constraints.
///
/// Shows [child] when the current screen width falls within the specified range
/// defined by [minWidth] and [maxWidth]. Optionally displays [alternateChild]
/// when the width is outside the range. Useful for responsive layouts.
///
/// Example:
/// ```dart
/// MediaQueryVisibility(
///   minWidth: 600,
///   maxWidth: 1200,
///   child: TabletLayout(),
///   alternateChild: MobileLayout(),
/// )
/// ```
class MediaQueryVisibility extends StatelessWidget {
/// Minimum screen width to show [child].
///
/// If `null`, no minimum constraint is applied.
  double? minWidth;
/// Maximum screen width to show [child].
///
/// If `null`, no maximum constraint is applied.
  double? maxWidth;
/// Widget to display when width is within range.
  Widget child;
/// Widget to display when width is outside range.
///
/// If `null`, nothing is displayed when outside range.
  Widget? alternateChild;
/// Creates a [MediaQueryVisibility].
///
/// Parameters:
/// - [minWidth] (`double?`, optional): Minimum width threshold.
/// - [maxWidth] (`double?`, optional): Maximum width threshold.
/// - [child] (`Widget`, required): Widget to show within range.
/// - [alternateChild] (`Widget?`, optional): Widget to show outside range.
  const MediaQueryVisibility({super.key, this.minWidth, this.maxWidth, required this.child, this.alternateChild});
  Widget build(BuildContext context);
}
/// Theme configuration for [Table] components.
///
/// [TableTheme] provides comprehensive styling options for table components
/// including borders, background colors, corner radius, and cell theming.
/// It integrates with the shadcn_flutter theming system to ensure consistent
/// table styling throughout an application.
///
/// Used with [ComponentTheme] to apply theme values throughout the widget tree.
///
/// Example:
/// ```dart
/// ComponentTheme<TableTheme>(
///   data: TableTheme(
///     border: Border.all(color: Colors.grey.shade300),
///     borderRadius: BorderRadius.circular(8.0),
///     backgroundColor: Colors.grey.shade50,
///     cellTheme: TableCellTheme(
///       padding: EdgeInsets.all(12.0),
///     ),
///   ),
///   child: MyTableWidget(),
/// );
/// ```
class TableTheme extends ComponentThemeData {
/// Border configuration for the entire table.
///
/// Type: `Border?`. Defines the outer border of the table container.
/// If null, uses the default theme border or no border.
  Border? border;
/// Border radius for the table corners.
///
/// Type: `BorderRadiusGeometry?`. Controls corner rounding of the table
/// container. If null, uses the theme's default radius.
  BorderRadiusGeometry? borderRadius;
/// Background color for the table container.
///
/// Type: `Color?`. Used as the background color behind all table content.
/// If null, uses the theme's default background color.
  Color? backgroundColor;
/// Default theme for all table cells.
///
/// Type: `TableCellTheme?`. Provides default styling for table cells
/// including padding, borders, and text styles. Individual cells can
/// override this theme.
  TableCellTheme? cellTheme;
/// Creates a [TableTheme].
///
/// All parameters are optional and will fall back to theme defaults
/// when not provided.
///
/// Parameters:
/// - [border] (Border?, optional): Table container border
/// - [backgroundColor] (Color?, optional): Table background color
/// - [borderRadius] (BorderRadiusGeometry?, optional): Corner radius
/// - [cellTheme] (TableCellTheme?, optional): Default cell styling
///
/// Example:
/// ```dart
/// TableTheme(
///   border: Border.all(color: Colors.grey),
///   borderRadius: BorderRadius.circular(4.0),
///   backgroundColor: Colors.white,
/// );
/// ```
  const TableTheme({this.border, this.backgroundColor, this.borderRadius, this.cellTheme});
  bool operator ==(Object other);
  int get hashCode;
/// Creates a copy of this theme with the given values replaced.
///
/// Returns a new [TableTheme] instance with the same values as this theme,
/// except for any parameters that are explicitly provided. Use [ValueGetter]
/// functions to specify new values.
///
/// Parameters are [ValueGetter] functions that return the new value when called.
/// This allows for conditional value setting and proper null handling.
///
/// Example:
/// ```dart
/// final newTheme = originalTheme.copyWith(
///   backgroundColor: () => Colors.blue.shade50,
///   border: () => Border.all(color: Colors.blue),
/// );
/// ```
  TableTheme copyWith({ValueGetter<Border?>? border, ValueGetter<Color?>? backgroundColor, ValueGetter<TableCellTheme?>? cellTheme});
}
/// Defines size constraints for table columns or rows.
///
/// Specifies minimum and maximum size limits that can be applied
/// to table dimensions. Used with [ResizableTable] to control
/// resize boundaries.
///
/// Example:
/// ```dart
/// ConstrainedTableSize(
///   min: 50.0,  // Minimum 50 pixels
///   max: 300.0, // Maximum 300 pixels
/// )
/// ```
class ConstrainedTableSize {
/// Minimum allowed size. Defaults to negative infinity (no minimum).
  double min;
/// Maximum allowed size. Defaults to positive infinity (no maximum).
  double max;
/// Creates a [ConstrainedTableSize] with optional min and max values.
  const ConstrainedTableSize({this.min = double.negativeInfinity, this.max = double.infinity});
}
/// Theme configuration for individual table cells.
///
/// [TableCellTheme] provides state-aware styling options for table cells
/// using [WidgetStateProperty] to handle different interactive states like
/// hover, selected, disabled, etc. This enables rich visual feedback for
/// table interactions.
///
/// ## State-Aware Properties
/// All properties use [WidgetStateProperty] to support different visual
/// states:
/// - [WidgetState.hovered]: Mouse hover state
/// - [WidgetState.selected]: Cell/row selection state
/// - [WidgetState.disabled]: Disabled interaction state
/// - [WidgetState.pressed]: Active press state
///
/// Example:
/// ```dart
/// TableCellTheme(
///   backgroundColor: WidgetStateProperty.resolveWith((states) {
///     if (states.contains(WidgetState.hovered)) {
///       return Colors.blue.shade50;
///     }
///     return null;
///   }),
///   textStyle: WidgetStateProperty.all(
///     TextStyle(fontWeight: FontWeight.w500),
///   ),
/// );
/// ```
class TableCellTheme {
/// State-aware border configuration for table cells.
///
/// Type: `WidgetStateProperty<Border?>?`. Defines cell borders that can
/// change based on interactive states. Useful for highlighting selected
/// or hovered cells.
  WidgetStateProperty<Border?>? border;
/// State-aware background color for table cells.
///
/// Type: `WidgetStateProperty<Color?>?`. Controls cell background colors
/// that can change based on hover, selection, or other states.
  WidgetStateProperty<Color?>? backgroundColor;
/// State-aware text styling for table cell content.
///
/// Type: `WidgetStateProperty<TextStyle?>?`. Controls text appearance
/// including color, weight, size that can change based on cell states.
  WidgetStateProperty<TextStyle?>? textStyle;
/// Creates a [TableCellTheme].
///
/// All parameters are optional and use [WidgetStateProperty] for
/// state-aware styling.
///
/// Parameters:
/// - [border] (`WidgetStateProperty<Border?>?`, optional): State-aware borders
/// - [backgroundColor] (`WidgetStateProperty<Color?>?`, optional): State-aware background
/// - [textStyle] (`WidgetStateProperty<TextStyle?>?`, optional): State-aware text styling
///
/// Example:
/// ```dart
/// TableCellTheme(
///   border: WidgetStateProperty.all(
///     Border.all(color: Colors.grey.shade300),
///   ),
///   backgroundColor: WidgetStateProperty.resolveWith((states) {
///     return states.contains(WidgetState.selected) ? Colors.blue.shade100 : null;
///   }),
/// );
/// ```
  const TableCellTheme({this.border, this.backgroundColor, this.textStyle});
  bool operator ==(Object other);
  int get hashCode;
/// Creates a copy of this cell theme with the given values replaced.
///
/// Returns a new [TableCellTheme] instance with the same state properties
/// as this theme, except for any parameters that are explicitly provided.
/// Use [ValueGetter] functions to specify new state properties.
///
/// Example:
/// ```dart
/// final newTheme = originalTheme.copyWith(
///   backgroundColor: () => WidgetStateProperty.all(Colors.yellow.shade50),
///   textStyle: () => WidgetStateProperty.all(TextStyle(fontWeight: FontWeight.bold)),
/// );
/// ```
  TableCellTheme copyWith({ValueGetter<WidgetStateProperty<Border>?>? border, ValueGetter<WidgetStateProperty<Color>?>? backgroundColor, ValueGetter<WidgetStateProperty<TextStyle>?>? textStyle});
}
/// Theme configuration for resizable tables.
///
/// Provides styling options for resizable table components including
/// the base table theme, resizer appearance, and interaction behavior.
///
/// Example:
/// ```dart
/// ResizableTableTheme(
///   tableTheme: TableTheme(...),
///   resizerThickness: 2.0,
///   resizerColor: Colors.blue,
/// )
/// ```
class ResizableTableTheme extends ComponentThemeData {
/// Base theme configuration for the table.
  TableTheme? tableTheme;
/// Thickness of the resize handle in pixels.
  double? resizerThickness;
/// Color of the resize handle.
  Color? resizerColor;
/// Creates a [ResizableTableTheme].
  const ResizableTableTheme({this.tableTheme, this.resizerThickness, this.resizerColor});
  bool operator ==(Object other);
  int get hashCode;
/// Creates a copy of this theme with the given fields replaced.
///
/// Parameters:
/// - [tableTheme] (`ValueGetter<TableTheme?>?`, optional): New table theme.
/// - [resizerThickness] (`ValueGetter<double?>?`, optional): New resizer thickness.
/// - [resizerColor] (`ValueGetter<Color?>?`, optional): New resizer color.
///
/// Returns: A new [ResizableTableTheme] with updated properties.
  ResizableTableTheme copyWith({ValueGetter<TableTheme?>? tableTheme, ValueGetter<double?>? resizerThickness, ValueGetter<Color?>? resizerColor});
}
/// Controller for managing resizable table column and row dimensions.
///
/// Provides programmatic control over table column widths and row heights
/// with support for constraints, default sizes, and interactive resizing.
/// Extends [ChangeNotifier] to notify listeners when dimensions change.
///
/// Example:
/// ```dart
/// final controller = ResizableTableController(
///   defaultColumnWidth: 100.0,
///   defaultRowHeight: 40.0,
///   columnWidths: {0: 150.0, 2: 200.0},
///   widthConstraints: {1: ConstrainedTableSize(min: 50, max: 300)},
/// );
/// ```
class ResizableTableController extends ChangeNotifier {
/// Creates a controller for managing resizable table dimensions.
///
/// This controller manages column widths and row heights with support for
/// constraints and dynamic resizing. It provides methods to resize individual
/// columns/rows or adjust shared borders between adjacent columns/rows.
///
/// Parameters:
/// - [columnWidths] (`Map<int, double>?`): Initial column widths by index
/// - [defaultColumnWidth] (double, required): Default width for columns without explicit width
/// - [rowHeights] (`Map<int, double>?`): Initial row heights by index
/// - [defaultRowHeight] (double, required): Default height for rows without explicit height
/// - [defaultWidthConstraint] (ConstrainedTableSize?): Default width constraints applied to all columns
/// - [defaultHeightConstraint] (ConstrainedTableSize?): Default height constraints applied to all rows
/// - [widthConstraints] (`Map<int, ConstrainedTableSize>?`): Per-column width constraints
/// - [heightConstraints] (`Map<int, ConstrainedTableSize>?`): Per-row height constraints
///
/// Example:
/// ```dart
/// ResizableTableController(
///   defaultColumnWidth: 100,
///   defaultRowHeight: 40,
///   widthConstraints: {
///     0: ConstrainedTableSize(min: 80, max: 200),
///   },
/// )
/// ```
  ResizableTableController({Map<int, double>? columnWidths, required double defaultColumnWidth, Map<int, double>? rowHeights, required double defaultRowHeight, ConstrainedTableSize? defaultWidthConstraint, ConstrainedTableSize? defaultHeightConstraint, Map<int, ConstrainedTableSize>? widthConstraints, Map<int, ConstrainedTableSize>? heightConstraints});
/// Resizes a specific column to a new width.
///
/// Parameters:
/// - [column] (`int`, required): Column index.
/// - [width] (`double`, required): New width in pixels.
///
/// Returns: `bool` ‚Äî true if resize succeeded, false otherwise.
  bool resizeColumn(int column, double width);
/// Resizes adjacent columns by dragging their shared border.
///
/// Parameters:
/// - [previousColumn] (`int`, required): Index of column before border.
/// - [nextColumn] (`int`, required): Index of column after border.
/// - [deltaWidth] (`double`, required): Width change in pixels.
///
/// Returns: `double` ‚Äî actual width change applied.
  double resizeColumnBorder(int previousColumn, int nextColumn, double deltaWidth);
/// Resizes adjacent rows by dragging their shared border.
///
/// Parameters:
/// - [previousRow] (`int`, required): Index of row before border.
/// - [nextRow] (`int`, required): Index of row after border.
/// - [deltaHeight] (`double`, required): Height change in pixels.
///
/// Returns: `double` ‚Äî actual height change applied.
  double resizeRowBorder(int previousRow, int nextRow, double deltaHeight);
/// Resizes a specific row to a new height.
///
/// Parameters:
/// - [row] (`int`, required): Row index.
/// - [height] (`double`, required): New height in pixels.
///
/// Returns: `bool` ‚Äî true if resize succeeded, false otherwise.
  bool resizeRow(int row, double height);
/// Gets an unmodifiable map of custom column widths.
///
/// Returns: `Map<int, double>?` ‚Äî map of column indices to widths, or null if none set.
  Map<int, double>? get columnWidths;
/// Gets an unmodifiable map of custom row heights.
///
/// Returns: `Map<int, double>?` ‚Äî map of row indices to heights, or null if none set.
  Map<int, double>? get rowHeights;
/// Gets the width of a specific column.
///
/// Parameters:
/// - [index] (`int`, required): Column index.
///
/// Returns: `double` ‚Äî column width in pixels.
  double getColumnWidth(int index);
/// Gets the height of a specific row.
///
/// Parameters:
/// - [index] (`int`, required): Row index.
///
/// Returns: `double` ‚Äî row height in pixels.
  double getRowHeight(int index);
/// Gets the minimum height constraint for a specific row.
///
/// Parameters:
/// - [index] (`int`, required): Row index.
///
/// Returns: `double?` ‚Äî minimum height, or null if unconstrained.
  double? getRowMinHeight(int index);
/// Gets the maximum height constraint for a specific row.
///
/// Parameters:
/// - [index] (`int`, required): Row index.
///
/// Returns: `double?` ‚Äî maximum height, or null if unconstrained.
  double? getRowMaxHeight(int index);
/// Gets the minimum width constraint for a specific column.
///
/// Parameters:
/// - [index] (`int`, required): Column index.
///
/// Returns: `double?` ‚Äî minimum width, or null if unconstrained.
  double? getColumnMinWidth(int index);
/// Gets the maximum width constraint for a specific column.
///
/// Parameters:
/// - [index] (`int`, required): Column index.
///
/// Returns: `double?` ‚Äî maximum width, or null if unconstrained.
  double? getColumnMaxWidth(int index);
}
/// Defines how table cells should resize.
///
/// Determines the behavior when a table cell is resized by the user.
enum TableCellResizeMode { expand, reallocate, none }
/// A table widget with resizable columns and rows.
///
/// Displays tabular data with interactive row and column resizing capabilities.
/// Supports frozen rows/columns, custom resize modes, and scrolling viewports.
///
/// Example:
/// ```dart
/// ResizableTable(
///   controller: ResizableTableController(),
///   rows: [
///     TableRow(children: [Text('Cell 1'), Text('Cell 2')]),
///     TableRow(children: [Text('Cell 3'), Text('Cell 4')]),
///   ],
/// )
/// ```
class ResizableTable extends StatefulWidget {
/// List of table rows to display.
  List<TableRow> rows;
/// Controller for managing table resize state.
  ResizableTableController controller;
/// Theme for table styling.
  ResizableTableTheme? theme;
/// How content should be clipped at table boundaries.
  Clip clipBehavior;
/// Resize mode for column widths.
  TableCellResizeMode cellWidthResizeMode;
/// Resize mode for row heights.
  TableCellResizeMode cellHeightResizeMode;
/// Configuration for frozen (non-scrolling) rows and columns.
  FrozenTableData? frozenCells;
/// Horizontal scroll offset.
  double? horizontalOffset;
/// Vertical scroll offset.
  double? verticalOffset;
/// Size of the visible viewport.
  Size? viewportSize;
/// Creates a [ResizableTable].
///
/// Parameters:
/// - [rows] (`List<TableRow>`, required): Table rows.
/// - [controller] (`ResizableTableController`, required): Resize controller.
/// - [theme] (`ResizableTableTheme?`, optional): Table theme.
/// - [clipBehavior] (`Clip`, default: `Clip.hardEdge`): Clipping behavior.
/// - [cellWidthResizeMode] (`TableCellResizeMode`, default: `reallocate`): Column resize mode.
/// - [cellHeightResizeMode] (`TableCellResizeMode`, default: `expand`): Row resize mode.
/// - [frozenCells] (`FrozenTableData?`, optional): Frozen cell configuration.
/// - [horizontalOffset] (`double?`, optional): Horizontal scroll offset.
/// - [verticalOffset] (`double?`, optional): Vertical scroll offset.
/// - [viewportSize] (`Size?`, optional): Viewport size.
  const ResizableTable({super.key, required this.rows, required this.controller, this.theme, this.clipBehavior = Clip.hardEdge, this.cellWidthResizeMode = TableCellResizeMode.reallocate, this.cellHeightResizeMode = TableCellResizeMode.expand, this.frozenCells, this.horizontalOffset, this.verticalOffset, this.viewportSize});
  State<ResizableTable> createState();
}
/// Represents a single cell in a table.
///
/// Defines cell content, spanning behavior, and styling. Cells can span
/// multiple columns or rows, respond to hover interactions, and have
/// custom themes and background colors.
///
/// Example:
/// ```dart
/// TableCell(
///   columnSpan: 2,
///   rowSpan: 1,
///   child: Text('Spanning cell'),
///   rowHover: true,
///   backgroundColor: Colors.blue.shade50,
/// )
/// ```
class TableCell {
/// Number of columns this cell spans. Defaults to 1.
  int columnSpan;
/// Number of rows this cell spans. Defaults to 1.
  int rowSpan;
/// The widget displayed in this cell.
  Widget child;
/// Whether to highlight this cell when hovering over its column.
  bool columnHover;
/// Whether to highlight this cell when hovering over its row.
  bool rowHover;
/// Background color for this cell. Overrides theme color.
  Color? backgroundColor;
/// Custom theme for this cell. Overrides table-level theme.
  TableCellTheme? theme;
/// Whether this cell responds to user interactions.
  bool enabled;
/// Creates a [TableCell].
  const TableCell({this.columnSpan = 1, this.rowSpan = 1, required this.child, this.backgroundColor, this.columnHover = false, this.rowHover = true, this.theme, this.enabled = true});
/// Builds the widget tree for this table cell.
///
/// This method renders the cell with appropriate styling including:
/// - Background color based on theme and state
/// - Border styling with state resolution
/// - Hover effects for column and row highlighting
/// - Selection state visualization
/// - Resize handles if the table is resizable
///
/// The build process integrates with the table's hover system to provide
/// visual feedback when the mouse hovers over cells in the same row or column.
///
/// Returns a [Widget] representing the fully styled table cell.
  Widget build(BuildContext context);
  bool operator ==(Object other);
  int get hashCode;
}
/// Represents a row in a table.
///
/// Contains a list of cells and optional styling for all cells in the row.
/// Can be marked as selected to highlight the entire row.
///
/// Example:
/// ```dart
/// TableRow(
///   cells: [
///     TableCell(child: Text('Cell 1')),
///     TableCell(child: Text('Cell 2')),
///   ],
///   selected: true,
///   cellTheme: TableCellTheme(...),
/// )
/// ```
class TableRow {
/// The cells contained in this row.
  List<TableCell> cells;
/// Theme applied to all cells in this row.
  TableCellTheme? cellTheme;
/// Whether this row is selected.
  bool selected;
/// Creates a [TableRow].
  const TableRow({required this.cells, this.cellTheme, this.selected = false});
/// Builds the default theme for cells in this row.
///
/// Creates a [TableCellTheme] with default styling when no explicit [cellTheme]
/// is provided. The default theme includes:
/// - Border with bottom line using theme border color
/// - Background color that changes to muted on hover
/// - Text style that becomes muted when disabled
///
/// The theme uses [WidgetStateProperty] to adapt styling based on cell state
/// (hovered, selected, disabled).
///
/// Parameters:
/// - [context] (BuildContext, required): Build context for accessing theme data
///
/// Returns [TableCellTheme] with default or custom cell styling.
  TableCellTheme buildDefaultTheme(BuildContext context);
  bool operator ==(Object other);
  int get hashCode;
}
/// Specialized row for table footers.
///
/// Extends [TableRow] with default styling appropriate for footer rows,
/// including muted background colors and custom hover effects.
///
/// Example:
/// ```dart
/// TableFooter(
///   cells: [
///     TableCell(child: Text('Total: \$100')),
///     TableCell(child: Text('Paid')),
///   ],
/// )
/// ```
class TableFooter extends TableRow {
/// Creates a [TableFooter].
  const TableFooter({required super.cells, super.cellTheme});
  TableCellTheme buildDefaultTheme(BuildContext context);
}
/// Specialized row for table headers.
///
/// Extends [TableRow] with default styling appropriate for header rows,
/// including bold text, muted background, and bottom border styling.
///
/// Example:
/// ```dart
/// TableHeader(
///   cells: [
///     TableCell(child: Text('Name')),
///     TableCell(child: Text('Age')),
///     TableCell(child: Text('City')),
///   ],
/// )
/// ```
class TableHeader extends TableRow {
/// Creates a [TableHeader].
  const TableHeader({required super.cells, super.cellTheme});
  TableCellTheme buildDefaultTheme(BuildContext context);
}
/// A flexible table widget with support for spanning, scrolling, and interactive features.
///
/// [Table] provides a comprehensive table component with advanced layout capabilities
/// including cell spanning, flexible sizing, frozen cells, scrolling, and rich theming.
/// It supports both simple data tables and complex layouts with header/footer rows.
///
/// ## Key Features
/// - **Cell Spanning**: Support for colspan and rowspan across multiple cells
/// - **Flexible Sizing**: Multiple sizing strategies (fixed, flex, intrinsic) for columns/rows
/// - **Frozen Cells**: Ability to freeze specific cells during scrolling
/// - **Interactive States**: Hover effects and selection states with visual feedback
/// - **Scrolling**: Optional horizontal and vertical scrolling with viewport control
/// - **Theming**: Comprehensive theming system for visual customization
///
/// ## Layout System
/// The table uses a sophisticated layout system that handles:
/// - Variable column widths via [TableSize] strategies
/// - Dynamic row heights based on content
/// - Complex cell spanning calculations
/// - Efficient rendering with viewport culling
///
/// ## Sizing Strategies
/// - [FlexTableSize]: Proportional sizing like CSS flex
/// - [FixedTableSize]: Absolute pixel sizes
/// - [IntrinsicTableSize]: Size based on content
///
/// Example:
/// ```dart
/// Table(
///   rows: [
///     TableHeader(cells: [
///       TableCell(child: Text('Name')),
///       TableCell(child: Text('Age')),
///       TableCell(child: Text('City')),
///     ]),
///     TableRow(cells: [
///       TableCell(child: Text('John Doe')),
///       TableCell(child: Text('25')),
///       TableCell(child: Text('New York')),
///     ]),
///   ],
///   columnWidths: {
///     0: FlexTableSize(flex: 2),
///     1: FixedTableSize(width: 80),
///     2: FlexTableSize(flex: 1),
///   },
/// );
/// ```
class Table extends StatefulWidget {
/// List of rows to display in the table.
///
/// Type: `List<TableRow>`. Contains the table data organized as rows.
/// Can include [TableRow], [TableHeader], and [TableFooter] instances.
/// Each row contains a list of [TableCell] widgets.
  List<TableRow> rows;
/// Default sizing strategy for all columns.
///
/// Type: `TableSize`. Used when no specific width is provided in
/// [columnWidths]. Defaults to [FlexTableSize] for proportional sizing.
  TableSize defaultColumnWidth;
/// Default sizing strategy for all rows.
///
/// Type: `TableSize`. Used when no specific height is provided in
/// [rowHeights]. Defaults to [IntrinsicTableSize] for content-based sizing.
  TableSize defaultRowHeight;
/// Specific column width overrides.
///
/// Type: `Map<int, TableSize>?`. Maps column indices to specific sizing
/// strategies. Overrides [defaultColumnWidth] for specified columns.
  Map<int, TableSize>? columnWidths;
/// Specific row height overrides.
///
/// Type: `Map<int, TableSize>?`. Maps row indices to specific sizing
/// strategies. Overrides [defaultRowHeight] for specified rows.
  Map<int, TableSize>? rowHeights;
/// Clipping behavior for the table content.
///
/// Type: `Clip`. Controls how content is clipped at table boundaries.
/// Defaults to [Clip.hardEdge] for clean boundaries.
  Clip clipBehavior;
/// Theme configuration for the table appearance.
///
/// Type: `TableTheme?`. Controls borders, colors, and overall styling.
/// If null, uses the default theme from [ComponentTheme].
  TableTheme? theme;
/// Configuration for frozen cells during scrolling.
///
/// Type: `FrozenTableData?`. Specifies which cells remain visible
/// during horizontal or vertical scrolling. Useful for headers/footers.
  FrozenTableData? frozenCells;
/// Horizontal scroll offset for the table viewport.
///
/// Type: `double?`. Controls horizontal scrolling position. If provided,
/// the table displays within a scrollable viewport.
  double? horizontalOffset;
/// Vertical scroll offset for the table viewport.
///
/// Type: `double?`. Controls vertical scrolling position. If provided,
/// the table displays within a scrollable viewport.
  double? verticalOffset;
/// Size constraints for the table viewport.
///
/// Type: `Size?`. When provided with scroll offsets, constrains the
/// visible area of the table. Essential for scrolling behavior.
  Size? viewportSize;
/// Creates a [Table] widget.
///
/// The table displays data organized in rows and cells with flexible
/// sizing and interactive features.
///
/// Parameters:
/// - [rows] (`List<TableRow>`, required): Table data organized as rows
/// - [defaultColumnWidth] (TableSize, default: FlexTableSize()): Default column sizing
/// - [defaultRowHeight] (TableSize, default: IntrinsicTableSize()): Default row sizing
/// - [columnWidths] (`Map<int, TableSize>?`, optional): Column-specific sizes
/// - [rowHeights] (`Map<int, TableSize>?`, optional): Row-specific sizes
/// - [clipBehavior] (Clip, default: Clip.hardEdge): Content clipping behavior
/// - [theme] (TableTheme?, optional): Visual styling configuration
/// - [frozenCells] (FrozenTableData?, optional): Frozen cell configuration
/// - [horizontalOffset] (double?, optional): Horizontal scroll position
/// - [verticalOffset] (double?, optional): Vertical scroll position
/// - [viewportSize] (Size?, optional): Viewport size constraints
///
/// Example:
/// ```dart
/// Table(
///   rows: [
///     TableHeader(cells: [TableCell(child: Text('Header'))]),
///     TableRow(cells: [TableCell(child: Text('Data'))]),
///   ],
///   columnWidths: {0: FixedTableSize(width: 200)},
/// );
/// ```
  const Table({super.key, required this.rows, this.defaultColumnWidth = const FlexTableSize(), this.defaultRowHeight = const IntrinsicTableSize(), this.columnWidths, this.rowHeights, this.clipBehavior = Clip.hardEdge, this.theme, this.frozenCells, this.horizontalOffset, this.verticalOffset, this.viewportSize});
  State<Table> createState();
}
/// Reference to a table row or column by index and span.
///
/// Used to identify specific rows or columns in table layouts,
/// particularly for frozen/pinned row and column functionality.
///
/// Example:
/// ```dart
/// TableRef(0, 2) // References rows/columns 0 and 1
/// TableRef(5)    // References row/column 5 with span of 1
/// ```
class TableRef {
/// Starting index of the reference.
  int index;
/// Number of rows/columns spanned. Defaults to 1.
  int span;
/// Creates a [TableRef].
  const TableRef(this.index, [this.span = 1]);
/// Tests if this reference includes the given index and span.
  bool test(int index, int span);
}
/// Configuration for frozen (pinned) rows and columns in a table.
///
/// Specifies which rows and columns should remain fixed in place
/// during scrolling, useful for keeping headers or key columns visible.
///
/// Example:
/// ```dart
/// FrozenTableData(
///   frozenRows: [TableRef(0)],      // Freeze first row (header)
///   frozenColumns: [TableRef(0, 2)], // Freeze first two columns
/// )
/// ```
class FrozenTableData {
/// Rows that should be frozen during vertical scrolling.
  Iterable<TableRef> frozenRows;
/// Columns that should be frozen during horizontal scrolling.
  Iterable<TableRef> frozenColumns;
/// Creates a [FrozenTableData].
  const FrozenTableData({this.frozenRows = const [], this.frozenColumns = const []});
/// Tests if a row at the given index and span is frozen.
  bool testRow(int index, int span);
/// Tests if a column at the given index and span is frozen.
  bool testColumn(int index, int span);
}
/// Parent data for table cell layout information.
///
/// Stores layout parameters for cells in a table including position,
/// span, and frozen state. Used internally by the table rendering system.
class TableParentData extends ContainerBoxParentData<RenderBox> {
/// Column index of this cell.
  int? column;
/// Row index of this cell.
  int? row;
/// Number of columns this cell spans.
  int? columnSpan;
/// Number of rows this cell spans.
  int? rowSpan;
/// Whether to compute size for this cell.
  bool computeSize;
/// Whether this cell's row is frozen.
  bool frozenRow;
/// Whether this cell's column is frozen.
  bool frozenColumn;
}
/// Low-level widget for positioning cells in table layouts.
///
/// Sets parent data for a table cell widget. Used internally by
/// table implementations to manage cell positioning and spanning.
///
/// Example:
/// ```dart
/// RawCell(
///   column: 0,
///   row: 1,
///   columnSpan: 2,
///   child: Container(...),
/// )
/// ```
class RawCell extends ParentDataWidget<TableParentData> {
/// Column index for this cell.
  int column;
/// Row index for this cell.
  int row;
/// Number of columns spanned. Defaults to 1.
  int? columnSpan;
/// Number of rows spanned. Defaults to 1.
  int? rowSpan;
/// Whether to compute size for this cell.
  bool computeSize;
/// Creates a [RawCell].
  const RawCell({super.key, required this.column, required this.row, this.columnSpan, this.rowSpan, this.computeSize = true, required super.child});
  void applyParentData(RenderObject renderObject);
  Type get debugTypicalAncestorWidgetClass;
}
/// Base class for table sizing strategies.
///
/// Abstract class that defines how table columns and rows should be sized.
/// Implementations include fixed, flexible, and intrinsic sizing modes.
abstract class TableSize {
/// Creates a [TableSize].
  const TableSize();
}
/// Table size mode that distributes available space using flex factors.
///
/// Similar to Flutter's [Flexible] widget, allocates space proportionally
/// based on the flex value. Used for responsive column/row sizing.
///
/// Example:
/// ```dart
/// FlexTableSize(flex: 2.0, fit: FlexFit.tight)
/// ```
class FlexTableSize extends TableSize {
/// Flex factor for space distribution. Defaults to 1.
  double flex;
/// How the space should be allocated. Defaults to tight.
  FlexFit fit;
/// Creates a [FlexTableSize].
  const FlexTableSize({this.flex = 1, this.fit = FlexFit.tight});
}
/// Table size mode with a fixed pixel value.
///
/// Allocates a specific fixed size regardless of available space.
/// Used for columns/rows that should maintain a constant size.
///
/// Example:
/// ```dart
/// FixedTableSize(150.0) // 150 pixels
/// ```
class FixedTableSize extends TableSize {
/// The fixed size value in pixels.
  double value;
/// Creates a [FixedTableSize] with the specified pixel value.
  const FixedTableSize(this.value);
}
/// Table size mode that uses the intrinsic size of cell content.
///
/// Sizes the column/row based on the natural size of its content.
/// May be expensive for large tables as it requires measuring content.
///
/// Example:
/// ```dart
/// IntrinsicTableSize() // Size based on content
/// ```
class IntrinsicTableSize extends TableSize {
/// Creates an [IntrinsicTableSize].
  const IntrinsicTableSize();
}
/// Table size mode that uses a fractional value of the table's size.
///
/// Sizes the column/row based on a fractional value of the table's size.
///
/// Example:
/// ```dart
/// FractionalTableSize(0.5) // 50% of table size
/// ```
class FractionalTableSize extends TableSize {
/// The fractional value of the table's size.
  double fraction;
/// Creates a [FractionalTableSize] with the specified fractional value.
  const FractionalTableSize(this.fraction);
}
/// Low-level table layout widget.
///
/// Provides raw table layout functionality with support for frozen rows/columns
/// and scrolling. Used internally by higher-level table widgets.
///
/// Example:
/// ```dart
/// RawTableLayout(
///   width: (index) => FlexTableSize(),
///   height: (index) => FixedTableSize(50),
///   clipBehavior: Clip.hardEdge,
///   children: [...],
/// )
/// ```
class RawTableLayout extends MultiChildRenderObjectWidget {
/// Creates a [RawTableLayout].
///
/// Parameters:
/// - [children] (`List<Widget>`, optional): Table cell widgets.
/// - [width] (`TableSizeSupplier`, required): Column width supplier.
/// - [height] (`TableSizeSupplier`, required): Row height supplier.
/// - [clipBehavior] (`Clip`, required): Content clipping behavior.
/// - [frozenColumn] (`CellPredicate?`, optional): Frozen column predicate.
/// - [frozenRow] (`CellPredicate?`, optional): Frozen row predicate.
/// - [verticalOffset] (`double?`, optional): Vertical scroll offset.
/// - [horizontalOffset] (`double?`, optional): Horizontal scroll offset.
/// - [viewportSize] (`Size?`, optional): Viewport size for scrolling.
  const RawTableLayout({super.key, super.children, required this.width, required this.height, required this.clipBehavior, this.frozenColumn, this.frozenRow, this.verticalOffset, this.horizontalOffset, this.viewportSize});
/// Supplier function for column widths.
  TableSizeSupplier width;
/// Supplier function for row heights.
  TableSizeSupplier height;
/// How content should be clipped.
  Clip clipBehavior;
/// Predicate for determining frozen columns.
  CellPredicate? frozenColumn;
/// Predicate for determining frozen rows.
  CellPredicate? frozenRow;
/// Vertical scroll offset.
  double? verticalOffset;
/// Horizontal scroll offset.
  double? horizontalOffset;
/// Size of the visible viewport.
  Size? viewportSize;
  RenderTableLayout createRenderObject(BuildContext context);
  void updateRenderObject(BuildContext context, RenderTableLayout renderObject);
}
/// Custom render object for laying out table cells with advanced features.
///
/// Provides a sophisticated table layout system with support for:
/// - Flexible and fixed column widths and row heights
/// - Frozen columns and rows (sticky headers/footers)
/// - Viewport-based scrolling and clipping
/// -Span cells (cells that span multiple columns/rows)
/// - Dynamic sizing based on content or constraints
///
/// This render object handles the complex layout calculations needed for
/// tables with variable-sized cells, scrolling, and frozen regions.
///
/// See also:
/// - [TableSize], which defines sizing strategies for columns and rows
/// - [TableLayoutResult], which contains the computed layout dimensions
class RenderTableLayout extends RenderBox with ContainerRenderObjectMixin<RenderBox, TableParentData>, RenderBoxContainerDefaultsMixin<RenderBox, TableParentData> {
/// Creates a render object for table layout.
///
/// Initializes the table layout system with sizing functions and optional
/// frozen cell configurations. This render object handles the complex
/// layout calculations for tables with variable cell sizes.
///
/// Parameters:
/// - [children] (`List<RenderBox>?`): Optional initial child render boxes
/// - [width] (TableSizeSupplier, required): Function providing width for each column
/// - [height] (TableSizeSupplier, required): Function providing height for each row
/// - [clipBehavior] (Clip, required): How to clip children outside table bounds
/// - [frozenCell] (CellPredicate?): Predicate identifying frozen columns
/// - [frozenRow] (CellPredicate?): Predicate identifying frozen rows
/// - [verticalOffset] (double?): Vertical scroll offset for viewport
/// - [horizontalOffset] (double?): Horizontal scroll offset for viewport
/// - [viewportSize] (Size?): Size of the visible viewport area
///
/// Frozen cells remain visible during scrolling, useful for sticky headers.
  RenderTableLayout({List<RenderBox>? children, required TableSizeSupplier width, required TableSizeSupplier height, required Clip clipBehavior, CellPredicate? frozenCell, CellPredicate? frozenRow, double? verticalOffset, double? horizontalOffset, Size? viewportSize});
  void setupParentData(RenderObject child);
  bool hitTestChildren(BoxHitTestResult result, {required Offset position});
  double computeMinIntrinsicWidth(double height);
  Size computeDryLayout(BoxConstraints constraints);
  void paint(PaintingContext context, Offset offset);
  void performLayout();
/// Computes the table layout with specified constraints.
///
/// Performs the complex table layout algorithm that:
/// 1. Determines maximum row and column counts from child cells
/// 2. Calculates fixed and flexible sizing for all columns and rows
/// 3. Distributes available space among flex items
/// 4. Handles both tight and loose flex constraints
/// 5. Computes final dimensions for each column and row
///
/// The layout algorithm respects size constraints from [TableSize] objects
/// and ensures cells spanning multiple columns/rows are properly handled.
///
/// Parameters:
/// - [constraints] (BoxConstraints, required): Layout constraints for the table
/// - [intrinsicComputer] (IntrinsicComputer?): Optional function to compute intrinsic sizes
///
/// Returns [TableLayoutResult] containing computed dimensions and layout metadata.
  TableLayoutResult computeTableSize(BoxConstraints constraints, [IntrinsicComputer? intrinsicComputer]);
  double computeMaxIntrinsicWidth(double height);
  double computeMinIntrinsicHeight(double width);
  double computeMaxIntrinsicHeight(double width);
/// Gets an unmodifiable list of computed column widths.
///
/// Returns the width of each column after layout calculation. The list
/// index corresponds to the column index, and the value is the width in
/// logical pixels.
///
/// Throws [AssertionError] if called before layout is complete.
///
/// Returns an unmodifiable `List<double>` of column widths.
  List<double> get columnWidths;
/// Gets an unmodifiable list of computed row heights.
///
/// Returns the height of each row after layout calculation. The list
/// index corresponds to the row index, and the value is the height in
/// logical pixels.
///
/// Throws [AssertionError] if called before layout is complete.
///
/// Returns an unmodifiable `List<double>` of row heights.
  List<double> get rowHeights;
/// Gets the top-left offset of a cell at the specified position.
///
/// Calculates the cumulative offset by summing the widths of all columns
/// before the specified column and heights of all rows before the specified row.
///
/// Parameters:
/// - [column] (int, required): Zero-based column index
/// - [row] (int, required): Zero-based row index
///
/// Throws [AssertionError] if called before layout is complete.
///
/// Returns [Offset] representing the cell's top-left corner position.
  Offset getOffset(int column, int row);
/// Gets the remaining unclaimed width in the table layout.
///
/// This represents horizontal space not allocated to any column after
/// fixed and flex sizing calculations. Useful for understanding how much
/// space is available for expansion or debugging layout issues.
///
/// Throws [AssertionError] if called before layout is complete.
///
/// Returns remaining width in logical pixels as a double.
  double get remainingWidth;
/// Gets the remaining unclaimed height in the table layout.
///
/// This represents vertical space not allocated to any row after
/// fixed and flex sizing calculations. Useful for understanding how much
/// space is available for expansion or debugging layout issues.
///
/// Throws [AssertionError] if called before layout is complete.
///
/// Returns remaining height in logical pixels as a double.
  double get remainingHeight;
/// Gets the remaining loose (flexible) width available for loose flex items.
///
/// Loose flex items can shrink below their flex allocation. This getter
/// returns the remaining width available specifically for items with
/// loose flex constraints (FlexFit.loose).
///
/// Throws [AssertionError] if called before layout is complete.
///
/// Returns remaining loose width in logical pixels as a double.
  double get remainingLooseWidth;
/// Gets the remaining loose (flexible) height available for loose flex items.
///
/// Loose flex items can shrink below their flex allocation. This getter
/// returns the remaining height available specifically for items with
/// loose flex constraints (FlexFit.loose).
///
/// Throws [AssertionError] if called before layout is complete.
///
/// Returns remaining loose height in logical pixels as a double.
  double get remainingLooseHeight;
/// Indicates whether any column uses tight flex sizing.
///
/// Tight flex items must occupy their full flex allocation. This getter
/// returns true if at least one column has a tight flex constraint
/// (FlexFit.tight), which affects how remaining space is distributed.
///
/// Throws [AssertionError] if called before layout is complete.
///
/// Returns true if table has tight flex width columns, false otherwise.
  bool get hasTightFlexWidth;
/// Indicates whether any row uses tight flex sizing.
///
/// Tight flex items must occupy their full flex allocation. This getter
/// returns true if at least one row has a tight flex constraint
/// (FlexFit.tight), which affects how remaining space is distributed.
///
/// Throws [AssertionError] if called before layout is complete.
///
/// Returns true if table has tight flex height rows, false otherwise.
  bool get hasTightFlexHeight;
}
/// Result of table layout calculations.
///
/// Contains computed column widths, row heights, and remaining space
/// information after layout. Used internally by the table rendering system.
class TableLayoutResult {
/// Computed widths for each column.
  List<double> columnWidths;
/// Computed heights for each row.
  List<double> rowHeights;
/// Remaining width after layout.
  double remainingWidth;
/// Remaining height after layout.
  double remainingHeight;
/// Remaining loose width for flex items.
  double remainingLooseWidth;
/// Remaining loose height for flex items.
  double remainingLooseHeight;
/// Whether tight flex sizing is used for width.
  bool hasTightFlexWidth;
/// Whether tight flex sizing is used for height.
  bool hasTightFlexHeight;
/// Creates a [TableLayoutResult].
  TableLayoutResult({required this.columnWidths, required this.rowHeights, required this.remainingWidth, required this.remainingHeight, required this.remainingLooseWidth, required this.remainingLooseHeight, required this.hasTightFlexWidth, required this.hasTightFlexHeight});
/// Calculates the top-left offset of a cell at the given position.
///
/// Computes the cumulative offset by summing all column widths before
/// the target column and all row heights before the target row.
///
/// Parameters:
/// - [column] (int, required): Zero-based column index
/// - [row] (int, required): Zero-based row index
///
/// Returns [Offset] representing the cell's position relative to table origin.
  Offset getOffset(int column, int row);
/// Returns the sum of all column widths and row heights.
  Size get size;
/// Gets the total width of the table.
///
/// Calculates the sum of all column widths to determine the table's
/// total horizontal extent. This is the natural width the table would
/// occupy without any constraints.
///
/// Returns total table width in logical pixels as a double.
  double get width;
/// Gets the total height of the table.
///
/// Calculates the sum of all row heights to determine the table's
/// total vertical extent. This is the natural height the table would
/// occupy without any constraints.
///
/// Returns total table height in logical pixels as a double.
  double get height;
}
/// Theme for [Steps].
class StepsTheme extends ComponentThemeData {
/// Diameter of the step indicator circle.
  double? indicatorSize;
/// Gap between the indicator and the step content.
  double? spacing;
/// Color of the indicator and connector line.
  Color? indicatorColor;
/// Thickness of the connector line.
  double? connectorThickness;
/// Creates a [StepsTheme].
  const StepsTheme({this.indicatorSize, this.spacing, this.indicatorColor, this.connectorThickness});
/// Creates a copy of this theme with the given fields replaced.
  StepsTheme copyWith({ValueGetter<double?>? indicatorSize, ValueGetter<double?>? spacing, ValueGetter<Color?>? indicatorColor, ValueGetter<double?>? connectorThickness});
  bool operator ==(Object other);
  int get hashCode;
}
/// Vertical step progression widget with numbered indicators and connectors.
///
/// A layout widget that displays a vertical sequence of steps, each with a
/// numbered circular indicator connected by lines. Ideal for showing progress
/// through multi-step processes, tutorials, or workflows.
///
/// ## Features
///
/// - **Numbered indicators**: Circular indicators with automatic step numbering
/// - **Connector lines**: Visual lines connecting consecutive steps
/// - **Flexible content**: Each step can contain any widget content
/// - **Responsive theming**: Customizable indicator size, spacing, and colors
/// - **Intrinsic sizing**: Automatically adjusts to content height
///
/// The widget automatically numbers each step starting from 1 and connects
/// them with vertical lines. Each step's content is placed to the right of
/// its indicator.
///
/// Example:
/// ```dart
/// Steps(
///   children: [
///     Column(
///       crossAxisAlignment: CrossAxisAlignment.start,
///       children: [
///         Text('Create Account', style: TextStyle(fontWeight: FontWeight.bold)),
///         Text('Sign up with your email address'),
///       ],
///     ),
///     Column(
///       crossAxisAlignment: CrossAxisAlignment.start,
///       children: [
///         Text('Verify Email', style: TextStyle(fontWeight: FontWeight.bold)),
///         Text('Check your inbox for verification'),
///       ],
///     ),
///     Column(
///       crossAxisAlignment: CrossAxisAlignment.start,
///       children: [
///         Text('Complete Profile', style: TextStyle(fontWeight: FontWeight.bold)),
///         Text('Add your personal information'),
///       ],
///     ),
///   ],
/// );
/// ```
class Steps extends StatelessWidget {
/// List of widgets representing each step in the sequence.
///
/// Each widget will be displayed with an automatically numbered
/// circular indicator showing its position in the sequence.
  List<Widget> children;
/// Creates a [Steps] widget.
///
/// Each child widget represents one step in the sequence and will be
/// displayed with an automatically numbered circular indicator.
///
/// Parameters:
/// - [children] (`List<Widget>`, required): list of widgets representing each step
///
/// Example:
/// ```dart
/// Steps(
///   children: [
///     Text('First step content'),
///     Text('Second step content'),
///     Text('Third step content'),
///   ],
/// )
/// ```
  const Steps({super.key, required this.children});
  Widget build(BuildContext context);
}
/// A vertical step indicator widget that displays a step's title and content.
///
/// Typically used as children within [Steps] to create a multi-step
/// process visualization. Displays a title in bold followed by content items.
///
/// Example:
/// ```dart
/// StepItem(
///   title: Text('Step Title'),
///   content: [
///     Text('Step description'),
///     Text('Additional details'),
///   ],
/// )
/// ```
class StepItem extends StatelessWidget {
/// The title of this step, displayed prominently.
  Widget title;
/// List of content widgets to display under the title.
  List<Widget> content;
/// Creates a [StepItem].
  const StepItem({super.key, required this.title, required this.content});
  Widget build(BuildContext context);
}
/// Mixin for parent data that supports paint ordering.
mixin PaintOrderParentDataMixin on rendering.ContainerBoxParentData<rendering.RenderBox> {
/// The paint order of this child. Higher values are painted on top.
/// If null, uses the default order (0).
  int? paintOrder;
/// Next sibling in the sorted paint order linked list.
  rendering.RenderBox? nextSortedSibling;
/// Previous sibling in the sorted paint order linked list.
  rendering.RenderBox? previousSortedSibling;
/// Internal index used for sorting.
  int paintIndex;
}
/// Mixin for render objects that support custom paint order.
///
/// This mixin provides the sorting logic for painting children in a custom order
/// based on their [PaintOrderParentDataMixin.paintOrder] property.
mixin PaintOrderMixin on rendering.RenderBox {
/// The first child in the sorted paint order.
  rendering.RenderBox? firstSortedChild;
/// The last child in the sorted paint order.
  rendering.RenderBox? lastSortedChild;
/// Get the first child - must be implemented by the render object.
  rendering.RenderBox? get paintOrderFirstChild;
/// Builds a sorted linked list of children based on their paint order.
///
/// Children without a paint order default to 0 and are painted in their
/// natural layout order. Children with a positive paint order are painted
/// above them.
  void buildSortedLinkedList();
/// Paints children in sorted paint order.
  void paintSorted(rendering.PaintingContext context, Offset offset);
/// Hit tests children in reverse sorted paint order (top-most first).
  bool hitTestSortedChildren(rendering.BoxHitTestResult result, {required Offset position});
}
/// Parent data for use with [RenderFlex].
///
/// Extends the base [rendering.FlexParentData] to add paint order support.
class FlexParentData extends rendering.FlexParentData with PaintOrderParentDataMixin {
  String toString();
}
/// A patched version of [rendering.RenderFlex] that supports custom paint ordering.
class RenderFlex extends rendering.RenderFlex with PaintOrderMixin {
/// Creates a flex render object with paint order support.
  RenderFlex({super.children, super.direction, super.mainAxisSize, super.mainAxisAlignment, super.crossAxisAlignment, super.textDirection, super.verticalDirection, super.textBaseline, super.clipBehavior, super.spacing});
  rendering.RenderBox? get paintOrderFirstChild;
  void setupParentData(rendering.RenderBox child);
  void performLayout();
  void paint(rendering.PaintingContext context, Offset offset);
  bool hitTestChildren(rendering.BoxHitTestResult result, {required Offset position});
}
/// A widget that displays its children in a one-dimensional array.
///
/// The [Flex] widget allows you to control the axis along which the children are
/// placed (horizontal or vertical). This is referred to as the _main axis_. If
/// you know the main axis in advance, then consider using a [Row] (if it's
/// horizontal) or [Column] (if it's vertical) instead, because that will be less
/// verbose.
///
/// To cause a child to expand to fill the available space in the [direction]
/// of this widget's main axis, wrap the child in an [Expanded] widget.
///
/// The [Flex] widget does not scroll (and in general it is considered an error
/// to have more children in a [Flex] than will fit in the available room). If
/// you have some widgets and want them to be able to scroll if there is
/// insufficient room, consider using a [ListView].
///
/// This patched version supports custom paint ordering via [PaintOrder] or
/// [Flexible.paintOrder].
///
/// See also:
///
///  * [Row], for a horizontal arrangement of children.
///  * [Column], for a vertical arrangement of children.
///  * [Expanded], to indicate children that should take all remaining room.
///  * [Flexible], to indicate children that should share remaining room.
///  * [PaintOrder], to control the paint order of children.
class Flex extends widgets.Flex {
/// Creates a flex layout with paint order support.
  const Flex({super.key, required super.direction, super.mainAxisAlignment, super.mainAxisSize, super.crossAxisAlignment, super.textDirection, super.verticalDirection, super.textBaseline, super.clipBehavior, super.spacing, super.children});
  RenderFlex createRenderObject(widgets.BuildContext context);
  void updateRenderObject(widgets.BuildContext context, covariant RenderFlex renderObject);
}
/// A widget that displays its children in a horizontal array.
///
/// To cause a child to expand to fill the available horizontal space, wrap the
/// child in an [Expanded] widget.
///
/// The [Row] widget does not scroll (and in general it is considered an error
/// to have more children in a [Row] than will fit in the available room). If
/// you have a line of widgets and want them to be able to scroll if there is
/// insufficient room, consider using a [ListView].
///
/// For a vertical variant, see [Column].
///
/// This patched version supports custom paint ordering via [PaintOrder] or
/// [Flexible.paintOrder].
///
/// See also:
///
///  * [Column], for a vertical equivalent.
///  * [Expanded], to indicate children that should take all remaining room.
///  * [Flexible], to indicate children that should share remaining room.
///  * [PaintOrder], to control the paint order of children.
class Row extends Flex {
/// Creates a horizontal array of children with paint order support.
  const Row({super.key, super.mainAxisAlignment, super.mainAxisSize, super.crossAxisAlignment, super.textDirection, super.verticalDirection, super.textBaseline, super.spacing, super.children, super.clipBehavior});
}
/// A widget that displays its children in a vertical array.
///
/// To cause a child to expand to fill the available vertical space, wrap the
/// child in an [Expanded] widget.
///
/// The [Column] widget does not scroll (and in general it is considered an
/// error to have more children in a [Column] than will fit in the available
/// room). If you have a line of widgets and want them to be able to scroll if
/// there is insufficient room, consider using a [ListView].
///
/// For a horizontal variant, see [Row].
///
/// This patched version supports custom paint ordering via [PaintOrder] or
/// [Flexible.paintOrder].
///
/// See also:
///
///  * [Row], for a horizontal equivalent.
///  * [Expanded], to indicate children that should take all remaining room.
///  * [Flexible], to indicate children that should share remaining room.
///  * [PaintOrder], to control the paint order of children.
class Column extends Flex {
/// Creates a vertical array of children with paint order support.
  const Column({super.key, super.mainAxisAlignment, super.mainAxisSize, super.crossAxisAlignment, super.textDirection, super.verticalDirection, super.textBaseline, super.spacing, super.children, super.clipBehavior});
}
/// A widget that controls how a child of a [Row], [Column], or [Flex] flexes.
///
/// Using a [Flexible] widget gives a child of a [Row], [Column], or [Flex]
/// the flexibility to expand to fill the available space in the main axis
/// (e.g., horizontally for a [Row] or vertically for a [Column]), but, unlike
/// [Expanded], [Flexible] does not require the child to fill the available
/// space.
///
/// A [Flexible] widget must be a descendant of a [Row], [Column], or [Flex],
/// and the path from the [Flexible] widget to its enclosing [Row], [Column], or
/// [Flex] must contain only [StatelessWidget]s or [StatefulWidget]s (not other
/// kinds of widgets, like [RenderObjectWidget]s).
///
/// This patched version also supports [paintOrder] to control the painting
/// order of children.
///
/// See also:
///
///  * [Expanded], which forces the child to expand to fill the available space.
///  * [PaintOrder], to control paint order without affecting flex behavior.
class Flexible extends widgets.ParentDataWidget<FlexParentData> {
/// Creates a widget that controls how a child of a [Row], [Column], or [Flex] flexes.
  const Flexible({super.key, this.flex = 1, this.fit = rendering.FlexFit.loose, this.paintOrder, required super.child});
/// The flex factor to use for this child.
  int flex;
/// How a flexible child is inscribed into the available space.
  rendering.FlexFit fit;
/// The paint order of this child. Higher values are painted on top.
  int? paintOrder;
  void applyParentData(rendering.RenderObject renderObject);
  Type get debugTypicalAncestorWidgetClass;
  void debugFillProperties(foundation.DiagnosticPropertiesBuilder properties);
}
/// A widget that expands a child of a [Row], [Column], or [Flex]
/// so that the child fills the available space.
///
/// Using an [Expanded] widget makes a child of a [Row], [Column], or [Flex]
/// expand to fill the available space along the main axis (e.g., horizontally
/// for a [Row] or vertically for a [Column]). If multiple children are
/// expanded, the available space is divided among them according to the [flex]
/// factor.
///
/// An [Expanded] widget must be a descendant of a [Row], [Column], or [Flex],
/// and the path from the [Expanded] widget to its enclosing [Row], [Column],
/// or [Flex] must contain only [StatelessWidget]s or [StatefulWidget]s (not
/// other kinds of widgets, like [RenderObjectWidget]s).
///
/// This patched version also supports [paintOrder] to control the painting
/// order of children.
///
/// See also:
///
///  * [Flexible], which does not force the child to fill the available space.
///  * [PaintOrder], to control paint order without affecting flex behavior.
class Expanded extends Flexible {
/// Creates a widget that expands a child of a [Row], [Column], or [Flex].
  const Expanded({super.key, super.flex, super.paintOrder, required super.child});
}
/// A widget that sets the paint order of a non-flexible child in a [Row], [Column], or [Flex].
class PaintOrder extends widgets.ParentDataWidget<FlexParentData> {
/// Creates a widget that sets the paint order of a child.
  const PaintOrder({super.key, required this.paintOrder, required super.child});
/// The paint order of this child. Higher values are painted on top.
  int paintOrder;
  void applyParentData(rendering.RenderObject renderObject);
  Type get debugTypicalAncestorWidgetClass;
  void debugFillProperties(foundation.DiagnosticPropertiesBuilder properties);
}
/// Parent data for use with [RenderStack].
class StackParentData extends rendering.StackParentData with PaintOrderParentDataMixin {
  String toString();
}
/// A patched version of [rendering.RenderStack] that supports custom paint ordering.
class RenderStack extends rendering.RenderStack with PaintOrderMixin {
/// Creates a stack render object with paint order support.
  RenderStack({super.children, super.alignment, super.textDirection, super.fit, super.clipBehavior});
  rendering.RenderBox? get paintOrderFirstChild;
  void setupParentData(rendering.RenderBox child);
  void performLayout();
  void paintStack(rendering.PaintingContext context, Offset offset);
  bool hitTestChildren(rendering.BoxHitTestResult result, {required Offset position});
}
/// A widget that positions its children relative to the edges of its box.
///
/// This class is useful if you want to overlap several children in a simple
/// way, for example having some text and an image, overlaid with a gradient
/// and a button attached to the bottom.
///
/// Each child of a [Stack] widget is either _positioned_ or _non-positioned_.
/// Positioned children are those wrapped in a [Positioned] widget that has at
/// least one non-null property. The stack sizes itself to contain all the
/// non-positioned children, which are positioned according to [alignment]
/// (which defaults to the top-left corner in left-to-right environments and
/// the top-right corner in right-to-left environments). The positioned
/// children are then placed relative to the stack according to their top,
/// right, bottom, and left properties.
///
/// This patched version supports custom paint ordering via [Positioned.paintOrder].
///
/// See also:
///
///  * [Positioned], for positioning children within this stack.
///  * [Align], which sizes itself based on its child's size and positions
///    the child according to an [Alignment] value.
class Stack extends widgets.Stack {
/// Creates a stack with paint order support.
  const Stack({super.key, super.alignment, super.textDirection, super.fit, super.clipBehavior, super.children});
  RenderStack createRenderObject(widgets.BuildContext context);
  void updateRenderObject(widgets.BuildContext context, covariant RenderStack renderObject);
}
/// A widget that controls where a child of a [Stack] is positioned.
///
/// A [Positioned] widget must be a descendant of a [Stack], and the path from
/// the [Positioned] widget to its enclosing [Stack] must contain only
/// [StatelessWidget]s or [StatefulWidget]s (not other kinds of widgets, like
/// [RenderObjectWidget]s).
///
/// If a widget is wrapped in a [Positioned], then it is a _positioned_ widget
/// in its [Stack]. If the [top] property is non-null, the top edge of this child
/// will be positioned [top] layout units from the top of the stack widget. The
/// [right], [bottom], and [left] properties work analogously.
///
/// If both the [top] and [bottom] properties are non-null, then the child will
/// be forced to have exactly the height required to satisfy both constraints.
/// Similarly, setting the [right] and [left] properties to non-null values will
/// force the child to have a particular width.
///
/// This patched version also supports [paintOrder] to control the painting
/// order of children.
///
/// See also:
///
///  * [Stack], which uses positioned children.
class Positioned extends widgets.ParentDataWidget<StackParentData> {
/// Creates a positioned widget with paint order support.
  const Positioned({super.key, this.left, this.top, this.right, this.bottom, this.width, this.height, this.paintOrder, required super.child});
/// Creates a Positioned with all edges set to 0.0 unless specified.
  const Positioned.fill({super.key, this.left = 0.0, this.top = 0.0, this.right = 0.0, this.bottom = 0.0, this.paintOrder, required super.child});
/// The distance that the child's left edge is inset from the left of the stack.
  double? left;
/// The distance that the child's top edge is inset from the top of the stack.
  double? top;
/// The distance that the child's right edge is inset from the right of the stack.
  double? right;
/// The distance that the child's bottom edge is inset from the bottom of the stack.
  double? bottom;
/// The child's width.
  double? width;
/// The child's height.
  double? height;
/// The paint order of this child. Higher values are painted on top.
  int? paintOrder;
  void applyParentData(rendering.RenderObject renderObject);
  Type get debugTypicalAncestorWidgetClass;
  void debugFillProperties(foundation.DiagnosticPropertiesBuilder properties);
}
/// A container widget that displays a list of collapsible items with only one item expanded at a time.
///
/// [Accordion] implements the classic accordion UI pattern where clicking on one item
/// expands it while automatically collapsing any other expanded items. This ensures
/// only one section is visible at a time, making it ideal for organizing related
/// information in a compact, scannable format.
///
/// ## Key Features
/// - **Single Expansion**: Only one accordion item can be expanded at a time
/// - **Visual Separation**: Automatic dividers between accordion items
/// - **Smooth Animation**: Configurable expand/collapse animations
/// - **Accessibility**: Full keyboard navigation and screen reader support
/// - **Theming**: Comprehensive theming via [AccordionTheme]
///
/// ## Usage Pattern
/// An accordion consists of multiple [AccordionItem] widgets, each containing:
/// - [AccordionTrigger]: The clickable header that shows/hides content
/// - Content: The collapsible content area revealed when expanded
///
/// The accordion automatically manages state to ensure mutual exclusion of expanded items.
///
/// Example:
/// ```dart
/// Accordion(
///   items: [
///     AccordionItem(
///       trigger: AccordionTrigger(
///         child: Text('Section 1'),
///       ),
///       content: Text('Content for section 1...'),
///     ),
///     AccordionItem(
///       trigger: AccordionTrigger(
///         child: Text('Section 2'),
///       ),
///       content: Text('Content for section 2...'),
///       expanded: true, // Initially expanded
///     ),
///   ],
/// );
/// ```
class Accordion extends StatefulWidget {
/// The list of accordion items to display.
///
/// Each item should be an [AccordionItem] widget containing a trigger and content.
/// The accordion automatically adds visual dividers between items and manages
/// the expansion state to ensure only one item can be expanded at a time.
  List<Widget> items;
/// Creates an [Accordion] widget with the specified items.
///
/// Parameters:
/// - [items] (`List<Widget>`, required): List of [AccordionItem] widgets to display.
///
/// The accordion automatically handles:
/// - State management for mutual exclusion of expanded items
/// - Visual dividers between items
/// - Animation coordination between items
/// - Proper accessibility semantics
///
/// Example:
/// ```dart
/// Accordion(
///   items: [
///     AccordionItem(
///       trigger: AccordionTrigger(child: Text('FAQ 1')),
///       content: Text('Answer to first question...'),
///     ),
///     AccordionItem(
///       trigger: AccordionTrigger(child: Text('FAQ 2')),
///       content: Text('Answer to second question...'),
///     ),
///   ],
/// );
/// ```
  const Accordion({super.key, required this.items});
  AccordionState createState();
}
/// State class for [Accordion] widget.
///
/// Manages the expansion state of accordion items, ensuring only one
/// item can be expanded at a time in single-expansion mode.
class AccordionState extends State<Accordion> {
  Widget build(BuildContext context);
}
/// Theme configuration for [Accordion], [AccordionItem], and [AccordionTrigger] widgets.
///
/// [AccordionTheme] provides comprehensive styling options for all accordion-related
/// widgets, including animation timing, spacing, colors, and iconography. It allows
/// for consistent accordion styling across an application while still permitting
/// per-instance customization.
///
/// Used with [ComponentTheme] to apply theme values throughout the widget tree.
///
/// Example:
/// ```dart
/// ComponentTheme<AccordionTheme>(
///   data: AccordionTheme(
///     duration: Duration(milliseconds: 300),
///     curve: Curves.easeInOut,
///     padding: 20.0,
///     arrowIcon: Icons.expand_more,
///     arrowIconColor: Colors.blue,
///   ),
///   child: MyAccordionWidget(),
/// );
/// ```
class AccordionTheme extends ComponentThemeData {
/// Duration of the expand/collapse animation.
///
/// Controls how long it takes for accordion items to animate between
/// expanded and collapsed states. If null, defaults to 200 milliseconds.
  Duration? duration;
/// Animation curve used when expanding accordion items.
///
/// Defines the easing function applied during expansion animations.
/// If null, defaults to [Curves.easeIn].
  Curve? curve;
/// Animation curve used when collapsing accordion items.
///
/// Defines the easing function applied during collapse animations.
/// If null, defaults to [Curves.easeOut].
  Curve? reverseCurve;
/// Vertical padding applied to accordion triggers and content.
///
/// Controls the space above and below trigger text and between triggers
/// and content. If null, defaults to 16 logical pixels scaled by theme.
  double? padding;
/// Horizontal spacing between trigger text and the expand/collapse icon.
///
/// Controls the gap between the trigger content and the arrow icon.
/// If null, defaults to 18 logical pixels scaled by theme.
  double? iconGap;
/// Height of divider lines between accordion items.
///
/// Controls the thickness of the visual separators between accordion items.
/// If null, defaults to 1 logical pixel scaled by theme.
  double? dividerHeight;
/// Color of divider lines between accordion items.
///
/// If null, uses the muted color from the theme color scheme.
  Color? dividerColor;
/// Icon displayed in the trigger to indicate expand/collapse state.
///
/// This icon is rotated 180 degrees when transitioning between states.
/// If null, defaults to [Icons.keyboard_arrow_up].
  IconData? arrowIcon;
/// Color of the expand/collapse arrow icon.
///
/// If null, uses the muted foreground color from the theme color scheme.
  Color? arrowIconColor;
/// Creates an [AccordionTheme] with the specified styling options.
///
/// All parameters are optional and will fall back to component defaults
/// when not specified.
///
/// Parameters:
/// - [duration] (Duration?, optional): Animation duration for expand/collapse.
/// - [curve] (Curve?, optional): Easing curve for expansion animation.
/// - [reverseCurve] (Curve?, optional): Easing curve for collapse animation.
/// - [padding] (double?, optional): Vertical padding for triggers and content.
/// - [iconGap] (double?, optional): Space between trigger text and icon.
/// - [dividerHeight] (double?, optional): Thickness of item dividers.
/// - [dividerColor] (Color?, optional): Color of item dividers.
/// - [arrowIcon] (IconData?, optional): Icon for expand/collapse indicator.
/// - [arrowIconColor] (Color?, optional): Color of the arrow icon.
  const AccordionTheme({this.duration, this.curve, this.reverseCurve, this.padding, this.iconGap, this.dividerHeight, this.dividerColor, this.arrowIcon, this.arrowIconColor});
/// Creates a copy of this theme with the given values replaced.
///
/// Uses [ValueGetter] functions to allow conditional updates where
/// null getters preserve the original value.
///
/// Example:
/// ```dart
/// final newTheme = originalTheme.copyWith(
///   duration: () => Duration(milliseconds: 400),
///   curve: () => Curves.bounceOut,
/// );
/// ```
  AccordionTheme copyWith({ValueGetter<Duration?>? duration, ValueGetter<Curve?>? curve, ValueGetter<Curve?>? reverseCurve, ValueGetter<double?>? padding, ValueGetter<double?>? iconGap, ValueGetter<double?>? dividerHeight, ValueGetter<Color?>? dividerColor, ValueGetter<IconData?>? arrowIcon, ValueGetter<Color?>? arrowIconColor});
  bool operator ==(Object other);
  int get hashCode;
  String toString();
}
/// An individual item within an [Accordion] that can be expanded or collapsed.
///
/// [AccordionItem] represents a single section within an accordion, containing
/// both a trigger (the clickable header) and the collapsible content area. It
/// manages its own animation state and coordinates with the parent [Accordion]
/// to implement the mutual exclusion behavior.
///
/// ## Key Features
/// - **Smooth Animation**: Configurable size transition animations
/// - **State Coordination**: Automatic integration with parent accordion state
/// - **Flexible Content**: Supports any widget as trigger or content
/// - **Initial State**: Can start expanded or collapsed
///
/// The item automatically handles expansion/collapse animations and coordinates
/// with its parent accordion to ensure only one item can be expanded at a time.
///
/// Example:
/// ```dart
/// AccordionItem(
///   expanded: true, // Start expanded
///   trigger: AccordionTrigger(
///     child: Row(
///       children: [
///         Icon(Icons.help_outline),
///         SizedBox(width: 8),
///         Text('Frequently Asked Question'),
///       ],
///     ),
///   ),
///   content: Padding(
///     padding: EdgeInsets.all(16),
///     child: Text('This is the detailed answer to the question...'),
///   ),
/// );
/// ```
class AccordionItem extends StatefulWidget {
/// The clickable header widget that controls expansion.
///
/// Typically an [AccordionTrigger] widget, but can be any widget that
/// provides user interaction. The trigger is always visible and clicking
/// it toggles the expansion state of the item.
  Widget trigger;
/// The collapsible content widget revealed when expanded.
///
/// This content is hidden when the item is collapsed and smoothly animated
/// into view when expanded. Can contain any widget content including text,
/// images, forms, or other complex UI elements.
  Widget content;
/// Whether this item should start in the expanded state.
///
/// When true, the item begins expanded and its content is immediately visible.
/// Only one item in an accordion should typically start expanded.
  bool expanded;
/// Creates an [AccordionItem] with the specified trigger and content.
///
/// Parameters:
/// - [trigger] (Widget, required): The clickable header widget.
/// - [content] (Widget, required): The collapsible content widget.
/// - [expanded] (bool, default: false): Initial expansion state.
///
/// The item automatically integrates with its parent [Accordion] to provide
/// proper state management and mutual exclusion behavior.
///
/// Example:
/// ```dart
/// AccordionItem(
///   trigger: AccordionTrigger(
///     child: Text('Item Title'),
///   ),
///   content: Container(
///     padding: EdgeInsets.all(16),
///     child: Text('Item content goes here...'),
///   ),
///   expanded: false,
/// );
/// ```
  const AccordionItem({super.key, required this.trigger, required this.content, this.expanded = false});
  State<AccordionItem> createState();
}
/// A specialized trigger widget designed for use within [AccordionItem].
///
/// [AccordionTrigger] provides a consistent, accessible interface for accordion
/// headers. It automatically includes:
/// - Hover effects with text underlining
/// - Focus management with keyboard navigation
/// - Animated expand/collapse icon
/// - Proper click and keyboard activation
/// - Accessibility semantics
///
/// The trigger automatically coordinates with its parent [AccordionItem] to
/// control the expansion state and provides visual feedback for user interactions.
///
/// ## Accessibility Features
/// - Full keyboard navigation support (Enter and Space keys)
/// - Focus indicators with theme-appropriate styling
/// - Screen reader compatibility
/// - Proper semantic roles and states
///
/// Example:
/// ```dart
/// AccordionTrigger(
///   child: Row(
///     children: [
///       Icon(Icons.info_outline),
///       SizedBox(width: 12),
///       Expanded(
///         child: Column(
///           crossAxisAlignment: CrossAxisAlignment.start,
///           children: [
///             Text('Primary Title', style: TextStyle(fontWeight: FontWeight.bold)),
///             Text('Subtitle', style: TextStyle(fontSize: 12)),
///           ],
///         ),
///       ),
///     ],
///   ),
/// );
/// ```
class AccordionTrigger extends StatefulWidget {
/// The content widget displayed within the trigger.
///
/// Typically contains text, icons, or other UI elements that describe the
/// accordion section. The child receives automatic text styling and hover
/// effects from the trigger.
  Widget child;
/// Creates an [AccordionTrigger] with the specified child content.
///
/// Parameters:
/// - [child] (Widget, required): The content to display in the trigger.
///
/// The trigger automatically provides:
/// - Click and keyboard interaction handling
/// - Hover effects with text underlining
/// - Focus management with visual indicators
/// - Animated expand/collapse icon
/// - Integration with parent [AccordionItem] state
///
/// Example:
/// ```dart
/// AccordionTrigger(
///   child: Text('Click to expand this section'),
/// );
/// ```
  const AccordionTrigger({super.key, required this.child});
  State<AccordionTrigger> createState();
}
/// Theme configuration for window components.
///
/// Provides styling options for window elements including title bar height
/// and resize border thickness. Used to customize the visual appearance
/// of window components within the application.
///
/// Example:
/// ```dart
/// WindowTheme(
///   titleBarHeight: 32.0,
///   resizeThickness: 4.0,
/// )
/// ```
class WindowTheme extends ComponentThemeData {
/// Height of the window's title bar in logical pixels.
///
/// Determines the vertical space allocated for the title bar which typically
/// contains the window title, control buttons (minimize, maximize, close),
/// and any custom action widgets.
///
/// If `null`, uses the default title bar height from the theme.
  double? titleBarHeight;
/// Thickness of the window's resize border in logical pixels.
///
/// Defines the width of the interactive area along window edges that
/// allows users to resize the window by dragging. A larger value makes
/// it easier to grab the edge for resizing.
///
/// If `null`, uses the default resize border thickness from the theme.
  double? resizeThickness;
/// Creates a window theme with optional title bar and resize border settings.
///
/// Both parameters are optional. When `null`, the corresponding values
/// will fall back to theme defaults.
  const WindowTheme({this.titleBarHeight, this.resizeThickness});
/// Creates a copy of this theme with optionally replaced values.
///
/// Uses [ValueGetter] functions to allow nullable value replacement.
/// If a parameter is `null`, the current value is retained. If provided,
/// the getter function is called to retrieve the new value.
///
/// Parameters:
/// - [titleBarHeight]: Optional getter for new title bar height
/// - [resizeThickness]: Optional getter for new resize thickness
///
/// Returns a new [WindowTheme] instance with updated values.
  WindowTheme copyWith({ValueGetter<double?>? titleBarHeight, ValueGetter<double?>? resizeThickness});
  bool operator ==(Object other);
  int get hashCode;
  String toString();
}
/// Configuration for window snapping behavior and positioning.
///
/// Defines how windows should snap to screen edges or specific regions,
/// including the target bounds and whether the window should be minimized
/// during the snap operation.
///
/// Example:
/// ```dart
/// WindowSnapStrategy(
///   relativeBounds: Rect.fromLTWH(0, 0, 0.5, 1), // Left half of screen
///   shouldMinifyWindow: false,
/// )
/// ```
class WindowSnapStrategy {
/// Relative bounds where the window should snap, in screen-relative coordinates.
///
/// Values range from 0.0 to 1.0, representing proportions of the screen.
/// For example, `Rect.fromLTWH(0, 0, 0.5, 1)` represents the left half
/// of the screen (0% to 50% horizontally, full height).
  Rect relativeBounds;
/// Whether the window should be minimized during the snap operation.
///
/// When `true`, the window will minimize before snapping to the target
/// position. When `false`, the window immediately snaps without minimizing.
///
/// Defaults to `true`.
  bool shouldMinifyWindow;
/// Creates a window snap strategy with the specified bounds and behavior.
///
/// Parameters:
/// - [relativeBounds]: Target screen region (required, in 0.0-1.0 coordinates)
/// - [shouldMinifyWindow]: Whether to minimize during snap (defaults to `true`)
  const WindowSnapStrategy({required this.relativeBounds, this.shouldMinifyWindow = true});
}
/// Complete state configuration for a window instance.
///
/// Encapsulates all aspects of a window's current state including position, size,
/// visual state (minimized, maximized), capabilities (resizable, draggable), and
/// behavior settings (snapping, always on top).
///
/// Key Properties:
/// - **Position & Size**: [bounds] for current position, [maximized] for fullscreen state
/// - **Visual State**: [minimized] for taskbar state, [alwaysOnTop] for layering
/// - **Capabilities**: [resizable], [draggable], [closable], [maximizable], [minimizable]
/// - **Behavior**: [enableSnapping] for edge snapping, [constraints] for size limits
///
/// Used primarily with [WindowController] to manage window state programmatically
/// and provide reactive updates to window appearance and behavior.
///
/// Example:
/// ```dart
/// WindowState(
///   bounds: Rect.fromLTWH(100, 100, 800, 600),
///   resizable: true,
///   draggable: true,
///   enableSnapping: true,
///   constraints: BoxConstraints(minWidth: 400, minHeight: 300),
/// )
/// ```
class WindowState {
/// Current position and size of the window.
///
/// Represents the window's bounding rectangle in logical pixels,
/// with coordinates relative to the screen's top-left corner.
  Rect bounds;
/// Bounds of the window when maximized, or `null` if not maximized.
///
/// When non-null, indicates the window is in maximized state and
/// stores the previous bounds for restoration when un-maximizing.
  Rect? maximized;
/// Whether the window is currently minimized to the taskbar.
///
/// When `true`, the window is hidden from view but remains in memory.
/// Defaults to `false`.
  bool minimized;
/// Whether the window should always appear on top of other windows.
///
/// When `true`, this window will be rendered above other windows
/// regardless of focus state. Defaults to `false`.
  bool alwaysOnTop;
/// Whether the window can be closed by the user.
///
/// When `false`, the close button is disabled or hidden.
/// Defaults to `true`.
  bool closable;
/// Whether the window can be resized by dragging its edges or corners.
///
/// When `false`, the window maintains a fixed size.
/// Defaults to `true`.
  bool resizable;
/// Whether the window can be moved by dragging its title bar.
///
/// When `false`, the window position is fixed.
/// Defaults to `true`.
  bool draggable;
/// Whether the window can be maximized to fill the screen.
///
/// When `false`, the maximize button is disabled or hidden.
/// Defaults to `true`.
  bool maximizable;
/// Whether the window can be minimized to the taskbar.
///
/// When `false`, the minimize button is disabled or hidden.
/// Defaults to `true`.
  bool minimizable;
/// Whether edge snapping is enabled for this window.
///
/// When `true`, dragging the window near screen edges or regions
/// will trigger snap-to-edge behavior. Defaults to `true`.
  bool enableSnapping;
/// Size constraints for the window.
///
/// Enforces minimum and maximum width/height limits when resizing.
/// Defaults to [kDefaultWindowConstraints].
  BoxConstraints constraints;
/// Creates a window state with the specified configuration.
///
/// Parameters:
/// - [bounds]: Current window bounds (required)
/// - [maximized]: Maximized state bounds (optional, `null` if not maximized)
/// - [minimized]: Minimized state (defaults to `false`)
/// - [alwaysOnTop]: Always-on-top behavior (defaults to `false`)
/// - [closable]: Allow closing (defaults to `true`)
/// - [resizable]: Allow resizing (defaults to `true`)
/// - [draggable]: Allow dragging (defaults to `true`)
/// - [maximizable]: Allow maximizing (defaults to `true`)
/// - [minimizable]: Allow minimizing (defaults to `true`)
/// - [enableSnapping]: Enable edge snapping (defaults to `true`)
/// - [constraints]: Size constraints (defaults to [kDefaultWindowConstraints])
  const WindowState({required this.bounds, this.maximized, this.minimized = false, this.alwaysOnTop = false, this.closable = true, this.resizable = true, this.draggable = true, this.maximizable = true, this.minimizable = true, this.enableSnapping = true, this.constraints = kDefaultWindowConstraints});
  bool operator ==(Object other);
  int get hashCode;
  String toString();
/// Creates a copy of this state with only the maximized bounds changed.
///
/// This is a specialized version of [copyWith] that only modifies the
/// [maximized] property while preserving all other state values.
///
/// Parameters:
/// - [maximized]: New maximized bounds, or `null` to restore window
///
/// Returns a new [WindowState] with updated maximized property.
  WindowState withMaximized(Rect? maximized);
/// Creates a copy of this state with selectively updated properties.
///
/// Uses [ValueGetter] functions to allow nullable value replacement.
/// Properties not provided (null) retain their current values. When
/// a getter is provided, it's called to obtain the new value.
///
/// Note: This method does not allow updating [maximized]. Use
/// [withMaximized] instead for that purpose.
///
/// Parameters:
/// - [bounds]: Optional getter for new window bounds
/// - [minimized]: Optional getter for minimized state
/// - [alwaysOnTop]: Optional getter for always-on-top behavior
/// - [closable]: Optional getter for closable state
/// - [resizable]: Optional getter for resizable state
/// - [draggable]: Optional getter for draggable state
/// - [maximizable]: Optional getter for maximizable state
/// - [minimizable]: Optional getter for minimizable state
/// - [enableSnapping]: Optional getter for snapping enabled state
/// - [constraints]: Optional getter for size constraints
///
/// Returns a new [WindowState] instance with updated values.
  WindowState copyWith({ValueGetter<Rect>? bounds, ValueGetter<bool>? minimized, ValueGetter<bool>? alwaysOnTop, ValueGetter<bool>? closable, ValueGetter<bool>? resizable, ValueGetter<bool>? draggable, ValueGetter<bool>? maximizable, ValueGetter<bool>? minimizable, ValueGetter<bool>? enableSnapping, ValueGetter<BoxConstraints>? constraints});
}
/// Reactive controller for managing window state and operations.
///
/// Provides programmatic control over window properties with automatic UI updates
/// through [ValueNotifier] pattern. Handles window state management, validation,
/// and coordination with the window widget lifecycle.
///
/// Key Capabilities:
/// - **Reactive Updates**: Automatic UI refresh when state changes
/// - **Property Management**: Convenient getters/setters for window properties
/// - **Lifecycle Handling**: Mount/unmount detection and validation
/// - **State Validation**: Ensures state consistency and constraint compliance
/// - **Handle Management**: Coordination with underlying window implementation
///
/// Usage Pattern:
/// 1. Create controller with initial window configuration
/// 2. Pass to Window.controlled() constructor
/// 3. Modify properties programmatically (bounds, minimized, etc.)
/// 4. UI automatically updates to reflect changes
/// 5. Listen to controller for state change notifications
///
/// Example:
/// ```dart
/// final controller = WindowController(
///   bounds: Rect.fromLTWH(100, 100, 800, 600),
///   resizable: true,
///   draggable: true,
/// );
///
/// // Programmatic control
/// controller.bounds = Rect.fromLTWH(200, 200, 900, 700);
/// controller.minimized = true;
/// controller.maximized = Rect.fromLTWH(0, 0, 1920, 1080);
///
/// // Listen for changes
/// controller.addListener(() {
///   print('Window state changed: ${controller.value}');
/// });
/// ```
class WindowController extends ValueNotifier<WindowState> {
/// Creates a [WindowController].
///
/// Parameters:
/// - [bounds] (`Rect`, required): Initial window bounds.
/// - [maximized] (`Rect?`, optional): Maximized bounds, or null if not maximized.
/// - [minimized] (`bool`, default: `false`): Initial minimized state.
/// - [focused] (`bool`, default: `false`): Initial focused state.
/// - [closable] (`bool`, default: `true`): Whether window can be closed.
/// - [resizable] (`bool`, default: `true`): Whether window can be resized.
/// - [draggable] (`bool`, default: `true`): Whether window can be dragged.
/// - [maximizable] (`bool`, default: `true`): Whether window can be maximized.
/// - [minimizable] (`bool`, default: `true`): Whether window can be minimized.
/// - [enableSnapping] (`bool`, default: `true`): Whether window snapping is enabled.
/// - [constraints] (`BoxConstraints`, default: `kDefaultWindowConstraints`): Size constraints.
  WindowController({required Rect bounds, Rect? maximized, bool minimized = false, bool focused = false, bool closable = true, bool resizable = true, bool draggable = true, bool maximizable = true, bool minimizable = true, bool enableSnapping = true, BoxConstraints constraints = kDefaultWindowConstraints});
/// Whether the controller is currently attached to a window widget.
///
/// Returns `true` if the controller is mounted within a window widget
/// and can safely access [attachedState]. Returns `false` otherwise.
  bool get mounted;
/// The window handle this controller is attached to.
///
/// Provides access to the underlying window implementation for advanced
/// operations. Only accessible when [mounted] is `true`.
///
/// Throws an assertion error if accessed when not mounted.
  WindowHandle get attachedState;
/// Current position and size of the window.
///
/// Setting this property updates the window bounds and triggers a UI refresh.
/// The setter is a no-op if the new value equals the current value.
  Rect get bounds;
/// Updates the window bounds.
///
/// Changes take effect immediately and trigger listener notifications.
  set bounds(Rect value);
/// Maximized bounds, or `null` if the window is not maximized.
///
/// When non-null, indicates the window is in maximized state.
  Rect? get maximized;
/// Sets the maximized state and bounds.
///
/// Pass a [Rect] to maximize the window to those bounds.
/// Pass `null` to restore the window from maximized state.
  set maximized(Rect? value);
/// Whether the window is currently minimized.
///
/// When `true`, the window is hidden from view (e.g., in taskbar).
  bool get minimized;
/// Sets the minimized state.
///
/// Set to `true` to minimize the window, `false` to restore it.
  set minimized(bool value);
/// Whether the window always appears on top of other windows.
  bool get alwaysOnTop;
/// Sets the always-on-top behavior.
///
/// When `true`, the window renders above other windows regardless of focus.
  set alwaysOnTop(bool value);
/// Whether the window can be closed.
  bool get closable;
/// Sets whether the window can be closed.
///
/// When `false`, the close button is disabled or hidden.
  set closable(bool value);
/// Whether the window can be resized by dragging edges/corners.
  bool get resizable;
/// Sets whether the window can be resized.
  set resizable(bool value);
/// Whether the window can be moved by dragging the title bar.
  bool get draggable;
/// Sets whether the window can be dragged.
  set draggable(bool value);
/// Whether the window can be maximized.
  bool get maximizable;
/// Sets whether the window can be maximized.
///
/// When `false`, the maximize button is disabled or hidden.
  set maximizable(bool value);
/// Whether the window can be minimized.
  bool get minimizable;
/// Sets whether the window can be minimized.
///
/// When `false`, the minimize button is disabled or hidden.
  set minimizable(bool value);
/// Whether edge snapping is enabled for the window.
  bool get enableSnapping;
/// Sets whether edge snapping is enabled.
///
/// When `true`, dragging near screen edges triggers snap behavior.
  set enableSnapping(bool value);
/// Size constraints for the window.
///
/// Defines min/max width and height limits for resizing.
  BoxConstraints get constraints;
/// Sets the size constraints for the window.
  set constraints(BoxConstraints value);
}
/// A resizable, draggable window widget with title bar and content area.
///
/// Provides a desktop-style window experience with full control over sizing,
/// positioning, and window controls (minimize, maximize, close). Supports both
/// controlled and uncontrolled modes for flexible state management.
///
/// Key Features:
/// - **Resizable**: Drag edges/corners to resize (when enabled)
/// - **Draggable**: Drag title bar to move window (when enabled)
/// - **Maximizable**: Fill screen or custom bounds
/// - **Minimizable**: Collapse to taskbar or hidden state
/// - **Snapping**: Auto-snap to screen edges when dragging near them
/// - **Customizable**: Title, actions, content, and theme settings
///
/// Usage Patterns:
///
/// **Uncontrolled Mode** (direct state props):
/// ```dart
/// WindowWidget(
///   title: Text('My Window'),
///   content: Text('Window content here'),
///   bounds: Rect.fromLTWH(100, 100, 800, 600),
///   resizable: true,
///   draggable: true,
/// )
/// ```
///
/// **Controlled Mode** (via controller):
/// ```dart
/// final controller = WindowController(
///   bounds: Rect.fromLTWH(100, 100, 800, 600),
/// );
///
/// WindowWidget.controlled(
///   controller: controller,
///   title: Text('Controlled Window'),
///   content: Text('Content'),
/// )
/// ```
///
/// See also:
/// - [WindowController] for programmatic window control
/// - [WindowTheme] for styling options
/// - [WindowState] for state configuration details
class WindowWidget extends StatefulWidget {
/// Widget displayed in the window's title bar.
///
/// Typically a [Text] widget, but can be any widget. Positioned on the
/// left side of the title bar by default.
  Widget? title;
/// Widget(s) displayed in the title bar's action area.
///
/// Usually contains window control buttons (minimize, maximize, close)
/// or custom action buttons. Positioned on the right side of the title bar.
  Widget? actions;
/// Main content widget displayed in the window body.
///
/// This is the primary content area below the title bar. Can be any widget,
/// such as forms, lists, or custom layouts.
  Widget? content;
/// Optional controller for programmatic window control.
///
/// When provided (via [WindowWidget.controlled]), the controller manages
/// all window state. When `null` (default constructor), widget properties
/// control the state directly.
  WindowController? controller;
/// Whether the window can be resized by dragging edges/corners.
///
/// Defaults to `true`. Ignored when using [WindowWidget.controlled].
  bool? resizable;
/// Whether the window can be moved by dragging the title bar.
///
/// Defaults to `true`. Ignored when using [WindowWidget.controlled].
  bool? draggable;
/// Whether the window can be closed.
///
/// Defaults to `true`. Ignored when using [WindowWidget.controlled].
  bool? closable;
/// Whether the window can be maximized.
///
/// Defaults to `true`. Ignored when using [WindowWidget.controlled].
  bool? maximizable;
/// Whether the window can be minimized.
///
/// Defaults to `true`. Ignored when using [WindowWidget.controlled].
  bool? minimizable;
/// Initial position and size of the window.
///
/// Required for default constructor. Ignored when using [WindowWidget.controlled].
  Rect? bounds;
/// Initial maximized bounds, or `null` if not maximized.
///
/// Ignored when using [WindowWidget.controlled].
  Rect? maximized;
/// Whether the window starts minimized.
///
/// Defaults to `false`. Ignored when using [WindowWidget.controlled].
  bool? minimized;
/// Whether edge snapping is enabled.
///
/// Defaults to `true`. Ignored when using [WindowWidget.controlled].
  bool? enableSnapping;
/// Size constraints for the window.
///
/// Enforces min/max dimensions during resizing.
/// Defaults to [kDefaultWindowConstraints]. Ignored when using [WindowWidget.controlled].
  BoxConstraints? constraints;
/// Height of the title bar in logical pixels.
///
/// If `null`, uses the theme's default title bar height.
  double? titleBarHeight;
/// Thickness of the resize border in logical pixels.
///
/// If `null`, uses the theme's default resize thickness.
  double? resizeThickness;
/// Creates a window with direct state management.
///
/// All window state properties ([bounds], [minimized], etc.) are managed
/// directly through widget properties. State changes require rebuilding
/// the widget with new property values.
///
/// Parameters:
/// - [title]: Title bar content
/// - [actions]: Action buttons area content
/// - [content]: Main window content
/// - [titleBarHeight]: Custom title bar height (optional)
/// - [resizeThickness]: Custom resize border thickness (optional)
/// - [resizable]: Enable resizing (defaults to `true`)
/// - [draggable]: Enable dragging (defaults to `true`)
/// - [closable]: Enable closing (defaults to `true`)
/// - [maximizable]: Enable maximizing (defaults to `true`)
/// - [minimizable]: Enable minimizing (defaults to `true`)
/// - [enableSnapping]: Enable edge snapping (defaults to `true`)
/// - [bounds]: Initial window bounds (required)
/// - [maximized]: Initial maximized bounds (optional)
/// - [minimized]: Start minimized (defaults to `false`)
/// - [constraints]: Size constraints (defaults to [kDefaultWindowConstraints])
  const WindowWidget({super.key, this.title, this.actions, this.content, this.titleBarHeight, this.resizeThickness, bool this.resizable = true, bool this.draggable = true, bool this.closable = true, bool this.maximizable = true, bool this.minimizable = true, bool this.enableSnapping = true, required Rect this.bounds, this.maximized, bool this.minimized = false, BoxConstraints this.constraints = kDefaultWindowConstraints});
/// Creates a window with controller-based state management.
///
/// State is managed entirely through the provided [controller]. All state
/// properties from the default constructor are unavailable and must be
/// controlled via the controller instead.
///
/// This pattern is recommended when you need:
/// - Programmatic control over window state
/// - To listen to state changes
/// - To share state across multiple widgets
/// - More reactive state updates
///
/// Parameters:
/// - [controller]: The window controller (required)
/// - [title]: Title bar content
/// - [actions]: Action buttons area content
/// - [content]: Main window content
/// - [titleBarHeight]: Custom title bar height (optional)
/// - [resizeThickness]: Custom resize border thickness (optional)
///
/// Example:
/// ```dart
/// final controller = WindowController(
///   bounds: Rect.fromLTWH(100, 100, 800, 600),
/// );
///
/// // Later, programmatically control:
/// controller.minimized = true;
/// controller.bounds = Rect.fromLTWH(200, 200, 900, 700);
/// ```
  const WindowWidget.controlled({super.key, this.title, this.actions, this.content, required WindowController this.controller, this.titleBarHeight, this.resizeThickness});
  State<WindowWidget> createState();
}
/// Interface for controlling window state and behavior.
///
/// Mixin that provides access to window properties and operations.
/// Implemented by window state classes to manage window lifecycle.
mixin WindowHandle on State<WindowWidget> {
/// Gets the current window bounds.
  Rect get bounds;
/// Sets the window bounds.
  set bounds(Rect value);
/// Gets the maximized bounds, or null if not maximized.
  Rect? get maximized;
/// Sets the maximized bounds.
  set maximized(Rect? value);
/// Whether the window is minimized.
  bool get minimized;
/// Sets the minimized state.
  set minimized(bool value);
/// Whether the window has focus.
  bool get focused;
/// Sets the focused state.
  set focused(bool value);
/// Closes the window.
  void close();
/// Whether the window stays on top of other windows.
  bool get alwaysOnTop;
/// Sets the always-on-top state.
  set alwaysOnTop(bool value);
/// Whether the window can be resized.
  bool get resizable;
/// Whether the window can be dragged.
  bool get draggable;
/// Whether the window can be closed.
  bool get closable;
/// Whether the window can be maximized.
  bool get maximizable;
/// Whether the window can be minimized.
  bool get minimizable;
/// Whether window snapping is enabled.
  bool get enableSnapping;
/// Sets the resizable state.
  set resizable(bool value);
/// Sets the draggable state.
  set draggable(bool value);
/// Sets the closable state.
  set closable(bool value);
/// Sets the maximizable state.
  set maximizable(bool value);
/// Sets the minimizable state.
  set minimizable(bool value);
/// Sets the snapping enabled state.
  set enableSnapping(bool value);
/// Gets the window controller.
  WindowController get controller;
}
/// A widget that manages multiple floating windows.
///
/// Provides a desktop-style window management system where multiple windows
/// can be displayed, dragged, resized, minimized, and maximized.
///
/// Example:
/// ```dart
/// WindowNavigator(
///   initialWindows: [
///     Window(
///       controller: WindowController(bounds: Rect.fromLTWH(100, 100, 400, 300)),
///       child: Text('Window Content'),
///     ),
///   ],
/// )
/// ```
class WindowNavigator extends StatefulWidget {
/// Initial list of windows to display.
  List<Window> initialWindows;
/// Optional background child widget.
  Widget? child;
/// Whether to show the top snap bar for window snapping.
  bool showTopSnapBar;
/// Creates a [WindowNavigator].
///
/// Parameters:
/// - [initialWindows] (`List<Window>`, required): Windows to display initially.
/// - [child] (`Widget?`, optional): Background widget.
/// - [showTopSnapBar] (`bool`, default: `true`): Show snap bar.
  const WindowNavigator({super.key, required this.initialWindows, this.child, this.showTopSnapBar = true});
  State<WindowNavigator> createState();
}
/// A comprehensive windowing system for creating desktop-like window interfaces.
///
/// **EXPERIMENTAL COMPONENT** - This component is in active development and APIs may change.
///
/// Provides a complete window management solution with draggable, resizable windows
/// that support minimizing, maximizing, and snapping to screen edges. Designed for
/// desktop-style applications requiring multiple simultaneous content areas.
///
/// Core Features:
/// - **Window Management**: Create, control, and destroy floating windows
/// - **Interactive Behaviors**: Drag, resize, minimize, maximize, close operations
/// - **Snapping System**: Intelligent edge snapping and window positioning
/// - **Layering Control**: Always-on-top and z-order management
/// - **Constraint System**: Size and position limits with validation
/// - **Theme Integration**: Full shadcn_flutter theme and styling support
///
/// Architecture:
/// - **Window**: Immutable window configuration and factory
/// - **WindowController**: Reactive state management for window properties
/// - **WindowWidget**: Stateful widget that renders the actual window
/// - **WindowNavigator**: Container managing multiple windows
///
/// The system supports both controlled (external state management) and
/// uncontrolled (internal state management) modes for different use cases.
///
/// Usage Patterns:
/// 1. **Simple Window**: Basic window with default behaviors
/// 2. **Controlled Window**: External state management with WindowController
/// 3. **Window Navigator**: Multiple windows with shared management
///
/// Example:
/// ```dart
/// // Simple window
/// final window = Window(
///   title: Text('My Window'),
///   content: MyContent(),
///   bounds: Rect.fromLTWH(100, 100, 800, 600),
///   resizable: true,
///   draggable: true,
/// );
///
/// // Controlled window
/// final controller = WindowController(initialState);
/// final controlledWindow = Window.controlled(
///   controller: controller,
///   title: Text('Controlled Window'),
///   content: MyContent(),
/// );
/// ```
class Window {
/// Title widget displayed in the window's title bar.
  Widget? title;
/// Custom action widgets displayed in the title bar (e.g., minimize, maximize, close buttons).
  Widget? actions;
/// Main content widget displayed in the window body.
  Widget? content;
/// Controller for programmatic window management (position, size, state).
  WindowController? controller;
/// Initial bounds (position and size) of the window.
  Rect? bounds;
/// Bounds when window is in maximized state.
  Rect? maximized;
/// Whether the window starts in minimized state.
  bool? minimized;
/// Whether the window should always appear on top of other windows.
  bool? alwaysOnTop;
/// Whether window snapping is enabled (snap to edges or other windows).
  bool? enableSnapping;
/// Whether the window can be resized by dragging edges.
  bool? resizable;
/// Whether the window can be dragged by its title bar.
  bool? draggable;
/// Whether the window can be closed via the close button.
  bool? closable;
/// Whether the window can be maximized.
  bool? maximizable;
/// Whether the window can be minimized.
  bool? minimizable;
/// Size constraints for the window (min/max width and height).
  BoxConstraints? constraints;
/// Notifier that indicates whether the window has been closed.
///
/// External code can listen to this notifier to react to window close events.
  ValueNotifier<bool> closed;
/// Creates a controlled window with behavior managed by a [WindowController].
///
/// This constructor creates a window whose state (position, size, minimized,
/// maximized) is entirely controlled programmatically through the provided
/// controller. All state properties are null and managed via the controller.
///
/// Parameters:
/// - [title] (Widget?): Title widget for the title bar
/// - [actions] (Widget?): Custom action widgets, defaults to `WindowActions()`
/// - [content] (Widget?): Main content widget
/// - [controller] (WindowController, required): Controller for programmatic management
///
/// Example:
/// ```dart
/// Window.controlled(
///   controller: myWindowController,
///   title: Text('Controlled Window'),
///   content: MyContentWidget(),
/// )
/// ```
  Window.controlled({this.title, this.actions = const WindowActions(), this.content, required this.controller});
/// Creates a window with explicit state and configuration.
///
/// This constructor creates a window with directly specified state properties
/// rather than using a controller. The window's initial position, size, and
/// capabilities are defined through the constructor parameters.
///
/// Parameters:
/// - [title] (Widget?): Title widget for the title bar
/// - [actions] (Widget?): Custom action widgets, defaults to `WindowActions()`
/// - [content] (Widget?): Main content widget
/// - [resizable] (bool): Whether window can be resized, defaults to true
/// - [draggable] (bool): Whether window can be dragged, defaults to true
/// - [closable] (bool): Whether window can be closed, defaults to true
/// - [maximizable] (bool): Whether window can be maximized, defaults to true
/// - [minimizable] (bool): Whether window can be minimized, defaults to true
/// - [enableSnapping] (bool): Whether snapping is enabled, defaults to true
/// - [bounds] (Rect, required): Initial window bounds (position and size)
/// - [maximized] (Rect?): Bounds when maximized
/// - [minimized] (bool): Whether starts minimized, defaults to false
/// - [alwaysOnTop] (bool): Whether always on top, defaults to false
/// - [constraints] (BoxConstraints): Size constraints, defaults to `kDefaultWindowConstraints`
///
/// Example:
/// ```dart
/// Window(
///   title: Text('My Window'),
///   bounds: Rect.fromLTWH(100, 100, 400, 300),
///   resizable: true,
///   content: MyContentWidget(),
/// )
/// ```
  Window({this.title, this.actions = const WindowActions(), this.content, bool this.resizable = true, bool this.draggable = true, bool this.closable = true, bool this.maximizable = true, bool this.minimizable = true, bool this.enableSnapping = true, required this.bounds, this.maximized, bool this.minimized = false, bool this.alwaysOnTop = false, BoxConstraints this.constraints = kDefaultWindowConstraints});
/// Gets a handle to the window's internal state.
///
/// Provides access to the window's state for programmatic control.
/// The window must be mounted (added to the widget tree) before accessing
/// this handle.
///
/// Throws [AssertionError] if the window is not mounted.
///
/// Returns [WindowHandle] for controlling the window state.
  WindowHandle get handle;
/// Indicates whether the window is currently mounted in the widget tree.
///
/// A window is mounted when it has been added to the widget tree and has
/// an associated build context. Unmounted windows cannot be controlled or
/// accessed.
///
/// Returns true if window is mounted, false otherwise.
  bool get mounted;
}
/// Mixin providing window management capabilities for WindowNavigator state.
///
/// This mixin defines the interface for managing multiple windows in a
/// window navigator. It provides methods for adding, removing, focusing,
/// and managing window states.
///
/// Implementations must provide these core window management operations:
/// - Adding and removing windows from the navigator
/// - Managing window focus and z-order
/// - Controlling always-on-top behavior
/// - Querying window focus state and window list
///
/// See also:
/// - [WindowNavigator], the widget that uses this mixin
/// - [Window], the window objects being managed
mixin WindowNavigatorHandle on State<WindowNavigator> {
/// Adds a new window to the navigator.
///
/// The window is added to the navigator's window list and typically
/// appears at the top of the window stack with focus.
///
/// Parameters:
/// - [window] (Window, required): The window to add
  void pushWindow(Window window);
/// Brings a window to the front and gives it focus.
///
/// Moves the specified window to the top of the window stack and
/// sets it as the focused window for keyboard input and user interaction.
///
/// Parameters:
/// - [window] (Window, required): The window to focus
  void focusWindow(Window window);
/// Removes focus from a window without closing it.
///
/// The window remains in the navigator but loses focus. Another window
/// may receive focus, or no window may be focused.
///
/// Parameters:
/// - [window] (Window, required): The window to unfocus
  void unfocusWindow(Window window);
/// Sets whether a window should always appear on top.
///
/// Always-on-top windows remain above other windows even when they
/// lose focus. Useful for tool palettes and notification windows.
///
/// Parameters:
/// - [window] (Window, required): The window to modify
/// - [value] (bool, required): True to set always-on-top, false to disable
  void setAlwaysOnTop(Window window, bool value);
/// Removes a window from the navigator.
///
/// The window is removed from the navigator's window list and destroyed.
/// If the window was focused, focus may move to another window.
///
/// Parameters:
/// - [window] (Window, required): The window to remove
  void removeWindow(Window window);
/// Checks if a window is currently focused.
///
/// Parameters:
/// - [window] (Window, required): The window to check
///
/// Returns true if the window is focused, false otherwise.
  bool isFocused(Window window);
/// Gets the list of all windows in the navigator.
///
/// Returns an ordered list of windows, typically in z-order from
/// bottom to top.
  List<Window> get windows;
}
/// Default size constraints for window components.
///
/// Defines minimum width and height values to ensure windows
/// remain usable and visible.
///
/// The constraints are:
/// - Minimum width: 200 pixels
/// - Minimum height: 200 pixels
const kDefaultWindowConstraints = BoxConstraints(minWidth: 200, minHeight: 200);
/// Data class containing viewport information for a window.
///
/// WindowViewport provides contextual information about a window's current
/// state within the window navigator. This data is made available to child
/// widgets through the Data inheritance mechanism.
///
/// The viewport information includes:
/// - Size of the visible area
/// - Reference to the navigator managing the window
/// - Focus and display state flags
/// - Interaction state (pointer events, minimization)
///
/// This class is typically used internally by the window system to pass
/// state information to window content and decoration widgets.
class WindowViewport {
/// The size of the window's visible area.
  Size size;
/// Reference to the window navigator managing this window.
  WindowNavigatorHandle navigator;
/// Whether this window currently has focus.
  bool focused;
/// Whether this window is set to always appear on top.
  bool alwaysOnTop;
/// Whether this window has been closed.
  bool closed;
/// Whether the window is being minimized (transitioning to minimized state).
  bool minify;
/// Whether pointer events should be ignored for this window.
  bool ignorePointer;
/// Creates a window viewport data object.
///
/// All parameters are required and define the current state of the window
/// within its viewport context.
///
/// Parameters:
/// - [size] (Size, required): Visible area size
/// - [navigator] (WindowNavigatorHandle, required): Managing navigator
/// - [focused] (bool, required): Focus state
/// - [alwaysOnTop] (bool, required): Always-on-top state
/// - [closed] (bool, required): Closed state
/// - [minify] (bool, required): Minimizing state
/// - [ignorePointer] (bool, required): Pointer event state
  const WindowViewport({required this.size, required this.navigator, required this.focused, required this.alwaysOnTop, required this.closed, required this.minify, required this.ignorePointer});
  bool operator ==(Object other);
  int get hashCode;
}
/// Default window actions widget providing minimize, maximize, and close buttons.
///
/// This widget provides the standard set of window control buttons typically
/// found in window title bars. The buttons automatically adapt based on the
/// window's capabilities (minimizable, maximizable, closable).
///
/// The widget retrieves window state from the build context using the Data
/// inheritance mechanism, accessing [WindowHandle] and [WindowViewport] data.
///
/// Buttons included:
/// - Minimize button: Collapses the window (if minimizable)
/// - Maximize/Restore button: Toggles between maximized and normal states (if maximizable)
/// - Close button: Closes the window (if closable)
///
/// Example:
/// ```dart
/// Window(
///   title: Text('My Window'),
///   actions: WindowActions(), // Default window controls
///   content: MyContent(),
/// )
/// ```
class WindowActions extends StatelessWidget {
/// Creates a default window actions widget.
///
/// This widget automatically displays appropriate control buttons based on
/// the window's configuration and capabilities.
  const WindowActions({super.key});
  Widget build(BuildContext context);
}
/// Theme configuration for [Basic] layout widgets.
///
/// Defines default alignment, spacing, and padding properties for Basic
/// layout components. These properties control how leading, trailing, title,
/// subtitle, and content elements are positioned and spaced.
class BasicTheme extends ComponentThemeData {
/// Alignment for the leading widget.
  AlignmentGeometry? leadingAlignment;
/// Alignment for the trailing widget.
  AlignmentGeometry? trailingAlignment;
/// Alignment for the title widget.
  AlignmentGeometry? titleAlignment;
/// Alignment for the subtitle widget.
  AlignmentGeometry? subtitleAlignment;
/// Alignment for the content widget.
  AlignmentGeometry? contentAlignment;
/// Spacing between content elements.
  double? contentSpacing;
/// Spacing between title and subtitle.
  double? titleSpacing;
/// Main axis alignment for the overall layout.
  MainAxisAlignment? mainAxisAlignment;
/// Padding around the entire Basic widget.
  EdgeInsetsGeometry? padding;
/// Creates a [BasicTheme].
  const BasicTheme({this.leadingAlignment, this.trailingAlignment, this.titleAlignment, this.subtitleAlignment, this.contentAlignment, this.contentSpacing, this.titleSpacing, this.mainAxisAlignment, this.padding});
/// Creates a copy of this theme with the given fields replaced.
  BasicTheme copyWith({ValueGetter<AlignmentGeometry?>? leadingAlignment, ValueGetter<AlignmentGeometry?>? trailingAlignment, ValueGetter<AlignmentGeometry?>? titleAlignment, ValueGetter<AlignmentGeometry?>? subtitleAlignment, ValueGetter<AlignmentGeometry?>? contentAlignment, ValueGetter<double?>? contentSpacing, ValueGetter<double?>? titleSpacing, ValueGetter<MainAxisAlignment?>? mainAxisAlignment, ValueGetter<EdgeInsetsGeometry?>? padding});
  bool operator ==(Object other);
  int get hashCode;
}
/// A versatile layout widget for arranging leading, title, subtitle, content, and trailing elements.
///
/// Provides a flexible row-based layout commonly used for list items, cards, or
/// any UI requiring a structured arrangement of multiple content sections. Each
/// section can be independently aligned and spaced.
///
/// Example:
/// ```dart
/// Basic(
///   leading: Icon(Icons.person),
///   title: Text('John Doe'),
///   subtitle: Text('john@example.com'),
///   trailing: Icon(Icons.chevron_right),
/// )
/// ```
class Basic extends StatelessWidget {
/// Leading widget, typically an icon or avatar.
  Widget? leading;
/// Primary title widget.
  Widget? title;
/// Secondary subtitle widget, displayed below title.
  Widget? subtitle;
/// Main content widget, displayed below title/subtitle.
  Widget? content;
/// Trailing widget, typically an icon or action button.
  Widget? trailing;
/// Alignment for the [leading] widget.
  AlignmentGeometry? leadingAlignment;
/// Alignment for the [trailing] widget.
  AlignmentGeometry? trailingAlignment;
/// Alignment for the [title] widget.
  AlignmentGeometry? titleAlignment;
/// Alignment for the [subtitle] widget.
  AlignmentGeometry? subtitleAlignment;
/// Alignment for the [content] widget.
  AlignmentGeometry? contentAlignment;
/// Spacing between content elements (default: 16).
  double? contentSpacing;
/// Spacing between title and subtitle (default: 4).
  double? titleSpacing;
/// Main axis alignment for the overall layout.
  MainAxisAlignment? mainAxisAlignment;
/// Padding around the entire widget.
  EdgeInsetsGeometry? padding;
/// Creates a [Basic] layout widget.
  const Basic({super.key, this.leading, this.title, this.subtitle, this.content, this.trailing, this.leadingAlignment, this.trailingAlignment, this.titleAlignment, this.subtitleAlignment, this.contentAlignment, this.contentSpacing, this.titleSpacing, this.mainAxisAlignment, this.padding});
  Widget build(BuildContext context);
}
/// Same as [Basic], but without forcing text styles.
///
/// Provides the same layout structure as [Basic] but doesn't apply default
/// text styling to title and subtitle elements. Use this when you need full
/// control over text appearance.
///
/// Example:
/// ```dart
/// BasicLayout(
///   leading: Icon(Icons.star),
///   title: Text('Custom styled title', style: myStyle),
///   subtitle: Text('Custom styled subtitle', style: myStyle),
/// )
/// ```
class BasicLayout extends StatelessWidget {
/// Leading widget, typically an icon or avatar.
  Widget? leading;
/// Primary title widget.
  Widget? title;
/// Secondary subtitle widget, displayed below title.
  Widget? subtitle;
/// Main content widget, displayed below title/subtitle.
  Widget? content;
/// Trailing widget, typically an icon or action button.
  Widget? trailing;
/// Alignment for the [leading] widget.
  AlignmentGeometry? leadingAlignment;
/// Alignment for the [trailing] widget.
  AlignmentGeometry? trailingAlignment;
/// Alignment for the [title] widget.
  AlignmentGeometry? titleAlignment;
/// Alignment for the [subtitle] widget.
  AlignmentGeometry? subtitleAlignment;
/// Alignment for the [content] widget.
  AlignmentGeometry? contentAlignment;
/// Spacing between content elements.
  double? contentSpacing;
/// Spacing between title and subtitle.
  double? titleSpacing;
/// Size constraints for the layout.
  BoxConstraints? constraints;
/// Creates a [BasicLayout] widget.
  const BasicLayout({super.key, this.leading, this.title, this.subtitle, this.content, this.trailing, this.leadingAlignment, this.trailingAlignment, this.titleAlignment, this.subtitleAlignment, this.contentAlignment, this.contentSpacing, this.titleSpacing, this.constraints});
  Widget build(BuildContext context);
}
/// A layout widget for labels with optional leading and trailing elements.
///
/// Arranges a main label with optional leading and trailing widgets in a
/// horizontal layout with consistent spacing.
///
/// Example:
/// ```dart
/// Label(
///   leading: Icon(Icons.person),
///   child: Text('Name'),
///   trailing: Icon(Icons.edit),
/// )
/// ```
class Label extends StatelessWidget {
/// Optional leading widget displayed before the label.
  Widget? leading;
/// The main label content.
  Widget child;
/// Optional trailing widget displayed after the label.
  Widget? trailing;
/// Creates a [Label].
///
/// Parameters:
/// - [child] (`Widget`, required): Main label content.
/// - [leading] (`Widget?`, optional): Leading widget.
/// - [trailing] (`Widget?`, optional): Trailing widget.
  const Label({super.key, this.leading, required this.child, this.trailing});
  Widget build(BuildContext context);
}
/// Theme data for customizing [Card] and [SurfaceCard] widget appearance.
///
/// This class defines the visual properties that can be applied to card widgets,
/// including padding, fill behavior, colors, borders, shadows, and surface effects.
/// These properties can be set at the theme level to provide consistent styling
/// across the application.
///
/// The theme affects both regular cards and surface cards, with surface cards
/// supporting additional blur and opacity effects for glassmorphism styling.
class CardTheme extends ComponentThemeData {
/// Padding inside the card.
  EdgeInsetsGeometry? padding;
/// Whether the card is filled.
  bool? filled;
/// The fill color when [filled] is true.
  Color? fillColor;
/// Border radius of the card.
  BorderRadiusGeometry? borderRadius;
/// Border color of the card.
  Color? borderColor;
/// Border width of the card.
  double? borderWidth;
/// Clip behavior of the card.
  Clip? clipBehavior;
/// Box shadow of the card.
  List<BoxShadow>? boxShadow;
/// Surface opacity for blurred background.
  double? surfaceOpacity;
/// Surface blur for blurred background.
  double? surfaceBlur;
/// Animation duration for transitions.
  Duration? duration;
/// Creates a [CardTheme].
  const CardTheme({this.padding, this.filled, this.fillColor, this.borderRadius, this.borderColor, this.borderWidth, this.clipBehavior, this.boxShadow, this.surfaceOpacity, this.surfaceBlur, this.duration});
/// Creates a copy of this theme with the given values replaced.
  CardTheme copyWith({ValueGetter<EdgeInsetsGeometry?>? padding, ValueGetter<bool?>? filled, ValueGetter<Color?>? fillColor, ValueGetter<BorderRadiusGeometry?>? borderRadius, ValueGetter<Color?>? borderColor, ValueGetter<double?>? borderWidth, ValueGetter<Clip?>? clipBehavior, ValueGetter<List<BoxShadow>?>? boxShadow, ValueGetter<double?>? surfaceOpacity, ValueGetter<double?>? surfaceBlur, ValueGetter<Duration?>? duration});
  bool operator ==(Object other);
  int get hashCode;
}
/// A versatile container widget that provides a card-like appearance with comprehensive styling options.
///
/// [Card] is a foundational layout component that wraps content in a visually distinct
/// container with configurable borders, shadows, fills, and surface effects. It serves
/// as the basis for many UI patterns including content cards, panels, sections, and
/// grouped information displays.
///
/// Key features:
/// - Flexible fill and border styling options
/// - Configurable shadow effects for depth perception
/// - Customizable corner radius and clipping behavior
/// - Surface effects for glassmorphism and blur styling
/// - Responsive padding with theme integration
/// - Animation support for state transitions
/// - Consistent theming across the application
///
/// The card supports various visual modes:
/// - Filled cards with solid background colors
/// - Outlined cards with transparent backgrounds and borders
/// - Surface cards with blur effects and opacity
/// - Elevated cards with shadow effects
/// - Custom combinations of fill, border, and shadow
///
/// Visual hierarchy can be achieved through:
/// - Shadow depth for elevation indication
/// - Fill colors for emphasis and categorization
/// - Border styles for subtle grouping
/// - Surface effects for modern glass-like appearances
///
/// Example:
/// ```dart
/// Card(
///   filled: true,
///   fillColor: Colors.white,
///   borderRadius: BorderRadius.circular(12),
///   boxShadow: [
///     BoxShadow(
///       color: Colors.black.withOpacity(0.1),
///       blurRadius: 8,
///       offset: Offset(0, 2),
///     ),
///   ],
///   child: Padding(
///     padding: EdgeInsets.all(16),
///     child: Column(
///       children: [
///         Text('Card Title', style: TextStyle(fontWeight: FontWeight.bold)),
///         SizedBox(height: 8),
///         Text('Card content goes here...'),
///       ],
///     ),
///   ),
/// );
/// ```
class Card extends StatelessWidget {
/// The child widget to display within the card.
  Widget child;
/// Padding inside the card around the [child].
///
/// If `null`, uses default padding from the theme.
  EdgeInsetsGeometry? padding;
/// Whether the card has a filled background.
///
/// When `true`, the card has a solid background color. When `false` or
/// `null`, uses theme defaults.
  bool? filled;
/// The background fill color of the card.
///
/// Only applies when [filled] is `true`. If `null`, uses theme default.
  Color? fillColor;
/// Border radius for rounded corners on the card.
///
/// If `null`, uses default border radius from the theme.
  BorderRadiusGeometry? borderRadius;
/// Color of the card's border.
///
/// If `null`, uses default border color from the theme.
  Color? borderColor;
/// Width of the card's border in logical pixels.
///
/// If `null`, uses default border width from the theme.
  double? borderWidth;
/// How to clip the card's content.
///
/// Controls overflow clipping behavior. If `null`, uses [Clip.none].
  Clip? clipBehavior;
/// Box shadows to apply to the card.
///
/// Creates elevation and depth effects. If `null`, no shadows are applied.
  List<BoxShadow>? boxShadow;
/// Opacity of the card's surface effect.
///
/// Controls the transparency of surface overlays. If `null`, uses theme default.
  double? surfaceOpacity;
/// Blur amount for the card's surface effect.
///
/// Creates a frosted glass or blur effect. If `null`, no blur is applied.
  double? surfaceBlur;
/// Duration for card appearance animations.
///
/// Controls how long transitions take when card properties change. If `null`,
/// uses default animation duration.
  Duration? duration;
/// Creates a [Card].
  const Card({super.key, required this.child, this.padding, this.filled, this.fillColor, this.borderRadius, this.clipBehavior, this.borderColor, this.borderWidth, this.boxShadow, this.surfaceOpacity, this.surfaceBlur, this.duration});
  Widget build(BuildContext context);
}
/// A card variant with surface blur and opacity effects.
///
/// Similar to [Card] but with enhanced visual effects including frosted glass
/// or translucent surface appearances. Useful for overlays or layered UI designs.
///
/// Example:
/// ```dart
/// SurfaceCard(
///   surfaceBlur: 10,
///   surfaceOpacity: 0.8,
///   child: Text('Overlay content'),
/// )
/// ```
class SurfaceCard extends StatelessWidget {
/// The child widget to display within the card.
  Widget child;
/// Padding inside the card around the [child].
///
/// If `null`, uses default padding from the theme.
  EdgeInsetsGeometry? padding;
/// Whether the card has a filled background.
///
/// When `true`, applies a solid background color.
  bool? filled;
/// The background fill color of the card.
///
/// Only applies when [filled] is `true`. If `null`, uses theme default.
  Color? fillColor;
/// Border radius for rounded corners on the card.
///
/// If `null`, uses default border radius from the theme.
  BorderRadiusGeometry? borderRadius;
/// Color of the card's border.
///
/// If `null`, uses default border color from the theme.
  Color? borderColor;
/// Width of the card's border in logical pixels.
///
/// If `null`, uses default border width from the theme.
  double? borderWidth;
/// How to clip the card's content.
///
/// Controls overflow clipping behavior. If `null`, uses [Clip.none].
  Clip? clipBehavior;
/// Box shadows to apply to the card.
///
/// Creates elevation and depth effects. If `null`, no shadows are applied.
  List<BoxShadow>? boxShadow;
/// Opacity of the card's surface effect.
///
/// Controls transparency for frosted glass or translucent effects. Higher
/// values are more opaque.
  double? surfaceOpacity;
/// Blur amount for the card's surface effect.
///
/// Creates a frosted glass appearance. Higher values create more blur.
  double? surfaceBlur;
/// Duration for card appearance animations.
///
/// Controls how long transitions take when properties change.
  Duration? duration;
/// Creates a [SurfaceCard].
  const SurfaceCard({super.key, required this.child, this.padding, this.filled, this.fillColor, this.borderRadius, this.clipBehavior, this.borderColor, this.borderWidth, this.boxShadow, this.surfaceOpacity, this.surfaceBlur, this.duration});
  Widget build(BuildContext context);
}
/// A modal dialog component for displaying important alerts and confirmations.
///
/// AlertDialog provides a focused overlay interface for critical user interactions
/// that require immediate attention or confirmation. Built on top of [ModalBackdrop]
/// and [ModalContainer], it ensures proper accessibility and visual hierarchy.
///
/// The dialog features a flexible layout system supporting optional leading/trailing
/// icons, title text, descriptive content, and customizable action buttons. All
/// elements automatically adapt to the current theme's color scheme and scaling.
///
/// Key features:
/// - Modal presentation with backdrop blur and overlay
/// - Flexible content layout with optional elements
/// - Automatic theme integration and responsive scaling
/// - Customizable surface effects (blur, opacity)
/// - Action button layout with proper spacing
/// - Safe area handling for various screen sizes
///
/// The component is a StatefulWidget to manage internal modal state and
/// ensure proper lifecycle management during show/hide transitions.
///
/// Example:
/// ```dart
/// AlertDialog(
///   leading: Icon(Icons.warning),
///   title: Text('Delete Item'),
///   content: Text('Are you sure you want to delete this item?'),
///   actions: [
///     Button.ghost(onPressed: () => Navigator.pop(context), child: Text('Cancel')),
///     Button.destructive(onPressed: _deleteItem, child: Text('Delete')),
///   ],
/// );
/// ```
class AlertDialog extends StatefulWidget {
/// Optional leading widget, typically an icon or graphic.
///
/// Type: `Widget?`. Displayed at the start of the dialog header with
/// automatic icon styling (XL size, muted foreground color).
  Widget? leading;
/// Optional trailing widget for additional dialog controls.
///
/// Type: `Widget?`. Positioned at the end of the dialog header with
/// similar styling to the leading widget.
  Widget? trailing;
/// Optional title widget for the dialog header.
///
/// Type: `Widget?`. Displayed prominently with large, semi-bold text styling.
/// Should contain the primary message or question for the user.
  Widget? title;
/// Optional content widget for detailed dialog information.
///
/// Type: `Widget?`. Provides additional context or description with
/// small, muted text styling. Positioned below the title.
  Widget? content;
/// Optional list of action buttons for user interaction.
///
/// Type: `List<Widget>?`. Buttons are arranged horizontally at the bottom
/// of the dialog with consistent spacing. Typically includes cancel and
/// confirmation options.
  List<Widget>? actions;
/// Surface blur intensity for the modal backdrop.
///
/// Type: `double?`. If null, uses theme default blur value.
/// Higher values create more pronounced background blur effects.
  double? surfaceBlur;
/// Surface opacity for the modal backdrop.
///
/// Type: `double?`. If null, uses theme default opacity value.
/// Controls the transparency level of the backdrop overlay.
  double? surfaceOpacity;
/// Barrier color for the modal backdrop.
///
/// Type: `Color?`. If null, defaults to black with 80% opacity.
/// The color overlay applied behind the dialog content.
  Color? barrierColor;
/// Internal padding for the dialog content.
///
/// Type: `EdgeInsetsGeometry?`. If null, uses responsive padding
/// based on theme scaling (24 * scaling). Controls spacing around
/// all dialog content.
  EdgeInsetsGeometry? padding;
/// Creates an [AlertDialog].
///
/// All parameters are optional, allowing for flexible dialog configurations
/// from simple text alerts to complex confirmation interfaces.
///
/// Parameters:
/// - [leading] (Widget?, optional): Icon or graphic at dialog start
/// - [title] (Widget?, optional): Primary dialog heading
/// - [content] (Widget?, optional): Detailed description or message
/// - [actions] (`List<Widget>?`, optional): Action buttons for user response
/// - [trailing] (Widget?, optional): Additional controls at dialog end
/// - [surfaceBlur] (double?, optional): Backdrop blur intensity
/// - [surfaceOpacity] (double?, optional): Backdrop opacity level
/// - [barrierColor] (Color?, optional): Backdrop overlay color
/// - [padding] (EdgeInsetsGeometry?, optional): Internal content padding
///
/// Example:
/// ```dart
/// AlertDialog(
///   title: Text('Confirm Action'),
///   content: Text('This action cannot be undone.'),
///   actions: [
///     TextButton(onPressed: () => Navigator.pop(context), child: Text('Cancel')),
///     ElevatedButton(onPressed: _confirm, child: Text('Confirm')),
///   ],
/// );
/// ```
  const AlertDialog({super.key, this.leading, this.title, this.content, this.actions, this.trailing, this.surfaceBlur, this.surfaceOpacity, this.barrierColor, this.padding});
  State<AlertDialog> createState();
}
/// A widget that applies a blur effect to its background.
///
/// Creates a frosted glass or translucent blur effect behind the child widget
/// using a backdrop filter. The blur amount is controlled by [surfaceBlur].
///
/// Example:
/// ```dart
/// SurfaceBlur(
///   surfaceBlur: 10,
///   borderRadius: BorderRadius.circular(8),
///   child: Container(
///     color: Colors.white.withOpacity(0.5),
///     child: Text('Blurred background'),
///   ),
/// )
/// ```
class SurfaceBlur extends StatefulWidget {
/// The child widget to display with blurred background.
  Widget child;
/// The amount of blur to apply (sigma value for blur filter).
///
/// If `null` or `<= 0`, no blur is applied.
  double? surfaceBlur;
/// Border radius for clipping the blur effect.
///
/// If `null`, no rounding is applied.
  BorderRadiusGeometry? borderRadius;
/// Creates a [SurfaceBlur].
  const SurfaceBlur({super.key, required this.child, this.surfaceBlur, this.borderRadius});
  State<SurfaceBlur> createState();
}
/// Theme configuration for [OutlinedContainer] appearance.
///
/// Defines styling properties including background color, border styles,
/// shadows, padding, and surface effects for outlined containers.
class OutlinedContainerTheme extends ComponentThemeData {
/// Background color for the container.
  Color? backgroundColor;
/// Color of the container's border.
  Color? borderColor;
/// Border radius for rounded corners.
  BorderRadiusGeometry? borderRadius;
/// Style of the border (solid, dotted, etc).
  BorderStyle? borderStyle;
/// Width of the border in logical pixels.
  double? borderWidth;
/// Box shadows to apply for depth/elevation effects.
  List<BoxShadow>? boxShadow;
/// Padding inside the container.
  EdgeInsetsGeometry? padding;
/// Opacity for surface overlay effects.
  double? surfaceOpacity;
/// Blur amount for surface backdrop effects.
  double? surfaceBlur;
/// Creates an [OutlinedContainerTheme].
  const OutlinedContainerTheme({this.backgroundColor, this.borderColor, this.borderRadius, this.borderStyle, this.borderWidth, this.boxShadow, this.padding, this.surfaceOpacity, this.surfaceBlur});
/// Creates a copy of this theme with the given fields replaced.
  OutlinedContainerTheme copyWith({ValueGetter<Color?>? backgroundColor, ValueGetter<Color?>? borderColor, ValueGetter<BorderRadiusGeometry?>? borderRadius, ValueGetter<BorderStyle?>? borderStyle, ValueGetter<double?>? borderWidth, ValueGetter<List<BoxShadow>?>? boxShadow, ValueGetter<EdgeInsetsGeometry?>? padding, ValueGetter<double?>? surfaceOpacity, ValueGetter<double?>? surfaceBlur});
  bool operator ==(Object other);
  int get hashCode;
}
/// A container widget with customizable border and surface effects.
///
/// Provides a styled container with border, background, shadows, padding,
/// and optional surface blur effects. Supports theming and animations.
///
/// Example:
/// ```dart
/// OutlinedContainer(
///   borderRadius: BorderRadius.circular(12),
///   borderColor: Colors.blue,
///   backgroundColor: Colors.white,
///   padding: EdgeInsets.all(16),
///   child: Text('Outlined content'),
/// )
/// ```
class OutlinedContainer extends StatefulWidget {
/// The child widget to display inside the container.
  Widget child;
/// Background color of the container.
///
/// If `null`, uses theme default.
  Color? backgroundColor;
/// Color of the container's border.
///
/// If `null`, uses theme default.
  Color? borderColor;
/// How to clip the container's content.
///
/// Defaults to [Clip.antiAlias].
  Clip clipBehavior;
/// Border radius for rounded corners.
///
/// If `null`, uses theme default.
  BorderRadiusGeometry? borderRadius;
/// Style of the border.
///
/// If `null`, uses [BorderStyle.solid].
  BorderStyle? borderStyle;
/// Width of the border in logical pixels.
///
/// If `null`, uses theme default.
  double? borderWidth;
/// Box shadows for elevation effects.
///
/// If `null`, no shadows are applied.
  List<BoxShadow>? boxShadow;
/// Padding inside the container.
///
/// If `null`, uses theme default.
  EdgeInsetsGeometry? padding;
/// Opacity for surface overlay effects.
///
/// If provided, modulates the background color's alpha.
  double? surfaceOpacity;
/// Blur amount for surface backdrop effects.
///
/// If `null` or `<= 0`, no blur is applied.
  double? surfaceBlur;
/// Explicit width of the container.
///
/// If `null`, size is determined by child and padding.
  double? width;
/// Explicit height of the container.
///
/// If `null`, size is determined by child and padding.
  double? height;
/// Duration for animating property changes.
///
/// If `null`, changes are applied immediately without animation.
  Duration? duration;
/// Creates an [OutlinedContainer].
  const OutlinedContainer({super.key, required this.child, this.borderColor, this.backgroundColor, this.clipBehavior = Clip.antiAlias, this.borderRadius, this.borderStyle, this.borderWidth, this.boxShadow, this.padding, this.surfaceOpacity, this.surfaceBlur, this.width, this.height, this.duration});
  State<OutlinedContainer> createState();
}
/// Properties for defining a dashed line appearance.
///
/// Encapsulates the visual properties of a dashed line including dash width,
/// gap between dashes, thickness, and color. Supports interpolation for animations.
class DashedLineProperties {
/// Width of each dash segment.
  double width;
/// Gap between consecutive dash segments.
  double gap;
/// Thickness (height) of the line.
  double thickness;
/// Color of the dashed line.
  Color color;
/// Creates [DashedLineProperties].
  const DashedLineProperties({required this.width, required this.gap, required this.thickness, required this.color});
/// Linearly interpolates between two [DashedLineProperties].
  static DashedLineProperties lerp(DashedLineProperties a, DashedLineProperties b, double t);
}
/// A widget that displays a horizontal dashed line.
///
/// Renders a customizable dashed line with configurable dash width, gap,
/// thickness, and color. Animates changes to properties smoothly.
///
/// Example:
/// ```dart
/// DashedLine(
///   width: 10,
///   gap: 5,
///   thickness: 2,
///   color: Colors.grey,
/// )
/// ```
class DashedLine extends StatelessWidget {
/// Width of each dash segment.
///
/// If `null`, uses scaled default (8).
  double? width;
/// Gap between consecutive dash segments.
///
/// If `null`, uses scaled default (5).
  double? gap;
/// Thickness (height) of the line.
///
/// If `null`, uses scaled default (1).
  double? thickness;
/// Color of the dashed line.
///
/// If `null`, uses theme border color.
  Color? color;
/// Creates a [DashedLine].
  const DashedLine({super.key, this.width, this.gap, this.thickness, this.color});
  Widget build(BuildContext context);
}
/// Properties for defining a dashed container border appearance.
///
/// Encapsulates the visual properties of a dashed container border including
/// dash width, gap, thickness, color, and border radius. Supports interpolation.
class DashedContainerProperties {
/// Width of each dash segment.
  double width;
/// Gap between consecutive dash segments.
  double gap;
/// Thickness of the border.
  double thickness;
/// Color of the dashed border.
  Color color;
/// Border radius for rounded corners.
  BorderRadiusGeometry borderRadius;
/// Creates [DashedContainerProperties].
  const DashedContainerProperties({required this.width, required this.gap, required this.thickness, required this.color, required this.borderRadius});
/// Linearly interpolates between two [DashedContainerProperties].
  static DashedContainerProperties lerp(BuildContext context, DashedContainerProperties a, DashedContainerProperties b, double t);
}
/// A container with a dashed border outline.
///
/// Renders a container with a customizable dashed border that can have rounded
/// corners. Animates border property changes smoothly.
///
/// Example:
/// ```dart
/// DashedContainer(
///   strokeWidth: 10,
///   gap: 5,
///   thickness: 2,
///   borderRadius: BorderRadius.circular(8),
///   child: Padding(
///     padding: EdgeInsets.all(16),
///     child: Text('Dashed border'),
///   ),
/// )
/// ```
class DashedContainer extends StatelessWidget {
/// Width of each dash segment.
///
/// If `null`, uses scaled default (8).
  double? strokeWidth;
/// Gap between consecutive dash segments.
///
/// If `null`, uses scaled default (5).
  double? gap;
/// Thickness of the border.
///
/// If `null`, uses scaled default (1).
  double? thickness;
/// Color of the dashed border.
///
/// If `null`, uses theme border color.
  Color? color;
/// The child widget inside the container.
  Widget child;
/// Border radius for rounded corners.
///
/// If `null`, uses theme default border radius.
  BorderRadiusGeometry? borderRadius;
/// Creates a [DashedContainer].
  const DashedContainer({super.key, this.strokeWidth, this.gap, this.thickness, this.color, required this.child, this.borderRadius});
  Widget build(BuildContext context);
}
/// A custom painter that draws a dashed horizontal line.
///
/// Paints a line with alternating dashes and gaps.
class DashedLinePainter extends CustomPainter {
/// Width of each dash segment.
  double width;
/// Gap between dash segments.
  double gap;
/// Thickness of the line.
  double thickness;
/// Color of the dashed line.
  Color color;
/// Creates a [DashedLinePainter].
///
/// Parameters:
/// - [width] (`double`, required): Dash segment width.
/// - [gap] (`double`, required): Gap between dashes.
/// - [thickness] (`double`, required): Line thickness.
/// - [color] (`Color`, required): Line color.
  DashedLinePainter({required this.width, required this.gap, required this.thickness, required this.color});
  void paint(Canvas canvas, Size size);
  bool shouldRepaint(covariant DashedLinePainter oldDelegate);
}
/// A custom painter that draws a dashed border around a rectangle.
///
/// Paints a dashed border with optional rounded corners.
class DashedPainter extends CustomPainter {
/// Width of each dash segment.
  double width;
/// Gap between dash segments.
  double gap;
/// Thickness of the border.
  double thickness;
/// Color of the dashed border.
  Color color;
/// Border radius for rounded corners.
  BorderRadius? borderRadius;
/// Creates a [DashedPainter].
///
/// Parameters:
/// - [width] (`double`, required): Dash segment width.
/// - [gap] (`double`, required): Gap between dashes.
/// - [thickness] (`double`, required): Border thickness.
/// - [color] (`Color`, required): Border color.
/// - [borderRadius] (`BorderRadius?`, optional): Corner radius.
  DashedPainter({required this.width, required this.gap, required this.thickness, required this.color, this.borderRadius});
  void paint(Canvas canvas, Size size);
  bool shouldRepaint(covariant DashedPainter oldDelegate);
}
/// Theme configuration for [OverflowMarquee] scrolling text displays.
///
/// Provides comprehensive styling and behavior options for marquee animations
/// including scroll direction, timing, fade effects, and animation curves.
/// All properties are optional and will fall back to default values when not specified.
///
/// Animation Properties:
/// - [direction]: Horizontal or vertical scrolling axis
/// - [duration]: Complete cycle time for one full scroll
/// - [delayDuration]: Pause time before restarting animation
/// - [curve]: Easing function for smooth animation transitions
///
/// Visual Properties:
/// - [step]: Pixel step size for scroll speed calculation
/// - [fadePortion]: Edge fade effect intensity (0.0 to 1.0)
///
/// Example:
/// ```dart
/// OverflowMarqueeTheme(
///   direction: Axis.horizontal,
///   duration: Duration(seconds: 5),
///   delayDuration: Duration(seconds: 1),
///   fadePortion: 0.1,
///   curve: Curves.easeInOut,
/// )
/// ```
class OverflowMarqueeTheme extends ComponentThemeData {
/// Scrolling direction of the marquee.
  Axis? direction;
/// Duration of one full scroll cycle.
  Duration? duration;
/// Delay before scrolling starts again.
  Duration? delayDuration;
/// Step size used to compute scroll speed.
  double? step;
/// Portion of the child to fade at the edges.
  double? fadePortion;
/// Animation curve of the scroll.
  Curve? curve;
/// Creates an [OverflowMarqueeTheme].
  const OverflowMarqueeTheme({this.direction, this.duration, this.delayDuration, this.step, this.fadePortion, this.curve});
/// Creates a copy of this theme with the given fields replaced.
  OverflowMarqueeTheme copyWith({ValueGetter<Axis?>? direction, ValueGetter<Duration?>? duration, ValueGetter<Duration?>? delayDuration, ValueGetter<double?>? step, ValueGetter<double?>? fadePortion, ValueGetter<Curve?>? curve});
  bool operator ==(Object other);
  int get hashCode;
}
/// Automatically scrolling widget for content that overflows its container.
///
/// Creates smooth, continuous scrolling animation for content that exceeds the
/// available space. Commonly used for long text labels, news tickers, or any
/// content that needs horizontal or vertical scrolling to be fully visible.
///
/// Key Features:
/// - **Auto-scroll Detection**: Only animates when content actually overflows
/// - **Bi-directional Support**: Horizontal and vertical scrolling modes
/// - **Edge Fading**: Smooth fade effects at container boundaries
/// - **Customizable Timing**: Configurable duration, delay, and animation curves
/// - **Performance Optimized**: Uses Flutter's Ticker system for smooth 60fps animation
/// - **Theme Integration**: Respects OverflowMarqueeTheme configuration
///
/// Animation Behavior:
/// 1. Measures content size vs. container size
/// 2. If content fits, displays normally without animation
/// 3. If content overflows, starts continuous scrolling animation
/// 4. Scrolls content from start to end position
/// 5. Pauses briefly (delayDuration) before restarting
/// 6. Applies edge fade effects for smooth visual transitions
///
/// The widget automatically handles text direction (RTL/LTR) and adapts
/// scroll behavior accordingly for proper internationalization support.
///
/// Example:
/// ```dart
/// OverflowMarquee(
///   direction: Axis.horizontal,
///   duration: Duration(seconds: 8),
///   delayDuration: Duration(seconds: 2),
///   fadePortion: 0.15,
///   child: Text(
///     'This is a very long text that will scroll horizontally when it overflows the container',
///     style: TextStyle(fontSize: 16),
///   ),
/// )
/// ```
class OverflowMarquee extends StatefulWidget {
/// The child widget to display and potentially scroll.
  Widget child;
/// Scroll direction (horizontal or vertical).
///
/// If `null`, uses theme default or [Axis.horizontal].
  Axis? direction;
/// Total duration for one complete scroll cycle.
///
/// If `null`, uses theme default.
  Duration? duration;
/// Distance to scroll per animation step.
///
/// If `null`, scrolls the entire overflow amount.
  double? step;
/// Pause duration between scroll cycles.
///
/// If `null`, uses theme default.
  Duration? delayDuration;
/// Portion of edges to apply fade effect (0.0 to 1.0).
///
/// For example, 0.15 fades 15% of each edge. If `null`, uses theme default.
  double? fadePortion;
/// Animation curve for scroll motion.
///
/// If `null`, uses theme default or [Curves.linear].
  Curve? curve;
/// Creates an [OverflowMarquee] widget with customizable scrolling behavior.
///
/// Parameters:
/// - [child] (Widget, required): Content to display and potentially scroll
/// - [direction] (Axis?, optional): Scroll direction, defaults to horizontal
/// - [duration] (Duration?, optional): Time for one complete scroll cycle
/// - [delayDuration] (Duration?, optional): Pause time before restarting animation
/// - [step] (double?, optional): Step size for scroll speed calculation
/// - [fadePortion] (double?, optional): Fade effect intensity at edges (0.0-1.0)
/// - [curve] (Curve?, optional): Animation easing curve
///
/// All optional parameters will use theme defaults or built-in fallback values
/// when not explicitly provided.
///
/// Example:
/// ```dart
/// OverflowMarquee(
///   duration: Duration(seconds: 10),
///   delayDuration: Duration(seconds: 1),
///   fadePortion: 0.2,
///   child: Text('Long scrolling text content'),
/// )
/// ```
  const OverflowMarquee({super.key, required this.child, this.direction, this.duration, this.delayDuration, this.step, this.fadePortion, this.curve});
  State<OverflowMarquee> createState();
}
/// Theme configuration for focus outline appearance.
///
/// Defines styling properties for focus outlines that indicate which element
/// has keyboard focus. Used by [FocusOutline] to apply consistent focus
/// visualization across the application.
class FocusOutlineTheme extends ComponentThemeData {
/// The alignment offset of the outline relative to the widget bounds.
///
/// Positive values expand the outline outward, negative values contract it.
  double? align;
/// Border radius for rounded corners on the focus outline.
  BorderRadiusGeometry? borderRadius;
/// The border style for the focus outline.
  Border? border;
/// Creates a [FocusOutlineTheme].
///
/// Parameters:
/// - [align] (`double?`, optional): Outline alignment offset.
/// - [border] (`Border?`, optional): Outline border style.
/// - [borderRadius] (`BorderRadiusGeometry?`, optional): Corner rounding.
  const FocusOutlineTheme({this.align, this.border, this.borderRadius});
/// Creates a copy of this theme with the given fields replaced.
///
/// Parameters:
/// - [border] (`ValueGetter<Border?>?`, optional): New border.
/// - [align] (`ValueGetter<double?>?`, optional): New alignment offset.
/// - [borderRadius] (`ValueGetter<BorderRadiusGeometry?>?`, optional): New border radius.
///
/// Returns: A new [FocusOutlineTheme] with updated properties.
  FocusOutlineTheme copyWith({ValueGetter<Border?>? border, ValueGetter<double?>? align, ValueGetter<BorderRadiusGeometry?>? borderRadius});
  bool operator ==(Object other);
  int get hashCode;
}
/// A widget that displays a visual outline when focused.
///
/// Wraps a child widget with a customizable border that appears when the
/// [focused] property is true. Commonly used to indicate keyboard focus state
/// for interactive elements.
///
/// Example:
/// ```dart
/// FocusOutline(
///   focused: hasFocus,
///   borderRadius: BorderRadius.circular(8),
///   child: TextButton(
///     onPressed: () {},
///     child: Text('Focused Button'),
///   ),
/// )
/// ```
class FocusOutline extends StatelessWidget {
/// The child widget to wrap with the focus outline.
  Widget child;
/// Whether to display the focus outline.
///
/// When `true`, the outline is visible. When `false`, it's hidden.
  bool focused;
/// Border radius for the focus outline corners.
///
/// If `null`, uses the default from [FocusOutlineTheme].
  BorderRadiusGeometry? borderRadius;
/// Alignment offset for positioning the outline.
///
/// If `null`, uses the default from [FocusOutlineTheme].
  double? align;
/// The border style for the outline.
///
/// If `null`, uses the default from [FocusOutlineTheme].
  Border? border;
/// The shape of the outline.
///
/// Can be [BoxShape.rectangle] or [BoxShape.circle].
  BoxShape? shape;
/// Creates a [FocusOutline].
///
/// Parameters:
/// - [child] (`Widget`, required): Widget to wrap.
/// - [focused] (`bool`, required): Whether to show the outline.
/// - [borderRadius] (`BorderRadiusGeometry?`, optional): Corner rounding.
/// - [align] (`double?`, optional): Outline offset.
/// - [border] (`Border?`, optional): Border style.
/// - [shape] (`BoxShape?`, optional): Outline shape.
  const FocusOutline({super.key, required this.child, required this.focused, this.borderRadius, this.align, this.border, this.shape});
  Widget build(BuildContext context);
}
/// Theme configuration for [CardImage] components.
///
/// Defines visual properties like scale animations, background colors,
/// border styling, and layout direction. Applied through the widget tree
/// using [ComponentTheme] to provide consistent theming across card images.
///
/// Example:
/// ```dart
/// ComponentTheme(
///   data: CardImageTheme(
///     hoverScale: 1.1,
///     backgroundColor: Colors.grey.shade100,
///     direction: Axis.horizontal,
///   ),
///   child: MyApp(),
/// );
/// ```
class CardImageTheme extends ComponentThemeData {
/// Button style for the card.
  AbstractButtonStyle? style;
/// Layout direction for title/subtitle relative to the image.
  Axis? direction;
/// Scale factor when hovering over the image.
  double? hoverScale;
/// Normal scale factor for the image.
  double? normalScale;
/// Background color for the image container.
  Color? backgroundColor;
/// Border color for the image container.
  Color? borderColor;
/// Gap between image and text content.
  double? gap;
/// Creates a [CardImageTheme].
///
/// All parameters are optional and provide default styling for [CardImage]
/// widgets in the component tree.
///
/// Parameters:
/// - [style] (AbstractButtonStyle?): button style configuration
/// - [direction] (Axis?): layout direction (vertical/horizontal)
/// - [hoverScale] (double?): image scale on hover (default: 1.05)
/// - [normalScale] (double?): normal image scale (default: 1.0)
/// - [backgroundColor] (Color?): image background color
/// - [borderColor] (Color?): image border color
/// - [gap] (double?): spacing between image and content
///
/// Example:
/// ```dart
/// CardImageTheme(
///   hoverScale: 1.1,
///   direction: Axis.horizontal,
///   backgroundColor: Colors.grey.shade50,
/// );
/// ```
  const CardImageTheme({this.style, this.direction, this.hoverScale, this.normalScale, this.backgroundColor, this.borderColor, this.gap});
/// Creates a copy of this theme with optionally overridden properties.
///
/// Uses [ValueGetter] functions to allow nullable overrides.
///
/// Example:
/// ```dart
/// final newTheme = existingTheme.copyWith(
///   hoverScale: () => 1.2,
///   backgroundColor: () => Colors.blue.shade50,
/// );
/// ```
  CardImageTheme copyWith({ValueGetter<AbstractButtonStyle?>? style, ValueGetter<Axis?>? direction, ValueGetter<double?>? hoverScale, ValueGetter<double?>? normalScale, ValueGetter<Color?>? backgroundColor, ValueGetter<Color?>? borderColor, ValueGetter<double?>? gap});
  bool operator ==(Object other);
  int get hashCode;
}
/// Interactive card component with an image and optional text content.
///
/// Combines an image with title, subtitle, and optional leading/trailing
/// widgets in a clickable card layout. Features hover animations with
/// configurable scale effects and supports both vertical and horizontal
/// orientations.
///
/// The widget wraps the content in a [Button] for interaction handling
/// and uses [OutlinedContainer] for the image styling. Layout direction
/// can be configured to show content below (vertical) or beside
/// (horizontal) the image.
///
/// Example:
/// ```dart
/// CardImage(
///   image: Image.network('https://example.com/image.jpg'),
///   title: Text('Card Title'),
///   subtitle: Text('Subtitle text'),
///   onPressed: () => print('Card tapped'),
/// );
/// ```
class CardImage extends StatefulWidget {
/// The primary image widget to display.
  Widget image;
/// Optional title widget displayed with the image.
  Widget? title;
/// Optional subtitle widget displayed below the title.
  Widget? subtitle;
/// Optional trailing widget (e.g., action buttons).
  Widget? trailing;
/// Optional leading widget (e.g., icon).
  Widget? leading;
/// Callback invoked when the card is pressed.
  VoidCallback? onPressed;
/// Whether the card is enabled for interaction.
  bool? enabled;
/// Custom button style for the card.
  AbstractButtonStyle? style;
/// Layout direction for content relative to image.
  Axis? direction;
/// Scale factor applied to image on hover.
  double? hoverScale;
/// Normal scale factor for the image.
  double? normalScale;
/// Background color for the image container.
  Color? backgroundColor;
/// Border color for the image container.
  Color? borderColor;
/// Gap between image and text content.
  double? gap;
/// Creates a [CardImage].
///
/// The [image] parameter is required and should contain the primary
/// visual content. All other parameters are optional and provide
/// customization for layout, interaction, and styling.
///
/// Parameters:
/// - [image] (Widget, required): primary image content
/// - [title] (Widget?): optional title text or widget
/// - [subtitle] (Widget?): optional subtitle below title
/// - [trailing] (Widget?): optional widget on the end side
/// - [leading] (Widget?): optional widget on the start side
/// - [onPressed] (VoidCallback?): tap callback, enables interaction
/// - [enabled] (bool?): whether card responds to interaction
/// - [style] (AbstractButtonStyle?): custom button styling
/// - [direction] (Axis?): vertical or horizontal layout
/// - [hoverScale] (double?): image scale on hover (default: 1.05)
/// - [normalScale] (double?): normal image scale (default: 1.0)
/// - [backgroundColor] (Color?): image background color
/// - [borderColor] (Color?): image border color
/// - [gap] (double?): spacing between image and content
///
/// Example:
/// ```dart
/// CardImage(
///   image: Image.asset('assets/photo.jpg'),
///   title: Text('Beautiful Landscape'),
///   subtitle: Text('Captured in the mountains'),
///   direction: Axis.horizontal,
///   hoverScale: 1.1,
///   onPressed: () => showDetails(),
/// );
/// ```
  const CardImage({super.key, required this.image, this.title, this.subtitle, this.trailing, this.leading, this.onPressed, this.enabled, this.style, this.direction, this.hoverScale, this.normalScale, this.backgroundColor, this.borderColor, this.gap});
  State<CardImage> createState();
}
/// Theme configuration for [TreeView] appearance and behavior.
///
/// TreeTheme defines the visual styling and behavioral options for tree view
/// components including branch lines, padding, expand icons, and selection modes.
/// All properties are optional and fall back to theme defaults when not specified.
///
/// Example:
/// ```dart
/// ComponentTheme<TreeTheme>(
///   data: TreeTheme(
///     branchLine: BranchLine.path,
///     padding: EdgeInsets.all(12),
///     expandIcon: true,
///     allowMultiSelect: true,
///     recursiveSelection: true,
///   ),
///   child: TreeView(...),
/// )
/// ```
class TreeTheme extends ComponentThemeData {
/// The branch line style for connecting tree nodes.
///
/// Type: `BranchLine?`. If null, uses BranchLine.path. Controls how visual
/// connections are drawn between parent and child nodes in the tree hierarchy.
  BranchLine? branchLine;
/// Padding around the entire tree view content.
///
/// Type: `EdgeInsetsGeometry?`. If null, uses 8 pixels on all sides.
/// This padding is applied to the scroll view containing all tree items.
  EdgeInsetsGeometry? padding;
/// Whether to show expand/collapse icons for nodes with children.
///
/// Type: `bool?`. If null, defaults to true. When false, nodes cannot be
/// visually expanded or collapsed, though the data structure remains hierarchical.
  bool? expandIcon;
/// Whether multiple nodes can be selected simultaneously.
///
/// Type: `bool?`. If null, defaults to true. When false, selecting a node
/// automatically deselects all other nodes, enforcing single selection mode.
  bool? allowMultiSelect;
/// Whether selecting a parent node also selects its children.
///
/// Type: `bool?`. If null, defaults to true. When true, selection operations
/// recursively affect all descendant nodes.
  bool? recursiveSelection;
/// Creates a theme for tree view components.
///
/// This constructor allows customization of tree visualization and behavior
/// including branch lines, spacing, icons, and selection modes.
///
/// Parameters:
/// - [branchLine] (BranchLine?): Visual style for lines connecting tree nodes
/// - [padding] (EdgeInsetsGeometry?): Padding around tree items
/// - [expandIcon] (bool?): Whether to show expand/collapse icons
/// - [allowMultiSelect] (bool?): Whether multiple nodes can be selected simultaneously
/// - [recursiveSelection] (bool?): Whether selecting parent selects all children
///
/// Example:
/// ```dart
/// TreeTheme(
///   branchLine: BranchLine.solid,
///   padding: EdgeInsets.all(8),
///   allowMultiSelect: true,
/// )
/// ```
  const TreeTheme({this.branchLine, this.padding, this.expandIcon, this.allowMultiSelect, this.recursiveSelection});
/// Creates a copy of this theme with the given fields replaced.
///
/// Parameters:
/// - [branchLine] (`ValueGetter<BranchLine?>?`, optional): New branch line style.
/// - [padding] (`ValueGetter<EdgeInsetsGeometry?>?`, optional): New padding.
/// - [expandIcon] (`ValueGetter<bool?>?`, optional): New expand icon visibility.
/// - [allowMultiSelect] (`ValueGetter<bool?>?`, optional): New multi-select setting.
/// - [recursiveSelection] (`ValueGetter<bool?>?`, optional): New recursive selection setting.
///
/// Returns: A new [TreeTheme] with updated properties.
  TreeTheme copyWith({ValueGetter<BranchLine?>? branchLine, ValueGetter<EdgeInsetsGeometry?>? padding, ValueGetter<bool?>? expandIcon, ValueGetter<bool?>? allowMultiSelect, ValueGetter<bool?>? recursiveSelection});
  bool operator ==(Object other);
  int get hashCode;
  String toString();
}
/// Abstract base class representing a node in a tree structure.
///
/// TreeNode defines the interface for all nodes in the tree hierarchy, providing
/// access to children, expansion state, and selection state. It supports immutable
/// updates through copy methods that return new instances with modified state.
///
/// The generic type parameter [T] represents the data type stored in tree items.
/// TreeNode is implemented by [TreeItem] for data-bearing nodes and [TreeRoot]
/// for the invisible root container.
///
/// Key operations include state updates for expansion and selection, child
/// manipulation, and leaf node detection. All state changes return new instances
/// to maintain immutability.
///
/// Example:
/// ```dart
/// TreeNode<String> node = TreeItem(
///   data: 'parent',
///   children: [TreeItem(data: 'child1'), TreeItem(data: 'child2')],
/// );
///
/// // Expand the node
/// TreeNode<String> expanded = node.updateState(expanded: true);
///
/// // Check if it's a leaf
/// bool isLeaf = node.leaf; // false, has children
/// ```
abstract class TreeNode<T> {
/// List of child nodes belonging to this node.
///
/// Returns: `List<TreeNode<T>>`. An empty list indicates a leaf node with no children.
/// The list defines the hierarchical structure beneath this node.
  List<TreeNode<T>> get children;
/// Whether this node is currently expanded to show its children.
///
/// Returns: `bool`. True when the node is expanded and children are visible,
/// false when collapsed. Root nodes are always considered expanded.
  bool get expanded;
/// Whether this node is currently selected.
///
/// Returns: `bool`. True when the node is part of the current selection,
/// false otherwise. Selection affects visual appearance and behavior.
  bool get selected;
/// Whether this node is a leaf (has no children).
///
/// Returns: `bool`. True when [children] is empty, false when the node has child nodes.
/// Convenient property for determining if a node can be expanded.
  bool get leaf;
/// Creates a new instance with updated expansion and/or selection state.
///
/// Returns a new TreeNode instance with the specified state changes while
/// preserving all other properties. This maintains immutability of tree structures.
///
/// Parameters:
/// - [expanded] (bool?, optional): New expansion state, or null to keep current
/// - [selected] (bool?, optional): New selection state, or null to keep current
///
/// Returns: A new `TreeNode<T>` instance with updated state
///
/// Example:
/// ```dart
/// TreeNode<String> expandedNode = node.updateState(expanded: true);
/// TreeNode<String> selectedNode = node.updateState(selected: true);
/// TreeNode<String> both = node.updateState(expanded: true, selected: true);
/// ```
  TreeNode<T> updateState({bool? expanded, bool? selected});
/// Creates a new instance with updated children list.
///
/// Returns a new TreeNode instance with the specified children while preserving
/// all other properties including state. Used for structural modifications.
///
/// Parameters:
/// - [children] (`List<TreeNode<T>>`): New list of child nodes
///
/// Returns: A new `TreeNode<T>` instance with updated children
///
/// Example:
/// ```dart
/// List<TreeNode<String>> newChildren = [TreeItem(data: 'new_child')];
/// TreeNode<String> updated = node.updateChildren(newChildren);
/// ```
  TreeNode<T> updateChildren(List<TreeNode<T>> children);
}
/// A concrete tree node implementation that holds data and state.
///
/// TreeItem represents a data-bearing node in the tree structure with support
/// for hierarchical organization, expansion/collapse state, and selection state.
/// It implements the immutable pattern where state changes return new instances.
///
/// Each TreeItem contains user data of type [T], a list of child nodes, and
/// boolean flags for expansion and selection state. The class provides equality
/// comparison based on all properties and implements proper hash codes.
///
/// TreeItem supports deep hierarchies through its children list, which can
/// contain other TreeItem instances or TreeRoot containers. The expansion state
/// controls visibility of children in tree views.
///
/// Example:
/// ```dart
/// // Create a simple item
/// TreeItem<String> item = TreeItem(
///   data: 'Document',
///   expanded: true,
///   selected: false,
///   children: [
///     TreeItem(data: 'Chapter 1'),
///     TreeItem(data: 'Chapter 2'),
///   ],
/// );
///
/// // Update its state
/// TreeItem<String> selected = item.updateState(selected: true);
/// ```
class TreeItem<T> extends TreeNode<T> {
/// The data value stored in this tree item.
///
/// Type: `T`. This is the actual content that the tree item represents,
/// such as a string, object, or any other data type.
  T data;
/// List of child nodes beneath this item in the tree hierarchy.
///
/// Type: `List<TreeNode<T>>`. Empty list indicates a leaf node. Children
/// are only visible when this item's [expanded] state is true.
  List<TreeNode<T>> children;
/// Whether this item is currently expanded to show its children.
///
/// Type: `bool`. When true, child nodes are visible in tree views.
/// When false, children are hidden but still present in the data structure.
  bool expanded;
/// Whether this item is currently selected.
///
/// Type: `bool`. Selection affects visual appearance and can trigger
/// recursive selection of children depending on tree configuration.
  bool selected;
/// Creates a [TreeItem] with the specified data and configuration.
///
/// Constructs a tree item node with user data and optional children,
/// expansion state, and selection state.
///
/// Parameters:
/// - [data] (T, required): The data value to store in this tree item
/// - [children] (`List<TreeNode<T>>`, default: []): Child nodes list
/// - [expanded] (bool, default: false): Initial expansion state
/// - [selected] (bool, default: false): Initial selection state
///
/// Example:
/// ```dart
/// // Simple leaf item
/// TreeItem<String> leaf = TreeItem(data: 'Leaf Node');
///
/// // Parent with children
/// TreeItem<String> parent = TreeItem(
///   data: 'Parent Node',
///   expanded: true,
///   children: [
///     TreeItem(data: 'Child 1'),
///     TreeItem(data: 'Child 2'),
///   ],
/// );
/// ```
  TreeItem({required this.data, this.children = const [], this.expanded = false, this.selected = false});
  TreeItem<T> updateState({bool? expanded, bool? selected});
  TreeItem<T> updateChildren(List<TreeNode<T>> children);
  bool operator ==(Object other);
  int get hashCode;
  String toString();
}
/// A special tree node that serves as an invisible root container.
///
/// TreeRoot represents the invisible root of a tree structure that contains
/// other tree nodes but doesn't appear in the visual tree. It's always considered
/// expanded and never selected, serving purely as a container for organizing
/// multiple top-level tree items.
///
/// This is useful when you need to group multiple tree items under a common
/// parent without showing that parent in the tree view. All children of a
/// TreeRoot appear at the top level of the tree.
///
/// TreeRoot maintains immutability like other tree nodes, but state update
/// operations (expanded/selected) have no effect since these properties are
/// fixed by design.
///
/// Example:
/// ```dart
/// TreeRoot<String> root = TreeRoot(
///   children: [
///     TreeItem(data: 'First Section'),
///     TreeItem(data: 'Second Section'),
///     TreeItem(data: 'Third Section'),
///   ],
/// );
///
/// // Root is always expanded and never selected
/// print(root.expanded); // true
/// print(root.selected); // false
/// ```
class TreeRoot<T> extends TreeNode<T> {
/// List of child nodes contained in this root.
///
/// Type: `List<TreeNode<T>>`. These children appear as top-level items
/// in the tree view since the root itself is invisible.
  List<TreeNode<T>> children;
/// Always returns true since root containers are conceptually always expanded.
///
/// Returns: `bool`. TreeRoot is always expanded to show its children.
  bool get expanded;
/// Always returns false since root containers cannot be selected.
///
/// Returns: `bool`. TreeRoot can never be selected in tree operations.
  bool get selected;
/// Creates a [TreeRoot] container with the specified children.
///
/// Constructs an invisible root node that serves as a container for
/// multiple top-level tree items.
///
/// Parameters:
/// - [children] (`List<TreeNode<T>>`, required): Child nodes to contain
///
/// Example:
/// ```dart
/// TreeRoot<String> root = TreeRoot(
///   children: [
///     TreeItem(data: 'Item 1'),
///     TreeItem(data: 'Item 2'),
///     TreeItem(data: 'Item 3'),
///   ],
/// );
/// ```
  TreeRoot({required this.children});
  TreeRoot<T> updateState({bool? expanded, bool? selected});
  TreeRoot<T> updateChildren(List<TreeNode<T>> children);
  bool operator ==(Object other);
  int get hashCode;
  String toString();
}
/// Represents the visual position of a selected item within a group.
///
/// Used to determine border radius styling for selected tree items
/// when multiple consecutive items are selected.
enum SelectionPosition { start, middle, end, single }
/// Reason for a focus change event in tree navigation.
///
/// Used to differentiate between programmatic focus changes and
/// user-initiated focus changes.
enum FocusChangeReason { focusScope, userInteraction }
/// Data container for rendering a tree node.
///
/// Holds all information needed to display a single tree node including
/// its position, expansion state, and visual styling.
class TreeNodeData<T> {
/// The tree node being rendered.
  TreeNode<T> node;
/// The branch line style for this node.
  BranchLine indentGuide;
/// Whether this node is currently expanded.
  bool expanded;
/// List of depth information from root to this node.
  List<TreeNodeDepth> depth;
/// Whether to show the expand/collapse icon.
  bool expandIcon;
/// Callback when focus changes for this node.
  void Function(FocusChangeReason reason)? onFocusChanged;
/// Visual position of this node within a selection group.
  SelectionPosition? selectionPosition;
/// Creates a [TreeNodeData] with the specified properties.
  TreeNodeData(this.depth, this.node, this.indentGuide, this.expanded, this.expandIcon, this.onFocusChanged);
}
/// Represents depth information for a tree node.
///
/// Contains index and count information used for rendering
/// indent guides and branch lines.
class TreeNodeDepth {
/// Index of this child among its siblings (0-based).
  int childIndex;
/// Total number of children at this level.
  int childCount;
/// Creates a [TreeNodeDepth] with the specified index and count.
  TreeNodeDepth(this.childIndex, this.childCount);
}
/// Extension methods for manipulating lists of tree nodes.
///
/// Provides convenience methods for common tree operations like expansion,
/// collapse, selection, and node replacement. All methods return a new list
/// and do not modify the original.
extension TreeNodeListExtension<K> on List<TreeNode<K>> {
/// Applies an operator to all nodes in the tree.
///
/// Parameters:
/// - [operator] (`TreeNodeUnaryOperator<K>`, required): Transform function.
///
/// Returns: `List<TreeNode<K>>` ‚Äî new tree with transformed nodes.
  List<TreeNode<K>> replaceNodes(TreeNodeUnaryOperator<K> operator);
/// Replaces a specific node in the tree.
///
/// Parameters:
/// - [oldNode] (`TreeNode<K>`, required): Node to replace.
/// - [newNode] (`TreeNode<K>`, required): Replacement node.
///
/// Returns: `List<TreeNode<K>>` ‚Äî new tree with node replaced.
  List<TreeNode<K>> replaceNode(TreeNode<K> oldNode, TreeNode<K> newNode);
/// Replaces a node by its item value.
///
/// Parameters:
/// - [oldItem] (`K`, required): Item value to find.
/// - [newItem] (`TreeNode<K>`, required): Replacement node.
///
/// Returns: `List<TreeNode<K>>` ‚Äî new tree with item replaced.
  List<TreeNode<K>> replaceItem(K oldItem, TreeNode<K> newItem);
/// Expands all nodes in the tree.
///
/// Returns: `List<TreeNode<K>>` ‚Äî new tree with all nodes expanded.
  List<TreeNode<K>> expandAll();
/// Collapses all nodes in the tree.
///
/// Returns: `List<TreeNode<K>>` ‚Äî new tree with all nodes collapsed.
  List<TreeNode<K>> collapseAll();
/// Expands a specific node.
///
/// Parameters:
/// - [target] (`TreeNode<K>`, required): Node to expand.
///
/// Returns: `List<TreeNode<K>>` ‚Äî new tree with node expanded.
  List<TreeNode<K>> expandNode(TreeNode<K> target);
/// Expands a node by its item value.
///
/// Parameters:
/// - [target] (`K`, required): Item value to find and expand.
///
/// Returns: `List<TreeNode<K>>` ‚Äî new tree with item expanded.
  List<TreeNode<K>> expandItem(K target);
/// Collapses a specific node.
///
/// Parameters:
/// - [target] (`TreeNode<K>`, required): Node to collapse.
///
/// Returns: `List<TreeNode<K>>` ‚Äî new tree with node collapsed.
  List<TreeNode<K>> collapseNode(TreeNode<K> target);
/// Collapses a node by its item value.
///
/// Parameters:
/// - [target] (`K`, required): Item value to find and collapse.
///
/// Returns: `List<TreeNode<K>>` ‚Äî new tree with item collapsed.
  List<TreeNode<K>> collapseItem(K target);
/// Gets all selected nodes in the tree.
///
/// Returns: `List<TreeNode<K>>` ‚Äî list of selected nodes.
  List<TreeNode<K>> get selectedNodes;
/// Gets all selected item values in the tree.
///
/// Returns: `List<K>` ‚Äî list of selected item values.
  List<K> get selectedItems;
/// Selects a specific node.
///
/// Parameters:
/// - [target] (`TreeNode<K>`, required): Node to select.
///
/// Returns: `List<TreeNode<K>>` ‚Äî new tree with node selected.
  List<TreeNode<K>> selectNode(TreeNode<K> target);
/// Selects a node by its item value.
///
/// Parameters:
/// - [target] (`K`, required): Item value to find and select.
///
/// Returns: `List<TreeNode<K>>` ‚Äî new tree with item selected.
  List<TreeNode<K>> selectItem(K target);
/// Deselects a specific node.
///
/// Parameters:
/// - [target] (`TreeNode<K>`, required): Node to deselect.
///
/// Returns: `List<TreeNode<K>>` ‚Äî new tree with node deselected.
  List<TreeNode<K>> deselectNode(TreeNode<K> target);
/// Deselects a node by its item value.
///
/// Parameters:
/// - [target] (`K`, required): Item value to find and deselect.
///
/// Returns: `List<TreeNode<K>>` ‚Äî new tree with item deselected.
  List<TreeNode<K>> deselectItem(K target);
/// Toggles selection state of a specific node.
///
/// Parameters:
/// - [target] (`TreeNode<K>`, required): Node to toggle.
///
/// Returns: `List<TreeNode<K>>` ‚Äî new tree with node selection toggled.
  List<TreeNode<K>> toggleSelectNode(TreeNode<K> target);
/// Toggles selection state of multiple nodes.
///
/// Parameters:
/// - [targets] (`Iterable<TreeNode<K>>`, required): Nodes to toggle.
///
/// Returns: `List<TreeNode<K>>` ‚Äî new tree with nodes toggled.
  List<TreeNode<K>> toggleSelectNodes(Iterable<TreeNode<K>> targets);
/// Toggles selection state of a node by its item value.
///
/// Parameters:
/// - [target] (`K`, required): Item value to toggle.
///
/// Returns: `List<TreeNode<K>>` ‚Äî new tree with item toggled.
  List<TreeNode<K>> toggleSelectItem(K target);
/// Toggles selection state of multiple items.
///
/// Parameters:
/// - [targets] (`Iterable<K>`, required): Item values to toggle.
///
/// Returns: `List<TreeNode<K>>` ‚Äî new tree with items toggled.
  List<TreeNode<K>> toggleSelectItems(Iterable<K> targets);
/// Selects all nodes in the tree.
///
/// Returns: `List<TreeNode<K>>` ‚Äî new tree with all nodes selected.
  List<TreeNode<K>> selectAll();
/// Deselects all nodes in the tree.
///
/// Returns: `List<TreeNode<K>>` ‚Äî new tree with all nodes deselected.
  List<TreeNode<K>> deselectAll();
/// Toggles selection state of all nodes in the tree.
///
/// Returns: `List<TreeNode<K>>` ‚Äî new tree with all selections toggled.
  List<TreeNode<K>> toggleSelectAll();
/// Selects specific nodes.
///
/// Parameters:
/// - [nodes] (`Iterable<TreeNode<K>>`, required): Nodes to select.
///
/// Returns: `List<TreeNode<K>>` ‚Äî new tree with nodes selected.
  List<TreeNode<K>> selectNodes(Iterable<TreeNode<K>> nodes);
/// Selects nodes by their item values.
///
/// Parameters:
/// - [items] (`Iterable<K>`, required): Item values to select.
///
/// Returns: `List<TreeNode<K>>` ‚Äî new tree with items selected.
  List<TreeNode<K>> selectItems(Iterable<K> items);
/// Deselects specific nodes.
///
/// Parameters:
/// - [nodes] (`Iterable<TreeNode<K>>`, required): Nodes to deselect.
///
/// Returns: `List<TreeNode<K>>` ‚Äî new tree with nodes deselected.
  List<TreeNode<K>> deselectNodes(Iterable<TreeNode<K>> nodes);
/// Deselects nodes by their item values.
///
/// Parameters:
/// - [items] (`Iterable<K>`, required): Item values to deselect.
///
/// Returns: `List<TreeNode<K>>` ‚Äî new tree with items deselected.
  List<TreeNode<K>> deselectItems(Iterable<K> items);
/// Sets the selected nodes, replacing current selection.
///
/// Parameters:
/// - [nodes] (`Iterable<TreeNode<K>>`, required): Nodes to select.
///
/// Returns: `List<TreeNode<K>>` ‚Äî new tree with only specified nodes selected.
  List<TreeNode<K>> setSelectedNodes(Iterable<TreeNode<K>> nodes);
/// Sets the selected items by value, replacing current selection.
///
/// Parameters:
/// - [items] (`Iterable<K>`, required): Item values to select.
///
/// Returns: `List<TreeNode<K>>` ‚Äî new tree with only specified items selected.
  List<TreeNode<K>> setSelectedItems(Iterable<K> items);
/// Applies an operator to all nodes with parent context.
///
/// Parameters:
/// - [operator] (`TreeNodeUnaryOperatorWithParent<K>`, required): Transform function with parent.
///
/// Returns: `List<TreeNode<K>>` ‚Äî new tree with transformed nodes.
  List<TreeNode<K>> replaceNodesWithParent(TreeNodeUnaryOperatorWithParent<K> operator);
/// Updates selection state based on recursive selection rules.
///
/// Ensures parent-child selection consistency when recursive selection is enabled.
///
/// Returns: `List<TreeNode<K>>` ‚Äî new tree with updated selection state.
  List<TreeNode<K>> updateRecursiveSelection();
}
/// Default handler for tree node selection changes.
///
/// Manages selection state updates by toggling, adding, or setting
/// selected nodes based on selection mode.
///
/// Example:
/// ```dart
/// final handler = TreeSelectionDefaultHandler(nodes, (updated) {
///   setState(() => nodes = updated);
/// });
/// ```
class TreeSelectionDefaultHandler<T> {
/// The current list of tree nodes.
  List<TreeNode<T>> nodes;
/// Callback when selection state changes.
  ValueChanged<List<TreeNode<T>>> onChanged;
/// Creates a [TreeSelectionDefaultHandler].
  TreeSelectionDefaultHandler(this.nodes, this.onChanged);
/// Handles a selection change event.
///
/// Parameters:
/// - [selectedNodes]: Nodes to select or deselect
/// - [multiSelect]: Whether multi-selection is enabled
/// - [selected]: Whether to select (true) or deselect (false)
  void call(List<TreeNode<T>> selectedNodes, bool multiSelect, bool selected);
}
/// Default handler for tree item expand/collapse operations.
///
/// Manages the expansion state of tree nodes when users interact
/// with expand/collapse controls.
///
/// Example:
/// ```dart
/// final handler = TreeItemExpandDefaultHandler(nodes, targetNode, (updated) {
///   setState(() => nodes = updated);
/// });
/// ```
class TreeItemExpandDefaultHandler<T> {
/// The current list of tree nodes.
  List<TreeNode<T>> nodes;
/// Callback when expansion state changes.
  ValueChanged<List<TreeNode<T>>> onChanged;
/// The target node to expand or collapse.
  TreeNode<T> target;
/// Creates a [TreeItemExpandDefaultHandler].
  TreeItemExpandDefaultHandler(this.nodes, this.target, this.onChanged);
/// Handles an expand/collapse event.
///
/// Parameters:
/// - [expanded]: Whether to expand (true) or collapse (false) the node
  void call(bool expanded);
}
/// A comprehensive tree view widget with hierarchical data display and interaction.
///
/// TreeView provides a scrollable tree interface that displays hierarchical data
/// with support for expansion/collapse, multi-selection, keyboard navigation,
/// and visual branch lines. It handles complex tree operations like recursive
/// selection, range selection, and immutable state updates.
///
/// The widget supports both mouse and keyboard interaction including:
/// - Click to select items and toggle expansion
/// - Ctrl+Click for multi-selection
/// - Shift+Click for range selection
/// - Arrow keys for navigation and selection
/// - Space bar for selection toggle
/// - Left/Right arrows for expand/collapse
///
/// Features:
/// - Hierarchical data display with customizable branch lines
/// - Single and multi-selection modes with recursive selection support
/// - Keyboard navigation and accessibility
/// - Scrollable content with shrink wrap support
/// - Customizable expand icons and visual styling
/// - Immutable state management with helper methods
/// - Focus management and scope integration
///
/// The tree uses immutable data structures where all modifications return new
/// instances. Helper methods and extensions provide convenient operations for
/// common tree manipulations like expanding, selecting, and filtering nodes.
///
/// Example:
/// ```dart
/// TreeView<String>(
///   nodes: [
///     TreeItem(
///       data: 'Documents',
///       expanded: true,
///       children: [
///         TreeItem(data: 'document1.txt'),
///         TreeItem(data: 'document2.txt'),
///       ],
///     ),
///     TreeItem(data: 'Images'),
///   ],
///   builder: (context, item) => Text(item.data),
///   onSelectionChanged: (selected, multiSelect, isSelected) {
///     // Handle selection changes
///   },
/// )
/// ```
class TreeView<T> extends StatefulWidget {
/// Creates a default selection changed handler for tree nodes.
///
/// Returns a handler that manages node selection state changes in a tree view.
/// The handler updates the tree structure when selection changes occur.
///
/// Parameters:
/// - [nodes] (`List<TreeNode<K>>`, required): Current tree node list
/// - [onChanged] (`ValueChanged<List<TreeNode<K>>>`, required): Callback when nodes change
///
/// Returns a `TreeNodeSelectionChanged<K>` function that handles selection changes.
  static TreeNodeSelectionChanged<K> defaultSelectionHandler<K>(List<TreeNode<K>> nodes, ValueChanged<List<TreeNode<K>>> onChanged);
/// Creates a default expand/collapse handler for tree items.
///
/// Returns a handler that manages the expanded/collapsed state of a specific
/// tree node. The handler updates the tree structure when expansion changes.
///
/// Parameters:
/// - [nodes] (`List<TreeNode<K>>`, required): Current tree node list
/// - [target] (`TreeNode<K>`, required): The node being expanded/collapsed
/// - [onChanged] (`ValueChanged<List<TreeNode<K>>>`, required): Callback when nodes change
///
/// Returns a `ValueChanged<bool>` function that handles expand/collapse events.
  static ValueChanged<bool> defaultItemExpandHandler<K>(List<TreeNode<K>> nodes, TreeNode<K> target, ValueChanged<List<TreeNode<K>>> onChanged);
/// Applies a transformation operator to all nodes in a tree.
///
/// Parameters:
/// - [nodes] (`List<TreeNode<K>>`, required): Tree nodes.
/// - [operator] (`TreeNodeUnaryOperator<K>`, required): Transformation function.
///
/// Returns: `List<TreeNode<K>>` ‚Äî transformed tree.
  static List<TreeNode<K>> replaceNodes<K>(List<TreeNode<K>> nodes, TreeNodeUnaryOperator<K> operator);
/// Applies a transformation operator to all nodes with parent context.
///
/// Parameters:
/// - [nodes] (`List<TreeNode<K>>`, required): Tree nodes.
/// - [operator] (`TreeNodeUnaryOperatorWithParent<K>`, required): Transformation function.
///
/// Returns: `List<TreeNode<K>>` ‚Äî transformed tree.
  static List<TreeNode<K>> replaceNodesWithParent<K>(List<TreeNode<K>> nodes, TreeNodeUnaryOperatorWithParent<K> operator);
/// Replaces a specific node in the tree.
///
/// Parameters:
/// - [nodes] (`List<TreeNode<K>>`, required): Tree nodes.
/// - [oldNode] (`TreeNode<K>`, required): Node to replace.
/// - [newNode] (`TreeNode<K>`, required): Replacement node.
///
/// Returns: `List<TreeNode<K>>` ‚Äî tree with node replaced.
  static List<TreeNode<K>> replaceNode<K>(List<TreeNode<K>> nodes, TreeNode<K> oldNode, TreeNode<K> newNode);
/// Replaces a node by matching its item value.
///
/// Parameters:
/// - [nodes] (`List<TreeNode<K>>`, required): Tree nodes.
/// - [oldItem] (`K`, required): Item value to find.
/// - [newItem] (`TreeNode<K>`, required): Replacement node.
///
/// Returns: `List<TreeNode<K>>` ‚Äî tree with item replaced.
  static List<TreeNode<K>> replaceItem<K>(List<TreeNode<K>> nodes, K oldItem, TreeNode<K> newItem);
/// Updates selection state to maintain parent-child consistency.
///
/// Parameters:
/// - [nodes] (`List<TreeNode<K>>`, required): Tree nodes.
///
/// Returns: `List<TreeNode<K>>` ‚Äî tree with updated selection.
  static List<TreeNode<K>> updateRecursiveSelection<K>(List<TreeNode<K>> nodes);
/// Gets all selected nodes from the tree.
///
/// Parameters:
/// - [nodes] (`List<TreeNode<K>>`, required): Tree nodes.
///
/// Returns: `List<TreeNode<K>>` ‚Äî selected nodes.
  static List<TreeNode<K>> getSelectedNodes<K>(List<TreeNode<K>> nodes);
/// Gets all selected item values from the tree.
///
/// Parameters:
/// - [nodes] (`List<TreeNode<K>>`, required): Tree nodes.
///
/// Returns: `List<K>` ‚Äî selected item values.
  static List<K> getSelectedItems<K>(List<TreeNode<K>> nodes);
/// Expands all nodes in the tree.
///
/// Parameters:
/// - [nodes] (`List<TreeNode<K>>`, required): Tree nodes.
///
/// Returns: `List<TreeNode<K>>` ‚Äî tree with all nodes expanded.
  static List<TreeNode<K>> expandAll<K>(List<TreeNode<K>> nodes);
/// Collapses all nodes in the tree.
///
/// Parameters:
/// - [nodes] (`List<TreeNode<K>>`, required): Tree nodes.
///
/// Returns: `List<TreeNode<K>>` ‚Äî tree with all nodes collapsed.
  static List<TreeNode<K>> collapseAll<K>(List<TreeNode<K>> nodes);
/// Expands a specific node.
///
/// Parameters:
/// - [nodes] (`List<TreeNode<K>>`, required): Tree nodes.
/// - [target] (`TreeNode<K>`, required): Node to expand.
///
/// Returns: `List<TreeNode<K>>` ‚Äî tree with node expanded.
  static List<TreeNode<K>> expandNode<K>(List<TreeNode<K>> nodes, TreeNode<K> target);
/// Expands a node by its item value.
///
/// Parameters:
/// - [nodes] (`List<TreeNode<K>>`, required): Tree nodes.
/// - [target] (`K`, required): Item value to expand.
///
/// Returns: `List<TreeNode<K>>` ‚Äî tree with item expanded.
  static List<TreeNode<K>> expandItem<K>(List<TreeNode<K>> nodes, K target);
/// Collapses a specific node.
///
/// Parameters:
/// - [nodes] (`List<TreeNode<K>>`, required): Tree nodes.
/// - [target] (`TreeNode<K>`, required): Node to collapse.
///
/// Returns: `List<TreeNode<K>>` ‚Äî tree with node collapsed.
  static List<TreeNode<K>> collapseNode<K>(List<TreeNode<K>> nodes, TreeNode<K> target);
/// Collapses a node by its item value.
///
/// Parameters:
/// - [nodes] (`List<TreeNode<K>>`, required): Tree nodes.
/// - [target] (`K`, required): Item value to collapse.
///
/// Returns: `List<TreeNode<K>>` ‚Äî tree with item collapsed.
  static List<TreeNode<K>> collapseItem<K>(List<TreeNode<K>> nodes, K target);
/// Selects a specific node.
///
/// Parameters:
/// - [nodes] (`List<TreeNode<K>>`, required): Tree nodes.
/// - [target] (`TreeNode<K>`, required): Node to select.
///
/// Returns: `List<TreeNode<K>>` ‚Äî tree with node selected.
  static List<TreeNode<K>> selectNode<K>(List<TreeNode<K>> nodes, TreeNode<K> target);
/// Selects a node by its item value.
///
/// Parameters:
/// - [nodes] (`List<TreeNode<K>>`, required): Tree nodes.
/// - [target] (`K`, required): Item value to select.
///
/// Returns: `List<TreeNode<K>>` ‚Äî tree with item selected.
  static List<TreeNode<K>> selectItem<K>(List<TreeNode<K>> nodes, K target);
/// Deselects a specific node.
///
/// Parameters:
/// - [nodes] (`List<TreeNode<K>>`, required): Tree nodes.
/// - [target] (`TreeNode<K>`, required): Node to deselect.
///
/// Returns: `List<TreeNode<K>>` ‚Äî tree with node deselected.
  static List<TreeNode<K>> deselectNode<K>(List<TreeNode<K>> nodes, TreeNode<K> target);
/// Deselects a node by its item value.
///
/// Parameters:
/// - [nodes] (`List<TreeNode<K>>`, required): Tree nodes.
/// - [target] (`K`, required): Item value to deselect.
///
/// Returns: `List<TreeNode<K>>` ‚Äî tree with item deselected.
  static List<TreeNode<K>> deselectItem<K>(List<TreeNode<K>> nodes, K target);
/// Toggles selection state of a specific node.
///
/// Parameters:
/// - [nodes] (`List<TreeNode<K>>`, required): Tree nodes.
/// - [target] (`TreeNode<K>`, required): Node to toggle.
///
/// Returns: `List<TreeNode<K>>` ‚Äî tree with node selection toggled.
  static List<TreeNode<K>> toggleSelectNode<K>(List<TreeNode<K>> nodes, TreeNode<K> target);
/// Toggles selection state of multiple nodes.
///
/// Parameters:
/// - [nodes] (`List<TreeNode<K>>`, required): Tree nodes.
/// - [targets] (`Iterable<TreeNode<K>>`, required): Nodes to toggle.
///
/// Returns: `List<TreeNode<K>>` ‚Äî tree with nodes toggled.
  static List<TreeNode<K>> toggleSelectNodes<K>(List<TreeNode<K>> nodes, Iterable<TreeNode<K>> targets);
/// Toggles selection state of a node by its item value.
///
/// Parameters:
/// - [nodes] (`List<TreeNode<K>>`, required): Tree nodes.
/// - [target] (`K`, required): Item value to toggle.
///
/// Returns: `List<TreeNode<K>>` ‚Äî tree with item toggled.
  static List<TreeNode<K>> toggleSelectItem<K>(List<TreeNode<K>> nodes, K target);
/// Toggles selection state of multiple items.
///
/// Parameters:
/// - [nodes] (`List<TreeNode<K>>`, required): Tree nodes.
/// - [targets] (`Iterable<K>`, required): Item values to toggle.
///
/// Returns: `List<TreeNode<K>>` ‚Äî tree with items toggled.
  static List<TreeNode<K>> toggleSelectItems<K>(List<TreeNode<K>> nodes, Iterable<K> targets);
/// Selects all nodes in the tree.
///
/// Parameters:
/// - [nodes] (`List<TreeNode<K>>`, required): Tree nodes.
///
/// Returns: `List<TreeNode<K>>` ‚Äî tree with all nodes selected.
  static List<TreeNode<K>> selectAll<K>(List<TreeNode<K>> nodes);
/// Deselects all nodes in the tree.
///
/// Parameters:
/// - [nodes] (`List<TreeNode<K>>`, required): Tree nodes.
///
/// Returns: `List<TreeNode<K>>` ‚Äî tree with all nodes deselected.
  static List<TreeNode<K>> deselectAll<K>(List<TreeNode<K>> nodes);
/// Toggles selection state of all nodes.
///
/// Parameters:
/// - [nodes] (`List<TreeNode<K>>`, required): Tree nodes.
///
/// Returns: `List<TreeNode<K>>` ‚Äî tree with all selections toggled.
  static List<TreeNode<K>> toggleSelectAll<K>(List<TreeNode<K>> nodes);
/// Selects specific nodes.
///
/// Parameters:
/// - [nodes] (`List<TreeNode<K>>`, required): Tree nodes.
/// - [selectedNodes] (`Iterable<TreeNode<K>>`, required): Nodes to select.
///
/// Returns: `List<TreeNode<K>>` ‚Äî tree with specified nodes selected.
  static List<TreeNode<K>> selectNodes<K>(List<TreeNode<K>> nodes, Iterable<TreeNode<K>> selectedNodes);
/// Selects nodes by their item values.
///
/// Parameters:
/// - [nodes] (`List<TreeNode<K>>`, required): Tree nodes.
/// - [selectedItems] (`Iterable<K>`, required): Item values to select.
///
/// Returns: `List<TreeNode<K>>` ‚Äî tree with specified items selected.
  static List<TreeNode<K>> selectItems<K>(List<TreeNode<K>> nodes, Iterable<K> selectedItems);
/// Deselects specific nodes.
///
/// Parameters:
/// - [nodes] (`List<TreeNode<K>>`, required): Tree nodes.
/// - [deselectedNodes] (`Iterable<TreeNode<K>>`, required): Nodes to deselect.
///
/// Returns: `List<TreeNode<K>>` ‚Äî tree with specified nodes deselected.
  static List<TreeNode<K>> deselectNodes<K>(List<TreeNode<K>> nodes, Iterable<TreeNode<K>> deselectedNodes);
/// Deselects nodes by their item values.
///
/// Parameters:
/// - [nodes] (`List<TreeNode<K>>`, required): Tree nodes.
/// - [deselectedItems] (`Iterable<K>`, required): Item values to deselect.
///
/// Returns: `List<TreeNode<K>>` ‚Äî tree with specified items deselected.
  static List<TreeNode<K>> deselectItems<K>(List<TreeNode<K>> nodes, Iterable<K> deselectedItems);
/// Sets the selected nodes, replacing current selection.
///
/// Parameters:
/// - [nodes] (`List<TreeNode<K>>`, required): Tree nodes.
/// - [selectedNodes] (`Iterable<TreeNode<K>>`, required): Nodes to select (all others deselected).
///
/// Returns: `List<TreeNode<K>>` ‚Äî tree with only specified nodes selected.
  static List<TreeNode<K>> setSelectedNodes<K>(List<TreeNode<K>> nodes, Iterable<TreeNode<K>> selectedNodes);
/// Sets the selected items by value, replacing current selection.
///
/// Parameters:
/// - [nodes] (`List<TreeNode<K>>`, required): Tree nodes.
/// - [selectedItems] (`Iterable<K>`, required): Item values to select (all others deselected).
///
/// Returns: `List<TreeNode<K>>` ‚Äî tree with only specified items selected.
  static List<TreeNode<K>> setSelectedItems<K>(List<TreeNode<K>> nodes, Iterable<K> selectedItems);
/// List of tree nodes to display in the tree view.
///
/// Type: `List<TreeNode<T>>`. The root-level nodes that will be rendered
/// in the tree. Can contain TreeItem instances and TreeRoot containers.
  List<TreeNode<T>> nodes;
/// Builder function to create widgets for tree items.
///
/// Type: `Widget Function(BuildContext, TreeItem<T>)`. Called for each
/// visible tree item to create its visual representation. Receives the
/// build context and the tree item data.
  Widget Function(BuildContext context, TreeItem<T> node) builder;
/// Whether the tree view should size itself to its content.
///
/// Type: `bool`, default: `false`. When true, the tree takes only the space
/// needed for its content instead of expanding to fill available space.
  bool shrinkWrap;
/// Optional scroll controller for the tree's scroll view.
///
/// Type: `ScrollController?`. Allows external control of scrolling behavior
/// and position within the tree view.
  ScrollController? controller;
/// The style of branch lines connecting tree nodes.
///
/// Type: `BranchLine?`. If null, uses the theme's branch line or BranchLine.path.
/// Controls the visual connections drawn between parent and child nodes.
  BranchLine? branchLine;
/// Padding around the tree view content.
///
/// Type: `EdgeInsetsGeometry?`. If null, uses 8 pixels on all sides.
/// Applied to the entire tree view scroll area.
  EdgeInsetsGeometry? padding;
/// Whether to show expand/collapse icons for nodes with children.
///
/// Type: `bool?`. If null, defaults to true from theme. When false,
/// nodes cannot be visually expanded or collapsed.
  bool? expandIcon;
/// Whether multiple tree nodes can be selected simultaneously.
///
/// Type: `bool?`. If null, defaults to true from theme. When false,
/// selecting a node automatically deselects all others.
  bool? allowMultiSelect;
/// Optional focus scope node for keyboard navigation.
///
/// Type: `FocusScopeNode?`. Controls focus behavior within the tree view
/// for keyboard navigation and accessibility.
  FocusScopeNode? focusNode;
/// Callback invoked when node selection changes.
///
/// Type: `TreeNodeSelectionChanged<T>?`. Called with the affected nodes,
/// whether multi-select mode is active, and the new selection state.
  TreeNodeSelectionChanged<T>? onSelectionChanged;
/// Whether selecting a parent node also selects its children.
///
/// Type: `bool?`. If null, defaults to true from theme. When true,
/// selection operations recursively affect all descendant nodes.
  bool? recursiveSelection;
/// Creates a [TreeView] with hierarchical data display and interaction.
///
/// Configures a tree view widget that displays hierarchical data with support
/// for expansion, selection, keyboard navigation, and visual styling.
///
/// Parameters:
/// - [key] (Key?): Widget identifier for the widget tree
/// - [nodes] (`List<TreeNode<T>>`, required): Root-level tree nodes to display
/// - [builder] (Widget Function(BuildContext, `TreeItem<T>`), required): Builder for tree items
/// - [shrinkWrap] (bool, default: false): Whether to size to content
/// - [controller] (ScrollController?, optional): Scroll controller for the tree
/// - [branchLine] (BranchLine?, optional): Style for connecting lines
/// - [padding] (EdgeInsetsGeometry?, optional): Padding around content
/// - [expandIcon] (bool?, optional): Whether to show expand/collapse icons
/// - [allowMultiSelect] (bool?, optional): Whether to allow multi-selection
/// - [focusNode] (FocusScopeNode?, optional): Focus node for keyboard navigation
/// - [onSelectionChanged] (`TreeNodeSelectionChanged<T>?`, optional): Selection callback
/// - [recursiveSelection] (bool?, optional): Whether to select children recursively
///
/// Example:
/// ```dart
/// TreeView<FileItem>(
///   nodes: fileTreeNodes,
///   allowMultiSelect: true,
///   recursiveSelection: true,
///   branchLine: BranchLine.path,
///   builder: (context, item) => ListTile(
///     leading: Icon(item.data.isDirectory ? Icons.folder : Icons.file_copy),
///     title: Text(item.data.name),
///     subtitle: Text(item.data.path),
///   ),
///   onSelectionChanged: (selectedNodes, multiSelect, isSelected) {
///     handleSelectionChange(selectedNodes, isSelected);
///   },
/// )
/// ```
  const TreeView({super.key, required this.nodes, required this.builder, this.shrinkWrap = false, this.controller, this.branchLine, this.padding, this.expandIcon, this.allowMultiSelect, this.focusNode, this.onSelectionChanged, this.recursiveSelection});
  State<TreeView<T>> createState();
}
/// Abstract base class for defining tree branch line styles.
///
/// BranchLine defines how visual connections are drawn between parent and child
/// nodes in tree views. Different implementations provide various visual styles
/// from no lines to complex path-based connections.
///
/// The class provides static instances for common branch line styles:
/// - [BranchLine.none] - No visual connections
/// - [BranchLine.line] - Simple vertical lines
/// - [BranchLine.path] - Connected path lines showing hierarchy
///
/// Custom implementations can be created by extending this class and implementing
/// the [build] method to return appropriate connection widgets.
///
/// Example:
/// ```dart
/// // Using built-in styles
/// TreeView(
///   branchLine: BranchLine.path, // Connected paths
///   // ... other properties
/// );
///
/// // Custom branch line implementation
/// class CustomBranchLine extends BranchLine {
///   @override
///   Widget build(BuildContext context, List<TreeNodeDepth> depth, int index) {
///     return CustomPaint(painter: MyCustomLinePainter());
///   }
/// }
/// ```
abstract class BranchLine {
/// Predefined branch line style with no visual connections.
  static const none = IndentGuideNone();
/// Predefined branch line style with simple vertical lines.
  static const line = IndentGuideLine();
/// Predefined branch line style with connected path lines.
  static const path = IndentGuidePath();
/// Builds the visual representation of branch lines for a tree node.
///
/// Creates a widget that shows the connection lines between tree nodes
/// based on the node's position in the hierarchy and its depth information.
///
/// Parameters:
/// - [context] (BuildContext): Build context for theme access
/// - [depth] (`List<TreeNodeDepth>`): Hierarchical depth information
/// - [index] (int): Index within the current depth level
///
/// Returns: A [Widget] representing the branch line visualization
  Widget build(BuildContext context, List<TreeNodeDepth> depth, int index);
}
/// Branch line implementation with no visual connections.
///
/// Displays tree nodes without any connecting lines between parent and child
/// nodes. Use this for a minimal tree appearance.
///
/// Example:
/// ```dart
/// TreeView(
///   branchLine: BranchLine.none,
///   // ...
/// );
/// ```
class IndentGuideNone implements BranchLine {
/// Creates an [IndentGuideNone].
  const IndentGuideNone();
  Widget build(BuildContext context, List<TreeNodeDepth> depth, int index);
}
/// Branch line implementation with simple vertical lines.
///
/// Displays vertical lines alongside tree nodes to indicate hierarchy levels.
/// Does not draw horizontal connections.
///
/// Example:
/// ```dart
/// TreeView(
///   branchLine: BranchLine.line,
///   // or with custom color:
///   branchLine: IndentGuideLine(color: Colors.blue),
/// );
/// ```
class IndentGuideLine implements BranchLine {
/// Custom color for the line. If null, uses the theme border color.
  Color? color;
/// Creates an [IndentGuideLine] with optional custom color.
  const IndentGuideLine({this.color});
  Widget build(BuildContext context, List<TreeNodeDepth> depth, int index);
}
/// Branch line implementation with connected path lines.
///
/// Displays L-shaped or T-shaped connectors showing the hierarchical
/// structure of the tree. This is the most common branch line style.
///
/// Example:
/// ```dart
/// TreeView(
///   branchLine: BranchLine.path,
///   // or with custom color:
///   branchLine: IndentGuidePath(color: Colors.grey),
/// );
/// ```
class IndentGuidePath implements BranchLine {
/// Custom color for the path. If null, uses the theme border color.
  Color? color;
/// Creates an [IndentGuidePath] with optional custom color.
  const IndentGuidePath({this.color});
  Widget build(BuildContext context, List<TreeNodeDepth> depth, int index);
}
/// A comprehensive tree item widget with interaction, expansion, and selection support.
///
/// TreeItemView provides a complete tree item interface that handles user
/// interaction, visual feedback, expansion/collapse behavior, and keyboard
/// navigation. It's designed to work within a TreeView context but can be
/// used independently for custom tree implementations.
///
/// The widget supports both single and double-click interactions, optional
/// leading and trailing widgets, expandable content, and focus management.
/// It automatically integrates with the tree's selection and expansion state
/// when used within a TreeView.
///
/// Features:
/// - Click and double-click interaction support
/// - Optional expand/collapse functionality for nodes with children
/// - Leading and trailing widget support for icons or actions
/// - Keyboard navigation with arrow keys and space bar
/// - Visual selection feedback with customizable styling
/// - Focus management and accessibility support
/// - Integration with tree branch lines and indentation
///
/// The widget automatically applies appropriate styling based on selection state,
/// focus state, and tree depth. It handles the visual representation of tree
/// hierarchy through indentation and branch line integration.
///
/// Example:
/// ```dart
/// TreeItemView(
///   leading: Icon(isDirectory ? Icons.folder : Icons.insert_drive_file),
///   trailing: PopupMenuButton(items: contextMenuItems),
///   expandable: hasChildren,
///   onPressed: () => selectItem(item),
///   onDoublePressed: () => openItem(item),
///   onExpand: (expanded) => toggleExpansion(item, expanded),
///   child: Text(item.name),
/// )
/// ```
class TreeItemView extends StatefulWidget {
/// The main content widget for this tree item.
///
/// Type: `Widget`. This widget represents the primary content of the tree item,
/// typically text or a combination of text and icons.
  Widget child;
/// Optional widget displayed at the leading edge of the item.
///
/// Type: `Widget?`. Commonly used for icons that represent the item type,
/// such as folder or file icons. Positioned before the main content.
  Widget? leading;
/// Optional widget displayed at the trailing edge of the item.
///
/// Type: `Widget?`. Commonly used for action buttons, status indicators,
/// or context menus. Positioned after the main content.
  Widget? trailing;
/// Callback invoked when the tree item is pressed/clicked.
///
/// Type: `VoidCallback?`. Called for single-click interactions. If null,
/// the item will not respond to press gestures.
  VoidCallback? onPressed;
/// Callback invoked when the tree item is double-pressed/double-clicked.
///
/// Type: `VoidCallback?`. Called for double-click interactions. If null,
/// the item will not respond to double-click gestures.
  VoidCallback? onDoublePressed;
/// Callback invoked when the expand/collapse state should change.
///
/// Type: `ValueChanged<bool>?`. Called with the desired expansion state
/// when the user interacts with expand controls or uses keyboard shortcuts.
  ValueChanged<bool>? onExpand;
/// Whether this item can be expanded to show children.
///
/// Type: `bool?`. If null, determined automatically based on whether the
/// tree node has children. When true, expand/collapse controls are shown.
  bool? expandable;
/// Optional focus node for keyboard navigation and focus management.
///
/// Type: `FocusNode?`. If null, a focus node is created automatically.
/// Allows external control of focus state for this tree item.
  FocusNode? focusNode;
/// Creates a [TreeItemView] with comprehensive tree item functionality.
///
/// Configures a tree item widget with interaction support, optional expansion,
/// and customizable leading/trailing elements.
///
/// Parameters:
/// - [key] (Key?): Widget identifier for the widget tree
/// - [child] (Widget, required): Main content widget for the tree item
/// - [leading] (Widget?, optional): Widget displayed before the content
/// - [trailing] (Widget?, optional): Widget displayed after the content
/// - [onPressed] (VoidCallback?, optional): Callback for press/click events
/// - [onDoublePressed] (VoidCallback?, optional): Callback for double-click events
/// - [onExpand] (`ValueChanged<bool>?`, optional): Callback for expansion changes
/// - [expandable] (bool?, optional): Whether the item can be expanded
/// - [focusNode] (FocusNode?, optional): Focus node for keyboard navigation
///
/// Example:
/// ```dart
/// TreeItemView(
///   leading: Icon(Icons.folder),
///   trailing: Badge(child: Text('3')),
///   expandable: true,
///   onPressed: () => handleSelection(),
///   onDoublePressed: () => handleOpen(),
///   onExpand: (expanded) => handleExpansion(expanded),
///   child: Text('Project Folder'),
/// )
/// ```
  const TreeItemView({super.key, required this.child, this.leading, this.trailing, this.onPressed, this.onDoublePressed, this.onExpand, this.expandable, this.focusNode});
  State<TreeItemView> createState();
}
/// Intent to expand a tree node.
///
/// Used with Flutter's Actions/Shortcuts system to programmatically
/// expand a collapsed tree node to show its children.
class ExpandTreeNodeIntent extends Intent {
/// Creates an [ExpandTreeNodeIntent].
  const ExpandTreeNodeIntent();
}
/// Intent to collapse a tree node.
///
/// Used with Flutter's Actions/Shortcuts system to programmatically
/// collapse an expanded tree node to hide its children.
class CollapseTreeNodeIntent extends Intent {
/// Creates a [CollapseTreeNodeIntent].
  const CollapseTreeNodeIntent();
}
/// Intent to select a tree node.
///
/// Used with Flutter's Actions/Shortcuts system to programmatically
/// select the currently focused tree node.
class SelectTreeNodeIntent extends Intent {
/// Creates a [SelectTreeNodeIntent].
  const SelectTreeNodeIntent();
}
/// Intent to navigate and select tree nodes directionally.
///
/// Used with Flutter's Actions/Shortcuts system to move focus
/// up or down the tree and optionally select nodes.
class DirectionalSelectTreeNodeIntent extends Intent {
/// Whether to move forward (true) or backward (false) in the tree.
  bool forward;
/// Creates a [DirectionalSelectTreeNodeIntent].
  const DirectionalSelectTreeNodeIntent(this.forward);
}
/// A multi-child layout widget that positions children using absolute coordinates.
///
/// Similar to Flutter's [Stack] but with more explicit positioning control.
/// Children are positioned using [GroupPositioned] widgets that specify their
/// exact location and/or size within the group's bounds.
///
/// Example:
/// ```dart
/// GroupWidget(
///   children: [
///     GroupPositioned(
///       top: 10,
///       left: 10,
///       child: Text('Positioned text'),
///     ),
///   ],
/// )
/// ```
class GroupWidget extends MultiChildRenderObjectWidget {
/// Creates a [GroupWidget].
  const GroupWidget({super.key, super.children});
  RenderObject createRenderObject(BuildContext context);
  void updateRenderObject(BuildContext context, RenderGroup renderObject);
}
/// Parent data for children of [GroupWidget].
///
/// Stores positioning and sizing information for each child widget within
/// a [GroupWidget]. These values are set by [GroupPositioned].
class GroupParentData extends ContainerBoxParentData<RenderBox> {
/// Distance from the top edge of the group.
  double? top;
/// Distance from the left edge of the group.
  double? left;
/// Distance from the right edge of the group.
  double? right;
/// Distance from the bottom edge of the group.
  double? bottom;
/// Explicit width of the child.
  double? width;
/// Explicit height of the child.
  double? height;
}
/// Render object for [GroupWidget] that handles absolute positioning of children.
///
/// Manages layout and painting of children positioned using [GroupParentData].
class RenderGroup extends RenderBox with ContainerRenderObjectMixin<RenderBox, GroupParentData>, RenderBoxContainerDefaultsMixin<RenderBox, GroupParentData> {
/// Creates a [RenderGroup].
///
/// Parameters:
/// - [children] (`List<RenderBox>?`, optional): Initial list of child render objects.
  RenderGroup({List<RenderBox>? children});
  void setupParentData(RenderBox child);
  void performLayout();
  void paint(PaintingContext context, Offset offset);
  bool hitTest(BoxHitTestResult result, {required Offset position});
  bool hitTestChildren(BoxHitTestResult result, {required Offset position});
}
/// Positions a child widget within a [GroupWidget].
///
/// Controls the position and optionally the size of a child using absolute
/// coordinates. At least one positioning parameter should be provided.
///
/// Example:
/// ```dart
/// GroupPositioned(
///   top: 20,
///   left: 20,
///   width: 100,
///   height: 50,
///   child: Container(color: Colors.blue),
/// )
/// ```
class GroupPositioned extends ParentDataWidget<GroupParentData> {
/// Creates a [GroupPositioned].
///
/// Parameters:
/// - [top] (`double?`, optional): Distance from top edge.
/// - [left] (`double?`, optional): Distance from left edge.
/// - [right] (`double?`, optional): Distance from right edge.
/// - [bottom] (`double?`, optional): Distance from bottom edge.
/// - [width] (`double?`, optional): Explicit width.
/// - [height] (`double?`, optional): Explicit height.
/// - [child] (`Widget`, required): The child to position.
  const GroupPositioned({super.key, this.top, this.left, this.right, this.bottom, this.width, this.height, required super.child});
/// Creates a [GroupPositioned] that fills the entire group bounds.
///
/// Sets all edges to 0, making the child fill the available space.
  const GroupPositioned.fill({super.key, this.top = 0, this.left = 0, this.right = 0, this.bottom = 0, this.width, this.height, required super.child});
/// Creates a [GroupPositioned] from a [Rect].
///
/// Positions and sizes the child according to the given rectangle.
  GroupPositioned.fromRect({super.key, required Rect rect, required super.child});
/// Distance from the top edge of the group.
  double? top;
/// Distance from the left edge of the group.
  double? left;
/// Distance from the right edge of the group.
  double? right;
/// Distance from the bottom edge of the group.
  double? bottom;
/// Explicit width of the child.
  double? width;
/// Explicit height of the child.
  double? height;
  void applyParentData(RenderObject renderObject);
  Type get debugTypicalAncestorWidgetClass;
}
/// Theme data for [ScrollableClient].
class ScrollableClientTheme extends ComponentThemeData {
/// Behavior for diagonal drag gestures.
  DiagonalDragBehavior? diagonalDragBehavior;
/// When drag gestures should start.
  DragStartBehavior? dragStartBehavior;
/// How the keyboard dismissal should behave.
  ScrollViewKeyboardDismissBehavior? keyboardDismissBehavior;
/// How to clip the scrollable content.
  Clip? clipBehavior;
/// How hit testing should behave for the scrollable.
  HitTestBehavior? hitTestBehavior;
/// Whether overscroll effects are enabled.
  bool? overscroll;
/// Creates a [ScrollableClientTheme].
  const ScrollableClientTheme({this.diagonalDragBehavior, this.dragStartBehavior, this.keyboardDismissBehavior, this.clipBehavior, this.hitTestBehavior, this.overscroll});
/// Creates a copy of this theme with the given fields replaced.
  ScrollableClientTheme copyWith({ValueGetter<DiagonalDragBehavior?>? diagonalDragBehavior, ValueGetter<DragStartBehavior?>? dragStartBehavior, ValueGetter<ScrollViewKeyboardDismissBehavior?>? keyboardDismissBehavior, ValueGetter<Clip?>? clipBehavior, ValueGetter<HitTestBehavior?>? hitTestBehavior, ValueGetter<bool?>? overscroll});
  bool operator ==(Object other);
  int get hashCode;
  String toString();
}
/// A customizable scrollable widget with two-axis scrolling support.
///
/// Provides fine-grained control over scrolling behavior for both vertical
/// and horizontal axes. Supports custom scroll physics, drag behaviors,
/// and viewport-aware content building.
///
/// Example:
/// ```dart
/// ScrollableClient(
///   mainAxis: Axis.vertical,
///   verticalDetails: ScrollableDetails.vertical(),
///   builder: (context, offset, viewportSize, child) {
///     return CustomPaint(
///       painter: MyPainter(offset),
///       child: child,
///     );
///   },
///   child: MyContent(),
/// )
/// ```
class ScrollableClient extends StatelessWidget {
/// Whether this is the primary scrollable in the widget tree.
  bool? primary;
/// Primary scrolling axis.
  Axis mainAxis;
/// Scroll configuration for vertical axis.
  ScrollableDetails verticalDetails;
/// Scroll configuration for horizontal axis.
  ScrollableDetails horizontalDetails;
/// Builder for creating content with viewport info.
  ScrollableBuilder builder;
/// Optional child widget.
  Widget? child;
/// Behavior for diagonal drag gestures.
  DiagonalDragBehavior? diagonalDragBehavior;
/// When drag gestures should start.
  DragStartBehavior? dragStartBehavior;
/// How keyboard dismissal should behave.
  ScrollViewKeyboardDismissBehavior? keyboardDismissBehavior;
/// How to clip content.
  Clip? clipBehavior;
/// Hit test behavior.
  HitTestBehavior? hitTestBehavior;
/// Whether overscroll effects are enabled.
  bool? overscroll;
/// Creates a [ScrollableClient].
  const ScrollableClient({super.key, this.primary, this.mainAxis = Axis.vertical, this.verticalDetails = const ScrollableDetails.vertical(), this.horizontalDetails = const ScrollableDetails.horizontal(), required this.builder, this.child, this.diagonalDragBehavior, this.dragStartBehavior, this.keyboardDismissBehavior, this.clipBehavior, this.hitTestBehavior, this.overscroll});
  Widget build(BuildContext context);
}
/// Viewport widget for [ScrollableClient] with two-dimensional scrolling.
///
/// Handles rendering and layout of scrollable content with both horizontal
/// and vertical scroll axes.
class ScrollableClientViewport extends TwoDimensionalViewport {
/// Whether overscroll effects are enabled.
  bool overscroll;
/// Creates a [ScrollableClientViewport].
  const ScrollableClientViewport({super.key, required super.verticalOffset, required super.verticalAxisDirection, required super.horizontalOffset, required super.horizontalAxisDirection, required super.delegate, required super.mainAxis, super.cacheExtent, super.clipBehavior = Clip.hardEdge, required this.overscroll});
  RenderTwoDimensionalViewport createRenderObject(BuildContext context);
}
/// Render object for [ScrollableClientViewport].
///
/// Manages the two-dimensional viewport rendering with overscroll support.
class RenderScrollableClientViewport extends RenderTwoDimensionalViewport {
/// Whether overscroll effects are enabled.
  bool overscroll;
/// Creates a [RenderScrollableClientViewport].
  RenderScrollableClientViewport({required super.horizontalOffset, required super.horizontalAxisDirection, required super.verticalOffset, required super.verticalAxisDirection, required super.delegate, required super.mainAxis, required super.childManager, super.cacheExtent, super.clipBehavior = Clip.hardEdge, required this.overscroll});
  void layoutChildSequence();
}
/// Applies a fade mask at the scroll edges of [child].
///
/// Useful for indicating overflow in scrollables without showing scrollbars.
class FadedScrollableViewport extends StatefulWidget {
/// The scrollable content to fade.
  Widget child;
/// Distance over which the fade ramps in or out.
  double fadeExtent;
/// Size of the fade gradient along the scroll axis.
  double fadeSize;
/// Creates a [FadedScrollableViewport].
  const FadedScrollableViewport({super.key, this.fadeExtent = 20.0, this.fadeSize = 50.0, required this.child});
  State<FadedScrollableViewport> createState();
}
/// Theme for [Breadcrumb].
class BreadcrumbTheme extends ComponentThemeData {
/// Separator widget between breadcrumb items.
  Widget? separator;
/// Padding around the breadcrumb row.
  EdgeInsetsGeometry? padding;
/// Creates a [BreadcrumbTheme].
  const BreadcrumbTheme({this.separator, this.padding});
/// Returns a copy of this theme with the given fields replaced.
  BreadcrumbTheme copyWith({ValueGetter<Widget?>? separator, ValueGetter<EdgeInsetsGeometry?>? padding});
  bool operator ==(Object other);
  int get hashCode;
}
/// Navigation breadcrumb trail showing hierarchical path with customizable separators.
///
/// A horizontal navigation widget that displays a series of linked items
/// representing the current location within a hierarchical structure.
/// Automatically adds separators between items and supports horizontal scrolling
/// for overflow handling.
///
/// ## Features
///
/// - **Hierarchical navigation**: Clear visual representation of path structure
/// - **Customizable separators**: Built-in arrow and slash separators or custom widgets
/// - **Overflow handling**: Horizontal scrolling when content exceeds available width
/// - **Touch-optimized**: Mobile-friendly scrolling behavior
/// - **Theming support**: Consistent styling through theme system
/// - **Responsive**: Automatically adapts to different screen sizes
///
/// The breadcrumb automatically handles the last item differently, showing it
/// as the current location without making it interactive.
///
/// Example:
/// ```dart
/// Breadcrumb(
///   separator: Breadcrumb.slashSeparator,
///   children: [
///     GestureDetector(
///       onTap: () => Navigator.pop(context),
///       child: Text('Home'),
///     ),
///     GestureDetector(
///       onTap: () => Navigator.pop(context),
///       child: Text('Products'),
///     ),
///     Text('Electronics'), // Current page
///   ],
/// );
/// ```
class Breadcrumb extends StatelessWidget {
/// Default arrow separator widget (>).
///
/// Can be used as the [separator] parameter for arrow-style navigation.
  static const Widget arrowSeparator = _ArrowSeparator();
/// Default slash separator widget (/).
///
/// Can be used as the [separator] parameter for slash-style navigation.
  static const Widget slashSeparator = _SlashSeparator();
/// The list of breadcrumb navigation items.
///
/// Each widget represents a step in the navigation trail, from root to
/// current location. The last item is styled as the current page.
  List<Widget> children;
/// Widget displayed between breadcrumb items.
///
/// If `null`, uses the default separator from the theme.
  Widget? separator;
/// Padding around the entire breadcrumb widget.
///
/// If `null`, uses default padding from the theme.
  EdgeInsetsGeometry? padding;
/// Creates a [Breadcrumb] navigation trail.
///
/// The last child in the list is treated as the current location and
/// is styled differently from the preceding navigation items.
///
/// Parameters:
/// - [children] (`List<Widget>`, required): breadcrumb items from root to current
/// - [separator] (Widget?, optional): custom separator between items
/// - [padding] (EdgeInsetsGeometry?, optional): padding around the breadcrumb
///
/// Example:
/// ```dart
/// Breadcrumb(
///   separator: Icon(Icons.chevron_right),
///   children: [
///     TextButton(onPressed: goHome, child: Text('Home')),
///     TextButton(onPressed: goToCategory, child: Text('Category')),
///     Text('Current Page'),
///   ],
/// )
/// ```
  const Breadcrumb({super.key, required this.children, this.separator, this.padding});
  Widget build(BuildContext context);
}
/// Theme configuration for [Stepper] components.
///
/// Defines default values for stepper direction, size, and visual variant.
/// Applied through [ComponentTheme] to provide consistent styling across
/// stepper widgets in the application.
///
/// Example:
/// ```dart
/// ComponentTheme(
///   data: StepperTheme(
///     direction: Axis.vertical,
///     size: StepSize.large,
///     variant: StepVariant.circle,
///   ),
///   child: MyApp(),
/// );
/// ```
class StepperTheme extends ComponentThemeData {
/// Layout direction for the stepper.
  Axis? direction;
/// Size variant for step indicators.
  StepSize? size;
/// Visual variant for step presentation.
  StepVariant? variant;
/// Creates a [StepperTheme].
///
/// All parameters are optional and provide default values for
/// stepper components in the widget tree.
///
/// Parameters:
/// - [direction] (Axis?): horizontal or vertical layout
/// - [size] (StepSize?): step indicator size (small, medium, large)
/// - [variant] (StepVariant?): visual style (circle, circleAlt, line)
  const StepperTheme({this.direction, this.size, this.variant});
/// Creates a copy of this theme with optionally overridden properties.
  StepperTheme copyWith({ValueGetter<Axis?>? direction, ValueGetter<StepSize?>? size, ValueGetter<StepVariant?>? variant});
  bool operator ==(Object other);
  int get hashCode;
}
/// Represents the state of an individual step in a stepper.
///
/// Currently supports failed state indication, with potential for
/// expansion to include additional states like completed, active, etc.
enum StepState { failed }
/// Immutable value representing the current state of a stepper.
///
/// Contains the current active step index and a map of step states
/// for any steps that have special states (like failed). Used by
/// [StepperController] to track and notify about stepper state changes.
///
/// Example:
/// ```dart
/// final value = StepperValue(
///   currentStep: 2,
///   stepStates: {1: StepState.failed},
/// );
/// ```
class StepperValue {
/// Map of step indices to their special states.
  Map<int, StepState> stepStates;
/// Index of the currently active step (0-based).
  int currentStep;
/// Creates a [StepperValue].
///
/// Parameters:
/// - [stepStates] (`Map<int, StepState>`, required): step states by index
/// - [currentStep] (int, required): currently active step index
  StepperValue({required this.stepStates, required this.currentStep});
  bool operator ==(Object other);
  int get hashCode;
  String toString();
}
/// Represents a single step in a stepper component.
///
/// Contains the step's title, optional content builder for step details,
/// and an optional custom icon. The content builder is called when
/// the step becomes active to show step-specific content.
///
/// Example:
/// ```dart
/// Step(
///   title: Text('Personal Info'),
///   icon: Icon(Icons.person),
///   contentBuilder: (context) => PersonalInfoForm(),
/// );
/// ```
class Step {
/// The title widget displayed for this step.
  Widget title;
/// Optional builder for step content shown when active.
  WidgetBuilder? contentBuilder;
/// Optional custom icon for the step indicator.
  Widget? icon;
/// Creates a [Step].
///
/// The [title] is required and typically contains the step name or description.
/// The [contentBuilder] is called when this step becomes active to show
/// detailed content. The [icon] replaces the default step number/checkmark.
///
/// Parameters:
/// - [title] (Widget, required): step title or label
/// - [contentBuilder] (WidgetBuilder?): builds content when step is active
/// - [icon] (Widget?): custom icon for step indicator
///
/// Example:
/// ```dart
/// Step(
///   title: Text('Account Setup'),
///   icon: Icon(Icons.account_circle),
///   contentBuilder: (context) => AccountSetupForm(),
/// );
/// ```
  const Step({required this.title, this.contentBuilder, this.icon});
}
/// Defines the size variants available for step indicators.
///
/// Each size includes both a numeric size value and a builder function
/// that applies appropriate text and icon styling. Sizes scale with
/// the theme's scaling factor.
///
/// Example:
/// ```dart
/// Stepper(
///   size: StepSize.large,
///   steps: mySteps,
///   controller: controller,
/// );
/// ```
enum StepSize { small, medium, large }
/// Abstract base class for step visual presentation variants.
///
/// Defines how steps are rendered and connected to each other. Three built-in
/// variants are provided: circle (default), circleAlt (alternative layout),
/// and line (minimal design). Custom variants can be created by extending
/// this class.
///
/// Example:
/// ```dart
/// Stepper(
///   variant: StepVariant.circle,
///   steps: mySteps,
///   controller: controller,
/// );
/// ```
abstract class StepVariant {
/// Circle variant with numbered indicators and connecting lines.
  static const StepVariant circle = _StepVariantCircle();
/// Alternative circle variant with centered step names.
  static const StepVariant circleAlt = _StepVariantCircleAlternative();
/// Minimal line variant with progress bars as step indicators.
  static const StepVariant line = _StepVariantLine();
/// Creates a [StepVariant].
  const StepVariant();
/// Builds the stepper widget using this variant's visual style.
///
/// Implementations should create the appropriate layout using the
/// provided [StepProperties] which contains step data, current state,
/// and sizing information.
  Widget build(BuildContext context, StepProperties properties);
}
/// Default small step indicator size in logical pixels.
const kSmallStepIndicatorSize = 36.0;
/// Default medium step indicator size in logical pixels.
const kMediumStepIndicatorSize = 40.0;
/// Default large step indicator size in logical pixels.
const kLargeStepIndicatorSize = 44.0;
/// Contains properties and state information for stepper rendering.
///
/// Used internally by [StepVariant] implementations to build the
/// appropriate stepper layout. Provides access to step data, current
/// state, sizing configuration, and layout direction.
///
/// Also includes utility methods like [hasFailure] to check for failed
/// steps and array-style access to individual steps.
class StepProperties {
/// Size configuration for step indicators.
  StepSize size;
/// List of steps in the stepper.
  List<Step> steps;
/// Listenable state containing current step and step states.
  ValueListenable<StepperValue> state;
/// Layout direction for the stepper.
  Axis direction;
/// Creates [StepProperties].
  const StepProperties({required this.size, required this.steps, required this.state, required this.direction});
/// Safely accesses a step by index, returning null if out of bounds.
  Step? operator [](int index);
/// Returns true if any step has a failed state.
  bool get hasFailure;
  bool operator ==(Object other);
  int get hashCode;
}
/// Controller for managing stepper state and navigation.
///
/// Extends [ValueNotifier] to provide reactive state updates when
/// the current step changes or step states are modified. Includes
/// methods for navigation (next/previous), direct step jumping,
/// and setting individual step states.
///
/// The controller should be disposed when no longer needed to prevent
/// memory leaks.
///
/// Example:
/// ```dart
/// final controller = StepperController(currentStep: 0);
///
/// // Navigate to next step
/// controller.nextStep();
///
/// // Mark step as failed
/// controller.setStatus(1, StepState.failed);
///
/// // Jump to specific step
/// controller.jumpToStep(3);
///
/// // Don't forget to dispose
/// controller.dispose();
/// ```
class StepperController extends ValueNotifier<StepperValue> {
/// Creates a [StepperController].
///
/// Parameters:
/// - [stepStates] (`Map<int, StepState>?`): initial step states (default: empty)
/// - [currentStep] (int?): initial active step index (default: 0)
///
/// Example:
/// ```dart
/// final controller = StepperController(
///   currentStep: 1,
///   stepStates: {0: StepState.failed},
/// );
/// ```
  StepperController({Map<int, StepState>? stepStates, int? currentStep});
/// Advances to the next step.
///
/// Increments the current step index by 1. Does not validate
/// if the next step exists - callers should check bounds.
///
/// Example:
/// ```dart
/// if (controller.value.currentStep < steps.length - 1) {
///   controller.nextStep();
/// }
/// ```
  void nextStep();
/// Returns to the previous step.
///
/// Decrements the current step index by 1. Does not validate
/// if the previous step exists - callers should check bounds.
///
/// Example:
/// ```dart
/// if (controller.value.currentStep > 0) {
///   controller.previousStep();
/// }
/// ```
  void previousStep();
/// Sets or clears the state of a specific step.
///
/// Parameters:
/// - [step] (int): zero-based step index to modify
/// - [state] (StepState?): new state, or null to clear
///
/// Example:
/// ```dart
/// // Mark step as failed
/// controller.setStatus(2, StepState.failed);
///
/// // Clear step state
/// controller.setStatus(2, null);
/// ```
  void setStatus(int step, StepState? state);
/// Jumps directly to the specified step.
///
/// Parameters:
/// - [step] (int): zero-based step index to navigate to
///
/// Example:
/// ```dart
/// // Jump to final step
/// controller.jumpToStep(steps.length - 1);
/// ```
  void jumpToStep(int step);
}
/// A multi-step navigation component with visual progress indication.
///
/// Displays a sequence of steps with customizable visual styles, supporting
/// both horizontal and vertical layouts. Each step can have a title, optional
/// content, and custom icons. The component tracks current step progress and
/// can display failed states.
///
/// Uses a [StepperController] for state management and navigation. Steps are
/// defined using [Step] objects, and visual presentation is controlled by
/// [StepVariant] and [StepSize] configurations.
///
/// The stepper automatically handles step indicators, connecting lines or
/// progress bars, and animated content transitions between steps.
///
/// Example:
/// ```dart
/// final controller = StepperController();
///
/// Stepper(
///   controller: controller,
///   direction: Axis.vertical,
///   variant: StepVariant.circle,
///   size: StepSize.medium,
///   steps: [
///     Step(
///       title: Text('Personal Info'),
///       contentBuilder: (context) => PersonalInfoForm(),
///     ),
///     Step(
///       title: Text('Address'),
///       contentBuilder: (context) => AddressForm(),
///     ),
///     Step(
///       title: Text('Confirmation'),
///       contentBuilder: (context) => ConfirmationView(),
///     ),
///   ],
/// );
/// ```
class Stepper extends StatelessWidget {
/// Controller for managing stepper state and navigation.
  StepperController controller;
/// List of steps to display in the stepper.
  List<Step> steps;
/// Layout direction (horizontal or vertical).
  Axis? direction;
/// Size variant for step indicators.
  StepSize? size;
/// Visual variant for step presentation.
  StepVariant? variant;
/// Creates a [Stepper].
///
/// The [controller] and [steps] are required. Other parameters are optional
/// and will use theme defaults or built-in defaults if not provided.
///
/// Parameters:
/// - [controller] (StepperController, required): manages state and navigation
/// - [steps] (`List<Step>`, required): list of steps to display
/// - [direction] (Axis?): horizontal or vertical layout (default: horizontal)
/// - [size] (StepSize?): step indicator size (default: medium)
/// - [variant] (StepVariant?): visual style (default: circle)
///
/// Example:
/// ```dart
/// final controller = StepperController(currentStep: 0);
///
/// Stepper(
///   controller: controller,
///   direction: Axis.vertical,
///   size: StepSize.large,
///   variant: StepVariant.line,
///   steps: [
///     Step(title: Text('Step 1')),
///     Step(title: Text('Step 2')),
///     Step(title: Text('Step 3')),
///   ],
/// );
/// ```
  const Stepper({super.key, required this.controller, required this.steps, this.direction, this.size, this.variant});
  Widget build(BuildContext context);
}
/// Data class providing step index context to descendant widgets.
///
/// Used internally by the stepper to pass the current step index
/// to child widgets like [StepNumber]. Accessible via [Data.maybeOf].
///
/// Example:
/// ```dart
/// final stepData = Data.maybeOf<StepNumberData>(context);
/// final stepIndex = stepData?.stepIndex ?? 0;
/// ```
class StepNumberData {
/// Zero-based index of the step.
  int stepIndex;
/// Creates [StepNumberData].
  const StepNumberData({required this.stepIndex});
  bool operator ==(Object other);
  int get hashCode;
  String toString();
}
/// Step indicator widget displaying step number, checkmark, or custom icon.
///
/// Renders a circular (or rectangular based on theme) step indicator that
/// shows the step number by default, a checkmark for completed steps,
/// or an X for failed steps. Colors and states are automatically managed
/// based on the stepper's current state.
///
/// Must be used within a [Stepper] widget tree to access step context.
/// Optionally supports custom icons and click handling.
///
/// Example:
/// ```dart
/// StepNumber(
///   icon: Icon(Icons.star),
///   onPressed: () => print('Step tapped'),
/// );
/// ```
class StepNumber extends StatelessWidget {
/// Custom icon to display instead of step number.
  Widget? icon;
/// Callback invoked when the step indicator is pressed.
  VoidCallback? onPressed;
/// Creates a [StepNumber].
///
/// Both parameters are optional. If [icon] is provided, it replaces
/// the default step number. If [onPressed] is provided, the step
/// becomes clickable.
///
/// Parameters:
/// - [icon] (Widget?): custom icon replacing step number
/// - [onPressed] (VoidCallback?): tap callback for interaction
///
/// Example:
/// ```dart
/// StepNumber(
///   icon: Icon(Icons.person),
///   onPressed: () => jumpToStep(stepIndex),
/// );
/// ```
  const StepNumber({super.key, this.icon, this.onPressed});
  Widget build(BuildContext context);
}
/// Clickable step title widget with optional subtitle.
///
/// Displays the step title and optional subtitle in a clickable container.
/// Used within stepper layouts to provide interactive step navigation.
/// Supports customizable cross-axis alignment for text positioning.
///
/// Example:
/// ```dart
/// StepTitle(
///   title: Text('Account Setup'),
///   subtitle: Text('Enter your personal details'),
///   onPressed: () => jumpToThisStep(),
/// );
/// ```
class StepTitle extends StatelessWidget {
/// The main title widget for the step.
  Widget title;
/// Optional subtitle widget displayed below the title.
  Widget? subtitle;
/// Cross-axis alignment for the title and subtitle.
  CrossAxisAlignment crossAxisAlignment;
/// Callback invoked when the title is pressed.
  VoidCallback? onPressed;
/// Creates a [StepTitle].
///
/// The [title] is required. The [subtitle], [crossAxisAlignment], and
/// [onPressed] parameters are optional.
///
/// Parameters:
/// - [title] (Widget, required): main title content
/// - [subtitle] (Widget?): optional subtitle below title
/// - [crossAxisAlignment] (CrossAxisAlignment): text alignment (default: stretch)
/// - [onPressed] (VoidCallback?): tap callback for interaction
///
/// Example:
/// ```dart
/// StepTitle(
///   title: Text('Payment Info'),
///   subtitle: Text('Credit card details'),
///   crossAxisAlignment: CrossAxisAlignment.center,
///   onPressed: () => navigateToPayment(),
/// );
/// ```
  const StepTitle({super.key, required this.title, this.subtitle, this.crossAxisAlignment = CrossAxisAlignment.stretch, this.onPressed});
  Widget build(BuildContext context);
}
/// Container widget for step content with optional action buttons.
///
/// Provides consistent padding and layout for step content, with optional
/// action buttons displayed below the main content. Actions are arranged
/// horizontally with appropriate spacing.
///
/// Typically used within step content builders to provide a consistent
/// layout for form content, descriptions, and navigation buttons.
///
/// Example:
/// ```dart
/// StepContainer(
///   child: Column(
///     children: [
///       TextFormField(decoration: InputDecoration(labelText: 'Name')),
///       TextFormField(decoration: InputDecoration(labelText: 'Email')),
///     ],
///   ),
///   actions: [
///     Button(
///       onPressed: controller.previousStep,
///       child: Text('Back'),
///     ),
///     Button(
///       onPressed: controller.nextStep,
///       child: Text('Next'),
///     ),
///   ],
/// );
/// ```
class StepContainer extends StatefulWidget {
/// The main content widget for the step.
  Widget child;
/// List of action widgets (typically buttons) displayed below content.
  List<Widget> actions;
/// Creates a [StepContainer].
///
/// The [child] and [actions] parameters are required. Actions can be
/// an empty list if no buttons are needed.
///
/// Parameters:
/// - [child] (Widget, required): main step content
/// - [actions] (`List<Widget>`, required): action buttons or widgets
///
/// Example:
/// ```dart
/// StepContainer(
///   child: FormFields(),
///   actions: [
///     Button(onPressed: previousStep, child: Text('Back')),
///     Button(onPressed: nextStep, child: Text('Continue')),
///   ],
/// );
/// ```
  const StepContainer({super.key, required this.child, required this.actions});
  State<StepContainer> createState();
}
/// Theme data for [ScrollableClient].
class ScrollableClientTheme extends ComponentThemeData {
/// Behavior for diagonal drag gestures.
  DiagonalDragBehavior? diagonalDragBehavior;
/// When drag gestures should start.
  DragStartBehavior? dragStartBehavior;
/// How the keyboard dismissal should behave.
  ScrollViewKeyboardDismissBehavior? keyboardDismissBehavior;
/// How to clip the scrollable content.
  Clip? clipBehavior;
/// How hit testing should behave for the scrollable.
  HitTestBehavior? hitTestBehavior;
/// Whether overscroll effects are enabled.
  bool? overscroll;
/// Creates a [ScrollableClientTheme].
  const ScrollableClientTheme({this.diagonalDragBehavior, this.dragStartBehavior, this.keyboardDismissBehavior, this.clipBehavior, this.hitTestBehavior, this.overscroll});
/// Creates a copy of this theme with the given fields replaced.
  ScrollableClientTheme copyWith({ValueGetter<DiagonalDragBehavior?>? diagonalDragBehavior, ValueGetter<DragStartBehavior?>? dragStartBehavior, ValueGetter<ScrollViewKeyboardDismissBehavior?>? keyboardDismissBehavior, ValueGetter<Clip?>? clipBehavior, ValueGetter<HitTestBehavior?>? hitTestBehavior, ValueGetter<bool?>? overscroll});
  bool operator ==(Object other);
  int get hashCode;
  String toString();
}
/// A customizable scrollable widget with two-axis scrolling support.
///
/// Provides fine-grained control over scrolling behavior for both vertical
/// and horizontal axes. Supports custom scroll physics, drag behaviors,
/// and viewport-aware content building.
///
/// Example:
/// ```dart
/// ScrollableClient(
///   mainAxis: Axis.vertical,
///   verticalDetails: ScrollableDetails.vertical(),
///   builder: (context, offset, viewportSize, child) {
///     return CustomPaint(
///       painter: MyPainter(offset),
///       child: child,
///     );
///   },
///   child: MyContent(),
/// )
/// ```
class ScrollableClient extends StatelessWidget {
/// Whether this is the primary scrollable in the widget tree.
  bool? primary;
/// Primary scrolling axis.
  Axis mainAxis;
/// Scroll configuration for vertical axis.
  ScrollableDetails verticalDetails;
/// Scroll configuration for horizontal axis.
  ScrollableDetails horizontalDetails;
/// Builder for creating content with viewport info.
  ScrollableBuilder builder;
/// Optional child widget.
  Widget? child;
/// Behavior for diagonal drag gestures.
  DiagonalDragBehavior? diagonalDragBehavior;
/// When drag gestures should start.
  DragStartBehavior? dragStartBehavior;
/// How keyboard dismissal should behave.
  ScrollViewKeyboardDismissBehavior? keyboardDismissBehavior;
/// How to clip content.
  Clip? clipBehavior;
/// Hit test behavior.
  HitTestBehavior? hitTestBehavior;
/// Whether overscroll effects are enabled.
  bool? overscroll;
/// Creates a [ScrollableClient].
  const ScrollableClient({super.key, this.primary, this.mainAxis = Axis.vertical, this.verticalDetails = const ScrollableDetails.vertical(), this.horizontalDetails = const ScrollableDetails.horizontal(), required this.builder, this.child, this.diagonalDragBehavior, this.dragStartBehavior, this.keyboardDismissBehavior, this.clipBehavior, this.hitTestBehavior, this.overscroll});
  Widget build(BuildContext context);
}
/// Viewport widget for [ScrollableClient] with two-dimensional scrolling.
///
/// Handles rendering and layout of scrollable content with both horizontal
/// and vertical scroll axes.
class ScrollableClientViewport extends TwoDimensionalViewport {
/// Whether overscroll effects are enabled.
  bool overscroll;
/// Creates a [ScrollableClientViewport].
  const ScrollableClientViewport({super.key, required super.verticalOffset, required super.verticalAxisDirection, required super.horizontalOffset, required super.horizontalAxisDirection, required super.delegate, required super.mainAxis, super.cacheExtent, super.clipBehavior = Clip.hardEdge, required this.overscroll});
  RenderTwoDimensionalViewport createRenderObject(BuildContext context);
}
/// Render object for [ScrollableClientViewport].
///
/// Manages the two-dimensional viewport rendering with overscroll support.
class RenderScrollableClientViewport extends RenderTwoDimensionalViewport {
/// Whether overscroll effects are enabled.
  bool overscroll;
/// Creates a [RenderScrollableClientViewport].
  RenderScrollableClientViewport({required super.horizontalOffset, required super.horizontalAxisDirection, required super.verticalOffset, required super.verticalAxisDirection, required super.delegate, required super.mainAxis, required super.childManager, super.cacheExtent, super.clipBehavior = Clip.hardEdge, required this.overscroll});
  void layoutChildSequence();
}
/// Theme configuration for [Timeline] widgets.
///
/// Provides styling and layout defaults for timeline components including
/// column constraints, spacing, indicator appearance, and connector styling.
/// Used with [ComponentTheme] to apply consistent timeline styling across
/// an application while allowing per-instance customization.
///
/// Example:
/// ```dart
/// ComponentTheme<TimelineTheme>(
///   data: TimelineTheme(
///     timeConstraints: BoxConstraints(minWidth: 100, maxWidth: 150),
///     spacing: 20.0,
///     dotSize: 16.0,
///     color: Colors.blue,
///     rowGap: 24.0,
///   ),
///   child: MyTimelineWidget(),
/// );
/// ```
class TimelineTheme extends ComponentThemeData {
/// Default constraints for the time column width.
///
/// Controls the minimum and maximum width allocated for displaying time
/// information in each timeline row. If null, individual Timeline widgets
/// use their own constraints or a default of 120 logical pixels.
  BoxConstraints? timeConstraints;
/// Default horizontal spacing between timeline columns.
///
/// Determines the gap between the time column, indicator column, and content
/// column. If null, defaults to 16 logical pixels scaled by theme scaling factor.
  double? spacing;
/// Default diameter of timeline indicator dots.
///
/// Controls the size of the circular (or square, based on theme radius) indicator
/// that marks each timeline entry. If null, defaults to 12 logical pixels.
  double? dotSize;
/// Default thickness of connector lines between timeline entries.
///
/// Controls the width of vertical lines that connect timeline indicators.
/// If null, defaults to 2 logical pixels scaled by theme scaling factor.
  double? connectorThickness;
/// Default color for indicators and connectors when not specified per entry.
///
/// Used as the fallback color for timeline dots and connecting lines when
/// individual [TimelineData] entries don't specify their own color.
  Color? color;
/// Default vertical spacing between timeline rows.
///
/// Controls the gap between each timeline entry in the vertical layout.
/// If null, defaults to 16 logical pixels scaled by theme scaling factor.
  double? rowGap;
/// Creates a [TimelineTheme] with the specified styling options.
///
/// All parameters are optional and will be merged with widget-level settings
/// or system defaults when not specified.
///
/// Parameters:
/// - [timeConstraints] (BoxConstraints?, optional): Width constraints for time column.
/// - [spacing] (double?, optional): Horizontal spacing between columns.
/// - [dotSize] (double?, optional): Size of timeline indicator dots.
/// - [connectorThickness] (double?, optional): Thickness of connecting lines.
/// - [color] (Color?, optional): Default color for indicators and connectors.
/// - [rowGap] (double?, optional): Vertical spacing between timeline entries.
  const TimelineTheme({this.timeConstraints, this.spacing, this.dotSize, this.connectorThickness, this.color, this.rowGap});
/// Creates a copy of this theme with the given values replaced.
///
/// Uses [ValueGetter] functions to allow conditional updates where
/// null getters preserve the original value.
///
/// Example:
/// ```dart
/// final newTheme = originalTheme.copyWith(
///   spacing: () => 24.0,
///   color: () => Colors.green,
/// );
/// ```
  TimelineTheme copyWith({ValueGetter<BoxConstraints?>? timeConstraints, ValueGetter<double?>? spacing, ValueGetter<double?>? dotSize, ValueGetter<double?>? connectorThickness, ValueGetter<Color?>? color, ValueGetter<double?>? rowGap});
  bool operator ==(Object other);
  int get hashCode;
}
/// Data model for individual timeline entries.
///
/// Represents a single item in a timeline with time information, title,
/// optional content, and optional custom color for the indicator and connector.
/// Used by [Timeline] to construct the visual timeline representation.
///
/// Example:
/// ```dart
/// TimelineData(
///   time: Text('2:30 PM'),
///   title: Text('Meeting Started'),
///   content: Text('Weekly team sync began with all members present.'),
///   color: Colors.green,
/// );
/// ```
class TimelineData {
/// Widget displaying the time or timestamp for this timeline entry.
///
/// Positioned in the left column of the timeline with right alignment.
/// Typically contains time information, dates, or sequence numbers.
  Widget time;
/// Widget displaying the main title or heading for this timeline entry.
///
/// Positioned in the right column as the primary content identifier.
/// Usually contains the event name, milestone title, or key description.
  Widget title;
/// Optional widget with additional details about this timeline entry.
///
/// Positioned below the title in the right column when provided.
/// Can contain descriptions, additional context, or supporting information.
  Widget? content;
/// Optional custom color for this entry's indicator and connector.
///
/// When provided, overrides the default theme color for this specific
/// timeline entry. If null, uses the theme's default color.
  Color? color;
/// Creates a [TimelineData] entry for use in [Timeline] widgets.
///
/// Parameters:
/// - [time] (Widget, required): Time or timestamp display widget.
/// - [title] (Widget, required): Main title or heading widget.
/// - [content] (Widget?, optional): Additional details widget.
/// - [color] (Color?, optional): Custom color for indicator and connector.
///
/// Example:
/// ```dart
/// TimelineData(
///   time: Text('10:00 AM', style: TextStyle(fontWeight: FontWeight.bold)),
///   title: Text('Project Kickoff'),
///   content: Text('Initial meeting to discuss project scope and timeline.'),
///   color: Colors.blue,
/// );
/// ```
  TimelineData({required this.time, required this.title, this.content, this.color});
}
/// A vertical timeline widget for displaying chronological data.
///
/// [Timeline] creates a structured vertical layout showing a sequence of events
/// or data points with time information, titles, optional content, and visual
/// indicators. Each entry is represented by a [TimelineData] object and displayed
/// with a consistent three-column layout:
///
/// 1. Left column: Time/timestamp information (right-aligned)
/// 2. Center column: Visual indicator dot and connecting lines
/// 3. Right column: Title and optional content
///
/// The timeline automatically handles:
/// - Proper spacing and alignment between columns
/// - Visual indicators with customizable colors per entry
/// - Connecting lines between entries (except for the last entry)
/// - Responsive sizing based on theme scaling
/// - Text styling consistent with the design system
///
/// Supports theming via [TimelineTheme] for consistent styling and can be
/// customized per instance with the [timeConstraints] parameter.
///
/// Example:
/// ```dart
/// Timeline(
///   data: [
///     TimelineData(
///       time: Text('9:00 AM'),
///       title: Text('Morning Standup'),
///       content: Text('Daily team sync to discuss progress and blockers.'),
///       color: Colors.green,
///     ),
///     TimelineData(
///       time: Text('2:00 PM'),
///       title: Text('Code Review'),
///       content: Text('Review pull requests and provide feedback.'),
///     ),
///   ],
/// );
/// ```
class Timeline extends StatelessWidget {
/// List of timeline entries to display.
///
/// Each [TimelineData] object represents one row in the timeline with
/// time information, title, optional content, and optional custom color.
/// The timeline renders entries in the order provided in this list.
  List<TimelineData> data;
/// Override constraints for the time column width.
///
/// When provided, overrides the theme's [TimelineTheme.timeConstraints]
/// for this specific timeline instance. Controls how much space is allocated
/// for displaying time information. If null, uses theme or default constraints.
  BoxConstraints? timeConstraints;
/// Creates a [Timeline] widget with the specified data entries.
///
/// Parameters:
/// - [data] (`List<TimelineData>`, required): Timeline entries to display in order.
/// - [timeConstraints] (BoxConstraints?, optional): Override width constraints for time column.
///
/// The timeline automatically handles layout, styling, and visual indicators
/// based on the current theme and provided data. Each entry's time, title,
/// content, and color are used to construct the appropriate visual representation.
///
/// Example:
/// ```dart
/// Timeline(
///   timeConstraints: BoxConstraints(minWidth: 80, maxWidth: 120),
///   data: [
///     TimelineData(
///       time: Text('Yesterday'),
///       title: Text('Initial Setup'),
///       content: Text('Project repository created and initial structure added.'),
///     ),
///     TimelineData(
///       time: Text('Today'),
///       title: Text('Feature Development'),
///       content: Text('Implementing core functionality and UI components.'),
///       color: Colors.orange,
///     ),
///   ],
/// );
/// ```
  const Timeline({super.key, required this.data, this.timeConstraints});
  Widget build(BuildContext context);
}
/// Reactive date input field with integrated date picker and text editing.
///
/// A high-level date input widget that combines text field functionality with
/// date picker integration. Provides automatic state management through the
/// controlled component pattern with support for both dialog and popover modes.
///
/// ## Features
///
/// - **Dual input modes**: Text field editing with date picker integration
/// - **Multiple presentation modes**: Dialog or popover-based date selection
/// - **Flexible date formatting**: Customizable date part ordering and separators
/// - **Calendar integration**: Rich calendar interface with multiple view types
/// - **Form integration**: Automatic validation and form field registration
/// - **Accessibility**: Full screen reader and keyboard navigation support
///
/// ## Usage Patterns
///
/// **Controller-based (recommended for complex state):**
/// ```dart
/// final controller = DatePickerController(DateTime.now());
///
/// DateInput(
///   controller: controller,
///   mode: PromptMode.popover,
///   placeholder: Text('Select date'),
/// )
/// ```
///
/// **Callback-based (simple state management):**
/// ```dart
/// DateTime? selectedDate;
///
/// DateInput(
///   initialValue: selectedDate,
///   onChanged: (date) => setState(() => selectedDate = date),
///   mode: PromptMode.dialog,
///   dialogTitle: Text('Choose Date'),
/// )
/// ```
class DateInput extends StatefulWidget with ControlledComponent<DateTime?> {
  DateTime? initialValue;
  ValueChanged<DateTime?>? onChanged;
  bool enabled;
  DatePickerController? controller;
/// Placeholder widget shown when no date is selected.
  Widget? placeholder;
/// Presentation mode for date picker (dialog or popover).
  PromptMode mode;
/// Initial calendar view to display.
  CalendarView? initialView;
/// Alignment of popover relative to anchor.
  AlignmentGeometry? popoverAlignment;
/// Alignment of anchor for popover positioning.
  AlignmentGeometry? popoverAnchorAlignment;
/// Padding inside the popover.
  EdgeInsetsGeometry? popoverPadding;
/// Title widget for dialog mode.
  Widget? dialogTitle;
/// Initial view type (date, month, or year).
  CalendarViewType? initialViewType;
/// Callback to determine date state (enabled/disabled).
  DateStateBuilder? stateBuilder;
/// Order of date components in the input display.
  List<DatePart>? datePartsOrder;
/// Separator widget between date parts.
  InputPart? separator;
/// Custom placeholders for individual date parts.
  Map<DatePart, Widget>? placeholders;
/// Creates a [DateInput].
///
/// Either [controller] or [onChanged] should be provided for interactivity.
/// The widget supports both controller-based and callback-based state management
/// patterns with flexible date picker integration options.
///
/// Parameters:
/// - [controller] (DatePickerController?, optional): external state controller
/// - [initialValue] (DateTime?, optional): starting date when no controller
/// - [onChanged] (`ValueChanged<DateTime?>?`, optional): date change callback
/// - [enabled] (bool, default: true): whether input is interactive
/// - [placeholder] (Widget?, optional): widget shown when no date selected
/// - [mode] (PromptMode, default: dialog): date picker presentation mode
/// - [initialView] (CalendarView?, optional): starting calendar view
/// - [popoverAlignment] (AlignmentGeometry?, optional): popover alignment
/// - [popoverAnchorAlignment] (AlignmentGeometry?, optional): anchor alignment
/// - [popoverPadding] (EdgeInsetsGeometry?, optional): popover padding
/// - [dialogTitle] (Widget?, optional): title for dialog mode
/// - [initialViewType] (CalendarViewType?, optional): calendar view type
/// - [stateBuilder] (DateStateBuilder?, optional): custom date state builder
/// - [datePartsOrder] (`List<DatePart>?`, optional): order of date components
/// - [separator] (InputPart?, optional): separator between date parts
/// - [placeholders] (`Map<DatePart, Widget>?`, optional): placeholders for date parts
///
/// Example:
/// ```dart
/// DateInput(
///   controller: controller,
///   mode: PromptMode.popover,
///   placeholder: Text('Select date'),
///   datePartsOrder: [DatePart.month, DatePart.day, DatePart.year],
/// )
/// ```
  const DateInput({super.key, this.controller, this.initialValue, this.onChanged, this.enabled = true, this.placeholder, this.mode = PromptMode.dialog, this.initialView, this.popoverAlignment, this.popoverAnchorAlignment, this.popoverPadding, this.dialogTitle, this.initialViewType, this.stateBuilder, this.datePartsOrder, this.separator, this.placeholders});
  State<DateInput> createState();
}
/// Represents a date with nullable components (year, month, day).
///
/// Useful for date input scenarios where individual date parts may be
/// missing or incomplete. Can convert to [DateTime] when all parts are present.
///
/// Example:
/// ```dart
/// final date = NullableDate(year: 2024, month: 1, day: 15);
/// print(date.nullableDate); // DateTime(2024, 1, 15)
/// ```
class NullableDate {
/// The year component (nullable).
  int? year;
/// The month component (nullable).
  int? month;
/// The day component (nullable).
  int? day;
/// Creates a [NullableDate].
///
/// Parameters:
/// - [year] (`int?`, optional): Year value.
/// - [month] (`int?`, optional): Month value (1-12).
/// - [day] (`int?`, optional): Day value (1-31).
  NullableDate({this.year, this.month, this.day});
  String toString();
  bool operator ==(Object other);
  int get hashCode;
/// Creates a copy with specified parts replaced.
///
/// Parameters:
/// - [year] (`ValueGetter<int?>?`, optional): New year value.
/// - [month] (`ValueGetter<int?>?`, optional): New month value.
/// - [day] (`ValueGetter<int?>?`, optional): New day value.
///
/// Returns: A new [NullableDate] with updated parts.
  NullableDate copyWith({ValueGetter<int?>? year, ValueGetter<int?>? month, ValueGetter<int?>? day});
/// Converts to [DateTime], using 1 for missing parts (month/day) to avoid year shift.
///
/// Returns: A [DateTime] instance (may be invalid if parts are null/0).
  DateTime get date;
/// Converts to [DateTime] only if all parts are present.
///
/// Returns: A [DateTime] if complete, otherwise null.
  DateTime? get nullableDate;
/// Converts to [DateTime] with default values if any part is null.
///
/// Parameters:
/// - [defaultYear] (`int`, optional): Default year value (0-9999).
/// - [defaultMonth] (`int`, optional): Default month value (1-12).
/// - [defaultDay] (`int`, optional): Default day value (1-31).
///
/// Returns: A [DateTime] instance with non-null parts.
  DateTime? getDateTime({int? defaultYear = 0, int? defaultMonth = 1, int? defaultDay = 1});
/// Retrieves the value of a specific date part.
///
/// Parameters:
/// - [part] (`DatePart`, required): The date part to retrieve.
///
/// Returns: The value of the specified part, or null if not set.
  int? operator [](DatePart part);
/// Converts to a map of date parts.
///
/// Returns: A `Map<DatePart, int>` with non-null parts.
  Map<DatePart, int> toMap();
}
/// Represents a time with nullable components (hour, minute, second).
///
/// Useful for time input scenarios where individual time parts may be
/// missing or incomplete. Can convert to [TimeOfDay] when hour and minute are present.
///
/// Example:
/// ```dart
/// final time = NullableTimeOfDay(hour: 14, minute: 30, second: 0);
/// print(time.toTimeOfDay); // TimeOfDay(hour: 14, minute: 30)
/// ```
class NullableTimeOfDay {
/// The hour component (nullable, 0-23).
  int? hour;
/// The minute component (nullable, 0-59).
  int? minute;
/// The second component (nullable, 0-59).
  int? second;
/// Creates a [NullableTimeOfDay].
///
/// Parameters:
/// - [hour] (`int?`, optional): Hour value (0-23).
/// - [minute] (`int?`, optional): Minute value (0-59).
/// - [second] (`int?`, optional): Second value (0-59).
  NullableTimeOfDay({this.hour, this.minute, this.second});
  String toString();
  bool operator ==(Object other);
  int get hashCode;
/// Creates a copy with specified parts replaced.
///
/// Parameters:
/// - [hour] (`ValueGetter<int?>?`, optional): New hour value.
/// - [minute] (`ValueGetter<int?>?`, optional): New minute value.
/// - [second] (`ValueGetter<int?>?`, optional): New second value.
///
/// Returns: A new [NullableTimeOfDay] with updated parts.
  NullableTimeOfDay copyWith({ValueGetter<int?>? hour, ValueGetter<int?>? minute, ValueGetter<int?>? second});
/// Converts to [TimeOfDay] if hour and minute are present.
///
/// Returns: A [TimeOfDay] instance, or null if hour, minute or second is null.
  TimeOfDay? get toTimeOfDay;
/// Converts to [TimeOfDay] with default values if any part is null.
///
/// Parameters:
/// - [defaultHour] (`int`, optional): Default hour value (0-23).
/// - [defaultMinute] (`int`, optional): Default minute value (0-59).
/// - [defaultSecond] (`int`, optional): Default second value (0-59).
///
/// Returns: A [TimeOfDay] instance with non-null parts.
  TimeOfDay? getTimeOfDay({int? defaultHour = 0, int? defaultMinute = 0, int? defaultSecond = 0});
/// Creates a [NullableTimeOfDay] from a [TimeOfDay].
///
/// Parameters:
/// - [timeOfDay] (`TimeOfDay?`, optional): The time to convert.
///
/// Returns: A [NullableTimeOfDay] instance, or null if input is null.
  static NullableTimeOfDay? fromTimeOfDay(TimeOfDay? timeOfDay);
/// Retrieves the value of a specific time part.
///
/// Parameters:
/// - [part] (`TimePart`, required): The time part to retrieve.
///
/// Returns: The value of the specified part, or null if not set.
  int? operator [](TimePart part);
/// Converts to a map of time parts.
///
/// Returns: A `Map<TimePart, int>` with non-null parts.
  Map<TimePart, int> toMap();
}
/// Reactive time input field with formatted text editing and validation.
///
/// A high-level time input widget that provides structured time entry through
/// formatted text fields. Supports hours, minutes, and optional seconds with
/// automatic state management through the controlled component pattern.
///
/// ## Features
///
/// - **Structured time entry**: Separate fields for hours, minutes, and seconds
/// - **Format validation**: Automatic validation and formatting of time components
/// - **Flexible display**: Optional seconds display and customizable separators
/// - **Form integration**: Automatic validation and form field registration
/// - **Keyboard navigation**: Tab navigation between time components
/// - **Accessibility**: Full screen reader support and keyboard input
///
/// ## Usage Patterns
///
/// **Controller-based (recommended for complex state):**
/// ```dart
/// final controller = ComponentController<TimeOfDay?>(TimeOfDay.now());
///
/// TimeInput(
///   controller: controller,
///   showSeconds: true,
///   placeholder: Text('Enter time'),
/// )
/// ```
///
/// **Callback-based (simple state management):**
/// ```dart
/// TimeOfDay? selectedTime;
///
/// TimeInput(
///   initialValue: selectedTime,
///   onChanged: (time) => setState(() => selectedTime = time),
///   showSeconds: false,
///   separator: InputPart.text(':'),
/// )
/// ```
class TimeInput extends StatefulWidget with ControlledComponent<TimeOfDay?> {
  TimeOfDay? initialValue;
  ValueChanged<TimeOfDay?>? onChanged;
  bool enabled;
  ComponentController<TimeOfDay?>? controller;
/// Placeholder widget shown when no time is selected.
  Widget? placeholder;
/// Whether to show seconds input field.
  bool showSeconds;
/// Separator widget between time parts.
  InputPart? separator;
/// Custom placeholders for individual time parts.
  Map<TimePart, Widget>? placeholders;
/// Creates a [TimeInput].
///
/// Either [controller] or [onChanged] should be provided for interactivity.
/// The widget supports both controller-based and callback-based state management
/// patterns with structured time component entry.
///
/// Parameters:
/// - [controller] (`ComponentController<TimeOfDay?>?`, optional): external state controller
/// - [initialValue] (TimeOfDay?, optional): starting time when no controller
/// - [onChanged] (`ValueChanged<TimeOfDay?>?`, optional): time change callback
/// - [enabled] (bool, default: true): whether input is interactive
/// - [placeholder] (Widget?, optional): widget shown when no time selected
/// - [showSeconds] (bool, default: false): whether to include seconds input
/// - [separator] (InputPart?, optional): separator between time components
/// - [placeholders] (`Map<TimePart, Widget>?`, optional): placeholders for time parts
///
/// Example:
/// ```dart
/// TimeInput(
///   controller: controller,
///   showSeconds: true,
///   separator: InputPart.text(':'),
///   placeholders: {
///     TimePart.hour: Text('HH'),
///     TimePart.minute: Text('MM'),
///     TimePart.second: Text('SS'),
///   },
/// )
/// ```
  const TimeInput({super.key, this.controller, this.initialValue, this.onChanged, this.enabled = true, this.placeholder, this.showSeconds = false, this.separator, this.placeholders});
  State<TimeInput> createState();
}
/// Reactive duration input field with formatted text editing and validation.
///
/// A high-level duration input widget that provides structured duration entry through
/// formatted text fields. Supports hours, minutes, and optional seconds with
/// automatic state management through the controlled component pattern.
///
/// ## Features
///
/// - **Structured duration entry**: Separate fields for hours, minutes, and seconds
/// - **Format validation**: Automatic validation and formatting of duration components
/// - **Flexible display**: Optional seconds display and customizable separators
/// - **Large value support**: Handle durations spanning multiple hours or days
/// - **Form integration**: Automatic validation and form field registration
/// - **Keyboard navigation**: Tab navigation between duration components
/// - **Accessibility**: Full screen reader support and keyboard input
///
/// ## Usage Patterns
///
/// **Controller-based (recommended for complex state):**
/// ```dart
/// final controller = ComponentController<Duration?>(Duration(hours: 1, minutes: 30));
///
/// DurationInput(
///   controller: controller,
///   showSeconds: true,
///   placeholder: Text('Enter duration'),
/// )
/// ```
///
/// **Callback-based (simple state management):**
/// ```dart
/// Duration? selectedDuration;
///
/// DurationInput(
///   initialValue: selectedDuration,
///   onChanged: (duration) => setState(() => selectedDuration = duration),
///   showSeconds: false,
///   separator: InputPart.text(':'),
/// )
/// ```
class DurationInput extends StatefulWidget with ControlledComponent<Duration?> {
  Duration? initialValue;
  ValueChanged<Duration?>? onChanged;
  bool enabled;
  ComponentController<Duration?>? controller;
/// Placeholder widget shown when no duration is selected.
  Widget? placeholder;
/// Whether to show seconds input field.
  bool showSeconds;
/// Separator widget between duration parts.
  InputPart? separator;
/// Custom placeholders for individual time parts.
  Map<TimePart, Widget>? placeholders;
/// Creates a [DurationInput].
///
/// Either [controller] or [onChanged] should be provided for interactivity.
/// The widget supports both controller-based and callback-based state management
/// patterns with structured duration component entry.
///
/// Parameters:
/// - [controller] (`ComponentController<Duration?>?`, optional): external state controller
/// - [initialValue] (Duration?, optional): starting duration when no controller
/// - [onChanged] (`ValueChanged<Duration?>?`, optional): duration change callback
/// - [enabled] (bool, default: true): whether input is interactive
/// - [placeholder] (Widget?, optional): widget shown when no duration selected
/// - [showSeconds] (bool, default: false): whether to include seconds input
/// - [separator] (InputPart?, optional): separator between duration components
/// - [placeholders] (`Map<TimePart, Widget>?`, optional): placeholders for time parts
///
/// Example:
/// ```dart
/// DurationInput(
///   controller: controller,
///   showSeconds: true,
///   separator: InputPart.text(':'),
///   placeholders: {
///     TimePart.hour: Text('HH'),
///     TimePart.minute: Text('MM'),
///     TimePart.second: Text('SS'),
///   },
/// )
/// ```
  const DurationInput({super.key, this.controller, this.initialValue, this.onChanged, this.enabled = true, this.placeholder, this.showSeconds = false, this.separator, this.placeholders});
  State<DurationInput> createState();
}
/// Theme configuration for [DatePicker] widget styling and behavior.
///
/// Defines the visual properties and default behaviors for date picker components
/// including presentation modes, calendar views, and popover positioning. Applied
/// globally through [ComponentTheme] or per-instance for customization.
///
/// Supports comprehensive customization of date picker appearance, initial views,
/// and interaction modes to match application design requirements.
class DatePickerTheme extends ComponentThemeData {
/// Default interaction mode for date picker triggers.
///
/// Determines whether date selection opens a popover or modal dialog.
/// When null, uses framework default prompt mode behavior.
  PromptMode? mode;
/// Initial calendar view to display when date picker opens.
///
/// Specifies the default time period view (month, year, decade, etc.)
/// shown when the calendar interface first appears. When null, uses
/// framework default initial view.
  CalendarView? initialView;
/// Initial calendar view type for date picker interface.
///
/// Determines the layout style and interaction pattern of the calendar
/// (grid, list, compact, etc.). When null, uses framework default view type.
  CalendarViewType? initialViewType;
/// Alignment point on the popover for anchor attachment.
///
/// Determines where the date picker popover positions itself relative
/// to the anchor widget. When null, uses framework default alignment.
  AlignmentGeometry? popoverAlignment;
/// Alignment point on the anchor widget for popover positioning.
///
/// Specifies which part of the trigger widget the popover should align to.
/// When null, uses framework default anchor alignment.
  AlignmentGeometry? popoverAnchorAlignment;
/// Internal padding applied to the date picker popover content.
///
/// Controls spacing around the calendar interface within the popover
/// container. When null, uses framework default padding.
  EdgeInsetsGeometry? popoverPadding;
/// Creates a [DatePickerTheme].
///
/// All parameters are optional and fall back to framework defaults when null.
/// The theme can be applied globally or to specific date picker instances.
  const DatePickerTheme({this.mode, this.initialView, this.initialViewType, this.popoverAlignment, this.popoverAnchorAlignment, this.popoverPadding});
/// Creates a copy of this theme with specified properties overridden.
  DatePickerTheme copyWith({ValueGetter<PromptMode?>? mode, ValueGetter<CalendarView?>? initialView, ValueGetter<CalendarViewType?>? initialViewType, ValueGetter<AlignmentGeometry?>? popoverAlignment, ValueGetter<AlignmentGeometry?>? popoverAnchorAlignment, ValueGetter<EdgeInsetsGeometry?>? popoverPadding});
  bool operator ==(Object other);
  int get hashCode;
}
/// A controller for managing the selected date in a [DatePicker].
///
/// [DatePickerController] extends [ValueNotifier] to hold the currently selected
/// date and notify listeners when it changes. Use this to programmatically control
/// the date picker or react to date selection changes.
///
/// Example:
/// ```dart
/// final controller = DatePickerController(DateTime.now());
/// controller.addListener(() {
///   print('Selected date: ${controller.value}');
/// });
/// ```
class DatePickerController extends ValueNotifier<DateTime?> with ComponentController<DateTime?> {
/// Creates a [DatePickerController] with the specified initial date.
  DatePickerController(super.value);
}
/// A controlled date picker widget with comprehensive date selection features.
///
/// [ControlledDatePicker] provides a complete date selection interface with
/// customizable presentation modes (popover or modal), calendar views, and
/// flexible positioning. It integrates with [DatePickerController] for
/// programmatic control.
///
/// Features:
/// - Multiple presentation modes (popover, modal)
/// - Various calendar views (month, year, decade)
/// - Custom date state builders
/// - Flexible positioning
/// - Optional placeholder when no date is selected
///
/// Example:
/// ```dart
/// ControlledDatePicker(
///   initialValue: DateTime.now(),
///   onChanged: (date) {
///     print('Selected: $date');
///   },
///   placeholder: Text('Select a date'),
/// )
/// ```
class ControlledDatePicker extends StatelessWidget with ControlledComponent<DateTime?> {
/// The initial date value.
  DateTime? initialValue;
/// Called when the selected date changes.
  ValueChanged<DateTime?>? onChanged;
/// Whether the date picker is enabled.
  bool enabled;
/// Optional controller for programmatic access.
  DatePickerController? controller;
/// Widget displayed when no date is selected.
  Widget? placeholder;
/// Presentation mode (popover or modal).
  PromptMode? mode;
/// Initial calendar view to display.
  CalendarView? initialView;
/// Popover alignment relative to the anchor.
  AlignmentGeometry? popoverAlignment;
/// Anchor alignment for popover positioning.
  AlignmentGeometry? popoverAnchorAlignment;
/// Internal padding for the popover.
  EdgeInsetsGeometry? popoverPadding;
/// Title for the dialog when using modal mode.
  Widget? dialogTitle;
/// Initial calendar view type.
  CalendarViewType? initialViewType;
/// Builder for customizing date cell states.
  DateStateBuilder? stateBuilder;
/// Creates a [ControlledDatePicker].
  const ControlledDatePicker({super.key, this.controller, this.initialValue, this.onChanged, this.enabled = true, this.placeholder, this.mode, this.initialView, this.popoverAlignment, this.popoverAnchorAlignment, this.popoverPadding, this.dialogTitle, this.initialViewType, this.stateBuilder});
  Widget build(BuildContext context);
}
/// A date picker widget for selecting dates.
///
/// Provides a date selection interface with calendar view in either
/// popover or dialog mode.
class DatePicker extends StatelessWidget {
/// The currently selected date value.
  DateTime? value;
/// Callback invoked when the selected date changes.
  ValueChanged<DateTime?>? onChanged;
/// Placeholder widget shown when no date is selected.
  Widget? placeholder;
/// The display mode for the date picker (popover or dialog).
  PromptMode? mode;
/// The initial calendar view to display.
  CalendarView? initialView;
/// Alignment of the popover relative to the anchor.
  AlignmentGeometry? popoverAlignment;
/// Anchor alignment for the popover.
  AlignmentGeometry? popoverAnchorAlignment;
/// Padding inside the popover.
  EdgeInsetsGeometry? popoverPadding;
/// Title widget for the dialog mode.
  Widget? dialogTitle;
/// The initial calendar view type (date, month, or year).
  CalendarViewType? initialViewType;
/// Builder function to determine the state of each date.
  DateStateBuilder? stateBuilder;
/// Whether the date picker is enabled.
  bool? enabled;
/// Creates a date picker.
  const DatePicker({super.key, required this.value, this.onChanged, this.placeholder, this.mode, this.initialView, this.popoverAlignment, this.popoverAnchorAlignment, this.popoverPadding, this.dialogTitle, this.initialViewType, this.stateBuilder, this.enabled});
  Widget build(BuildContext context);
}
/// Represents a range of dates with a start and end time.
///
/// Immutable value type for representing a continuous period between two dates.
/// Commonly used with date range pickers to specify selected date intervals.
///
/// Example:
/// ```dart
/// final range = DateTimeRange(
///   DateTime(2024, 1, 1),
///   DateTime(2024, 1, 31),
/// );
/// ```
class DateTimeRange {
/// The start date/time of the range.
  DateTime start;
/// The end date/time of the range.
  DateTime end;
/// Creates a [DateTimeRange].
///
/// Parameters:
/// - [start] (`DateTime`, required): The beginning of the range.
/// - [end] (`DateTime`, required): The end of the range.
  const DateTimeRange(this.start, this.end);
  bool operator ==(Object other);
  int get hashCode;
  String toString();
/// Creates a copy of this range with the given fields replaced.
///
/// Parameters:
/// - [start] (`ValueGetter<DateTime>?`, optional): New start date.
/// - [end] (`ValueGetter<DateTime>?`, optional): New end date.
///
/// Returns: A new [DateTimeRange] with updated values.
  DateTimeRange copyWith({ValueGetter<DateTime>? start, ValueGetter<DateTime>? end});
}
/// A widget for selecting a date range.
///
/// Provides an interactive date range picker that allows users to select a start
/// and end date. Supports both dialog and popover presentation modes with
/// customizable calendar views and state management.
///
/// Example:
/// ```dart
/// DateRangePicker(
///   value: currentRange,
///   onChanged: (range) => setState(() => currentRange = range),
///   mode: PromptMode.dialog,
/// )
/// ```
class DateRangePicker extends StatelessWidget {
/// The currently selected date range.
  DateTimeRange? value;
/// Callback when the date range changes.
  ValueChanged<DateTimeRange?>? onChanged;
/// Placeholder widget shown when no range is selected.
  Widget? placeholder;
/// Presentation mode (dialog or popover).
  PromptMode mode;
/// Initial calendar view to display.
  CalendarView? initialView;
/// Initial view type (date, month, or year).
  CalendarViewType? initialViewType;
/// Alignment of popover relative to anchor.
  AlignmentGeometry? popoverAlignment;
/// Alignment of anchor for popover positioning.
  AlignmentGeometry? popoverAnchorAlignment;
/// Padding inside the popover.
  EdgeInsetsGeometry? popoverPadding;
/// Title widget for dialog mode.
  Widget? dialogTitle;
/// Callback to determine date state (enabled/disabled).
  DateStateBuilder? stateBuilder;
/// Creates a [DateRangePicker].
///
/// Parameters:
/// - [value] (`DateTimeRange?`, required): Current selected range.
/// - [onChanged] (`ValueChanged<DateTimeRange?>?`, optional): Called when range changes.
/// - [placeholder] (`Widget?`, optional): Shown when no range selected.
/// - [mode] (`PromptMode`, default: `PromptMode.dialog`): Presentation mode.
/// - [initialView] (`CalendarView?`, optional): Starting calendar view.
/// - [initialViewType] (`CalendarViewType?`, optional): Starting view type.
/// - [popoverAlignment] (`AlignmentGeometry?`, optional): Popover alignment.
/// - [popoverAnchorAlignment] (`AlignmentGeometry?`, optional): Anchor alignment.
/// - [popoverPadding] (`EdgeInsetsGeometry?`, optional): Popover padding.
/// - [dialogTitle] (`Widget?`, optional): Dialog title.
/// - [stateBuilder] (`DateStateBuilder?`, optional): Date state callback.
  const DateRangePicker({super.key, required this.value, this.onChanged, this.placeholder, this.mode = PromptMode.dialog, this.initialView, this.popoverAlignment, this.popoverAnchorAlignment, this.popoverPadding, this.dialogTitle, this.initialViewType, this.stateBuilder});
  Widget build(BuildContext context);
}
/// Theme data for customizing [StarRating] widget appearance.
///
/// This class defines the visual properties that can be applied to
/// [StarRating] widgets, including colors for filled and unfilled stars,
/// star sizing, and spacing between stars. These properties can be set
/// at the theme level to provide consistent styling across the application.
class StarRatingTheme extends ComponentThemeData {
/// The color of the filled portion of the stars.
  Color? activeColor;
/// The color of the unfilled portion of the stars.
  Color? backgroundColor;
/// The size of each star.
  double? starSize;
/// The spacing between stars.
  double? starSpacing;
/// Creates a [StarRatingTheme].
  const StarRatingTheme({this.activeColor, this.backgroundColor, this.starSize, this.starSpacing});
/// Returns a copy of this theme with the given fields replaced.
  StarRatingTheme copyWith({ValueGetter<Color?>? activeColor, ValueGetter<Color?>? backgroundColor, ValueGetter<double?>? starSize, ValueGetter<double?>? starSpacing});
  bool operator ==(Object other);
  int get hashCode;
}
/// A controller for managing [StarRating] widget values programmatically.
///
/// This controller extends [ValueNotifier] and implements [ComponentController]
/// to provide a standardized way to control star rating values externally.
/// It allows programmatic manipulation of the rating value and provides
/// change notification capabilities.
///
/// The controller maintains a double value representing the current rating,
/// which is typically in the range of 0.0 to the maximum rating value.
///
/// Example:
/// ```dart
/// final controller = StarRatingController(3.5);
///
/// // Listen to changes
/// controller.addListener(() {
///   print('Rating changed to: ${controller.value}');
/// });
///
/// // Update the rating
/// controller.value = 4.0;
/// ```
class StarRatingController extends ValueNotifier<double> with ComponentController<double> {
/// Creates a [StarRatingController] with the given initial [value].
///
/// The [value] parameter sets the initial rating value. Defaults to 0.0
/// if not specified. The value should typically be within the range
/// supported by the star rating widget (0.0 to max value).
///
/// Parameters:
/// - [value] (double, default: 0.0): Initial rating value
  StarRatingController([super.value = 0.0]);
}
/// Reactive star rating widget with automatic state management and controller support.
///
/// A high-level star rating widget that provides automatic state management through
/// the controlled component pattern. Supports both controller-based and callback-based
/// state management with comprehensive customization options for star appearance,
/// interaction behavior, and rating precision.
///
/// ## Features
///
/// - **Fractional ratings**: Support for decimal values (e.g., 3.5 stars)
/// - **Step control**: Configurable rating increments for precision
/// - **Visual customization**: Comprehensive star shape and appearance options
/// - **Interactive feedback**: Touch and drag support for rating selection
/// - **Form integration**: Automatic validation and form field registration
/// - **Accessibility**: Full screen reader and keyboard navigation support
///
/// ## Usage Patterns
///
/// **Controller-based (recommended for complex state):**
/// ```dart
/// final controller = StarRatingController(3.5);
///
/// ControlledStarRating(
///   controller: controller,
///   max: 5.0,
///   step: 0.5,
///   activeColor: Colors.amber,
/// )
/// ```
///
/// **Callback-based (simple state management):**
/// ```dart
/// double currentRating = 0.0;
///
/// ControlledStarRating(
///   initialValue: currentRating,
///   onChanged: (rating) => setState(() => currentRating = rating),
///   max: 5.0,
///   step: 1.0,
/// )
/// ```
class ControlledStarRating extends StatelessWidget with ControlledComponent<double> {
  double initialValue;
  ValueChanged<double>? onChanged;
  bool enabled;
  StarRatingController? controller;
/// The minimum increment for rating changes.
///
/// When a user interacts with the star rating, the value will snap to
/// multiples of this step. For example, a step of `0.5` allows half-star
/// ratings, while `1.0` allows only whole-star ratings.
  double step;
/// The layout direction of the stars.
///
/// Stars can be arranged horizontally ([Axis.horizontal]) or vertically
/// ([Axis.vertical]). Defaults to horizontal.
  Axis direction;
/// The maximum rating value.
///
/// Determines how many stars are displayed. For example, `max: 5.0` shows
/// 5 stars. Defaults to `5.0`.
  double max;
/// The color of filled star portions.
///
/// If `null`, uses the theme's primary color.
  Color? activeColor;
/// The color of unfilled star portions.
///
/// If `null`, uses a default background color from the theme.
  Color? backgroundColor;
/// The number of points per star.
///
/// Controls the star shape. Defaults to `5` for traditional five-pointed
/// stars. Higher values create stars with more points.
  double starPoints;
/// Override size of each star.
///
/// If `null`, uses the default size from the theme.
  double? starSize;
/// Override spacing between stars.
///
/// If `null`, uses the default spacing from the theme.
  double? starSpacing;
/// Rounding radius for star points.
///
/// Controls how rounded the tips of the star points appear. If `null`,
/// uses sharp points.
  double? starPointRounding;
/// Rounding radius for star valleys.
///
/// Controls how rounded the inner valleys between star points appear.
/// If `null`, uses sharp valleys.
  double? starValleyRounding;
/// Vertical compression factor for stars.
///
/// Values less than `1.0` make stars appear squashed. If `null`, stars
/// maintain their natural proportions.
  double? starSquash;
/// Inner to outer radius ratio for stars.
///
/// Controls the depth of star valleys. Lower values create deeper valleys.
/// If `null`, uses a default ratio.
  double? starInnerRadiusRatio;
/// Rotation angle for stars in radians.
///
/// Rotates each star by this angle. If `null`, stars are not rotated.
  double? starRotation;
/// Creates a [ControlledStarRating].
///
/// Either [controller] or [onChanged] should be provided for interactivity.
/// The widget supports both controller-based and callback-based state management
/// patterns with extensive star appearance customization options.
///
/// Parameters:
/// - [controller] (StarRatingController?, optional): external state controller
/// - [initialValue] (double, default: 0.0): starting rating when no controller
/// - [onChanged] (`ValueChanged<double>?`, optional): rating change callback
/// - [enabled] (bool, default: true): whether star rating is interactive
/// - [step] (double, default: 0.5): minimum increment for rating changes
/// - [direction] (Axis, default: horizontal): layout direction of stars
/// - [max] (double, default: 5.0): maximum rating value
/// - [activeColor] (Color?, optional): color of filled star portions
/// - [backgroundColor] (Color?, optional): color of unfilled star portions
/// - [starPoints] (double, default: 5): number of points per star
/// - [starSize] (double?, optional): override size of each star
/// - [starSpacing] (double?, optional): override spacing between stars
/// - [starPointRounding] (double?, optional): rounding radius for star points
/// - [starValleyRounding] (double?, optional): rounding radius for star valleys
/// - [starSquash] (double?, optional): vertical compression factor
/// - [starInnerRadiusRatio] (double?, optional): inner to outer radius ratio
/// - [starRotation] (double?, optional): rotation angle in radians
///
/// Example:
/// ```dart
/// ControlledStarRating(
///   controller: controller,
///   max: 5.0,
///   step: 0.1,
///   activeColor: Colors.amber,
///   backgroundColor: Colors.grey[300],
/// )
/// ```
  const ControlledStarRating({super.key, this.controller, this.initialValue = 0.0, this.onChanged, this.enabled = true, this.step = 0.5, this.direction = Axis.horizontal, this.max = 5.0, this.activeColor, this.backgroundColor, this.starPoints = 5, this.starSize, this.starSpacing, this.starPointRounding, this.starValleyRounding, this.starSquash, this.starInnerRadiusRatio, this.starRotation});
  Widget build(BuildContext context);
}
/// An interactive star rating widget for collecting user feedback and ratings.
///
/// [StarRating] provides a customizable rating interface using star-shaped
/// indicators that users can tap or drag to select a rating value. The widget
/// supports fractional ratings, customizable star appearance, and both horizontal
/// and vertical orientations.
///
/// Key features:
/// - Interactive star-based rating selection
/// - Support for fractional ratings (e.g., 3.5 stars)
/// - Customizable star shape with points, rounding, and squashing
/// - Horizontal and vertical layout orientations
/// - Configurable step increments for rating precision
/// - Visual feedback with filled/unfilled star indicators
/// - Touch and drag interaction support
/// - Accessibility integration
///
/// The widget displays a series of star shapes that fill based on the current
/// rating value. Users can interact with the stars to select new rating values,
/// with support for fine-grained control through the step parameter.
///
/// Star appearance can be extensively customized:
/// - Number of points per star
/// - Star size and spacing
/// - Point and valley rounding
/// - Star squashing and inner radius ratio
/// - Rotation angle
/// - Fill and background colors
///
/// Example:
/// ```dart
/// StarRating(
///   value: currentRating,
///   max: 5.0,
///   step: 0.5, // Allow half-star ratings
///   onChanged: (rating) => setState(() => currentRating = rating),
///   activeColor: Colors.amber,
///   backgroundColor: Colors.grey[300],
/// );
/// ```
class StarRating extends StatefulWidget {
/// The current rating value.
///
/// Should be between `0` and [max]. Fractional values are supported.
  double value;
/// Callback invoked when the rating changes.
///
/// If `null`, the widget is in read-only mode.
  ValueChanged<double>? onChanged;
/// The minimum increment for rating changes.
///
/// When a user interacts with the stars, the value will snap to multiples
/// of this step. Defaults to `0.5` for half-star precision.
  double step;
/// The layout direction of the stars.
///
/// Can be [Axis.horizontal] or [Axis.vertical]. Defaults to horizontal.
  Axis direction;
/// The maximum rating value.
///
/// Determines how many stars are displayed. Defaults to `5.0`.
  double max;
/// The color of filled star portions.
///
/// If `null`, uses the theme's primary color.
  Color? activeColor;
/// The color of unfilled star portions.
///
/// If `null`, uses a default background color from the theme.
  Color? backgroundColor;
/// The number of points per star.
///
/// Defaults to `5` for traditional five-pointed stars.
  double starPoints;
/// Override size of each star.
///
/// If `null`, uses the default size from the theme.
  double? starSize;
/// Override spacing between stars.
///
/// If `null`, uses the default spacing from the theme.
  double? starSpacing;
/// Rounding radius for star points.
///
/// Controls how rounded the tips of the star points appear. If `null`,
/// uses sharp points.
  double? starPointRounding;
/// Rounding radius for star valleys.
///
/// Controls how rounded the inner valleys between star points appear.
/// If `null`, uses sharp valleys.
  double? starValleyRounding;
/// Vertical compression factor for stars.
///
/// Values less than `1.0` make stars appear squashed. If `null`, stars
/// maintain their natural proportions.
  double? starSquash;
/// Inner to outer radius ratio for stars.
///
/// Controls the depth of star valleys. Lower values create deeper valleys.
/// If `null`, uses a default ratio.
  double? starInnerRadiusRatio;
/// Rotation angle for stars in radians.
///
/// Rotates each star by this angle. If `null`, stars are not rotated.
  double? starRotation;
/// Whether the star rating is interactive.
///
/// When `false`, the widget is in read-only mode. Defaults to `true` if
/// [onChanged] is provided.
  bool? enabled;
/// Creates a [StarRating].
  const StarRating({super.key, required this.value, this.onChanged, this.step = 0.5, this.direction = Axis.horizontal, this.max = 5.0, this.activeColor, this.backgroundColor, this.starPoints = 5, this.starSize, this.starSpacing, this.starPointRounding, this.starValleyRounding, this.starSquash, this.starInnerRadiusRatio, this.starRotation, this.enabled});
  State<StarRating> createState();
}
/// Intent for increasing the star rating value via keyboard shortcuts.
///
/// Used with Flutter's shortcuts and actions system to handle keyboard
/// input for incrementing the rating. Typically bound to right arrow key.
class IncreaseStarIntent extends Intent {
/// The step size to increase the rating by.
  double step;
/// Creates an [IncreaseStarIntent].
  const IncreaseStarIntent(this.step);
}
/// Intent for decreasing the star rating value via keyboard shortcuts.
///
/// Used with Flutter's shortcuts and actions system to handle keyboard
/// input for decrementing the rating. Typically bound to left arrow key.
class DecreaseStarIntent extends Intent {
/// The step size to decrease the rating by.
  double step;
/// Creates a [DecreaseStarIntent].
  const DecreaseStarIntent(this.step);
}
/// Position where an input feature is displayed.
///
/// Determines whether an input feature (icon, button, widget) appears on
/// the leading (left/start) or trailing (right/end) side of the input.
enum InputFeaturePosition { leading, trailing, above, below }
/// Adds a hint/info button to the input field with a popover.
///
/// Displays an icon button that shows a popover with additional information
/// when clicked. Optionally supports keyboard shortcuts (F1) to open the hint.
///
/// Example:
/// ```dart
/// TextField(
///   features: [
///     InputHintFeature(
///       popupBuilder: (context) => const Text('Enter your email'),
///       icon: Icon(Icons.help),
///     ),
///   ],
/// )
/// ```
class InputHintFeature extends InputFeature {
/// Builder for the hint popover content.
  WidgetBuilder popupBuilder;
/// Custom icon to display (defaults to info icon).
  Widget? icon;
/// Position of the hint button.
  InputFeaturePosition position;
/// Whether to enable keyboard shortcut (F1) to show the hint.
  bool enableShortcuts;
/// Creates an [InputHintFeature].
///
/// Parameters:
/// - [popupBuilder] (`WidgetBuilder`, required): Builds the hint content.
/// - [position] (`InputFeaturePosition`, default: `InputFeaturePosition.trailing`):
///   Where to place the hint icon.
/// - [icon] (`Widget?`, optional): Custom icon widget.
/// - [enableShortcuts] (`bool`, default: `true`): Enable F1 keyboard shortcut.
/// - [visibility] (`InputFeatureVisibility`, optional): Controls visibility.
/// - [skipFocusTraversal] (`bool`, optional): Whether to skip in focus order.
  const InputHintFeature({super.visibility, super.skipFocusTraversal, required this.popupBuilder, this.position = InputFeaturePosition.trailing, this.icon, this.enableShortcuts = true});
  InputFeatureState createState();
}
/// Intent to show an input hint popover.
///
/// Used in keyboard shortcut actions to trigger the hint display.
class InputShowHintIntent extends Intent {
/// Creates an [InputShowHintIntent].
  const InputShowHintIntent();
}
/// Mode for password visibility toggling.
///
/// Determines whether the password visibility toggle holds (shows while pressed)
/// or toggles (switches state on each press).
enum PasswordPeekMode { hold, toggle }
/// Adds a password visibility toggle feature to the input field.
///
/// Provides a button that allows users to toggle between showing and hiding
/// password text. Supports both hold-to-reveal and toggle modes.
///
/// Example:
/// ```dart
/// TextField(
///   obscureText: true,
///   features: [
///     InputPasswordToggleFeature(
///       mode: PasswordPeekMode.toggle,
///     ),
///   ],
/// )
/// ```
class InputPasswordToggleFeature extends InputFeature {
/// The mode for password peeking behavior.
  PasswordPeekMode mode;
/// Position of the toggle button.
  InputFeaturePosition position;
/// Icon to display when password is hidden.
  Widget? icon;
/// Icon to display when password is shown.
  Widget? iconShow;
/// Creates an [InputPasswordToggleFeature].
///
/// Parameters:
/// - [mode] (`PasswordPeekMode`, default: `PasswordPeekMode.toggle`):
///   Toggle or hold behavior.
/// - [position] (`InputFeaturePosition`, default: `InputFeaturePosition.trailing`):
///   Where to place the toggle.
/// - [icon] (`Widget?`, optional): Custom icon for hidden state.
/// - [iconShow] (`Widget?`, optional): Custom icon for visible state.
/// - [visibility] (`InputFeatureVisibility`, optional): Controls visibility.
/// - [skipFocusTraversal] (`bool`, optional): Whether to skip in focus order.
  const InputPasswordToggleFeature({super.visibility, this.icon, this.iconShow, this.mode = PasswordPeekMode.toggle, this.position = InputFeaturePosition.trailing, super.skipFocusTraversal});
  InputFeatureState createState();
}
/// Adds a clear button to the input field.
///
/// Provides a button that clears all text from the input when pressed.
/// Commonly used to improve user experience by offering quick text removal.
///
/// Example:
/// ```dart
/// TextField(
///   features: [
///     InputClearFeature(
///       position: InputFeaturePosition.trailing,
///     ),
///   ],
/// )
/// ```
class InputClearFeature extends InputFeature {
/// Position of the clear button.
  InputFeaturePosition position;
/// Custom icon for the clear button.
  Widget? icon;
/// Creates an [InputClearFeature].
///
/// Parameters:
/// - [position] (`InputFeaturePosition`, default: `InputFeaturePosition.trailing`):
///   Where to place the clear button.
/// - [icon] (`Widget?`, optional): Custom icon widget.
/// - [visibility] (`InputFeatureVisibility`, optional): Controls visibility.
/// - [skipFocusTraversal] (`bool`, optional): Whether to skip in focus order.
  const InputClearFeature({super.visibility, super.skipFocusTraversal, this.position = InputFeaturePosition.trailing, this.icon});
  InputFeatureState createState();
}
/// Adds a revalidate button to the input field.
///
/// Provides a button that triggers form validation when pressed.
/// Useful for manually triggering validation after user input.
///
/// Example:
/// ```dart
/// TextField(
///   features: [
///     InputRevalidateFeature(),
///   ],
/// )
/// ```
class InputRevalidateFeature extends InputFeature {
/// Position of the revalidate button.
  InputFeaturePosition position;
/// Custom icon for the revalidate button.
  Widget? icon;
/// Creates an [InputRevalidateFeature].
///
/// Parameters:
/// - [position] (`InputFeaturePosition`, default: `InputFeaturePosition.trailing`):
///   Where to place the revalidate button.
/// - [icon] (`Widget?`, optional): Custom icon widget.
/// - [visibility] (`InputFeatureVisibility`, optional): Controls visibility.
/// - [skipFocusTraversal] (`bool`, optional): Whether to skip in focus order.
  const InputRevalidateFeature({super.visibility, super.skipFocusTraversal, this.position = InputFeaturePosition.trailing, this.icon});
  InputFeatureState createState();
}
/// Adds autocomplete functionality to the input field.
///
/// Displays a popover with suggestions as the user types. Suggestions are
/// provided by the [querySuggestions] callback and can be selected to fill
/// the input.
///
/// Example:
/// ```dart
/// TextField(
///   features: [
///     InputAutoCompleteFeature(
///       querySuggestions: (query) async {
///         return ['apple', 'apricot', 'avocado']
///             .where((s) => s.startsWith(query));
///       },
///       child: const Text('Fruits'),
///     ),
///   ],
/// )
/// ```
class InputAutoCompleteFeature extends InputFeature {
/// Callback to provide suggestions for a given query.
  SuggestionBuilder querySuggestions;
/// Child widget displayed in the suggestion list.
  Widget child;
/// Constraints for the popover size.
  BoxConstraints? popoverConstraints;
/// Width constraint for the popover.
  PopoverConstraint? popoverWidthConstraint;
/// Anchor alignment for the popover.
  AlignmentDirectional? popoverAnchorAlignment;
/// Popover alignment relative to the anchor.
  AlignmentDirectional? popoverAlignment;
/// Autocomplete mode (e.g., popover or inline).
  AutoCompleteMode mode;
/// Creates an [InputAutoCompleteFeature].
///
/// Parameters:
/// - [querySuggestions] (`SuggestionBuilder`, required): Provides suggestions.
/// - [child] (`Widget`, required): Content for suggestion items.
/// - [popoverConstraints] (`BoxConstraints?`, optional): Size constraints.
/// - [popoverWidthConstraint] (`PopoverConstraint?`, optional): Width constraint.
/// - [popoverAnchorAlignment] (`AlignmentDirectional?`, optional): Anchor alignment.
/// - [popoverAlignment] (`AlignmentDirectional?`, optional): Popover alignment.
/// - [mode] (`AutoCompleteMode`, required): Autocomplete display mode.
/// - [visibility] (`InputFeatureVisibility`, optional): Controls visibility.
/// - [skipFocusTraversal] (`bool`, optional): Whether to skip in focus order.
  const InputAutoCompleteFeature({super.visibility, super.skipFocusTraversal, required this.querySuggestions, required this.child, this.popoverConstraints, this.popoverWidthConstraint, this.popoverAnchorAlignment, this.popoverAlignment, this.mode = AutoCompleteMode.replaceWord});
  InputFeatureState createState();
}
/// Adds spinner controls (increment/decrement) to numeric input fields.
///
/// Provides up/down buttons to adjust numeric values in fixed steps.
/// Optionally supports gesture-based adjustments (e.g., drag to change value).
///
/// Example:
/// ```dart
/// TextField(
///   keyboardType: TextInputType.number,
///   features: [
///     InputSpinnerFeature(
///       step: 5.0,
///       enableGesture: true,
///     ),
///   ],
/// )
/// ```
class InputSpinnerFeature extends InputFeature {
/// The amount to increment or decrement on each step.
  double step;
/// Whether to enable gesture-based value adjustment.
  bool enableGesture;
/// Default value when the input is invalid or empty.
  double? invalidValue;
/// Minimum allowed value.
  double? min;
/// Maximum allowed value.
  double? max;
/// Creates an [InputSpinnerFeature].
///
/// Parameters:
/// - [step] (`double`, default: `1.0`): Increment/decrement step size.
/// - [enableGesture] (`bool`, default: `true`): Enable drag gestures.
/// - [invalidValue] (`double?`, default: `0.0`): Fallback value for invalid input.
/// - [min] (`double?`, optional): Minimum allowed value.
/// - [max] (`double?`, optional): Maximum allowed value.
/// - [visibility] (`InputFeatureVisibility`, optional): Controls visibility.
/// - [skipFocusTraversal] (`bool`, optional): Whether to skip in focus order.
  const InputSpinnerFeature({super.visibility, super.skipFocusTraversal, this.step = 1.0, this.enableGesture = true, this.invalidValue = 0.0, this.min, this.max});
  InputFeatureState createState();
}
/// Adds a single increment button to numeric input fields.
///
/// Provides a button that increases the numeric value by a fixed step.
class InputStepperButtonFeature extends InputFeature {
/// The amount to increment on each press.
  double step;
/// Default value when the input is invalid or empty.
  double? invalidValue;
/// Minimum allowed value.
  double? min;
/// Maximum allowed value.
  double? max;
/// Position of the increment button.
  InputFeaturePosition position;
/// Custom icon for the increment button.
  Widget? icon;
/// Creates an [InputStepperButtonFeature].
///
/// Parameters:
/// - [step] (`double`, default: `1.0`): Increment step size.
/// - [invalidValue] (`double?`, default: `0.0`): Fallback value for invalid input.
/// - [min] (`double?`, optional): Minimum allowed value.
/// - [max] (`double?`, optional): Maximum allowed value.
/// - [position] (`InputFeaturePosition`, default: `InputFeaturePosition.trailing`):
///   Where to place the button.
/// - [icon] (`Widget?`, optional): Custom icon widget.
/// - [visibility] (`InputFeatureVisibility`, optional): Controls visibility.
/// - [skipFocusTraversal] (`bool`, optional): Whether to skip in focus order.
  const InputStepperButtonFeature({super.visibility, super.skipFocusTraversal, this.step = 1.0, this.invalidValue = 0.0, this.min, this.max, this.position = InputFeaturePosition.trailing, this.icon = const Icon(LucideIcons.plus)});
/// Creates a decrement button feature for numeric inputs.
///
/// Parameters:
/// - [step] (`double`, default: `-1.0`): Decrement step size.
/// - [invalidValue] (`double?`, default: `0.0`): Fallback value for invalid input.
/// - [min] (`double?`, optional): Minimum allowed value.
/// - [max] (`double?`, optional): Maximum allowed value.
/// - [position] (`InputFeaturePosition`, default: `InputFeaturePosition.trailing`):
///   Where to place the button.
/// - [icon] (`Widget?`, optional): Custom icon widget.
/// - [visibility] (`InputFeatureVisibility`, optional): Controls visibility.
/// - [skipFocusTraversal] (`bool`, optional): Whether to skip in focus order.
  const InputStepperButtonFeature.decrement({super.visibility, super.skipFocusTraversal, this.step = -1.0, this.invalidValue = 0.0, this.min, this.max, this.position = InputFeaturePosition.trailing, this.icon = const Icon(LucideIcons.minus)});
  InputFeatureState createState();
}
/// Adds a copy button to the input field.
///
/// Provides a button that copies the current input text to the clipboard.
/// Useful for allowing users to easily copy generated or displayed content.
///
/// Example:
/// ```dart
/// TextField(
///   controller: TextEditingController(text: 'Copy me!'),
///   features: [
///     InputCopyFeature(),
///   ],
/// )
/// ```
class InputCopyFeature extends InputFeature {
/// Position of the copy button.
  InputFeaturePosition position;
/// Custom icon for the copy button.
  Widget? icon;
/// Creates an [InputCopyFeature].
///
/// Parameters:
/// - [position] (`InputFeaturePosition`, default: `InputFeaturePosition.trailing`):
///   Where to place the copy button.
/// - [icon] (`Widget?`, optional): Custom icon widget.
/// - [visibility] (`InputFeatureVisibility`, optional): Controls visibility.
/// - [skipFocusTraversal] (`bool`, optional): Whether to skip in focus order.
  const InputCopyFeature({super.visibility, super.skipFocusTraversal, this.position = InputFeaturePosition.trailing, this.icon});
  InputFeatureState createState();
}
/// Adds a custom widget to the leading (left) side of the input field.
///
/// Allows you to place any widget before the input text, such as icons,
/// labels, or other decorative elements.
///
/// Example:
/// ```dart
/// TextField(
///   features: [
///     InputLeadingFeature(
///       Icon(Icons.search),
///     ),
///   ],
/// )
/// ```
class InputLeadingFeature extends InputFeature {
/// The widget to display on the leading side.
  Widget prefix;
/// Creates an [InputLeadingFeature].
///
/// Parameters:
/// - [prefix] (`Widget`, required): The widget to show before the input.
/// - [visibility] (`InputFeatureVisibility`, optional): Controls visibility.
/// - [skipFocusTraversal] (`bool`, optional): Whether to skip in focus order.
  const InputLeadingFeature(this.prefix, {super.visibility, super.skipFocusTraversal});
  InputFeatureState createState();
}
/// Adds a custom widget to the trailing (right) side of the input field.
///
/// Allows you to place any widget after the input text, such as icons,
/// buttons, or other decorative elements.
///
/// Example:
/// ```dart
/// TextField(
///   features: [
///     InputTrailingFeature(
///       Icon(Icons.arrow_forward),
///     ),
///   ],
/// )
/// ```
class InputTrailingFeature extends InputFeature {
/// The widget to display on the trailing side.
  Widget suffix;
/// Creates an [InputTrailingFeature].
///
/// Parameters:
/// - [suffix] (`Widget`, required): The widget to show after the input.
/// - [visibility] (`InputFeatureVisibility`, optional): Controls visibility.
/// - [skipFocusTraversal] (`bool`, optional): Whether to skip in focus order.
  const InputTrailingFeature(this.suffix, {super.visibility, super.skipFocusTraversal});
  InputFeatureState createState();
}
/// Adds a custom widget above or below the text input area.
///
/// Use this feature to place helper content inside the input decoration,
/// directly above or below the editable text.
///
/// Example:
/// ```dart
/// TextField(
///   features: [
///     InputAboveBelowFeature(
///       child: Text('Billing email').small().muted(),
///       position: InputFeaturePosition.above,
///     ),
///   ],
/// )
/// ```
class InputAboveBelowFeature extends InputFeature {
/// Widget shown above or below the editable text.
  Widget? child;
/// Position of the [child] relative to the editable text.
  InputFeaturePosition position;
/// Creates an [InputAboveBelowFeature].
///
/// Parameters:
/// - [child] (`Widget?`, optional): Widget displayed above or below the input text.
/// - [position] (`InputFeaturePosition`, default: `InputFeaturePosition.below`): Placement.
/// - [visibility] (`InputFeatureVisibility`, optional): Controls visibility.
/// - [skipFocusTraversal] (`bool`, optional): Whether to skip in focus order.
  const InputAboveBelowFeature({super.visibility, super.skipFocusTraversal, this.child, this.position = InputFeaturePosition.below});
/// Creates an [InputAboveBelowFeature] displayed above the input text.
///
/// Parameters:
/// - [child] (`Widget?`, optional): Widget displayed above the input text.
/// - [visibility] (`InputFeatureVisibility`, optional): Controls visibility.
/// - [skipFocusTraversal] (`bool`, optional): Whether to skip in focus order.
  const InputAboveBelowFeature.above(this.child, {super.visibility, super.skipFocusTraversal});
/// Creates an [InputAboveBelowFeature] displayed below the input text.
///
/// Parameters:
/// - [child] (`Widget?`, optional): Widget displayed below the input text.
/// - [visibility] (`InputFeatureVisibility`, optional): Controls visibility.
/// - [skipFocusTraversal] (`bool`, optional): Whether to skip in focus order.
  const InputAboveBelowFeature.below(this.child, {super.visibility, super.skipFocusTraversal});
  InputFeatureState createState();
}
/// Adds a paste button to the input field.
///
/// Provides a button that pastes content from the clipboard into the input.
/// Useful for improving user experience when entering copied data.
///
/// Example:
/// ```dart
/// TextField(
///   features: [
///     InputPasteFeature(
///       position: InputFeaturePosition.trailing,
///     ),
///   ],
/// )
/// ```
class InputPasteFeature extends InputFeature {
/// Position of the paste button.
  InputFeaturePosition position;
/// Custom icon for the paste button.
  Widget? icon;
/// Creates an [InputPasteFeature].
///
/// Parameters:
/// - [position] (`InputFeaturePosition`, default: `InputFeaturePosition.trailing`):
///   Where to place the paste button.
/// - [icon] (`Widget?`, optional): Custom icon widget.
/// - [visibility] (`InputFeatureVisibility`, optional): Controls visibility.
/// - [skipFocusTraversal] (`bool`, optional): Whether to skip in focus order.
  const InputPasteFeature({super.visibility, super.skipFocusTraversal, this.position = InputFeaturePosition.trailing, this.icon});
  InputFeatureState createState();
}
/// A multi-line text input widget with resizable dimensions and comprehensive styling.
///
/// [TextArea] provides an enhanced text editing experience with support for
/// multi-line input, dynamic resizing capabilities, and extensive customization
/// options. It supports both expandable height and width modes, allowing users
/// to adjust the text area size by dragging resize handles.
///
/// Key features:
/// - Multi-line text editing with optional height/width expansion
/// - Configurable minimum and maximum dimensions
/// - Support for leading and trailing widgets
/// - Comprehensive text formatting and input validation
/// - Integration with Flutter's text editing ecosystem
/// - Customizable appearance through theming
///
/// The widget can operate in several resize modes:
/// - Fixed size: When both [expandableHeight] and [expandableWidth] are false
/// - Expandable height: When [expandableHeight] is true, allows vertical resizing
/// - Expandable width: When [expandableWidth] is true, allows horizontal resizing
/// - Fully expandable: When both expansion modes are enabled
///
/// Example:
/// ```dart
/// TextArea(
///   placeholder: Text('Enter your message...'),
///   expandableHeight: true,
///   minHeight: 100,
///   maxHeight: 300,
///   onChanged: (text) => print('Text: $text'),
/// );
/// ```
class TextArea extends TextInputStatefulWidget {
/// Whether the text area can be resized vertically by the user.
///
/// When true, displays a resize handle that allows users to adjust
/// the height of the text area within the specified min/max constraints.
  bool expandableHeight;
/// Whether the text area can be resized horizontally by the user.
///
/// When true, displays a resize handle that allows users to adjust
/// the width of the text area within the specified min/max constraints.
  bool expandableWidth;
/// Initial height of the text area in logical pixels.
///
/// Sets the starting height when the text area is first displayed.
/// If [expandableHeight] is true, users can resize from this initial value.
  double initialHeight;
/// Initial width of the text area in logical pixels.
///
/// Sets the starting width when the text area is first displayed.
/// If [expandableWidth] is true, users can resize from this initial value.
  double initialWidth;
/// Callback invoked when the text area height changes.
///
/// Called when the user resizes the text area vertically. The callback
/// receives the new height value in logical pixels.
  ValueChanged<double>? onHeightChanged;
/// Callback invoked when the text area width changes.
///
/// Called when the user resizes the text area horizontally. The callback
/// receives the new width value in logical pixels.
  ValueChanged<double>? onWidthChanged;
/// Minimum allowed width in logical pixels.
///
/// Prevents the text area from being resized below this width value.
/// Only applies when [expandableWidth] is true.
  double minWidth;
/// Minimum allowed height in logical pixels.
///
/// Prevents the text area from being resized below this height value.
/// Only applies when [expandableHeight] is true.
  double minHeight;
/// Maximum allowed width in logical pixels.
///
/// Prevents the text area from being resized above this width value.
/// Only applies when [expandableWidth] is true.
  double maxWidth;
/// Maximum allowed height in logical pixels.
///
/// Prevents the text area from being resized above this height value.
/// Only applies when [expandableHeight] is true.
  double maxHeight;
/// Creates a [TextArea] with comprehensive configuration options.
///
/// The text area supports both controlled and uncontrolled modes. Use
/// [controller] for controlled mode or [initialValue] for uncontrolled mode.
/// The text area can be configured for resizing, styling, and various
/// text input behaviors.
///
/// Parameters:
/// - [expandableHeight] (bool, default: false): Enable vertical resizing
/// - [expandableWidth] (bool, default: false): Enable horizontal resizing
/// - [initialHeight] (double, default: 100): Starting height in pixels
/// - [initialWidth] (double, default: double.infinity): Starting width in pixels
/// - [enabled] (bool, default: true): Whether the text area accepts input
/// - [readOnly] (bool, default: false): Whether the text is read-only
/// - [obscureText] (bool, default: false): Whether to hide the text
/// - [obscuringCharacter] (String, default: '‚Ä¢'): Character for hiding text
/// - [textAlign] (TextAlign, default: TextAlign.start): Horizontal text alignment
/// - [minWidth] (double, default: 100): Minimum width constraint
/// - [minHeight] (double, default: 100): Minimum height constraint
/// - [maxWidth] (double, default: double.infinity): Maximum width constraint
/// - [maxHeight] (double, default: double.infinity): Maximum height constraint
/// - [textAlignVertical] (TextAlignVertical, default: top): Vertical text alignment
/// - [clipBehavior] (Clip, default: Clip.hardEdge): Content clipping behavior
/// - [autofocus] (bool, default: false): Whether to auto-focus on creation
///
/// Example:
/// ```dart
/// TextArea(
///   placeholder: Text('Enter your message'),
///   expandableHeight: true,
///   minHeight: 100,
///   maxHeight: 300,
///   onChanged: (text) => _handleTextChange(text),
/// );
/// ```
  const TextArea({super.key, super.groupId, super.controller, super.focusNode, super.decoration, super.padding, super.placeholder, super.crossAxisAlignment, super.clearButtonSemanticLabel, super.keyboardType, super.textInputAction, super.textCapitalization, super.style, super.strutStyle, super.textAlign, super.textAlignVertical, super.textDirection, super.readOnly, super.showCursor, super.autofocus, super.obscuringCharacter, super.obscureText, super.autocorrect, super.smartDashesType, super.smartQuotesType, super.enableSuggestions, super.maxLines, super.minLines, super.expands, super.maxLength, super.maxLengthEnforcement, super.onChanged, super.onEditingComplete, super.onSubmitted, super.onTapOutside, super.onTapUpOutside, super.inputFormatters, super.enabled, super.cursorWidth, super.cursorHeight, super.cursorRadius, super.cursorOpacityAnimates, super.cursorColor, super.selectionHeightStyle, super.selectionWidthStyle, super.keyboardAppearance, super.scrollPadding, super.enableInteractiveSelection, super.selectionControls, super.dragStartBehavior, super.scrollController, super.scrollPhysics, super.onTap, super.autofillHints, super.clipBehavior, super.restorationId, super.stylusHandwritingEnabled, super.enableIMEPersonalizedLearning, super.contentInsertionConfiguration, super.contextMenuBuilder, super.initialValue, super.hintText, super.border, super.borderRadius, super.filled, super.statesController, super.magnifierConfiguration, super.spellCheckConfiguration, super.undoController, super.features, super.submitFormatters, super.skipInputFeatureFocusTraversal, this.expandableHeight = false, this.expandableWidth = false, this.initialHeight = 100, this.initialWidth = double.infinity, this.onHeightChanged, this.onWidthChanged, this.minWidth = 100, this.minHeight = 100, this.maxWidth = double.infinity, this.maxHeight = double.infinity});
  State<TextArea> createState();
}
/// Theme data for customizing [InputOTP] widget appearance.
///
/// This class defines the visual properties that can be applied to
/// [InputOTP] widgets, including spacing between OTP input fields
/// and the height of the input containers. These properties can be
/// set at the theme level to provide consistent styling across the application.
class InputOTPTheme extends ComponentThemeData {
/// Horizontal spacing between OTP input fields.
  double? spacing;
/// Height of each OTP input container.
  double? height;
/// Creates an [InputOTPTheme].
///
/// Parameters:
/// - [spacing] (`double?`, optional): Space between input fields.
/// - [height] (`double?`, optional): Height of input containers.
  const InputOTPTheme({this.spacing, this.height});
/// Creates a copy of this theme with specified properties overridden.
///
/// Parameters:
/// - [spacing] (`ValueGetter<double?>?`, optional): New spacing value.
/// - [height] (`ValueGetter<double?>?`, optional): New height value.
///
/// Returns: A new [InputOTPTheme] with updated properties.
  InputOTPTheme copyWith({ValueGetter<double?>? spacing, ValueGetter<double?>? height});
  bool operator ==(Object other);
  int get hashCode;
}
/// Abstract base class for OTP input child elements.
///
/// Defines the interface for children that can be placed within an [InputOTP]
/// widget, including actual input fields, separators, and spacers.
/// Subclasses implement the [build] method to render their content.
///
/// Common factories:
/// - [separator]: Creates a visual separator between OTP groups.
/// - [space]: Creates spacing between OTP input fields.
/// - [empty]: Creates an empty placeholder.
/// - [InputOTPChild.input]: Creates a configurable character input.
/// - [InputOTPChild.character]: Creates a character input with preset filters.
///
/// Example:
/// ```dart
/// InputOTP(
///   children: [
///     InputOTPChild.input(predicate: (cp) => cp >= 48 && cp <= 57),
///     InputOTPChild.space,
///     InputOTPChild.input(),
///   ],
/// )
/// ```
abstract class InputOTPChild {
/// A visual separator between OTP groups (e.g., a dash or line).
  static InputOTPChild get separator;
/// Spacing between OTP input fields.
  static InputOTPChild get space;
/// An empty placeholder that takes no space.
  static InputOTPChild get empty;
/// Creates a customizable character input field.
///
/// Parameters:
/// - [predicate] (`CodepointPredicate?`, optional): Function to validate codepoints.
/// - [transform] (`CodepointUnaryOperator?`, optional): Function to transform codepoints.
/// - [obscured] (`bool`, default: `false`): Whether to obscure the input.
/// - [readOnly] (`bool`, default: `false`): Whether the input is read-only.
/// - [keyboardType] (`TextInputType?`, optional): Keyboard type for input.
///
/// Returns: A [CharacterInputOTPChild] configured with the specified options.
  factory InputOTPChild.input({CodepointPredicate? predicate, CodepointUnaryOperator? transform, bool obscured = false, bool readOnly = false, TextInputType? keyboardType});
/// Creates a character input with alphabet and digit filtering.
///
/// Parameters:
/// - [allowLowercaseAlphabet] (`bool`, default: `false`): Allow lowercase letters.
/// - [allowUppercaseAlphabet] (`bool`, default: `false`): Allow uppercase letters.
/// - [allowDigit] (`bool`, default: `false`): Allow numeric digits.
/// - [obscured] (`bool`, default: `false`): Whether to obscure the input.
/// - [onlyUppercaseAlphabet] (`bool`, default: `false`): Convert to uppercase only.
/// - [onlyLowercaseAlphabet] (`bool`, default: `false`): Convert to lowercase only.
/// - [readOnly] (`bool`, default: `false`): Whether the input is read-only.
/// - [keyboardType] (`TextInputType?`, optional): Keyboard type for input.
///
/// Returns: A [CharacterInputOTPChild] configured for alphabet/digit input.
///
/// Example:
/// ```dart
/// InputOTPChild.character(
///   allowDigit: true,
///   allowUppercaseAlphabet: true,
/// )
/// ```
  factory InputOTPChild.character({bool allowLowercaseAlphabet = false, bool allowUppercaseAlphabet = false, bool allowDigit = false, bool obscured = false, bool onlyUppercaseAlphabet = false, bool onlyLowercaseAlphabet = false, bool readOnly = false, TextInputType? keyboardType});
/// Creates an [InputOTPChild].
  const InputOTPChild();
/// Builds the widget for this OTP child.
///
/// Parameters:
/// - [context] (`BuildContext`, required): The build context.
/// - [data] (`InputOTPChildData`, required): Data for building the child.
///
/// Returns: The widget representing this OTP child.
  Widget build(BuildContext context, InputOTPChildData data);
/// Whether this child can hold a value (i.e., is an input field).
  bool get hasValue;
}
/// A character-based OTP input field with validation and transformation.
///
/// Supports filtering input based on codepoint predicates and transforming
/// input characters (e.g., converting to uppercase). Commonly used for
/// creating numeric or alphanumeric OTP fields.
///
/// Example:
/// ```dart
/// CharacterInputOTPChild(
///   predicate: CharacterInputOTPChild.isDigit,
///   keyboardType: TextInputType.number,
/// )
/// ```
class CharacterInputOTPChild extends InputOTPChild {
/// Tests if the codepoint is a lowercase letter (a-z).
///
/// Parameters:
/// - [codepoint] (`int`, required): The codepoint to test.
///
/// Returns: `true` if the codepoint is a lowercase letter.
  static bool isAlphabetLower(int codepoint);
/// Tests if the codepoint is an uppercase letter (A-Z).
///
/// Parameters:
/// - [codepoint] (`int`, required): The codepoint to test.
///
/// Returns: `true` if the codepoint is an uppercase letter.
  static bool isAlphabetUpper(int codepoint);
/// Converts a lowercase letter to uppercase.
///
/// Parameters:
/// - [codepoint] (`int`, required): The codepoint to convert.
///
/// Returns: The uppercase codepoint if lowercase, otherwise unchanged.
  static int lowerToUpper(int codepoint);
/// Converts an uppercase letter to lowercase.
///
/// Parameters:
/// - [codepoint] (`int`, required): The codepoint to convert.
///
/// Returns: The lowercase codepoint if uppercase, otherwise unchanged.
  static int upperToLower(int codepoint);
/// Tests if the codepoint is a digit (0-9).
///
/// Parameters:
/// - [codepoint] (`int`, required): The codepoint to test.
///
/// Returns: `true` if the codepoint is a digit.
  static bool isDigit(int codepoint);
/// Predicate to validate allowed codepoints.
  CodepointPredicate? predicate;
/// Function to transform codepoints before storing.
  CodepointUnaryOperator? transform;
/// Whether to obscure the input character.
  bool obscured;
/// Whether the input is read-only.
  bool readOnly;
/// The keyboard type to use for input.
  TextInputType? keyboardType;
/// Creates a [CharacterInputOTPChild].
///
/// Parameters:
/// - [predicate] (`CodepointPredicate?`, optional): Validates input codepoints.
/// - [transform] (`CodepointUnaryOperator?`, optional): Transforms codepoints.
/// - [obscured] (`bool`, default: `false`): Whether to obscure the character.
/// - [readOnly] (`bool`, default: `false`): Whether the field is read-only.
/// - [keyboardType] (`TextInputType?`, optional): Keyboard type for input.
  const CharacterInputOTPChild({this.predicate, this.transform, this.obscured = false, this.readOnly = false, this.keyboardType});
  bool get hasValue;
  Widget build(BuildContext context, InputOTPChildData data);
}
/// A widget-based OTP child that doesn't accept input.
///
/// Used for displaying static content like separators or spacers within
/// an [InputOTP] widget. This child does not hold any value.
///
/// Example:
/// ```dart
/// WidgetInputOTPChild(
///   Icon(Icons.arrow_forward),
/// )
/// ```
class WidgetInputOTPChild extends InputOTPChild {
/// The widget to display.
  Widget child;
/// Creates a [WidgetInputOTPChild].
///
/// Parameters:
/// - [child] (`Widget`, required): The widget to display.
  const WidgetInputOTPChild(this.child);
  Widget build(BuildContext context, InputOTPChildData data);
  bool get hasValue;
}
/// A visual separator for OTP input groups.
///
/// Displays a dash "-" character between groups of OTP input fields.
/// Automatically applies theming and spacing based on the current theme.
///
/// Example:
/// ```dart
/// InputOTP(
///   children: [
///     InputOTPChild.input(),
///     OTPSeparator(),
///     InputOTPChild.input(),
///   ],
/// )
/// ```
class OTPSeparator extends StatelessWidget {
/// Creates an [OTPSeparator].
  const OTPSeparator({super.key});
  Widget build(BuildContext context);
}
/// Data passed to [InputOTPChild.build] for rendering OTP input fields.
///
/// Contains information about focus nodes, index positions, current value,
/// and callbacks for changing values. Used internally by [InputOTP] to
/// coordinate input fields.
class InputOTPChildData {
/// Focus node for the previous input field.
  FocusNode? previousFocusNode;
/// Focus node for this input field.
  FocusNode? focusNode;
/// Focus node for the next input field.
  FocusNode? nextFocusNode;
/// Overall index within all OTP children.
  int index;
/// Index of the group this child belongs to.
  int groupIndex;
/// Total number of children in this group.
  int groupLength;
/// Relative index within the group.
  int relativeIndex;
/// Current value (codepoint) of this input field.
  int? value;
/// Updates the value for this OTP input field.
///
/// Parameters:
/// - [value] (`int?`, required): The new codepoint value or null.
  void changeValue(int? value);
}
/// Extension methods for [OTPCodepointList].
extension OTPCodepointListExtension on OTPCodepointList {
/// Converts the codepoint list to a string.
///
/// Null values are converted to empty strings.
///
/// Returns: A string representation of the OTP code.
///
/// Example:
/// ```dart
/// final codes = [49, 50, 51]; // '1', '2', '3'
/// print(codes.otpToString()); // '123'
/// ```
  String otpToString();
}
/// A specialized input widget for One-Time Password (OTP) and verification code entry.
///
/// [InputOTP] provides a user-friendly interface for entering OTP codes, verification
/// numbers, and similar sequential input scenarios. The widget displays a series of
/// individual input fields that automatically advance focus as the user types,
/// creating an intuitive experience for multi-digit input.
///
/// Key features:
/// - Sequential character input with automatic focus advancement
/// - Customizable field layout with separators and spacing
/// - Support for various character types (digits, letters, symbols)
/// - Keyboard navigation and clipboard paste support
/// - Form integration with validation support
/// - Accessibility features for screen readers
/// - Theming and visual customization
///
/// The widget uses a flexible child system that allows mixing input fields
/// with separators, spaces, and custom widgets:
/// - Character input fields for actual OTP digits/letters
/// - Separators for visual grouping (e.g., dashes, dots)
/// - Spacing elements for layout control
/// - Custom widgets for specialized display needs
///
/// Common use cases:
/// - SMS verification codes (e.g., 6-digit codes)
/// - Two-factor authentication tokens
/// - Credit card security codes
/// - License key input
/// - PIN code entry
///
/// Example:
/// ```dart
/// InputOTP(
///   children: [
///     CharacterInputOTPChild(),
///     CharacterInputOTPChild(),
///     CharacterInputOTPChild(),
///     InputOTPChild.separator,
///     CharacterInputOTPChild(),
///     CharacterInputOTPChild(),
///     CharacterInputOTPChild(),
///   ],
///   onChanged: (code) => _handleOTPChange(code),
///   onSubmitted: (code) => _verifyOTP(code),
/// );
/// ```
class InputOTP extends StatefulWidget {
/// The list of children defining input fields, separators, and spaces.
  List<InputOTPChild> children;
/// Initial OTP codepoint values.
  OTPCodepointList? initialValue;
/// Called when the OTP value changes.
  ValueChanged<OTPCodepointList>? onChanged;
/// Called when the user submits the OTP (e.g., presses Enter on last field).
  ValueChanged<OTPCodepointList>? onSubmitted;
/// Creates an [InputOTP] widget.
///
/// Parameters:
/// - [children] (`List<InputOTPChild>`, required): The OTP input fields and decorations.
/// - [initialValue] (`OTPCodepointList?`, optional): Initial codepoints.
/// - [onChanged] (`ValueChanged<OTPCodepointList>?`, optional): Value change callback.
/// - [onSubmitted] (`ValueChanged<OTPCodepointList>?`, optional): Submit callback.
  const InputOTP({super.key, required this.children, this.initialValue, this.onChanged, this.onSubmitted});
  State<InputOTP> createState();
}
/// Theme data for customizing [TextField] appearance.
///
/// This class defines the visual properties that can be applied to
/// [TextField] widgets, including border styling, fill state, padding,
/// and border radius. These properties can be set at the theme level
/// to provide consistent styling across the application.
class TextFieldTheme extends ComponentThemeData {
/// Border radius for text field corners.
///
/// If `null`, uses default border radius from the theme.
  BorderRadiusGeometry? borderRadius;
/// Whether the text field has a filled background.
///
/// When `true`, applies a background fill color.
  bool? filled;
/// Padding inside the text field.
///
/// If `null`, uses default padding from the theme.
  EdgeInsetsGeometry? padding;
/// Border style for the text field.
///
/// If `null`, uses default border from the theme.
  Border? border;
/// Creates a [TextFieldTheme].
///
/// Parameters:
/// - [border] (`Border?`, optional): Border style.
/// - [borderRadius] (`BorderRadiusGeometry?`, optional): Corner rounding.
/// - [filled] (`bool?`, optional): Whether background is filled.
/// - [padding] (`EdgeInsetsGeometry?`, optional): Internal padding.
  const TextFieldTheme({this.border, this.borderRadius, this.filled, this.padding});
/// Creates a copy of this theme with the given fields replaced.
///
/// Parameters use value getters to allow `null` values to be explicitly set.
  TextFieldTheme copyWith({ValueGetter<Border?>? border, ValueGetter<BorderRadiusGeometry?>? borderRadius, ValueGetter<bool?>? filled, ValueGetter<EdgeInsetsGeometry?>? padding});
  bool operator ==(Object other);
  int get hashCode;
}
/// Standard height for text field components in logical pixels.
const kTextFieldHeight = 34;
/// Abstract base class for controlling input feature visibility.
///
/// Defines when UI elements like clear buttons, password toggles, or other
/// input features should be visible based on text field state. Supports
/// logical operations (AND, OR, NOT) to combine multiple visibility conditions.
///
/// Example:
/// ```dart
/// // Show clear button when text is not empty and field is focused
/// final visibility = InputFeatureVisibility.textNotEmpty &
///                   InputFeatureVisibility.focused;
/// ```
abstract class InputFeatureVisibility {
/// Creates a visibility condition that is true when all [features] are true.
  factory InputFeatureVisibility.and(Iterable<InputFeatureVisibility> features);
/// Creates a visibility condition that is true when any [features] is true.
  factory InputFeatureVisibility.or(Iterable<InputFeatureVisibility> features);
/// Creates a visibility condition that inverts the given [feature].
  factory InputFeatureVisibility.not(InputFeatureVisibility feature);
/// Visibility condition: text field is not empty.
  static const InputFeatureVisibility textNotEmpty = _TextNotEmptyInputFeatureVisibility();
/// Visibility condition: text field is empty.
  static const InputFeatureVisibility textEmpty = _TextEmptyInputFeatureVisibility();
/// Visibility condition: text field has focus.
  static const InputFeatureVisibility focused = _FocusedInputFeatureVisibility();
/// Visibility condition: text field is being hovered.
  static const InputFeatureVisibility hovered = _HoveredInputFeatureVisibility();
/// Visibility condition: never visible.
  static const InputFeatureVisibility never = _NeverVisibleInputFeatureVisibility();
/// Visibility condition: always visible.
  static const InputFeatureVisibility always = _AlwaysVisibleInputFeatureVisibility();
/// Visibility condition: text field has selected text.
  static const InputFeatureVisibility hasSelection = _HasSelectionInputFeatureVisibility();
/// Creates an [InputFeatureVisibility].
  const InputFeatureVisibility();
/// Gets the listenable dependencies for this visibility condition.
///
/// Returns the state objects that should be monitored for changes.
  Iterable<Listenable> getDependencies(TextFieldState state);
/// Checks if the feature can be shown in the current state.
///
/// Returns `true` if all visibility conditions are met.
  bool canShow(TextFieldState state);
/// Combines this visibility with [other] using logical AND.
  InputFeatureVisibility and(InputFeatureVisibility other);
/// Operator form of [and]. Combines conditions with logical AND.
  InputFeatureVisibility operator &(InputFeatureVisibility other);
/// Combines this visibility with [other] using logical OR.
  InputFeatureVisibility or(InputFeatureVisibility other);
/// Operator form of [or]. Combines conditions with logical OR.
  InputFeatureVisibility operator |(InputFeatureVisibility other);
/// Inverts this visibility condition using logical NOT.
  InputFeatureVisibility operator ~();
}
/// Abstract factory for creating input field feature components.
///
/// Provides factory constructors for common text field features like password
/// toggles, clear buttons, hints, autocomplete, and spinners. Features can be
/// conditionally shown based on field state using [InputFeatureVisibility].
///
/// Example:
/// ```dart
/// TextField(
///   leading: [
///     InputFeature.hint(
///       popupBuilder: (context) => Text('Enter email'),
///     ),
///   ],
///   trailing: [
///     InputFeature.clear(),
///     InputFeature.passwordToggle(),
///   ],
/// )
/// ```
abstract class InputFeature {
/// Creates a hint/tooltip feature for the input field.
///
/// Parameters:
/// - [visibility] (`InputFeatureVisibility`, default: always): When to show hint.
/// - [popupBuilder] (`WidgetBuilder`, required): Builds the hint popup content.
/// - [icon] (`Widget?`, optional): Icon to display for the hint trigger.
/// - [position] (`InputFeaturePosition`, default: trailing): Where to place the hint.
/// - [enableShortcuts] (`bool`, default: true): Enable keyboard shortcuts.
/// - [skipFocusTraversal] (`bool`, default: false): Skip in focus order.
  factory InputFeature.hint({InputFeatureVisibility visibility, required WidgetBuilder popupBuilder, Widget? icon, InputFeaturePosition position, bool enableShortcuts, bool skipFocusTraversal});
/// Creates a password visibility toggle feature.
///
/// Parameters:
/// - [visibility] (`InputFeatureVisibility`, default: always): When to show toggle.
/// - [mode] (`PasswordPeekMode`, default: toggle): Toggle or peek mode.
/// - [position] (`InputFeaturePosition`, default: trailing): Where to place toggle.
/// - [icon] (`Widget?`, optional): Icon when password is hidden.
/// - [iconShow] (`Widget?`, optional): Icon when password is visible.
/// - [skipFocusTraversal] (`bool`, default: false): Skip in focus order.
  factory InputFeature.passwordToggle({InputFeatureVisibility visibility, PasswordPeekMode mode, InputFeaturePosition position, Widget? icon, Widget? iconShow, bool skipFocusTraversal});
/// Creates a clear text button feature.
///
/// Parameters:
/// - [visibility] (`InputFeatureVisibility`, default: textNotEmpty): When to show clear button.
/// - [position] (`InputFeaturePosition`, default: trailing): Where to place button.
/// - [icon] (`Widget?`, optional): Custom clear icon.
/// - [skipFocusTraversal] (`bool`, default: false): Skip in focus order.
  factory InputFeature.clear({InputFeatureVisibility visibility, InputFeaturePosition position, Widget? icon, bool skipFocusTraversal});
/// Creates a revalidate button feature.
///
/// Triggers form validation when clicked.
///
/// Parameters:
/// - [visibility] (`InputFeatureVisibility`, default: always): When to show button.
/// - [position] (`InputFeaturePosition`, default: trailing): Where to place button.
/// - [icon] (`Widget?`, optional): Custom revalidate icon.
/// - [skipFocusTraversal] (`bool`, default: false): Skip in focus order.
  factory InputFeature.revalidate({InputFeatureVisibility visibility, InputFeaturePosition position, Widget? icon, bool skipFocusTraversal});
/// Creates an autocomplete feature.
///
/// Parameters:
/// - [visibility] (`InputFeatureVisibility`, default: focused): When to show autocomplete.
/// - [querySuggestions] (`SuggestionBuilder`, required): Builds suggestion list.
/// - [child] (`Widget`, required): Child widget in the autocomplete popup.
/// - [popoverConstraints] (`BoxConstraints?`, optional): Size constraints for popup.
/// - [popoverWidthConstraint] (`PopoverConstraint?`, optional): Width constraint mode.
/// - [popoverAnchorAlignment] (`AlignmentDirectional?`, optional): Anchor alignment.
/// - [popoverAlignment] (`AlignmentDirectional?`, optional): Popup alignment.
/// - [mode] (`AutoCompleteMode`, default: popup): Display mode.
/// - [skipFocusTraversal] (`bool`, default: false): Skip in focus order.
  factory InputFeature.autoComplete({InputFeatureVisibility visibility, required SuggestionBuilder querySuggestions, required Widget child, BoxConstraints? popoverConstraints, PopoverConstraint? popoverWidthConstraint, AlignmentDirectional? popoverAnchorAlignment, AlignmentDirectional? popoverAlignment, AutoCompleteMode mode, bool skipFocusTraversal});
/// Creates a numeric spinner feature for incrementing/decrementing values.
///
/// Parameters:
/// - [visibility] (`InputFeatureVisibility`, default: always): When to show spinner.
/// - [step] (`double`, default: 1): Increment/decrement step size.
/// - [enableGesture] (`bool`, default: true): Enable drag gestures.
/// - [invalidValue] (`double?`, optional): Value to use when input is invalid.
/// - [min] (`double?`, optional): Minimum allowed value.
/// - [max] (`double?`, optional): Maximum allowed value.
/// - [skipFocusTraversal] (`bool`, default: false): Skip in focus order.
  factory InputFeature.spinner({InputFeatureVisibility visibility, double step, bool enableGesture, double? invalidValue, double? min, double? max, bool skipFocusTraversal});
/// Creates an increment button feature for numeric inputs.
///
/// Parameters:
/// - [visibility] (`InputFeatureVisibility`, default: always): When to show button.
/// - [position] (`InputFeaturePosition`, default: trailing): Where to place button.
/// - [step] (`double`, default: 1): Increment step size.
/// - [invalidValue] (`double?`, optional): Value to use when input is invalid.
/// - [min] (`double?`, optional): Minimum allowed value.
/// - [max] (`double?`, optional): Maximum allowed value.
/// - [icon] (`Widget?`, optional): Custom icon widget.
/// - [skipFocusTraversal] (`bool`, default: false): Skip in focus order.
  factory InputFeature.incrementButton({InputFeatureVisibility visibility, InputFeaturePosition position, double step, double? invalidValue, double? min, double? max, Widget? icon, bool skipFocusTraversal});
/// Creates a decrement button feature for numeric inputs.
///
/// Parameters:
/// - [visibility] (`InputFeatureVisibility`, default: always): When to show button.
/// - [position] (`InputFeaturePosition`, default: trailing): Where to place button.
/// - [step] (`double`, default: -1): Decrement step size.
/// - [invalidValue] (`double?`, optional): Value to use when input is invalid.
/// - [min] (`double?`, optional): Minimum allowed value.
/// - [max] (`double?`, optional): Maximum allowed value.
/// - [icon] (`Widget?`, optional): Custom icon widget.
/// - [skipFocusTraversal] (`bool`, default: false): Skip in focus order.
  factory InputFeature.decrementButton({InputFeatureVisibility visibility, InputFeaturePosition position, double step, double? invalidValue, double? min, double? max, Widget? icon, bool skipFocusTraversal});
/// Creates a copy to clipboard button feature.
///
/// Parameters:
/// - [visibility] (`InputFeatureVisibility`, default: textNotEmpty): When to show copy button.
/// - [position] (`InputFeaturePosition`, default: trailing): Where to place button.
/// - [icon] (`Widget?`, optional): Custom copy icon.
/// - [skipFocusTraversal] (`bool`, default: false): Skip in focus order.
  factory InputFeature.copy({InputFeatureVisibility visibility, InputFeaturePosition position, Widget? icon, bool skipFocusTraversal});
/// Creates a paste from clipboard button feature.
///
/// Parameters:
/// - [visibility] (`InputFeatureVisibility`, default: always): When to show paste button.
/// - [position] (`InputFeaturePosition`, default: trailing): Where to place button.
/// - [icon] (`Widget?`, optional): Custom paste icon.
/// - [skipFocusTraversal] (`bool`, default: false): Skip in focus order.
  factory InputFeature.paste({InputFeatureVisibility visibility, InputFeaturePosition position, Widget? icon, bool skipFocusTraversal});
/// Creates a custom leading widget feature.
///
/// Parameters:
/// - [child] (`Widget`, required): Widget to display.
/// - [visibility] (`InputFeatureVisibility`, default: always): When to show widget.
/// - [skipFocusTraversal] (`bool`, default: false): Skip in focus order.
  factory InputFeature.leading(Widget child, {InputFeatureVisibility visibility, bool skipFocusTraversal});
/// Creates a custom trailing widget feature.
  factory InputFeature.trailing(Widget child, {InputFeatureVisibility visibility, bool skipFocusTraversal});
/// Creates a custom widget feature displayed above the input text.
///
/// Parameters:
/// - [child] (`Widget?`, optional): Widget displayed above the input.
/// - [visibility] (`InputFeatureVisibility`, default: always): When to show widget.
/// - [skipFocusTraversal] (`bool`, default: false): Skip in focus order.
  factory InputFeature.above(Widget? child, {InputFeatureVisibility visibility, bool skipFocusTraversal});
/// Creates a custom widget feature displayed below the input text.
///
/// Parameters:
/// - [child] (`Widget?`, optional): Widget displayed below the input.
/// - [visibility] (`InputFeatureVisibility`, default: always): When to show widget.
/// - [skipFocusTraversal] (`bool`, default: false): Skip in focus order.
  factory InputFeature.below(Widget? child, {InputFeatureVisibility visibility, bool skipFocusTraversal});
/// Visibility mode for this input feature.
  InputFeatureVisibility visibility;
/// Whether to skip this feature in focus traversal.
  bool skipFocusTraversal;
/// Creates an input feature.
  const InputFeature({this.visibility = InputFeatureVisibility.always, this.skipFocusTraversal = true});
/// Creates the state for this input feature.
  InputFeatureState createState();
/// Checks if an old feature can be updated to a new feature.
  static bool canUpdate(InputFeature oldFeature, InputFeature newFeature);
}
/// Abstract base state class for input features.
///
/// Manages the lifecycle and state of features that extend text field
/// functionality, such as clear buttons, counters, or custom decorations.
abstract class InputFeatureState<T extends InputFeature> {
/// The input feature associated with this state.
  T get feature;
/// The ticker provider for animations.
  TickerProvider get tickerProvider;
/// The build context for this feature.
  BuildContext get context;
/// The parent text field widget.
  TextField get input;
/// Whether this feature is currently attached to a text field.
  bool get attached;
/// The text editing controller for the text field.
  TextEditingController get controller;
/// Initializes this feature state.
///
/// Called when the feature is first attached to a text field.
  void initState();
/// Called when dependencies change.
///
/// Override to respond to dependency changes in the widget tree.
  void didChangeDependencies();
/// Disposes resources used by this feature state.
///
/// Called when the feature is detached from the text field.
  void dispose();
/// Called when the feature is updated.
///
/// Override to respond to feature configuration changes.
  void didFeatureUpdate(InputFeature oldFeature);
/// Called when the text field's text changes.
///
/// Override to respond to text changes.
  void onTextChanged(String text);
/// Called when the text field's selection changes.
///
/// Override to respond to selection changes.
  void onSelectionChanged(TextSelection selection);
/// Builds leading widgets for the text field.
///
/// Override to provide widgets shown before the input.
  Iterable<Widget> buildLeading();
/// Builds trailing widgets for the text field.
///
/// Override to provide widgets shown after the input.
  Iterable<Widget> buildTrailing();
/// Builds prefix widgets for the text field.
///
/// Override to provide widgets shown before the editable text.
  Iterable<Widget> buildPrefix();
/// Builds suffix widgets for the text field.
///
/// Override to provide widgets shown after the editable text.
  Iterable<Widget> buildSuffix();
/// Builds widgets displayed above the input, inside the decoration.
///
/// Override to provide widgets rendered above the editable text.
  Iterable<Widget> buildAbove();
/// Builds widgets displayed below the input, inside the decoration.
///
/// Override to provide widgets rendered below the editable text.
  Iterable<Widget> buildBelow();
/// Builds actions for keyboard shortcuts.
///
/// Override to provide custom actions.
  Iterable<MapEntry<Type, Action<Intent>>> buildActions();
/// Builds keyboard shortcuts.
///
/// Override to provide custom keyboard shortcuts.
  Iterable<MapEntry<ShortcutActivator, Intent>> buildShortcuts();
/// Wraps the text field widget.
///
/// Override to wrap the field with additional widgets.
  Widget wrap(Widget child);
/// Intercepts and modifies the text field configuration.
///
/// Override to modify the text field before rendering.
  TextField interceptInput(TextField input);
/// Triggers a state update for the attached text field.
///
/// Parameters:
/// - [fn] (`VoidCallback`, required): State update callback.
///
/// Throws: AssertionError if feature is not attached.
  void setState(VoidCallback fn);
}
/// Mixin defining the interface for text input widgets.
///
/// Provides a comprehensive set of properties that text input widgets
/// must implement, ensuring consistency across [TextField], [ChipInput],
/// [TextArea], and similar components. This mixin helps avoid missing
/// properties when implementing custom text input widgets.
///
/// Properties are organized into categories:
/// - Basic configuration: groupId, controller, focusNode
/// - Visual styling: decoration, padding, placeholder, border, borderRadius
/// - Text configuration: style, strutStyle, textAlign, textDirection
/// - Input behavior: keyboardType, textInputAction, autocorrect, enableSuggestions
/// - Cursor styling: cursorWidth, cursorHeight, cursorRadius, cursorColor
/// - Selection: enableInteractiveSelection, selectionControls, selectionHeightStyle
/// - Callbacks: onChanged, onSubmitted, onEditingComplete, onTap
/// - Features: features, inputFormatters, submitFormatters
mixin TextInput on Widget {
/// Group identifier for related text inputs.
  Object get groupId;
/// Text editing controller for the input.
  TextEditingController? get controller;
/// Focus node for keyboard focus management.
  FocusNode? get focusNode;
/// Box decoration for the input container.
  BoxDecoration? get decoration;
/// Padding inside the input.
  EdgeInsetsGeometry? get padding;
/// Placeholder widget shown when empty.
  Widget? get placeholder;
/// Cross-axis alignment for content.
  CrossAxisAlignment get crossAxisAlignment;
/// Semantic label for the clear button.
  String? get clearButtonSemanticLabel;
/// Type of keyboard to show.
  TextInputType? get keyboardType;
/// Action button on the keyboard.
  TextInputAction? get textInputAction;
/// Text capitalization behavior.
  TextCapitalization get textCapitalization;
/// Text style for input content.
  TextStyle? get style;
/// Strut style for text layout.
  StrutStyle? get strutStyle;
/// Horizontal text alignment.
  TextAlign get textAlign;
/// Vertical text alignment.
  TextAlignVertical? get textAlignVertical;
/// Text direction.
  TextDirection? get textDirection;
/// Whether the input is read-only.
  bool get readOnly;
/// Whether to show the cursor.
  bool? get showCursor;
/// Whether to auto-focus on mount.
  bool get autofocus;
/// Character used for obscuring text.
  String get obscuringCharacter;
/// Whether to obscure text (password fields).
  bool get obscureText;
/// Whether to enable autocorrection.
  bool get autocorrect;
/// Smart dashes behavior.
  SmartDashesType get smartDashesType;
/// Smart quotes behavior.
  SmartQuotesType get smartQuotesType;
/// Whether to enable suggestions.
  bool get enableSuggestions;
/// Maximum number of lines.
  int? get maxLines;
/// Minimum number of lines.
  int? get minLines;
/// Whether the input should expand to fill available space.
  bool get expands;
/// Maximum character length.
  int? get maxLength;
/// How to enforce max length.
  MaxLengthEnforcement? get maxLengthEnforcement;
/// Callback when text changes.
  ValueChanged<String>? get onChanged;
/// Callback when editing is complete.
  VoidCallback? get onEditingComplete;
/// Callback when text is submitted.
  ValueChanged<String>? get onSubmitted;
/// Callback when tapped outside.
  TapRegionCallback? get onTapOutside;
/// Callback when tap up occurs outside.
  TapRegionCallback? get onTapUpOutside;
/// Input formatters for text.
  List<TextInputFormatter>? get inputFormatters;
/// Whether the input is enabled.
  bool get enabled;
/// Width of the cursor.
  double get cursorWidth;
/// Height of the cursor.
  double? get cursorHeight;
/// Radius of the cursor.
  Radius get cursorRadius;
/// Whether cursor opacity animates.
  bool get cursorOpacityAnimates;
/// Color of the cursor.
  Color? get cursorColor;
/// Selection height style.
  ui.BoxHeightStyle get selectionHeightStyle;
/// Selection width style.
  ui.BoxWidthStyle get selectionWidthStyle;
/// Keyboard appearance brightness.
  Brightness? get keyboardAppearance;
/// Scroll padding for keyboard avoidance.
  EdgeInsets get scrollPadding;
/// Whether interactive selection is enabled.
  bool get enableInteractiveSelection;
/// Controls for text selection.
  TextSelectionControls? get selectionControls;
/// Drag start behavior.
  DragStartBehavior get dragStartBehavior;
/// Scroll controller.
  ScrollController? get scrollController;
/// Scroll physics.
  ScrollPhysics? get scrollPhysics;
/// Callback when tapped.
  GestureTapCallback? get onTap;
/// Autofill hints for the platform.
  Iterable<String>? get autofillHints;
/// Clip behavior.
  Clip get clipBehavior;
/// Restoration ID for state restoration.
  String? get restorationId;
/// Whether stylus handwriting is enabled.
  bool get stylusHandwritingEnabled;
/// Whether IME personalized learning is enabled.
  bool get enableIMEPersonalizedLearning;
/// Content insertion configuration.
  ContentInsertionConfiguration? get contentInsertionConfiguration;
/// Context menu builder.
  EditableTextContextMenuBuilder? get contextMenuBuilder;
/// Initial value for the input.
  String? get initialValue;
/// Hint text displayed when empty.
  String? get hintText;
/// Border styling.
  Border? get border;
/// Border radius.
  BorderRadiusGeometry? get borderRadius;
/// Whether the input has a filled background.
  bool? get filled;
/// Widget states controller.
  WidgetStatesController? get statesController;
/// Magnifier configuration.
  TextMagnifierConfiguration? get magnifierConfiguration;
/// Spell check configuration.
  SpellCheckConfiguration? get spellCheckConfiguration;
/// Undo history controller.
  UndoHistoryController? get undoController;
/// List of input features.
  List<InputFeature> get features;
/// Input formatters applied on submit.
  List<TextInputFormatter>? get submitFormatters;
/// Whether to skip focus traversal for input features.
  bool get skipInputFeatureFocusTraversal;
}
/// Abstract base class for stateful text input widgets.
///
/// Combines [StatefulWidget] with [TextInput] mixin to provide a base
/// for implementing text input components with state.
abstract class TextInputStatefulWidget extends StatefulWidget with TextInput {
  Object groupId;
  TextEditingController? controller;
  FocusNode? focusNode;
  BoxDecoration? decoration;
  EdgeInsetsGeometry? padding;
  Widget? placeholder;
  CrossAxisAlignment crossAxisAlignment;
  String? clearButtonSemanticLabel;
  TextInputType? keyboardType;
  TextInputAction? textInputAction;
  TextCapitalization textCapitalization;
  TextStyle? style;
  StrutStyle? strutStyle;
  TextAlign textAlign;
  TextAlignVertical? textAlignVertical;
  TextDirection? textDirection;
  bool readOnly;
  bool? showCursor;
  bool autofocus;
  String obscuringCharacter;
  bool obscureText;
  bool autocorrect;
  SmartDashesType smartDashesType;
  SmartQuotesType smartQuotesType;
  bool enableSuggestions;
  int? maxLines;
  int? minLines;
  bool expands;
  int? maxLength;
  MaxLengthEnforcement? maxLengthEnforcement;
  ValueChanged<String>? onChanged;
  VoidCallback? onEditingComplete;
  ValueChanged<String>? onSubmitted;
  TapRegionCallback? onTapOutside;
  TapRegionCallback? onTapUpOutside;
  List<TextInputFormatter>? inputFormatters;
  bool enabled;
  double cursorWidth;
  double? cursorHeight;
  Radius cursorRadius;
  bool cursorOpacityAnimates;
  Color? cursorColor;
  ui.BoxHeightStyle selectionHeightStyle;
  ui.BoxWidthStyle selectionWidthStyle;
  Brightness? keyboardAppearance;
  EdgeInsets scrollPadding;
  bool enableInteractiveSelection;
  TextSelectionControls? selectionControls;
  DragStartBehavior dragStartBehavior;
  ScrollController? scrollController;
  ScrollPhysics? scrollPhysics;
  GestureTapCallback? onTap;
  Iterable<String>? autofillHints;
  Clip clipBehavior;
  String? restorationId;
  bool stylusHandwritingEnabled;
  bool enableIMEPersonalizedLearning;
  ContentInsertionConfiguration? contentInsertionConfiguration;
  EditableTextContextMenuBuilder? contextMenuBuilder;
  String? initialValue;
  String? hintText;
  Border? border;
  BorderRadiusGeometry? borderRadius;
  bool? filled;
  WidgetStatesController? statesController;
  TextMagnifierConfiguration? magnifierConfiguration;
  SpellCheckConfiguration? spellCheckConfiguration;
  UndoHistoryController? undoController;
  List<InputFeature> features;
  List<TextInputFormatter>? submitFormatters;
  bool skipInputFeatureFocusTraversal;
/// Creates a stateful text input widget with comprehensive configuration options.
///
/// This constructor accepts all properties defined in the [TextInput] mixin,
/// providing extensive control over text input behavior, appearance, and interactions.
///
/// Most parameters mirror Flutter's [EditableText] widget while adding custom
/// features like input features, decorations, and form integration.
///
/// Key parameters include:
/// - [controller]: Text editing controller, created automatically if null
/// - [focusNode]: Focus node for keyboard interaction
/// - [decoration]: Box decoration for the input container
/// - [padding]: Inner padding around the text field
/// - [placeholder]: Widget shown when field is empty
/// - [enabled]: Whether input accepts user interaction, defaults to true
/// - [readOnly]: Whether text can be edited, defaults to false
/// - [obscureText]: Whether to hide input (for passwords), defaults to false
/// - [maxLines]: Maximum number of lines, defaults to 1
/// - [features]: List of input features (e.g., clear button, character count)
///
/// See [TextInput] mixin documentation for full parameter details.
  const TextInputStatefulWidget({super.key, this.groupId = EditableText, this.controller, this.focusNode, this.decoration, this.padding, this.placeholder, this.crossAxisAlignment = CrossAxisAlignment.center, this.clearButtonSemanticLabel, this.keyboardType, this.textInputAction, this.textCapitalization = TextCapitalization.none, this.style, this.strutStyle, this.textAlign = TextAlign.start, this.textAlignVertical, this.textDirection, this.readOnly = false, this.showCursor, this.autofocus = false, this.obscuringCharacter = '‚Ä¢', this.obscureText = false, this.autocorrect = true, this.smartDashesType = SmartDashesType.enabled, this.smartQuotesType = SmartQuotesType.enabled, this.enableSuggestions = true, this.maxLines = 1, this.minLines, this.expands = false, this.maxLength, this.maxLengthEnforcement, this.onChanged, this.onEditingComplete, this.onSubmitted, this.onTapOutside, this.onTapUpOutside, this.inputFormatters, this.enabled = true, this.cursorWidth = 2.0, this.cursorHeight, this.cursorRadius = const Radius.circular(2.0), this.cursorOpacityAnimates = true, this.cursorColor, this.selectionHeightStyle = ui.BoxHeightStyle.tight, this.selectionWidthStyle = ui.BoxWidthStyle.tight, this.keyboardAppearance, this.scrollPadding = const EdgeInsets.all(20.0), this.enableInteractiveSelection = true, this.selectionControls, this.dragStartBehavior = DragStartBehavior.start, this.scrollController, this.scrollPhysics, this.onTap, this.autofillHints = const [], this.clipBehavior = Clip.hardEdge, this.restorationId, this.stylusHandwritingEnabled = EditableText.defaultStylusHandwritingEnabled, this.enableIMEPersonalizedLearning = true, this.contentInsertionConfiguration, this.contextMenuBuilder, this.initialValue, this.hintText, this.border, this.borderRadius, this.filled, this.statesController, this.magnifierConfiguration, this.spellCheckConfiguration, this.undoController, this.features = const [], this.submitFormatters = const [], this.skipInputFeatureFocusTraversal = false});
/// Creates a copy of this text field with the given properties replaced.
///
/// All parameters are optional and allow selective property replacement.
  TextField copyWith({ValueGetter<Key?>? key, ValueGetter<Object>? groupId, ValueGetter<TextEditingController?>? controller, ValueGetter<String?>? initialValue, ValueGetter<FocusNode?>? focusNode, ValueGetter<UndoHistoryController?>? undoController, ValueGetter<BoxDecoration?>? decoration, ValueGetter<EdgeInsetsGeometry?>? padding, ValueGetter<Widget?>? placeholder, ValueGetter<CrossAxisAlignment>? crossAxisAlignment, ValueGetter<String?>? clearButtonSemanticLabel, ValueGetter<TextInputType?>? keyboardType, ValueGetter<TextInputAction?>? textInputAction, ValueGetter<TextCapitalization>? textCapitalization, ValueGetter<TextStyle?>? style, ValueGetter<StrutStyle?>? strutStyle, ValueGetter<TextAlign>? textAlign, ValueGetter<TextAlignVertical?>? textAlignVertical, ValueGetter<TextDirection?>? textDirection, ValueGetter<bool>? readOnly, ValueGetter<bool?>? showCursor, ValueGetter<bool>? autofocus, ValueGetter<String>? obscuringCharacter, ValueGetter<bool>? obscureText, ValueGetter<bool>? autocorrect, ValueGetter<SmartDashesType>? smartDashesType, ValueGetter<SmartQuotesType>? smartQuotesType, ValueGetter<bool>? enableSuggestions, ValueGetter<int?>? maxLines, ValueGetter<int?>? minLines, ValueGetter<bool>? expands, ValueGetter<int?>? maxLength, ValueGetter<MaxLengthEnforcement?>? maxLengthEnforcement, ValueGetter<ValueChanged<String>?>? onChanged, ValueGetter<VoidCallback?>? onEditingComplete, ValueGetter<ValueChanged<String>?>? onSubmitted, ValueGetter<TapRegionCallback?>? onTapOutside, ValueGetter<TapRegionCallback?>? onTapUpOutside, ValueGetter<List<TextInputFormatter>?>? inputFormatters, ValueGetter<bool>? enabled, ValueGetter<double>? cursorWidth, ValueGetter<double?>? cursorHeight, ValueGetter<Radius>? cursorRadius, ValueGetter<bool>? cursorOpacityAnimates, ValueGetter<Color?>? cursorColor, ValueGetter<ui.BoxHeightStyle>? selectionHeightStyle, ValueGetter<ui.BoxWidthStyle>? selectionWidthStyle, ValueGetter<Brightness?>? keyboardAppearance, ValueGetter<EdgeInsets>? scrollPadding, ValueGetter<bool>? enableInteractiveSelection, ValueGetter<TextSelectionControls?>? selectionControls, ValueGetter<DragStartBehavior>? dragStartBehavior, ValueGetter<ScrollController?>? scrollController, ValueGetter<ScrollPhysics?>? scrollPhysics, ValueGetter<GestureTapCallback?>? onTap, ValueGetter<Iterable<String>?>? autofillHints, ValueGetter<Clip>? clipBehavior, ValueGetter<String?>? restorationId, ValueGetter<bool>? stylusHandwritingEnabled, ValueGetter<bool>? enableIMEPersonalizedLearning, ValueGetter<ContentInsertionConfiguration?>? contentInsertionConfiguration, ValueGetter<EditableTextContextMenuBuilder?>? contextMenuBuilder, ValueGetter<String?>? hintText, ValueGetter<Border?>? border, ValueGetter<BorderRadiusGeometry?>? borderRadius, ValueGetter<bool?>? filled, ValueGetter<WidgetStatesController?>? statesController, ValueGetter<TextMagnifierConfiguration?>? magnifierConfiguration, ValueGetter<SpellCheckConfiguration?>? spellCheckConfiguration, ValueGetter<List<InputFeature>>? features, ValueGetter<List<TextInputFormatter>?>? submitFormatters, ValueGetter<bool>? skipInputFeatureFocusTraversal});
}
/// A highly customizable single-line text input widget with extensive feature support.
///
/// [TextField] provides a comprehensive text editing experience with support for
/// a wide range of input types, validation, formatting, and interactive features.
/// It serves as the foundation for most text input scenarios in the shadcn_flutter
/// design system, offering both basic text input and advanced capabilities through
/// its feature system.
///
/// Key features:
/// - Comprehensive text input with platform-native behavior
/// - Extensive customization through [InputFeature] system
/// - Built-in support for validation and formatting
/// - Configurable appearance with theming support
/// - Context menu customization and clipboard operations
/// - Keyboard shortcuts and accessibility support
/// - Form integration with automatic value management
///
/// The widget supports various input modes:
/// - Single-line text input (default)
/// - Obscured text for passwords
/// - Formatted input with custom formatters
/// - Auto-completion and suggestions
/// - Numeric input with spinners
///
/// Input features can be added to enhance functionality:
/// - Clear button for easy text clearing
/// - Password visibility toggle
/// - Copy/paste operations
/// - Auto-complete suggestions
/// - Validation indicators
/// - Custom leading/trailing widgets
///
/// Example:
/// ```dart
/// TextField(
///   hintText: 'Enter your email',
///   keyboardType: TextInputType.emailAddress,
///   features: [
///     InputClearFeature(),
///     InputRevalidateFeature(),
///   ],
///   onChanged: (text) => _handleTextChange(text),
/// );
/// ```
class TextField extends TextInputStatefulWidget {
/// Returns a native platform context menu builder.
///
/// Uses the platform's default text selection toolbar.
  static EditableTextContextMenuBuilder nativeContextMenuBuilder();
/// Returns a Cupertino-style context menu builder.
///
/// Uses iOS-style text selection toolbar.
  static EditableTextContextMenuBuilder cupertinoContextMenuBuilder();
/// Returns a Material Design context menu builder.
///
/// Uses Material Design text selection toolbar.
  static EditableTextContextMenuBuilder materialContextMenuBuilder();
/// Creates a text input field widget.
///
/// A comprehensive text field implementation with support for various input
/// types, validation, formatting, and interactive features. All parameters
/// are forwarded to the parent [TextInputStatefulWidget] constructor.
///
/// This constructor provides extensive customization options matching Flutter's
/// [EditableText] while adding custom features like input decorations, features,
/// and form integration.
///
/// Example:
/// ```dart
/// TextField(
///   controller: myController,
///   hintText: 'Enter text',
///   keyboardType: TextInputType.text,
///   maxLines: 3,
///   onChanged: (value) => print(value),
/// )
/// ```
///
/// See [TextInputStatefulWidget] and [TextInput] for parameter details.
  const TextField({super.key, super.groupId, super.controller, super.initialValue, super.focusNode, super.undoController, super.decoration, super.padding, super.placeholder, super.crossAxisAlignment, super.clearButtonSemanticLabel, super.keyboardType, super.textInputAction, super.textCapitalization, super.style, super.strutStyle, super.textAlign, super.textAlignVertical, super.textDirection, super.readOnly, super.showCursor, super.autofocus, super.obscuringCharacter, super.obscureText, super.autocorrect, super.smartDashesType, super.smartQuotesType, super.enableSuggestions, super.maxLines, super.minLines, super.expands, super.maxLength, super.maxLengthEnforcement, super.onChanged, super.onEditingComplete, super.onSubmitted, super.onTapOutside, super.onTapUpOutside, super.inputFormatters, super.enabled, super.cursorWidth, super.cursorHeight, super.cursorRadius, super.cursorOpacityAnimates, super.cursorColor, super.selectionHeightStyle, super.selectionWidthStyle, super.keyboardAppearance, super.scrollPadding, super.enableInteractiveSelection, super.selectionControls, super.dragStartBehavior, super.scrollController, super.scrollPhysics, super.onTap, super.autofillHints, super.clipBehavior, super.restorationId, super.stylusHandwritingEnabled, super.enableIMEPersonalizedLearning, super.contentInsertionConfiguration, super.contextMenuBuilder = defaultContextMenuBuilder, super.hintText, super.border, super.borderRadius, super.filled, super.statesController, super.magnifierConfiguration, super.spellCheckConfiguration, super.features, super.submitFormatters, super.skipInputFeatureFocusTraversal});
/// Default context menu builder for editable text.
///
/// Builds the standard context menu for text selection operations.
  static Widget defaultContextMenuBuilder(BuildContext context, EditableTextState editableTextState);
/// Default spell check suggestions toolbar builder.
///
/// Builds the toolbar showing spell check suggestions.
  static Widget defaultSpellCheckSuggestionsToolbarBuilder(BuildContext context, EditableTextState editableTextState);
  State<TextField> createState();
  void debugFillProperties(DiagnosticPropertiesBuilder properties);
}
/// State class for [TextField] widget.
///
/// Manages the text field's state including text editing, selection,
/// input features, form integration, and restoration.
class TextFieldState extends State<TextField> with RestorationMixin, AutomaticKeepAliveClientMixin<TextField>, FormValueSupplier<String, TextField>, TickerProviderStateMixin implements TextSelectionGestureDetectorBuilderDelegate, AutofillClient {
/// The effective text editing controller for this text field.
///
/// Returns the widget's controller or the internally created controller.
  TextEditingController get effectiveController;
  bool get forcePressEnabled;
  GlobalKey<EditableTextState> editableTextKey;
  bool get selectionEnabled;
  void initState();
  void didChangeDependencies();
  void didUpdateWidget(TextField oldWidget);
  void restoreState(RestorationBucket? oldBucket, bool initialRestore);
  String? get restorationId;
  void dispose();
  bool get wantKeepAlive;
  TextField get widget;
  String get autofillId;
  void autofill(TextEditingValue newEditingValue);
  TextInputConfiguration get textInputConfiguration;
  Widget build(BuildContext context);
  void didReplaceFormValue(String value);
}
/// Intent to append text to the current text field content.
///
/// Used with Flutter's Actions/Shortcuts system to programmatically
/// append text to a text field.
class TextFieldAppendTextIntent extends Intent {
/// Creates a [TextFieldAppendTextIntent] with the text to append.
  const TextFieldAppendTextIntent({required this.text});
/// The text to append to the current content.
  String text;
}
/// Intent to clear all text from the text field.
///
/// Used with Flutter's Actions/Shortcuts system to programmatically
/// clear text field content.
class TextFieldClearIntent extends Intent {
/// Creates a [TextFieldClearIntent].
  const TextFieldClearIntent();
}
/// Intent to replace the current word in the text field.
///
/// Replaces the word at the current cursor position with new text.
/// Used with Flutter's Actions/Shortcuts system.
class TextFieldReplaceCurrentWordIntent extends Intent {
/// Creates a [TextFieldReplaceCurrentWordIntent] with replacement text.
  const TextFieldReplaceCurrentWordIntent({required this.text});
/// The text to replace the current word with.
  String text;
}
/// Intent to set the entire text field content to a specific value.
///
/// Replaces all existing text with the provided text.
/// Used with Flutter's Actions/Shortcuts system.
class TextFieldSetTextIntent extends Intent {
/// Creates a [TextFieldSetTextIntent] with the new text.
  const TextFieldSetTextIntent({required this.text});
/// The text to set as the field's content.
  String text;
}
/// Intent to set the text selection in the text field.
///
/// Used with Flutter's Actions/Shortcuts system to programmatically
/// control cursor position and text selection.
class TextFieldSetSelectionIntent extends Intent {
/// The text selection to apply.
  TextSelection selection;
/// Creates a [TextFieldSetSelectionIntent] with the selection.
  const TextFieldSetSelectionIntent({required this.selection});
}
/// Intent to select all text in the field and copy it to clipboard.
///
/// Combines selection and copy operations in a single intent.
/// Used with Flutter's Actions/Shortcuts system.
class TextFieldSelectAllAndCopyIntent extends Intent {
/// Creates a [TextFieldSelectAllAndCopyIntent].
  const TextFieldSelectAllAndCopyIntent();
}
/// A file picker widget for selecting and managing file uploads.
///
/// **Work in Progress** - This component is under active development and
/// may have incomplete functionality or undergo API changes.
///
/// Provides a comprehensive interface for file selection with drag-and-drop
/// support, file management capabilities, and customizable presentation.
/// Displays selected files as a list of manageable items with options
/// for adding, removing, and organizing uploaded files.
///
/// Supports hot drop functionality for drag-and-drop file uploads and
/// provides visual feedback during file operations. The picker can be
/// customized with titles, subtitles, and custom file item presentations.
///
/// Example:
/// ```dart
/// FilePicker(
///   title: Text('Upload Documents'),
///   subtitle: Text('Drag files here or click to browse'),
///   hotDropEnabled: true,
///   onAdd: () => _selectFiles(),
///   children: selectedFiles.map((file) =>
///     FileItem(file: file, onRemove: () => _removeFile(file))
///   ).toList(),
/// )
/// ```
class FilePicker extends StatelessWidget {
/// Title widget displayed above the file picker.
  Widget? title;
/// Subtitle widget displayed below the title.
  Widget? subtitle;
/// Whether drag-and-drop functionality is enabled.
  bool hotDropEnabled;
/// Whether a drag-and-drop operation is currently in progress.
  bool hotDropping;
/// List of file item widgets to display.
  List<Widget> children;
/// Callback when the add file button is pressed.
  VoidCallback? onAdd;
/// Creates a [FilePicker].
///
/// Parameters:
/// - [title] (`Widget?`, optional): Title displayed above picker.
/// - [subtitle] (`Widget?`, optional): Subtitle below title.
/// - [hotDropEnabled] (`bool`, default: `false`): Enable drag-and-drop.
/// - [hotDropping] (`bool`, default: `false`): Currently dropping files.
/// - [onAdd] (`VoidCallback?`, optional): Called when add button pressed.
/// - [children] (`List<Widget>`, required): File item widgets.
  const FilePicker({super.key, this.title, this.subtitle, this.hotDropEnabled = false, this.hotDropping = false, this.onAdd, required this.children});
  Widget build(BuildContext context);
}
/// A widget representing a single file item in a file picker or upload list.
///
/// [FileItem] displays information about a selected or uploaded file including
/// name, size, type, and optional thumbnail. It provides interactive controls
/// for file management such as remove, retry, download, and preview actions.
///
/// Supports displaying upload progress for files currently being uploaded and
/// provides visual feedback through thumbnails and status indicators.
///
/// Example:
/// ```dart
/// FileItem(
///   fileName: Text('document.pdf'),
///   fileSize: Text('1.2 MB'),
///   fileType: Text('PDF'),
///   uploadProgress: 0.75, // 75% uploaded
///   onRemove: () => removeFile(),
///   thumbnail: Icon(Icons.picture_as_pdf),
/// )
/// ```
class FileItem extends StatelessWidget {
/// Upload progress from 0.0 to 1.0, or null if not uploading.
  double? uploadProgress;
/// Called when the remove button is pressed.
  VoidCallback? onRemove;
/// Called when the retry button is pressed (for failed uploads).
  VoidCallback? onRetry;
/// Called when the download button is pressed.
  VoidCallback? onDownload;
/// Optional thumbnail widget for the file.
  Widget? thumbnail;
/// Called when the preview button is pressed.
  VoidCallback? onPreview;
/// Widget displaying the file name.
  Widget fileName;
/// Optional widget displaying the file size.
  Widget? fileSize;
/// Optional widget displaying the file type/format.
  Widget? fileType;
/// Creates a [FileItem].
  const FileItem({super.key, this.uploadProgress, this.onRemove, this.onRetry, this.onDownload, this.thumbnail, this.onPreview, required this.fileName, this.fileSize, this.fileType});
  Widget build(BuildContext context);
}
/// Theme configuration for [ChipInput] widget styling and behavior.
///
/// Defines visual properties and default behaviors for chip input components
/// including popover constraints and chip rendering preferences. Applied globally
/// through [ComponentTheme] or per-instance for customization.
class ChipInputTheme extends ComponentThemeData {
/// Whether to render selected items as interactive chip widgets by default.
///
/// When true, selected items appear as dismissible chip widgets with close buttons.
/// When false, items appear as simple text tokens. Individual [ChipInput] widgets
/// can override this default behavior.
  bool? useChips;
/// The spacing between chips.
  double? spacing;
/// Creates a [ChipInputTheme].
///
/// All parameters are optional and fall back to framework defaults when null.
/// The theme can be applied globally or to specific chip input instances.
  const ChipInputTheme({this.spacing, this.useChips});
/// Creates a copy of this theme with specified properties overridden.
///
/// Each parameter function is called only if provided, allowing selective
/// overrides while preserving existing values for unspecified properties.
  ChipInputTheme copyWith({ValueGetter<BoxConstraints?>? popoverConstraints, ValueGetter<bool?>? useChips, ValueGetter<double?>? spacing});
  bool operator ==(Object other);
  int get hashCode;
}
/// A text editing controller that supports inline chip widgets.
///
/// Extends [TextEditingController] to manage text with embedded chip objects
/// represented by special Unicode codepoints from the Private Use Area (U+E000-U+F8FF).
/// Each chip is mapped to a unique codepoint allowing up to 6400 chips per controller.
///
/// Use this when you need to display removable tags or tokens within a text field,
/// such as email recipients, keywords, or selected items.
///
/// Example:
/// ```dart
/// final controller = ChipEditingController<String>(
///   initialChips: ['tag1', 'tag2'],
/// );
/// ```
class ChipEditingController<T> extends TextEditingController {
/// Factory constructor creating a chip editing controller.
///
/// Optionally initializes with [text] and [initialChips].
  factory ChipEditingController({String? text, List<T>? initialChips});
  set text(String newText);
  set value(TextEditingValue newValue);
/// Returns an unmodifiable list of all chips in the controller.
  List<T> get chips;
/// Sets the chips in this controller, replacing all existing chips.
  set chips(List<T> newChips);
/// Removes all chips from the controller, leaving only plain text.
  void removeAllChips();
  TextSpan buildTextSpan({required BuildContext context, TextStyle? style, required bool withComposing});
/// Returns the plain text without chip characters.
  String get plainText;
/// Returns the text at the current cursor position.
  String get textAtCursor;
/// Inserts a chip at the cursor position by converting the text at cursor.
///
/// Uses [chipConverter] to convert the text at cursor to a chip.
  void insertChipAtCursor(T? Function(String chipText) chipConverter);
/// Clears the text at the current cursor position.
  void clearTextAtCursor();
/// Appends a chip at the end of the chip sequence.
  void appendChip(T chip);
/// Appends a chip at the current cursor position.
  void appendChipAtCursor(T chip);
/// Inserts a chip at a specific position in the text.
  void insertChip(T chip);
/// Removes the specified chip from the controller.
  void removeChip(T chip);
}
/// A text input widget that supports inline chip elements.
///
/// Allows users to create chip tokens within a text field, useful for
/// tags, email recipients, or any multi-item input scenario.
class ChipInput<T> extends TextInputStatefulWidget {
/// Checks if a code unit represents a chip character.
  static bool isChipUnicode(int codeUnit);
/// Checks if a string character is a chip character.
  static bool isChipCharacter(String character);
/// Builder function for creating chip widgets.
  ChipWidgetBuilder<T> chipBuilder;
/// Callback to convert text into a chip object.
  ChipSubmissionCallback<T> onChipSubmitted;
/// Callback invoked when the list of chips changes.
  ValueChanged<List<T>>? onChipsChanged;
/// Whether to display items as visual chips (defaults to theme setting).
  bool? useChips;
/// Initial chips to display in the input.
  List<T>? initialChips;
/// Whether to automatically insert autocomplete suggestions as chips.
  bool autoInsertSuggestion;
/// Creates a chip input widget.
  const ChipInput({super.key, super.groupId, ChipEditingController<T>? super.controller, super.focusNode, super.decoration, super.padding, super.placeholder, super.crossAxisAlignment, super.clearButtonSemanticLabel, super.keyboardType, super.textInputAction, super.textCapitalization, super.style, super.strutStyle, super.textAlign, super.textAlignVertical, super.textDirection, super.readOnly, super.showCursor, super.autofocus, super.obscuringCharacter, super.obscureText, super.autocorrect, super.smartDashesType, super.smartQuotesType, super.enableSuggestions, super.maxLines, super.minLines, super.expands, super.maxLength, super.maxLengthEnforcement, super.onChanged, super.onEditingComplete, super.onSubmitted, super.onTapOutside, super.onTapUpOutside, super.inputFormatters, super.enabled, super.cursorWidth, super.cursorHeight, super.cursorRadius, super.cursorOpacityAnimates, super.cursorColor, super.selectionHeightStyle, super.selectionWidthStyle, super.keyboardAppearance, super.scrollPadding, super.enableInteractiveSelection, super.selectionControls, super.dragStartBehavior, super.scrollController, super.scrollPhysics, super.onTap, super.autofillHints, super.clipBehavior, super.restorationId, super.stylusHandwritingEnabled, super.enableIMEPersonalizedLearning, super.contentInsertionConfiguration, super.contextMenuBuilder, super.initialValue, super.hintText, super.border, super.borderRadius, super.filled, super.statesController, super.magnifierConfiguration, super.spellCheckConfiguration, super.undoController, super.features, super.submitFormatters, super.skipInputFeatureFocusTraversal, required this.chipBuilder, required this.onChipSubmitted, this.autoInsertSuggestion = true, this.onChipsChanged, this.useChips, this.initialChips});
  ChipEditingController<T>? get controller;
  State<ChipInput<T>> createState();
}
/// State class for [ChipInput].
///
/// Manages the chip input's internal state and chip rendering.
class ChipInputState<T> extends State<ChipInput<T>> with FormValueSupplier<List<T>, ChipInput<T>> implements _ChipProvider<T> {
  Widget? buildChip(BuildContext context, T chip);
  void initState();
  void didUpdateWidget(covariant ChipInput<T> oldWidget);
  void dispose();
  Widget build(BuildContext context);
  void didReplaceFormValue(List<T> value);
}
/// Intent for submitting a chip in the chip input.
class ChipSubmitIntent extends Intent {
/// Creates a chip submit intent.
  const ChipSubmitIntent();
}
/// Theme configuration for [TimePicker] widget appearance and behavior.
///
/// Defines default settings for time picker components including display
/// format, popover positioning, and dialog customization.
class TimePickerTheme extends ComponentThemeData {
/// Mode for displaying the time picker (popover or dialog).
  PromptMode? mode;
/// Alignment of the popover relative to its anchor.
  AlignmentGeometry? popoverAlignment;
/// Alignment point on the anchor widget for popover positioning.
  AlignmentGeometry? popoverAnchorAlignment;
/// Padding inside the popover.
  EdgeInsetsGeometry? popoverPadding;
/// Whether to use 24-hour time format.
  bool? use24HourFormat;
/// Whether to show seconds picker.
  bool? showSeconds;
/// Custom title widget for the time picker dialog.
  Widget? dialogTitle;
/// Creates a [TimePickerTheme].
  const TimePickerTheme({this.mode, this.popoverAlignment, this.popoverAnchorAlignment, this.popoverPadding, this.use24HourFormat, this.showSeconds, this.dialogTitle});
/// Creates a copy of this theme with the given fields replaced.
  TimePickerTheme copyWith({ValueGetter<PromptMode?>? mode, ValueGetter<AlignmentGeometry?>? popoverAlignment, ValueGetter<AlignmentGeometry?>? popoverAnchorAlignment, ValueGetter<EdgeInsetsGeometry?>? popoverPadding, ValueGetter<bool?>? use24HourFormat, ValueGetter<bool?>? showSeconds, ValueGetter<Widget?>? dialogTitle});
  bool operator ==(Object other);
  int get hashCode;
}
/// A controller for managing [ControlledTimePicker] values programmatically.
///
/// This controller extends `ValueNotifier<TimeOfDay?>` to provide reactive
/// state management for time picker components. It implements [ComponentController]
/// to integrate with the controlled component system, allowing external control
/// and listening to time selection changes.
///
/// Example:
/// ```dart
/// final controller = TimePickerController(TimeOfDay(hour: 12, minute: 30));
/// controller.addListener(() {
///   print('Selected time: ${controller.value}');
/// });
/// ```
class TimePickerController extends ValueNotifier<TimeOfDay?> with ComponentController<TimeOfDay?> {
/// Creates a [TimePickerController] with an optional initial value.
///
/// Parameters:
/// - [value] (TimeOfDay?, optional): Initial time value for the controller
  TimePickerController([super.value]);
}
/// A controlled time picker widget for selecting time values with external state management.
///
/// This widget provides a time selection interface that can be controlled either through
/// a [TimePickerController] or through direct property values. It supports multiple
/// presentation modes (dialog or popover), customizable time formats (12-hour/24-hour),
/// and optional seconds display.
///
/// The time picker integrates with the controlled component system, making it suitable
/// for form integration, validation, and programmatic control. It presents the selected
/// time in a readable format and opens an interactive time selection interface when activated.
///
/// Example:
/// ```dart
/// ControlledTimePicker(
///   initialValue: TimeOfDay(hour: 9, minute: 30),
///   use24HourFormat: true,
///   showSeconds: false,
///   placeholder: Text('Select meeting time'),
///   onChanged: (time) {
///     print('Selected time: ${time?.format(context)}');
///   },
/// );
/// ```
class ControlledTimePicker extends StatelessWidget with ControlledComponent<TimeOfDay?> {
  TimeOfDay? initialValue;
  ValueChanged<TimeOfDay?>? onChanged;
  bool enabled;
  TimePickerController? controller;
/// The presentation mode for the time picker interface.
///
/// Determines how the time selection interface is displayed to the user.
/// Can be either dialog mode (modal popup) or popover mode (dropdown).
  PromptMode mode;
/// Widget displayed when no time is selected.
///
/// This placeholder appears in the picker button when [initialValue] is null
/// and no time has been selected yet. If null, a default placeholder is used.
  Widget? placeholder;
/// Alignment for the popover relative to its anchor widget.
///
/// Used only when [mode] is [PromptMode.popover]. Controls where the popover
/// appears relative to the picker button.
  AlignmentGeometry? popoverAlignment;
/// Alignment of the anchor point on the picker button.
///
/// Used only when [mode] is [PromptMode.popover]. Determines which point
/// on the picker button the popover aligns to.
  AlignmentGeometry? popoverAnchorAlignment;
/// Internal padding for the popover content.
///
/// Used only when [mode] is [PromptMode.popover]. Controls spacing inside
/// the popover container around the time picker interface.
  EdgeInsetsGeometry? popoverPadding;
/// Whether to use 24-hour format for time display and input.
///
/// When true, times are displayed in 24-hour format (00:00-23:59).
/// When false or null, uses the system default format preference.
  bool? use24HourFormat;
/// Whether to include seconds in the time selection.
///
/// When true, the time picker allows selection of seconds in addition
/// to hours and minutes. When false, only hours and minutes are selectable.
  bool showSeconds;
/// Optional title widget for the dialog mode.
///
/// Used only when [mode] is [PromptMode.dialog]. Displayed at the top
/// of the modal time picker dialog.
  Widget? dialogTitle;
/// Creates a [ControlledTimePicker].
///
/// Either [controller] or [initialValue] should be provided to establish
/// the initial time state. The picker can be customized with various
/// presentation options and time format preferences.
///
/// Parameters:
/// - [controller] (TimePickerController?, optional): External controller for programmatic control
/// - [initialValue] (TimeOfDay?, optional): Initial time when no controller is provided
/// - [onChanged] (`ValueChanged<TimeOfDay?>?`, optional): Callback for time selection changes
/// - [enabled] (bool, default: true): Whether the picker accepts user interaction
/// - [mode] (PromptMode, default: PromptMode.dialog): Presentation style (dialog or popover)
/// - [placeholder] (Widget?, optional): Content displayed when no time is selected
/// - [popoverAlignment] (AlignmentGeometry?, optional): Popover positioning relative to anchor
/// - [popoverAnchorAlignment] (AlignmentGeometry?, optional): Anchor point on picker button
/// - [popoverPadding] (EdgeInsetsGeometry?, optional): Internal popover content padding
/// - [use24HourFormat] (bool?, optional): Whether to use 24-hour time format
/// - [showSeconds] (bool, default: false): Whether to include seconds selection
/// - [dialogTitle] (Widget?, optional): Title for dialog mode display
///
/// Example:
/// ```dart
/// ControlledTimePicker(
///   initialValue: TimeOfDay(hour: 14, minute: 30),
///   mode: PromptMode.popover,
///   use24HourFormat: true,
///   onChanged: (time) => print('Selected: $time'),
/// );
/// ```
  const ControlledTimePicker({super.key, this.controller, this.initialValue, this.onChanged, this.enabled = true, this.mode = PromptMode.dialog, this.placeholder, this.popoverAlignment, this.popoverAnchorAlignment, this.popoverPadding, this.use24HourFormat, this.showSeconds = false, this.dialogTitle});
  Widget build(BuildContext context);
}
/// A time picker widget for selecting time values.
///
/// Provides time selection interface with hours, minutes, and optional
/// seconds in either popover or dialog mode.
class TimePicker extends StatelessWidget {
/// The currently selected time value.
  TimeOfDay? value;
/// Callback invoked when the selected time changes.
  ValueChanged<TimeOfDay?>? onChanged;
/// The display mode for the time picker (popover or dialog).
  PromptMode mode;
/// Placeholder widget shown when no time is selected.
  Widget? placeholder;
/// Alignment of the popover relative to the anchor.
  AlignmentGeometry? popoverAlignment;
/// Anchor alignment for the popover.
  AlignmentGeometry? popoverAnchorAlignment;
/// Padding inside the popover.
  EdgeInsetsGeometry? popoverPadding;
/// Whether to use 24-hour format.
  bool? use24HourFormat;
/// Whether to show seconds selection.
  bool showSeconds;
/// Title widget for the dialog mode.
  Widget? dialogTitle;
/// Whether the time picker is enabled.
  bool? enabled;
/// Creates a time picker.
  const TimePicker({super.key, required this.value, this.onChanged, this.mode = PromptMode.dialog, this.placeholder, this.popoverAlignment, this.popoverAnchorAlignment, this.popoverPadding, this.use24HourFormat, this.showSeconds = false, this.dialogTitle, this.enabled});
  Widget build(BuildContext context);
}
/// Dialog widget for interactive time selection.
///
/// Displays input fields for hours, minutes, and optional seconds
/// with AM/PM toggle for 12-hour format.
class TimePickerDialog extends StatefulWidget {
/// The initial time value.
  TimeOfDay? initialValue;
/// Callback invoked when the time changes.
  ValueChanged<TimeOfDay?>? onChanged;
/// Whether to use 24-hour format.
  bool use24HourFormat;
/// Whether to show seconds input.
  bool showSeconds;
/// Creates a time picker dialog.
  const TimePickerDialog({super.key, this.initialValue, this.onChanged, required this.use24HourFormat, this.showSeconds = false});
  State<TimePickerDialog> createState();
}
/// Controller for managing [DurationPicker] values programmatically.
///
/// Extends `ValueNotifier<Duration?>` to provide reactive state management
/// for duration picker components. Integrates with the controlled component
/// system for external control and change notifications.
///
/// Example:
/// ```dart
/// final controller = DurationPickerController(Duration(hours: 2, minutes: 30));
/// controller.addListener(() {
///   print('Selected duration: ${controller.value}');
/// });
/// ```
class DurationPickerController extends ValueNotifier<Duration?> with ComponentController<Duration?> {
/// Creates a [DurationPickerController] with an initial value.
  DurationPickerController(super.value);
}
/// Widget for picking duration values with day, hour, minute, and second components.
///
/// Provides an input interface for selecting time durations. Can be controlled
/// externally via [DurationPickerController] or used with callbacks.
///
/// Example:
/// ```dart
/// DurationPicker(
///   value: Duration(hours: 1, minutes: 30),
///   onChanged: (duration) {
///     print('Selected: $duration');
///   },
/// )
/// ```
class DurationPicker extends StatelessWidget {
/// The currently selected duration value.
  Duration? value;
/// Callback invoked when the selected duration changes.
  ValueChanged<Duration?>? onChanged;
/// The display mode for the duration picker (popover or dialog).
  PromptMode mode;
/// Placeholder widget shown when no duration is selected.
  Widget? placeholder;
/// Alignment of the popover relative to the anchor.
  AlignmentGeometry? popoverAlignment;
/// Anchor alignment for the popover.
  AlignmentGeometry? popoverAnchorAlignment;
/// Padding inside the popover.
  EdgeInsetsGeometry? popoverPadding;
/// Title widget for the dialog mode.
  Widget? dialogTitle;
/// Whether the duration picker is enabled.
  bool? enabled;
/// Creates a duration picker.
  const DurationPicker({super.key, required this.value, this.onChanged, this.mode = PromptMode.dialog, this.placeholder, this.popoverAlignment, this.popoverAnchorAlignment, this.popoverPadding, this.dialogTitle, this.enabled});
  Widget build(BuildContext context);
}
/// Dialog widget for interactive duration selection.
///
/// Displays input fields for days, hours, minutes, and seconds
/// for selecting durations.
class DurationPickerDialog extends StatefulWidget {
/// The initial duration value.
  Duration? initialValue;
/// Callback invoked when the duration changes.
  ValueChanged<Duration?>? onChanged;
/// Creates a duration picker dialog.
  const DurationPickerDialog({super.key, this.initialValue, this.onChanged});
  State<DurationPickerDialog> createState();
}
/// Represents a range of time with a start and end time.
///
/// Used to define time intervals or periods. Both [start] and [end]
/// are represented as [TimeOfDay] values.
///
/// Example:
/// ```dart
/// final workHours = TimeRange(
///   start: TimeOfDay(hour: 9, minute: 0),
///   end: TimeOfDay(hour: 17, minute: 0),
/// );
/// ```
class TimeRange {
/// The start time of the range.
  TimeOfDay start;
/// The end time of the range.
  TimeOfDay end;
/// Creates a [TimeRange] with the specified start and end times.
  const TimeRange({required this.start, required this.end});
/// Creates a copy of this range with the given fields replaced.
  TimeRange copyWith({ValueGetter<TimeOfDay>? start, ValueGetter<TimeOfDay>? end});
  bool operator ==(Object other);
  int get hashCode;
  String toString();
}
/// Represents a collection of list modifications.
///
/// Encapsulates multiple [ListChange] objects that can be applied to a list
/// in sequence. Useful for batch operations or undo/redo functionality.
class ListChanges<T> {
/// The list of individual changes to apply.
  List<ListChange<T>> changes;
/// Creates a [ListChanges] with the specified [changes].
  const ListChanges(this.changes);
/// Applies all changes to the given [list] in order.
///
/// Parameters:
/// - [list] (`List<T>`, required): The list to modify.
  void apply(List<T> list);
}
/// Base class for list modification operations.
///
/// Extend this class to create custom list change types. Each change
/// implements [apply] to modify a list in a specific way.
abstract class ListChange<T> {
/// Creates a [ListChange].
  const ListChange();
/// Applies this change to the given [list].
///
/// Parameters:
/// - [list] (`List<T>`, required): The list to modify.
  void apply(List<T> list);
}
/// A list change that swaps two items.
///
/// Exchanges the items at positions [from] and [to] in the list.
class ListSwapChange<T> extends ListChange<T> {
/// The source index.
  int from;
/// The destination index.
  int to;
/// Creates a [ListSwapChange] that swaps items at [from] and [to].
  const ListSwapChange(this.from, this.to);
  void apply(List<T> list);
}
/// A list change that removes an item.
///
/// Removes the item at the specified [index] from the list.
class ListRemoveChange<T> extends ListChange<T> {
/// The index of the item to remove.
  int index;
/// Creates a [ListRemoveChange] that removes the item at [index].
  const ListRemoveChange(this.index);
  void apply(List<T> list);
}
/// A list change that inserts an item.
///
/// Inserts [item] at the specified [index] in the list.
class ListInsertChange<T> extends ListChange<T> {
/// The index where the item will be inserted.
  int index;
/// The item to insert.
  T item;
/// Creates a [ListInsertChange] that inserts [item] at [index].
  const ListInsertChange(this.index, this.item);
  void apply(List<T> list);
}
/// A low-level sortable list widget with customizable rendering.
///
/// Provides the foundation for building sortable lists with custom item
/// rendering and change tracking. Use this when you need fine-grained control
/// over the sortable list behavior.
class RawSortableList<T> extends StatelessWidget {
/// The delegate that provides item data.
  SortableListDelegate<T> delegate;
/// Builder for creating item widgets.
  SortableWidgetBuilder<T> builder;
/// Callback invoked when the list order changes.
///
/// Receives a [ListChanges] object containing all modifications.
  ValueChanged<ListChanges<T>>? onChanged;
/// Whether the list accepts reordering interactions.
  bool enabled;
/// Creates a [RawSortableList].
///
/// Parameters:
/// - [delegate] (`SortableListDelegate<T>`, required): Provides item data.
/// - [builder] (`SortableWidgetBuilder<T>`, required): Builds item widgets.
/// - [onChanged] (`ValueChanged<ListChanges<T>>?`, optional): Change callback.
/// - [enabled] (`bool`, default: `true`): Whether reordering is enabled.
  const RawSortableList({super.key, required this.delegate, required this.builder, this.onChanged, this.enabled = true});
  Widget build(BuildContext context);
}
/// Parent data for sortable items within a [RawSortableStack].
///
/// Extends [ContainerBoxParentData] to include positioning information
/// for items in a sortable layout.
class RawSortableParentData extends ContainerBoxParentData<RenderBox> {
/// The current position offset of this sortable item.
  Offset? position;
}
/// Widget that positions a sortable item at a specific offset.
///
/// Used internally by sortable lists to position items during drag
/// operations. Wraps a child widget and updates its parent data with
/// the specified [offset].
class RawSortableItemPositioned extends ParentDataWidget<RawSortableParentData> {
/// The offset where the item should be positioned.
  Offset offset;
/// Creates a [RawSortableItemPositioned].
///
/// Parameters:
/// - [offset] (`Offset`, required): Position offset for the child.
/// - [child] (`Widget`, required): The child widget to position.
  const RawSortableItemPositioned({super.key, required this.offset, required super.child});
  void applyParentData(RenderObject renderObject);
  Type get debugTypicalAncestorWidgetClass;
}
/// RawSortableStack prevents the stacking children from going outside the bounds of this widget.
/// A raw sortable stack widget for managing layered sortable items.
///
/// Provides basic stacking functionality for sortable components without
/// additional layout or styling. Clamps child positions to widget bounds.
class RawSortableStack extends MultiChildRenderObjectWidget {
/// Creates a raw sortable stack.
  const RawSortableStack({super.key, required super.children});
  RenderObject createRenderObject(BuildContext context);
  void updateRenderObject(BuildContext context, RenderRawSortableStack renderObject);
}
/// Render object for managing sortable item stacking and positioning.
///
/// Handles layout, painting, and hit testing for sortable items arranged
/// in a stack. Clamps child positions to widget bounds to prevent items
/// from escaping during drag operations.
class RenderRawSortableStack extends RenderBox with ContainerRenderObjectMixin<RenderBox, RawSortableParentData>, RenderBoxContainerDefaultsMixin<RenderBox, RawSortableParentData> {
/// Whether drag-and-drop interactions are enabled.
  bool enabled;
  void setupParentData(RenderBox child);
  void performLayout();
  void paint(PaintingContext context, Offset offset);
  bool hitTestChildren(BoxHitTestResult result, {required Offset position});
}
/// Abstract base for providing items to a sortable list.
///
/// Implement this class to create custom item sources for sortable lists.
/// Provides item count and item retrieval methods.
abstract class SortableListDelegate<T> {
/// Creates a [SortableListDelegate].
  const SortableListDelegate();
/// The number of items in the list.
///
/// Returns `null` for infinite or unknown-length lists.
  int? get itemCount;
/// Retrieves the item at the specified [index].
///
/// Parameters:
/// - [context] (`BuildContext`, required): Build context.
/// - [index] (`int`, required): Item index.
///
/// Returns: `T` ‚Äî the item data.
  T getItem(BuildContext context, int index);
}
/// A delegate that provides items from an explicit list.
///
/// Wraps a fixed [List] of items for use in a sortable list.
class SortableChildListDelegate<T> extends SortableListDelegate<T> {
/// The list of items.
  List<T> items;
/// Builder for creating item widgets.
  SortableWidgetBuilder<T> builder;
/// Creates a [SortableChildListDelegate].
///
/// Parameters:
/// - [items] (`List<T>`, required): The list of items.
/// - [builder] (`SortableWidgetBuilder<T>`, required): Item widget builder.
  const SortableChildListDelegate(this.items, this.builder);
  int get itemCount;
  T getItem(BuildContext context, int index);
}
/// A delegate that builds items on demand.
///
/// Creates items using a builder function rather than from a fixed list.
/// Useful for large or lazily-generated item sets.
class SortableChildBuilderDelegate<T> extends SortableListDelegate<T> {
/// The number of items, or `null` for infinite lists.
  int? itemCount;
/// Builder function for creating items.
  SortableItemBuilder<T> builder;
/// Creates a [SortableChildBuilderDelegate].
///
/// Parameters:
/// - [itemCount] (`int?`, optional): Number of items, or `null` for infinite.
/// - [builder] (`SortableItemBuilder<T>`, required): Item builder function.
  const SortableChildBuilderDelegate({this.itemCount, required this.builder});
  T getItem(BuildContext context, int index);
}
/// A mixin that defines the interface for controlling component values.
///
/// This mixin combines the capabilities of [ValueNotifier] to provide
/// a standardized way for widgets to expose their current value and
/// notify listeners of changes. Components that implement this interface
/// can be controlled programmatically and integrated with form validation
/// systems.
///
/// The generic type [T] represents the type of value this controller manages.
mixin ComponentController<T> implements ValueNotifier<T> {
}
/// A concrete implementation of [ComponentController] that manages a single value.
///
/// This controller provides a simple way to programmatically control any
/// component that accepts a [ComponentController]. It extends [ValueNotifier]
/// to provide change notification capabilities.
///
/// The controller maintains the current value and notifies listeners when
/// the value changes through the inherited [ValueNotifier.value] setter.
///
/// Example:
/// ```dart
/// final controller = ComponentValueController<String>('initial value');
///
/// // Listen to changes
/// controller.addListener(() {
///   print('Value changed to: ${controller.value}');
/// });
///
/// // Update the value
/// controller.value = 'new value';
/// ```
class ComponentValueController<T> extends ValueNotifier<T> implements ComponentController<T> {
/// Creates a [ComponentValueController] with the given initial [value].
///
/// The [value] parameter sets the initial state of the controller.
/// Listeners will be notified whenever this value changes.
  ComponentValueController(super.value);
}
/// A mixin that provides a standardized interface for controlled components.
///
/// This mixin defines the contract that all controlled form components should
/// follow. It provides properties for external control through a controller,
/// initial value specification, change notifications, and enabled state management.
///
/// Components that use this mixin can be controlled either through a
/// [ComponentController] (for programmatic control) or through direct
/// property values (for declarative control).
///
/// The generic type [T] represents the type of value this component manages.
mixin ControlledComponent<T> on Widget {
/// The controller for managing this component's value programmatically.
///
/// When provided, the controller takes precedence over [initialValue]
/// and manages the component's state externally. This is useful for
/// form validation, programmatic value changes, and state persistence.
  ComponentController<T>? get controller;
/// The initial value for this component when no controller is provided.
///
/// This value is used only when [controller] is null. It sets the
/// component's initial state and is ignored if a controller is present.
  T? get initialValue;
/// Callback invoked when the component's value changes.
///
/// This callback is called whenever the user interacts with the component
/// or when the value is changed programmatically. The callback receives
/// the new value as its parameter.
  ValueChanged<T>? get onChanged;
/// Whether this component is enabled and accepts user input.
///
/// When false, the component is displayed in a disabled state and
/// does not respond to user interactions. The visual appearance
/// typically changes to indicate the disabled state.
  bool get enabled;
}
/// Immutable data container for controlled component state.
///
/// This class encapsulates the three essential pieces of state that
/// controlled components need: the current value, a change callback,
/// and the enabled status. It provides a convenient way to pass
/// this state to widget builders.
///
/// The generic type [T] represents the type of value being managed.
class ControlledComponentData<T> {
/// The current value of the component.
///
/// This represents the component's current state and should be
/// used by the UI to display the correct value to the user.
  T value;
/// Callback to invoke when the value should change.
///
/// This callback should be called whenever the user interaction
/// or programmatic action requires the value to be updated.
/// The new value should be passed as the parameter.
  ValueChanged<T> onChanged;
/// Whether the component should accept user input.
///
/// When false, the component should display in a disabled state
/// and ignore user interactions.
  bool enabled;
/// Creates a [ControlledComponentData] with the specified state.
///
/// All parameters are required as they represent the essential
/// state needed for any controlled component to function properly.
///
/// Parameters:
/// - [value] (T, required): The current value to display
/// - [onChanged] (`ValueChanged<T>`, required): Callback for value changes
/// - [enabled] (bool, required): Whether the component accepts input
  const ControlledComponentData({required this.value, required this.onChanged, required this.enabled});
}
/// A widget adapter that bridges controlled component logic with custom UI implementations.
///
/// This adapter provides a standardized way to implement controlled components
/// by handling the common logic for value management, controller integration,
/// and state synchronization. It implements the [ControlledComponent] mixin
/// and manages the lifecycle of value updates between controllers and UI.
///
/// The adapter supports both controlled mode (with a [controller]) and
/// uncontrolled mode (with an [initialValue]). When a controller is provided,
/// it becomes the source of truth for the component's value. When no controller
/// is provided, the component maintains its own internal state.
///
/// The generic type [T] represents the type of value this adapter manages.
///
/// Example:
/// ```dart
/// ControlledComponentAdapter<String>(
///   initialValue: 'Hello',
///   onChanged: (value) => print('Value changed: $value'),
///   builder: (context, data) {
///     return GestureDetector(
///       onTap: () => data.onChanged('${data.value}!'),
///       child: Text(data.value),
///     );
///   },
/// );
/// ```
class ControlledComponentAdapter<T> extends StatefulWidget with ControlledComponent<T> {
  T? initialValue;
  ValueChanged<T>? onChanged;
  bool enabled;
  ComponentController<T>? controller;
/// A builder function that creates the widget UI using the provided state data.
///
/// This function receives the current [BuildContext] and [ControlledComponentData]
/// containing the current value, change callback, and enabled state. The builder
/// should create a widget that displays the current value and calls the
/// onChanged callback when user interaction occurs.
  Widget Function(BuildContext context, ControlledComponentData<T> data) builder;
/// Creates a [ControlledComponentAdapter].
///
/// Either [controller] or [initialValue] must be provided to establish
/// the component's initial state. The [builder] function is required
/// and will be called to construct the UI with the current state.
///
/// Parameters:
/// - [builder] (required): Function that builds the UI using state data
/// - [initialValue] (T?, optional): Initial value when no controller is used
/// - [onChanged] (`ValueChanged<T>?`, optional): Callback for value changes
/// - [controller] (`ComponentController<T>?`, optional): External controller for value management
/// - [enabled] (bool, default: true): Whether the component accepts user input
///
/// Throws [AssertionError] if neither controller nor initialValue is provided.
///
/// Example:
/// ```dart
/// ControlledComponentAdapter<bool>(
///   initialValue: false,
///   enabled: true,
///   builder: (context, data) => Switch(
///     value: data.value,
///     onChanged: data.enabled ? data.onChanged : null,
///   ),
/// );
/// ```
  const ControlledComponentAdapter({super.key, required this.builder, this.initialValue, this.onChanged, this.controller, this.enabled = true});
  State<ControlledComponentAdapter<T>> createState();
}
/// Abstract base class for implementing form field validation logic.
///
/// Validators are responsible for checking the validity of form field values
/// and returning appropriate validation results. They support both synchronous
/// and asynchronous validation through the [FutureOr] return type.
///
/// Validators can be combined using logical operators:
/// - `&` or `+`: Combines validators (all must pass)
/// - `|`: Creates OR logic (at least one must pass)
/// - `~` or unary `-`: Negates the validator result
///
/// The generic type [T] represents the type of value being validated.
///
/// Example:
/// ```dart
/// final validator = RequiredValidator<String>() &
///                   MinLengthValidator(3) &
///                   EmailValidator();
/// ```
abstract class Validator<T> {
/// Creates a [Validator].
  const Validator();
/// Validates the given [value] and returns a validation result.
///
/// This method performs the actual validation logic and should return
/// null if the value is valid, or a [ValidationResult] describing the
/// validation error if invalid.
///
/// Parameters:
/// - [context] (BuildContext): The build context for localization access
/// - [value] (T?): The value to validate (may be null)
/// - [lifecycle] (FormValidationMode): The current validation trigger mode
///
/// Returns a `FutureOr<ValidationResult?>` that is null for valid values
/// or contains error information for invalid values.
  FutureOr<ValidationResult?> validate(BuildContext context, T? value, FormValidationMode lifecycle);
/// Combines this validator with another validator using AND logic.
///
/// Both validators must pass for the combined validator to be valid.
/// If either validator fails, the combined validator fails.
///
/// Parameters:
/// - [other] (`Validator<T>`): The validator to combine with this one
///
/// Returns a new [CompositeValidator] that requires both validators to pass.
///
/// Example:
/// ```dart
/// final combined = requiredValidator.combine(emailValidator);
/// ```
  Validator<T> combine(Validator<T> other);
/// Combines this validator with another using AND logic (alias for [combine]).
///
/// This operator provides a convenient syntax for combining validators
/// where both must pass for validation to succeed.
///
/// Example:
/// ```dart
/// final validator = RequiredValidator<String>() & EmailValidator();
/// ```
  Validator<T> operator &(Validator<T> other);
/// Combines this validator with another using OR logic.
///
/// At least one validator must pass for the combined validator to be valid.
/// Only if both validators fail will the combined validator fail.
///
/// Parameters:
/// - [other] (`Validator<T>`): The validator to combine with this one using OR logic
///
/// Returns a new [OrValidator] that requires at least one validator to pass.
///
/// Example:
/// ```dart
/// final validator = emailValidator | phoneValidator;
/// ```
  Validator<T> operator |(Validator<T> other);
/// Negates this validator's result.
///
/// Creates a validator that passes when this validator fails, and
/// fails when this validator passes. Useful for creating inverse
/// validation logic.
///
/// Returns a [NotValidator] that inverts this validator's result.
///
/// Example:
/// ```dart
/// final notEmpty = ~EmptyValidator<String>();
/// ```
  Validator<T> operator ~();
/// Negates this validator's result (alias for `~` operator).
///
/// Provides an alternative syntax for creating negated validators.
///
/// Example:
/// ```dart
/// final notEmpty = -EmptyValidator<String>();
/// ```
  Validator<T> operator -();
/// Combines this validator with another using AND logic (alias for [combine]).
///
/// Alternative syntax for combining validators where both must pass.
///
/// Example:
/// ```dart
/// final validator = requiredValidator + lengthValidator;
/// ```
  Validator<T> operator +(Validator<T> other);
/// Determines if this validator should be re-run when the specified form key changes.
///
/// This method is used for cross-field validation where one field's validity
/// depends on another field's value. Return true if this validator should
/// be re-executed when the specified form field changes.
///
/// Parameters:
/// - [source] (FormKey): The form key that changed
///
/// Returns true if validation should be re-run, false otherwise.
///
/// Example:
/// ```dart
/// @override
/// bool shouldRevalidate(FormKey source) {
///   return source == passwordFieldKey; // Re-validate when password changes
/// }
/// ```
  bool shouldRevalidate(FormKey<dynamic> source);
}
/// Defines when form field validation should occur during the component lifecycle.
///
/// This enumeration controls the timing of validation execution, allowing
/// fine-grained control over when validation logic runs. Different validation
/// modes can be used to optimize user experience and performance.
enum FormValidationMode { initial, changed, submitted }
/// A validator wrapper that controls when validation occurs based on form lifecycle.
///
/// [ValidationMode] wraps another validator and only executes it during specific
/// validation modes. This allows fine-grained control over when validation rules
/// are applied during the form lifecycle (initial load, value changes, submission).
///
/// Example:
/// ```dart
/// ValidationMode(
///   EmailValidator(),
///   mode: {FormValidationMode.changed, FormValidationMode.submitted},
/// )
/// ```
class ValidationMode<T> extends Validator<T> {
/// The underlying validator to execute when mode conditions are met.
  Validator<T> validator;
/// The set of validation modes during which this validator should run.
  Set<FormValidationMode> mode;
/// Creates a [ValidationMode] that conditionally validates based on lifecycle mode.
  const ValidationMode(this.validator, {this.mode = const {FormValidationMode.changed, FormValidationMode.submitted, FormValidationMode.initial}});
  FutureOr<ValidationResult?> validate(BuildContext context, T? value, FormValidationMode lifecycle);
  void operator ==(Object other);
  int get hashCode;
}
/// A widget that prevents form components from submitting their values to form controllers.
///
/// This widget creates a boundary that blocks form-related data propagation,
/// effectively isolating child components from parent form controllers. When
/// [ignoring] is true, any form components within the child widget tree will
/// not participate in form validation or data collection.
///
/// This is useful for creating UI components that look like form fields but
/// should not be included in form submission or validation, such as search
/// fields, filters, or decorative input elements.
///
/// Example:
/// ```dart
/// Form(
///   child: Column(
///     children: [
///       TextInput(label: 'Name'), // Participates in form
///       IgnoreForm(
///         child: TextInput(label: 'Search'), // Ignored by form
///       ),
///     ],
///   ),
/// );
/// ```
class IgnoreForm<T> extends StatelessWidget {
/// Whether to ignore form participation for child components.
///
/// When true, creates a boundary that prevents child form components
/// from registering with parent form controllers. When false, child
/// components behave normally and participate in form operations.
  bool ignoring;
/// The widget subtree to optionally isolate from form participation.
  Widget child;
/// Creates an [IgnoreForm] widget.
///
/// Parameters:
/// - [child] (Widget, required): The widget subtree to wrap
/// - [ignoring] (bool, default: true): Whether to block form participation
///
/// Example:
/// ```dart
/// IgnoreForm(
///   ignoring: shouldIgnore,
///   child: MyFormField(),
/// );
/// ```
  const IgnoreForm({super.key, this.ignoring = true, required this.child});
  widgets.Widget build(widgets.BuildContext context);
}
/// A validator that applies conditional validation based on form state.
///
/// [ConditionalValidator] only executes validation when a predicate condition
/// is met. This allows validation rules to depend on other form field values
/// or dynamic conditions.
///
/// Example:
/// ```dart
/// ConditionalValidator<String>(
///   (context, value, getFieldValue) async {
///     final country = await getFieldValue('country');
///     return country == 'US';
///   },
///   message: 'ZIP code required for US addresses',
///   dependencies: ['country'],
/// )
/// ```
class ConditionalValidator<T> extends Validator<T> {
/// The predicate function that determines if validation should be applied.
  FuturePredicate<T> predicate;
/// The error message to display when validation fails.
  String message;
/// List of form field keys this validator depends on.
  List<FormKey> dependencies;
/// Creates a [ConditionalValidator] with the specified predicate and dependencies.
  const ConditionalValidator(this.predicate, {required this.message, this.dependencies = const []});
  FutureOr<ValidationResult?> validate(BuildContext context, T? value, FormValidationMode lifecycle);
  bool shouldRevalidate(FormKey<dynamic> source);
  void operator ==(Object other);
  int get hashCode;
}
/// A validator that uses a custom builder function for validation logic.
///
/// [ValidatorBuilder] provides a flexible way to create validators using
/// inline functions or custom validation logic without extending the Validator class.
///
/// Example:
/// ```dart
/// ValidatorBuilder<String>(
///   (value) {
///     if (value != null && value.contains('@')) {
///       return null; // Valid
///     }
///     return InvalidResult('Must contain @');
///   },
/// )
/// ```
class ValidatorBuilder<T> extends Validator<T> {
/// The function that performs the validation.
  ValidatorBuilderFunction<T> builder;
/// List of form field keys this validator depends on.
  List<FormKey> dependencies;
/// Creates a [ValidatorBuilder] with the specified builder function.
  const ValidatorBuilder(this.builder, {this.dependencies = const []});
  FutureOr<ValidationResult?> validate(BuildContext context, T? value, FormValidationMode lifecycle);
  bool shouldRevalidate(FormKey<dynamic> source);
  void operator ==(Object other);
  int get hashCode;
}
/// A validator that negates the result of another validator.
///
/// [NotValidator] inverts the validation logic - it passes when the wrapped
/// validator fails and fails when the wrapped validator passes. Useful for
/// creating exclusion rules.
///
/// Example:
/// ```dart
/// NotValidator(
///   EmailValidator(),
///   message: 'Must not be an email address',
/// )
/// ```
class NotValidator<T> extends Validator<T> {
/// The validator whose result will be negated.
  Validator<T> validator;
/// Custom error message, or null to use default localized message.
  String? message;
/// Creates a [NotValidator] that negates the result of another validator.
  const NotValidator(this.validator, {this.message});
  FutureOr<ValidationResult?> validate(BuildContext context, T? value, FormValidationMode state);
  void operator ==(Object other);
  int get hashCode;
}
/// A validator that combines multiple validators with OR logic.
///
/// [OrValidator] passes if at least one of the wrapped validators passes.
/// Only fails if all validators fail. Useful for accepting multiple valid formats.
///
/// Example:
/// ```dart
/// OrValidator([
///   EmailValidator(),
///   PhoneValidator(),
/// ])
/// ```
class OrValidator<T> extends Validator<T> {
/// The list of validators to combine with OR logic.
  List<Validator<T>> validators;
/// Creates an [OrValidator] from a list of validators.
  const OrValidator(this.validators);
  FutureOr<ValidationResult?> validate(BuildContext context, T? value, FormValidationMode state);
  Validator<T> operator |(Validator<T> other);
  bool shouldRevalidate(FormKey<dynamic> source);
  void operator ==(Object other);
  int get hashCode;
}
/// A validator that ensures a value is not null.
///
/// [NonNullValidator] is a simple validator that fails if the value is null.
/// Commonly used to mark fields as required.
///
/// Example:
/// ```dart
/// NonNullValidator<String>(
///   message: 'This field is required',
/// )
/// ```
class NonNullValidator<T> extends Validator<T> {
/// Custom error message, or null to use default localized message.
  String? message;
/// Creates a [NonNullValidator] with an optional custom message.
  const NonNullValidator({this.message});
  FutureOr<ValidationResult?> validate(BuildContext context, T? value, FormValidationMode state);
  bool operator ==(Object other);
  int get hashCode;
}
/// A validator that ensures a string is not null or empty.
///
/// [NotEmptyValidator] extends [NonNullValidator] to also check for empty strings.
/// Commonly used for text field validation.
///
/// Example:
/// ```dart
/// NotEmptyValidator(
///   message: 'Please enter a value',
/// )
/// ```
class NotEmptyValidator extends NonNullValidator<String> {
/// Creates a [NotEmptyValidator] with an optional custom message.
  const NotEmptyValidator({super.message});
  FutureOr<ValidationResult?> validate(BuildContext context, String? value, FormValidationMode state);
  bool operator ==(Object other);
  int get hashCode;
}
/// A validator that checks if a string's length is within specified bounds.
///
/// [LengthValidator] validates that a string's length falls within the minimum
/// and/or maximum bounds. Either bound can be null to check only one direction.
///
/// Example:
/// ```dart
/// LengthValidator(
///   min: 3,
///   max: 20,
///   message: 'Must be between 3 and 20 characters',
/// )
/// ```
class LengthValidator extends Validator<String> {
/// Minimum length requirement (inclusive), or null for no minimum.
  int? min;
/// Maximum length requirement (inclusive), or null for no maximum.
  int? max;
/// Custom error message, or null to use default localized message.
  String? message;
/// Creates a [LengthValidator] with optional min/max bounds.
  const LengthValidator({this.min, this.max, this.message});
  FutureOr<ValidationResult?> validate(BuildContext context, String? value, FormValidationMode state);
  bool operator ==(Object other);
  int get hashCode;
}
/// Defines comparison operators for numeric validation.
///
/// Used by [CompareValidator] to specify the type of comparison to perform.
enum CompareType { greater, greaterOrEqual, less, lessOrEqual, equal }
/// A validator that compares a field's value with another form field's value.
///
/// [CompareWith] validates by comparing the current field's value against
/// another field identified by a [FormKey]. Supports various comparison types
/// including equality, greater than, less than, etc.
///
/// Example:
/// ```dart
/// CompareWith.greaterOrEqual(
///   FormKey<int>('minAge'),
///   message: 'Must be at least the minimum age',
/// )
/// ```
class CompareWith<T extends Comparable<T>> extends Validator<T> {
/// The form field key to compare against.
  FormKey<T> key;
/// The type of comparison to perform.
  CompareType type;
/// Custom error message, or null to use default localized message.
  String? message;
/// Creates a [CompareWith] validator with the specified comparison type.
  const CompareWith(this.key, this.type, {this.message});
/// Creates a validator that checks for equality with another field.
  const CompareWith.equal(this.key, {this.message});
/// Creates a validator that checks if value is greater than another field.
  const CompareWith.greater(this.key, {this.message});
/// Creates a validator that checks if value is greater than or equal to another field.
  const CompareWith.greaterOrEqual(this.key, {this.message});
/// Creates a validator that checks if value is less than another field.
  const CompareWith.less(this.key, {this.message});
/// Creates a validator that checks if value is less than or equal to another field.
  const CompareWith.lessOrEqual(this.key, {this.message});
  FutureOr<ValidationResult?> validate(BuildContext context, T? value, FormValidationMode state);
  bool shouldRevalidate(FormKey<dynamic> source);
  bool operator ==(Object other);
  int get hashCode;
}
/// A validator for ensuring password strength and security requirements.
///
/// [SafePasswordValidator] checks passwords against common security criteria:
/// digits, lowercase letters, uppercase letters, and special characters.
/// Each requirement can be individually enabled or disabled.
///
/// Example:
/// ```dart
/// SafePasswordValidator(
///   requireDigit: true,
///   requireLowercase: true,
///   requireUppercase: true,
///   requireSpecialChar: true,
///   message: 'Password must meet security requirements',
/// )
/// ```
class SafePasswordValidator extends Validator<String> {
/// Custom error message, or null to use default localized messages.
  String? message;
/// Whether password must contain at least one digit.
  bool requireDigit;
/// Whether password must contain at least one lowercase letter.
  bool requireLowercase;
/// Whether password must contain at least one uppercase letter.
  bool requireUppercase;
/// Whether password must contain at least one special character.
  bool requireSpecialChar;
/// Creates a [SafePasswordValidator] with configurable requirements.
  const SafePasswordValidator({this.requireDigit = true, this.requireLowercase = true, this.requireUppercase = true, this.requireSpecialChar = true, this.message});
  FutureOr<ValidationResult?> validate(BuildContext context, String? value, FormValidationMode state);
  bool operator ==(Object other);
  int get hashCode;
}
/// A validator that checks if a numeric value meets a minimum threshold.
///
/// [MinValidator] ensures that numeric values are greater than (or equal to)
/// a specified minimum value. Useful for enforcing minimum quantities, ages, etc.
///
/// Example:
/// ```dart
/// MinValidator<int>(
///   18,
///   inclusive: true,
///   message: 'Must be at least 18 years old',
/// )
/// ```
class MinValidator<T extends num> extends Validator<T> {
/// The minimum acceptable value.
  T min;
/// Whether the minimum value itself is acceptable (true) or must be exceeded (false).
  bool inclusive;
/// Custom error message, or null to use default localized message.
  String? message;
/// Creates a [MinValidator] with the specified minimum value.
  const MinValidator(this.min, {this.inclusive = true, this.message});
  FutureOr<ValidationResult?> validate(BuildContext context, T? value, FormValidationMode state);
  bool operator ==(Object other);
  int get hashCode;
}
/// A validator that checks if a numeric value does not exceed a maximum threshold.
///
/// [MaxValidator] ensures that numeric values are less than (or equal to)
/// a specified maximum value. Useful for enforcing maximum quantities, limits, etc.
///
/// Example:
/// ```dart
/// MaxValidator<int>(
///   100,
///   inclusive: true,
///   message: 'Must not exceed 100',
/// )
/// ```
class MaxValidator<T extends num> extends Validator<T> {
/// The maximum acceptable value.
  T max;
/// Whether the maximum value itself is acceptable (true) or must not be reached (false).
  bool inclusive;
/// Custom error message, or null to use default localized message.
  String? message;
/// Creates a [MaxValidator] with the specified maximum value.
  const MaxValidator(this.max, {this.inclusive = true, this.message});
  FutureOr<ValidationResult?> validate(BuildContext context, T? value, FormValidationMode state);
  bool operator ==(Object other);
  int get hashCode;
}
/// A validator that checks if a numeric value falls within a specified range.
///
/// [RangeValidator] ensures values are between minimum and maximum bounds.
/// Both bounds can be inclusive or exclusive depending on configuration.
///
/// Example:
/// ```dart
/// RangeValidator<double>(
///   0.0,
///   100.0,
///   inclusive: true,
///   message: 'Must be between 0 and 100',
/// )
/// ```
class RangeValidator<T extends num> extends Validator<T> {
/// The minimum acceptable value.
  T min;
/// The maximum acceptable value.
  T max;
/// Whether the bounds are inclusive (true) or exclusive (false).
  bool inclusive;
/// Custom error message, or null to use default localized message.
  String? message;
/// Creates a [RangeValidator] with the specified min and max bounds.
  const RangeValidator(this.min, this.max, {this.inclusive = true, this.message});
  FutureOr<ValidationResult?> validate(BuildContext context, T? value, FormValidationMode state);
  bool operator ==(Object other);
  int get hashCode;
}
/// A validator that checks if a string matches a regular expression pattern.
///
/// [RegexValidator] provides flexible pattern-based validation using regular
/// expressions. Useful for validating formats like phone numbers, postal codes, etc.
///
/// Example:
/// ```dart
/// RegexValidator(
///   RegExp(r'^\d{3}-\d{3}-\d{4}$'),
///   message: 'Must be in format: XXX-XXX-XXXX',
/// )
/// ```
class RegexValidator extends Validator<String> {
/// The regular expression pattern to match against.
  RegExp pattern;
/// Custom error message, or null to use default localized message.
  String? message;
/// Creates a [RegexValidator] with the specified pattern.
  const RegexValidator(this.pattern, {this.message});
  FutureOr<ValidationResult?> validate(BuildContext context, String? value, FormValidationMode state);
  bool operator ==(Object other);
  int get hashCode;
}
/// A validator that checks if a string is a valid email address.
///
/// [EmailValidator] uses the email_validator package to validate email
/// addresses according to standard email format rules.
///
/// Example:
/// ```dart
/// EmailValidator(
///   message: 'Please enter a valid email address',
/// )
/// ```
class EmailValidator extends Validator<String> {
/// Custom error message, or null to use default localized message.
  String? message;
/// Creates an [EmailValidator] with an optional custom message.
  const EmailValidator({this.message});
  FutureOr<ValidationResult?> validate(BuildContext context, String? value, FormValidationMode state);
  bool operator ==(Object other);
  int get hashCode;
}
/// A validator that checks if a string is a valid URL.
///
/// [URLValidator] validates URLs using Dart's Uri parsing capabilities
/// to ensure the string represents a valid web address.
///
/// Example:
/// ```dart
/// URLValidator(
///   message: 'Please enter a valid URL',
/// )
/// ```
class URLValidator extends Validator<String> {
/// Custom error message, or null to use default localized message.
  String? message;
/// Creates a [URLValidator] with an optional custom message.
  const URLValidator({this.message});
  FutureOr<ValidationResult?> validate(BuildContext context, String? value, FormValidationMode state);
  bool operator ==(Object other);
  int get hashCode;
}
/// A validator that compares a value against a static comparison value.
///
/// [CompareTo] validates by comparing the field value against a fixed value
/// (unlike [CompareWith] which compares against another field). Supports
/// various comparison types.
///
/// Example:
/// ```dart
/// CompareTo.greaterOrEqual(
///   18,
///   message: 'Must be at least 18',
/// )
/// ```
class CompareTo<T extends Comparable<T>> extends Validator<T> {
/// The value to compare against.
  T? value;
/// The type of comparison to perform.
  CompareType type;
/// Custom error message, or null to use default localized message.
  String? message;
/// Creates a [CompareTo] validator with the specified comparison type.
  const CompareTo(this.value, this.type, {this.message});
/// Creates a validator that checks for equality with a value.
  const CompareTo.equal(this.value, {this.message});
/// Creates a validator that checks if field value is greater than the specified value.
  const CompareTo.greater(this.value, {this.message});
/// Creates a validator that checks if field value is greater than or equal to the specified value.
  const CompareTo.greaterOrEqual(this.value, {this.message});
/// Creates a validator that checks if field value is less than the specified value.
  const CompareTo.less(this.value, {this.message});
/// Creates a validator that checks if field value is less than or equal to the specified value.
  const CompareTo.lessOrEqual(this.value, {this.message});
  FutureOr<ValidationResult?> validate(BuildContext context, T? value, FormValidationMode state);
  bool operator ==(Object other);
  int get hashCode;
}
/// A validator that combines multiple validators with AND logic.
///
/// [CompositeValidator] runs multiple validators sequentially and only passes
/// if all validators pass. If any validator fails, validation stops and returns
/// that error. Created automatically when using the `&` operator between validators.
///
/// Example:
/// ```dart
/// CompositeValidator([
///   NonNullValidator(),
///   MinLengthValidator(3),
///   EmailValidator(),
/// ])
/// ```
class CompositeValidator<T> extends Validator<T> {
/// The list of validators to run sequentially.
  List<Validator<T>> validators;
/// Creates a [CompositeValidator] from a list of validators.
  const CompositeValidator(this.validators);
  FutureOr<ValidationResult?> validate(BuildContext context, T? value, FormValidationMode state);
  Validator<T> combine(Validator<T> other);
  bool shouldRevalidate(FormKey<dynamic> source);
  bool operator ==(Object other);
  int get hashCode;
}
/// Abstract base class representing the result of a validation operation.
///
/// [ValidationResult] encapsulates the outcome of validating a form field value.
/// Subclasses include [InvalidResult] for validation failures and [ValidResult]
/// for successful validation.
abstract class ValidationResult {
/// The form validation mode that triggered this result.
  FormValidationMode state;
/// Creates a [ValidationResult] with the specified validation state.
  const ValidationResult({required this.state});
/// The form field key associated with this validation result.
  FormKey get key;
/// Attaches a form field key to this validation result.
  ValidationResult attach(FormKey key);
}
/// A validation result that indicates a value should be replaced.
///
/// [ReplaceResult] is used when validation determines that the submitted
/// value should be transformed or replaced with a different value. For example,
/// trimming whitespace or formatting input.
class ReplaceResult<T> extends ValidationResult {
/// The replacement value to use.
  T value;
/// Creates a [ReplaceResult] with the specified replacement value.
  const ReplaceResult(this.value, {required super.state});
/// Creates a [ReplaceResult] already attached to a form field key.
  const ReplaceResult.attached(this.value, {required FormKey key, required super.state});
  FormKey get key;
  ReplaceResult<T> attach(FormKey key);
}
/// A validation result indicating that validation failed.
///
/// [InvalidResult] contains an error message describing why validation failed.
/// This is the most common validation result type returned by validators when
/// a value doesn't meet the validation criteria.
class InvalidResult extends ValidationResult {
/// The error message describing the validation failure.
  String message;
/// Creates an [InvalidResult] with the specified error message.
  const InvalidResult(this.message, {required super.state});
/// Creates an [InvalidResult] already attached to a form field key.
  const InvalidResult.attached(this.message, {required FormKey key, required super.state});
  FormKey get key;
  InvalidResult attach(FormKey key);
}
/// A notification sent when a form field's validation state changes.
///
/// [FormValidityNotification] is dispatched through the notification system
/// when a field's validity transitions between valid, invalid, or null states.
/// Useful for updating UI or tracking form validation status.
class FormValidityNotification extends Notification {
/// The previous validation result, or null if there was none.
  ValidationResult? oldValidity;
/// The new validation result, or null if now valid.
  ValidationResult? newValidity;
/// Creates a [FormValidityNotification] with old and new validity states.
  const FormValidityNotification(this.newValidity, this.oldValidity);
}
/// A key that uniquely identifies a form field and its type.
///
/// [FormKey] extends [LocalKey] and is used throughout the form system to
/// reference specific form fields. It includes type information to ensure
/// type-safe access to form values.
///
/// Example:
/// ```dart
/// const emailKey = FormKey<String>('email');
/// const ageKey = FormKey<int>('age');
/// ```
class FormKey<T> extends LocalKey {
/// The underlying key object.
  Object key;
/// Creates a [FormKey] with the specified key object.
  const FormKey(this.key);
/// Gets the generic type parameter of this key.
  Type get type;
/// Checks if a dynamic value is an instance of this key's type.
  bool isInstanceOf(dynamic value);
/// Gets the value associated with this key from the form values map.
  T? getValue(FormMapValues values);
/// Operator overload to get the value from form values (same as [getValue]).
  T? operator [](FormMapValues values);
  bool operator ==(Object other);
  int get hashCode;
  String toString();
}
/// A form field entry that wraps a form widget with validation.
///
/// [FormEntry] associates a [FormKey] with a form field widget and optional
/// validator. It integrates with the form state management system to track
/// field values and validation states.
class FormEntry<T> extends StatefulWidget {
/// The form field widget to wrap.
  Widget child;
/// Optional validator function for this form field.
///
/// Called when form validation is triggered. Should return `null` for valid
/// values or a validation error message for invalid values.
  Validator<T>? validator;
/// Creates a form entry with a typed key.
///
/// The [key] parameter must be a [FormKey<T>] to ensure type safety.
  const FormEntry({required FormKey<T> super.key, required this.child, this.validator});
  FormKey get key;
  State<FormEntry> createState();
}
/// Interface for form field state management.
///
/// Provides methods and properties for managing form field lifecycle, validation,
/// and value reporting. Typically mixed into state classes that participate in
/// form validation and submission workflows.
///
/// Implementations should:
/// - Track mount state to prevent operations on disposed widgets
/// - Report value changes to parent forms
/// - Support both synchronous and asynchronous validation
mixin FormFieldHandle {
/// Whether the widget is currently mounted in the widget tree.
  bool get mounted;
/// The unique key identifying this field within its form.
  FormKey get formKey;
/// Reports a new value to the form and triggers validation.
///
/// Parameters:
/// - [value] (`T?`, required): The new field value.
///
/// Returns: `FutureOr<ValidationResult?>` ‚Äî validation result if applicable.
  FutureOr<ValidationResult?> reportNewFormValue<T>(T? value);
/// Re-runs validation on the current value.
///
/// Returns: `FutureOr<ValidationResult?>` ‚Äî validation result if applicable.
  FutureOr<ValidationResult?> revalidate();
/// A listenable for the current validation state.
///
/// Returns `null` if no validation has been performed or if validation passed.
  ValueListenable<ValidationResult?>? get validity;
}
/// State class for [FormEntry] widgets.
///
/// Manages form field lifecycle and integrates with parent [FormController]
/// for validation and value reporting.
class FormEntryState extends State<FormEntry> with FormFieldHandle {
  FormKey get formKey;
  ValueListenable<ValidationResult?>? get validity;
  void didChangeDependencies();
  void dispose();
  Widget build(BuildContext context);
  FutureOr<ValidationResult?> reportNewFormValue<T>(T? value);
  FutureOr<ValidationResult?> revalidate();
}
/// A widget that intercepts form value reports.
///
/// Wraps a form field to observe value changes before they reach the parent form.
/// Useful for implementing side effects like logging, analytics, or derived state
/// updates when form field values change.
///
/// Example:
/// ```dart
/// FormEntryInterceptor<String>(
///   onValueReported: (value) => print('Email changed: $value'),
///   child: TextFormField(),
/// )
/// ```
class FormEntryInterceptor<T> extends StatefulWidget {
/// The child widget (typically a form field).
  Widget child;
/// Callback invoked when a value is reported by the child field.
  ValueChanged<T>? onValueReported;
/// Creates a [FormEntryInterceptor].
///
/// Parameters:
/// - [child] (`Widget`, required): The form field to wrap.
/// - [onValueReported] (`ValueChanged<T>?`, optional): Called with new values.
  const FormEntryInterceptor({super.key, required this.child, this.onValueReported});
  State<FormEntryInterceptor<T>> createState();
}
/// Holds the current value and validator for a form field.
///
/// Immutable snapshot of a form field's state used internally by form controllers
/// to track field values and their associated validation rules.
class FormValueState<T> {
/// The current field value.
  T? value;
/// The validator function for this field.
  Validator<T>? validator;
/// Creates a [FormValueState].
///
/// Parameters:
/// - [value] (`T?`, optional): Current field value.
/// - [validator] (`Validator<T>?`, optional): Validation function.
  FormValueState({this.value, this.validator});
  String toString();
  bool operator ==(Object other);
  int get hashCode;
}
/// Extension methods for [FormMapValues].
extension FormMapValuesExtension on FormMapValues {
/// Retrieves a typed value for a specific form key.
///
/// Parameters:
/// - [key] (`FormKey<T>`, required): The form key to look up.
///
/// Returns: `T?` ‚Äî the value if found and correctly typed, null otherwise.
  T? getValue<T>(FormKey<T> key);
}
/// A widget that provides form management capabilities for collecting and validating user input.
///
/// The Form widget creates a container that manages multiple form fields, providing
/// centralized validation, data collection, and submission handling. It maintains
/// form state through a [FormController] and coordinates validation across all
/// participating form fields.
///
/// Form components within the widget tree automatically register themselves with
/// the nearest Form ancestor, allowing centralized management of field values,
/// validation states, and error handling. The Form provides validation lifecycle
/// management and supports both synchronous and asynchronous validation.
///
/// Example:
/// ```dart
/// final controller = FormController();
///
/// Form(
///   controller: controller,
///   onSubmit: (values) async {
///     print('Form submitted with values: $values');
///   },
///   child: Column(
///     children: [
///       TextInput(
///         key: FormKey<String>('name'),
///         label: 'Name',
///         validator: RequiredValidator(),
///       ),
///       Button(
///         onPressed: () => controller.submit(),
///         child: Text('Submit'),
///       ),
///     ],
///   ),
/// );
/// ```
class Form extends StatefulWidget {
/// Retrieves the nearest [FormController] from the widget tree, if any.
///
/// Returns the [FormController] instance from the nearest Form ancestor,
/// or null if no Form is found in the widget tree. This method is safe
/// to call even when no Form is present.
///
/// Parameters:
/// - [context] (BuildContext): The build context to search from
///
/// Returns the [FormController] if found, null otherwise.
  static FormController? maybeOf(BuildContext context);
/// Retrieves the nearest [FormController] from the widget tree.
///
/// Returns the [FormController] instance from the nearest Form ancestor.
/// Throws an assertion error if no Form is found in the widget tree.
/// Use [maybeOf] if the Form might not be present.
///
/// Parameters:
/// - [context] (BuildContext): The build context to search from
///
/// Returns the [FormController] from the nearest Form ancestor.
///
/// Throws [AssertionError] if no Form is found in the widget tree.
  static FormController of(BuildContext context);
/// Optional controller for programmatic form management.
///
/// When provided, this controller manages form state externally and allows
/// programmatic access to form values, validation states, and submission.
/// If null, the Form creates and manages its own internal controller.
  FormController? controller;
/// The widget subtree containing form fields.
///
/// This child widget should contain the form fields and other UI elements
/// that participate in the form. Form fields within this subtree automatically
/// register with this Form instance.
  Widget child;
/// Callback invoked when the form is submitted.
///
/// This callback receives a map of form values keyed by their [FormKey]
/// identifiers. It is called when [FormController.submit] is invoked and
/// all form validations pass successfully.
///
/// The callback can return a Future for asynchronous submission processing.
  FormSubmitCallback? onSubmit;
/// Creates a [Form] widget.
///
/// The [child] parameter is required and should contain the form fields
/// and UI elements that participate in the form. The [controller] and
/// [onSubmit] parameters are optional but commonly used for form management.
///
/// Parameters:
/// - [child] (Widget, required): The widget subtree containing form fields
/// - [onSubmit] (FormSubmitCallback?, optional): Callback for form submission
/// - [controller] (FormController?, optional): External form state controller
///
/// Example:
/// ```dart
/// Form(
///   onSubmit: (values) => print('Submitted: $values'),
///   child: Column(
///     children: [
///       TextInput(key: FormKey('email'), label: 'Email'),
///       Button(child: Text('Submit')),
///     ],
///   ),
/// );
/// ```
  const Form({super.key, required this.child, this.onSubmit, this.controller});
  State<Form> createState();
}
/// Controller for managing form state, validation, and submission.
///
/// The FormController coordinates all form field interactions, maintaining
/// a centralized registry of field values and validation states. It provides
/// programmatic access to form data collection, validation triggering, and
/// submission handling.
///
/// The controller automatically manages the lifecycle of form fields as they
/// register and unregister, tracking their values and validation results.
/// It supports both synchronous and asynchronous validation, cross-field
/// validation dependencies, and comprehensive error state management.
///
/// Example:
/// ```dart
/// final controller = FormController();
///
/// // Listen to form state changes
/// controller.addListener(() {
///   print('Form validity: ${controller.isValid}');
///   print('Form values: ${controller.values}');
/// });
///
/// // Submit the form
/// await controller.submit();
///
/// // Access specific field values
/// final emailValue = controller.getValue(emailKey);
/// ```
class FormController extends ChangeNotifier {
/// A map of all current form field values keyed by their [FormKey].
///
/// This getter provides access to the current state of all registered form
/// fields. The map is rebuilt on each access to reflect the latest values
/// from all active form fields.
///
/// Returns a `Map<FormKey, Object?>` where each key corresponds to a form field
/// and each value is the current value of that field.
  Map<FormKey, Object?> get values;
  void dispose();
/// A map of all current validation results keyed by their [FormKey].
///
/// This getter provides access to the validation state of all registered
/// form fields. Values can be either synchronous ValidationResult objects
/// or `Future<ValidationResult?>` for asynchronous validation.
///
/// Returns a `Map<FormKey, FutureOr<ValidationResult?>>` representing the
/// current validation state of all form fields.
  Map<FormKey, FutureOr<ValidationResult?>> get validities;
/// A map of all current validation errors keyed by their [FormKey].
///
/// This getter filters the validation results to only include fields with
/// validation errors. For asynchronous validations that are still pending,
/// a [WaitingResult] is included to indicate the validation is in progress.
///
/// Returns a `Map<FormKey, ValidationResult>` containing only fields with errors.
  Map<FormKey, ValidationResult> get errors;
/// Retrieves the validation result for a specific form field.
///
/// This method returns the current validation state for the specified form key,
/// which can be either a synchronous ValidationResult or a Future for asynchronous
/// validation. Returns null if no validation result exists for the key.
///
/// Parameters:
/// - [key] (FormKey): The form key to get validation result for
///
/// Returns the validation result or null if none exists.
  FutureOr<ValidationResult?>? getError(FormKey key);
/// Retrieves the synchronous validation result for a specific form field.
///
/// This method returns the current validation state for the specified form key,
/// converting asynchronous validations to [WaitingResult] objects. This provides
/// a synchronous interface for accessing validation states.
///
/// Parameters:
/// - [key] (FormKey): The form key to get validation result for
///
/// Returns the synchronous validation result or null if valid.
  ValidationResult? getSyncError(FormKey key);
/// Retrieves the current value for a specific form field.
///
/// Parameters:
/// - [key] (`FormKey<T>`, required): The form key to look up.
///
/// Returns: `T?` ‚Äî the field value if exists, null otherwise.
  T? getValue<T>(FormKey<T> key);
/// Checks if a form field has a non-null value.
///
/// Parameters:
/// - [key] (`FormKey`, required): The form key to check.
///
/// Returns: `bool` ‚Äî true if field has a value, false otherwise.
  bool hasValue(FormKey key);
/// Revalidates all form fields with validators.
///
/// Runs validation on all registered fields and updates their validation states.
/// Supports both synchronous and asynchronous validators.
///
/// Parameters:
/// - [context] (`BuildContext`, required): The build context.
/// - [state] (`FormValidationMode`, required): Validation mode to use.
  void revalidate(BuildContext context, FormValidationMode state);
/// Attaches a form field to this controller.
///
/// Registers the field and runs initial validation if a validator is provided.
/// Manages field lifecycle transitions (initial ‚Üí changed) and coordinates
/// revalidation of dependent fields.
///
/// Parameters:
/// - [context] (`BuildContext`, required): The build context.
/// - [handle] (`FormFieldHandle`, required): The field handle to attach.
/// - [value] (`Object?`, required): Current field value.
/// - [validator] (`Validator?`, optional): Validation function.
/// - [forceRevalidate] (`bool`, default: `false`): Force revalidation even if unchanged.
///
/// Returns: `FutureOr<ValidationResult?>` ‚Äî validation result if applicable.
  FutureOr<ValidationResult?> attach(BuildContext context, FormFieldHandle handle, Object? value, Validator? validator, [bool forceRevalidate = false]);
}
/// State class for the [Form] widget that manages form controller lifecycle.
///
/// This state class is responsible for initializing and updating the
/// [FormController] used by the [Form] widget. It ensures proper controller
/// management when the controller property changes and provides the controller
/// to descendant widgets through the data inheritance mechanism.
///
/// The state handles two scenarios:
/// - Creates a default [FormController] if none is provided
/// - Updates to a new controller when the widget's controller property changes
///
/// See also:
/// - [Form], the widget that uses this state
/// - [FormController], the controller managed by this state
class FormState extends State<Form> {
  void initState();
  void didUpdateWidget(covariant Form oldWidget);
  Widget build(BuildContext context);
}
/// Widget builder for displaying form entry validation errors.
///
/// Conditionally renders error messages based on validation state and modes.
class FormEntryErrorBuilder extends StatelessWidget {
/// Builder function that creates the error display widget.
  Widget Function(BuildContext context, ValidationResult? error, Widget? child) builder;
/// Optional child widget passed to the builder.
  Widget? child;
/// Validation modes that trigger error display.
  Set<FormValidationMode>? modes;
/// Creates a form entry error builder.
  const FormEntryErrorBuilder({super.key, required this.builder, this.child, this.modes});
  Widget build(BuildContext context);
}
/// Validation result indicating a validation is in progress.
///
/// Used when asynchronous validation is being performed and the result
/// is not yet available.
class WaitingResult extends ValidationResult {
/// Creates a waiting result attached to a form key.
  const WaitingResult.attached({required FormKey key, required super.state});
  FormKey get key;
  WaitingResult attach(FormKey key);
}
/// Widget builder for displaying form-wide validation errors.
///
/// Provides access to all form validation errors for rendering error summaries.
class FormErrorBuilder extends StatelessWidget {
/// Optional child widget passed to the builder.
  Widget? child;
/// Builder function that creates the error display from all form errors.
  Widget Function(BuildContext context, Map<FormKey, ValidationResult> errors, Widget? child) builder;
/// Creates a form error builder.
  const FormErrorBuilder({super.key, required this.builder, this.child});
  Widget build(BuildContext context);
}
/// Widget builder for displaying pending form validations.
///
/// Shows feedback while asynchronous validations are in progress.
class FormPendingBuilder extends StatelessWidget {
/// Optional child widget passed to the builder.
  Widget? child;
/// Builder function for creating pending validation display.
  FormPendingWidgetBuilder builder;
/// Creates a form pending builder.
  const FormPendingBuilder({super.key, required this.builder, this.child});
  Widget build(widgets.BuildContext context);
}
/// Extension methods on [BuildContext] for form operations.
extension FormExtension on BuildContext {
/// Gets the current value for a form field by key.
///
/// Returns null if the form or field is not found.
  T? getFormValue<T>(FormKey<T> key);
/// Submits the form and triggers validation.
///
/// Returns a [SubmissionResult] with form values and any validation errors.
/// May return a Future if asynchronous validation is in progress.
  FutureOr<SubmissionResult> submitForm();
}
/// Mixin that provides form value management for stateful widgets.
///
/// Integrates a widget with the form system, managing value updates,
/// validation, and form state synchronization.
mixin FormValueSupplier<T, X extends StatefulWidget> on State<X> {
/// Gets the current form value.
  T? get formValue;
/// Sets a new form value and triggers validation.
  set formValue(T? value);
  void didChangeDependencies();
/// Called when a form value is replaced by validation logic.
///
/// Subclasses should override this to handle value replacements.
  void didReplaceFormValue(T value);
}
/// Result of a form submission containing values and validation errors.
///
/// Returned when a form is submitted, containing all field values
/// and any validation errors that occurred.
class SubmissionResult {
/// Map of form field values keyed by their FormKey.
  Map<FormKey, Object?> values;
/// Map of validation errors keyed by their FormKey.
  Map<FormKey, ValidationResult> errors;
/// Creates a submission result.
  const SubmissionResult(this.values, this.errors);
  String toString();
  bool operator ==(Object other);
  int get hashCode;
}
/// A standard form field widget with label, validation, and error display.
///
/// Provides a consistent layout for form inputs with labels, hints,
/// validation, and error messaging.
class FormField<T> extends StatelessWidget {
/// The label widget for the form field.
  Widget label;
/// Optional hint text displayed below the field.
  Widget? hint;
/// The main input widget.
  Widget child;
/// Optional widget displayed before the label.
  Widget? leadingLabel;
/// Optional widget displayed after the label.
  Widget? trailingLabel;
/// Alignment of the label axis.
  MainAxisAlignment? labelAxisAlignment;
/// Gap between leading label and main label.
  double? leadingGap;
/// Gap between main label and trailing label.
  double? trailingGap;
/// Padding around the form field.
  EdgeInsetsGeometry? padding;
/// Validator function for this field.
  Validator<T>? validator;
/// Validation modes that trigger error display.
  Set<FormValidationMode>? showErrors;
/// Creates a form field.
  const FormField({required FormKey<T> super.key, required this.label, required this.child, this.leadingLabel, this.trailingLabel, this.labelAxisAlignment = MainAxisAlignment.start, this.leadingGap, this.trailingGap, this.padding = EdgeInsets.zero, this.validator, this.hint, this.showErrors});
  FormKey<T> get key;
  Widget build(BuildContext context);
}
/// An inline form field widget with label next to the input.
///
/// Provides a compact horizontal layout for form inputs with labels
/// and validation.
class FormInline<T> extends StatelessWidget {
/// The label widget for the form field.
  Widget label;
/// Optional hint text displayed below the field.
  Widget? hint;
/// The main input widget.
  Widget child;
/// Validator function for this field.
  Validator<T>? validator;
/// Validation modes that trigger error display.
  Set<FormValidationMode>? showErrors;
/// Creates an inline form field.
  const FormInline({required FormKey<T> super.key, required this.label, required this.child, this.validator, this.hint, this.showErrors});
  FormKey<T> get key;
  Widget build(BuildContext context);
}
/// A table-based layout for multiple form fields.
///
/// Arranges form fields in a table layout for structured data entry.
class FormTableLayout extends StatelessWidget {
/// List of form field rows to display in the table.
  List<FormField> rows;
/// Vertical spacing between rows.
  double? spacing;
/// Creates a [FormTableLayout].
///
/// Parameters:
/// - [rows] (`List<FormField>`, required): Form fields to arrange in rows.
/// - [spacing] (`double?`, optional): Custom row spacing.
  const FormTableLayout({super.key, required this.rows, this.spacing});
  Widget build(BuildContext context);
}
/// A button that automatically handles form submission states.
///
/// Renders different content based on form validation state:
/// - Default: Shows [child] with optional leading/trailing widgets
/// - Loading: Shows [loading] during async validation
/// - Error: Shows [error] when validation fails
///
/// Automatically disables during validation and enables when form is valid.
///
/// Example:
/// ```dart
/// SubmitButton(
///   child: Text('Submit'),
///   loading: Text('Validating...'),
///   error: Text('Fix errors'),
/// )
/// ```
class SubmitButton extends StatelessWidget {
/// Button style configuration.
  AbstractButtonStyle? style;
/// Default button content.
  Widget child;
/// Content shown during async validation (loading state).
  Widget? loading;
/// Content shown when validation errors exist.
  Widget? error;
/// Leading widget in default state.
  Widget? leading;
/// Trailing widget in default state.
  Widget? trailing;
/// Leading widget in loading state.
  Widget? loadingLeading;
/// Trailing widget in loading state.
  Widget? loadingTrailing;
/// Leading widget in error state.
  Widget? errorLeading;
/// Trailing widget in error state.
  Widget? errorTrailing;
/// Content alignment within the button.
  AlignmentGeometry? alignment;
/// Whether to disable hover effects.
  bool disableHoverEffect;
/// Whether the button is enabled (null uses form state).
  bool? enabled;
/// Whether to enable haptic feedback on press.
  bool? enableFeedback;
/// Whether to disable state transition animations.
  bool disableTransition;
/// Focus node for keyboard navigation.
  FocusNode? focusNode;
/// Creates a [SubmitButton].
///
/// Parameters:
/// - [child] (`Widget`, required): Default button content.
/// - [style] (`AbstractButtonStyle?`, optional): Button styling.
/// - [loading] (`Widget?`, optional): Loading state content.
/// - [error] (`Widget?`, optional): Error state content.
/// - [leading] (`Widget?`, optional): Leading widget (default state).
/// - [trailing] (`Widget?`, optional): Trailing widget (default state).
/// - [loadingLeading] (`Widget?`, optional): Leading widget (loading state).
/// - [loadingTrailing] (`Widget?`, optional): Trailing widget (loading state).
/// - [errorLeading] (`Widget?`, optional): Leading widget (error state).
/// - [errorTrailing] (`Widget?`, optional): Trailing widget (error state).
/// - [alignment] (`AlignmentGeometry?`, optional): Content alignment.
/// - [disableHoverEffect] (`bool`, default: `false`): Disable hover.
/// - [enabled] (`bool?`, optional): Override enabled state.
/// - [enableFeedback] (`bool?`, optional): Enable haptic feedback.
/// - [disableTransition] (`bool`, default: `false`): Disable animations.
/// - [focusNode] (`FocusNode?`, optional): Focus node.
  const SubmitButton({super.key, required this.child, this.style, this.loading, this.error, this.leading, this.trailing, this.alignment, this.loadingLeading, this.loadingTrailing, this.errorLeading, this.errorTrailing, this.disableHoverEffect = false, this.enabled, this.enableFeedback, this.disableTransition = false, this.focusNode});
  widgets.Widget build(widgets.BuildContext context);
}
/// Represents a phone number with country code information.
///
/// [PhoneNumber] combines a country (with dial code) and a phone number
/// string to create a complete international phone number.
///
/// Example:
/// ```dart
/// final phone = PhoneNumber(
///   Country(dialCode: '+1', code: 'US'),
///   '5551234567',
/// );
/// print(phone.fullNumber); // +15551234567
/// ```
class PhoneNumber {
/// The country associated with this phone number.
  Country country;
/// The phone number without the country code.
  String number;
/// Creates a [PhoneNumber] with the specified country and number.
  const PhoneNumber(this.country, this.number);
/// Gets the complete phone number including country code.
  String get fullNumber;
/// Gets the full number or null if the number is empty.
  String? get value;
  String toString();
  bool operator ==(Object other);
  int get hashCode;
}
/// Theme data for [PhoneInput].
class PhoneInputTheme extends ComponentThemeData {
/// The padding of the [PhoneInput].
  EdgeInsetsGeometry? padding;
/// The border radius of the [PhoneInput].
  BorderRadiusGeometry? borderRadius;
/// The constraints of the country selector popup.
  BoxConstraints? popupConstraints;
/// The maximum width of the [PhoneInput].
  double? maxWidth;
/// The height of the flag.
  double? flagHeight;
/// The width of the flag.
  double? flagWidth;
/// The gap between the flag and the country code.
  double? flagGap;
/// The gap between the country code and the text field.
  double? countryGap;
/// The shape of the flag.
  Shape? flagShape;
/// Theme data for [PhoneInput].
  const PhoneInputTheme({this.padding, this.borderRadius, this.popupConstraints, this.maxWidth, this.flagHeight, this.flagWidth, this.flagGap, this.countryGap, this.flagShape});
/// Creates a copy of this [PhoneInputTheme] with the given values overridden.
  PhoneInputTheme copyWith({ValueGetter<EdgeInsetsGeometry?>? padding, ValueGetter<BorderRadiusGeometry?>? borderRadius, ValueGetter<BoxConstraints?>? popupConstraints, ValueGetter<double?>? maxWidth, ValueGetter<double?>? flagHeight, ValueGetter<double?>? flagWidth, ValueGetter<double?>? flagGap, ValueGetter<double?>? countryGap, ValueGetter<Shape?>? flagShape});
  bool operator ==(Object other);
  int get hashCode;
  String toString();
}
/// A specialized input widget for entering international phone numbers.
///
/// This widget provides a comprehensive phone number input interface with
/// country selection, automatic formatting, and validation. It displays a
/// country flag, country code, and a text field for the phone number,
/// handling the complexities of international phone number formats.
///
/// The component automatically filters input to ensure only valid phone
/// number characters are entered, and provides a searchable country
/// selector popup for easy country selection. It integrates with the form
/// system to provide phone number validation and data collection.
///
/// Example:
/// ```dart
/// PhoneInput(
///   initialCountry: Country.unitedStates,
///   onChanged: (phoneNumber) {
///     print('Phone: ${phoneNumber.fullNumber}');
///     print('Country: ${phoneNumber.country.name}');
///   },
///   searchPlaceholder: Text('Search countries...'),
/// );
/// ```
class PhoneInput extends StatefulWidget {
/// The default country to display when no initial value is provided.
///
/// If both [initialCountry] and [initialValue] are null, defaults to
/// United States. When [initialValue] is provided, its country takes
/// precedence over this setting.
  Country? initialCountry;
/// The initial phone number value including country and number.
///
/// When provided, both the country selector and number field are
/// initialized with the values from this phone number. Takes precedence
/// over [initialCountry] for country selection.
  PhoneNumber? initialValue;
/// Callback invoked when the phone number changes.
///
/// Called whenever the user changes either the country selection or
/// the phone number text. The callback receives a [PhoneNumber] object
/// containing both the selected country and entered number.
  ValueChanged<PhoneNumber>? onChanged;
/// Optional text editing controller for the number input field.
///
/// When provided, this controller manages the text content of the phone
/// number input field. If null, an internal controller is created and managed.
  TextEditingController? controller;
/// Whether to filter out plus (+) symbols from input.
///
/// When true, plus symbols are automatically removed from user input
/// since the country code already provides the international prefix.
  bool filterPlusCode;
/// Whether to filter out leading zeros from input.
///
/// When true, leading zeros are automatically removed from the phone number
/// to normalize the input format according to international standards.
  bool filterZeroCode;
/// Whether to filter out country codes from input.
///
/// When true, prevents users from entering the country code digits manually
/// since the country selector provides this information automatically.
  bool filterCountryCode;
/// Whether to allow only numeric characters in the input.
///
/// When true, restricts input to numeric characters only, removing
/// any letters, symbols, or formatting characters that users might enter.
  bool onlyNumber;
/// Optional list of countries to display in the country selector.
///
/// When provided, only these countries will be available for selection
/// in the country picker popup. If null, all supported countries are available.
  List<Country>? countries;
/// Widget displayed as placeholder in the country search field.
///
/// Appears in the search input at the top of the country selector popup
/// to guide users on how to search for countries.
  Widget? searchPlaceholder;
/// Creates a [PhoneInput] widget.
///
/// The widget can be initialized with a specific country or complete phone
/// number. Various filtering options control how user input is processed
/// to ensure valid phone number format.
///
/// Parameters:
/// - [initialCountry] (Country?, optional): Default country when no initial value provided
/// - [initialValue] (PhoneNumber?, optional): Complete initial phone number with country
/// - [onChanged] (`ValueChanged<PhoneNumber>?`, optional): Callback for phone number changes
/// - [controller] (TextEditingController?, optional): Controller for the number input field
/// - [filterPlusCode] (bool, default: true): Whether to filter out plus symbols
/// - [filterZeroCode] (bool, default: true): Whether to filter out leading zeros
/// - [filterCountryCode] (bool, default: true): Whether to filter out country codes
/// - [onlyNumber] (bool, default: true): Whether to allow only numeric input
/// - [countries] (`List<Country>?`, optional): Specific countries to show in selector
/// - [searchPlaceholder] (Widget?, optional): Placeholder for country search field
///
/// Example:
/// ```dart
/// PhoneInput(
///   initialCountry: Country.canada,
///   filterPlusCode: true,
///   onChanged: (phone) => _validatePhoneNumber(phone),
/// );
/// ```
  const PhoneInput({super.key, this.initialCountry, this.initialValue, this.onChanged, this.controller, this.filterPlusCode = true, this.filterZeroCode = true, this.filterCountryCode = true, this.onlyNumber = true, this.countries, this.searchPlaceholder});
  State<PhoneInput> createState();
}
/// Theme data for customizing [Select] widget appearance and behavior.
///
/// This class defines the visual and behavioral properties that can be applied to
/// [Select] widgets, including popup constraints, positioning, styling, and
/// interaction behaviors. These properties can be set at the theme level
/// to provide consistent behavior across the application.
class SelectTheme extends ComponentThemeData {
/// Constraints for the popup menu size.
  BoxConstraints? popupConstraints;
/// Alignment of the popover relative to the anchor.
  AlignmentGeometry? popoverAlignment;
/// Anchor alignment for the popover.
  AlignmentGeometry? popoverAnchorAlignment;
/// Border radius for select items.
  BorderRadiusGeometry? borderRadius;
/// Padding inside select items.
  EdgeInsetsGeometry? padding;
/// Whether to disable hover effects on items.
  bool? disableHoverEffect;
/// Whether the selected item can be unselected.
  bool? canUnselect;
/// Whether to automatically close the popover after selection.
  bool? autoClosePopover;
/// Creates a select theme.
  const SelectTheme({this.popupConstraints, this.popoverAlignment, this.popoverAnchorAlignment, this.borderRadius, this.padding, this.disableHoverEffect, this.canUnselect, this.autoClosePopover});
/// Creates a copy of this theme with the given fields replaced.
  SelectTheme copyWith({ValueGetter<BoxConstraints?>? popupConstraints, ValueGetter<AlignmentGeometry?>? popoverAlignment, ValueGetter<AlignmentGeometry?>? popoverAnchorAlignment, ValueGetter<BorderRadiusGeometry?>? borderRadius, ValueGetter<EdgeInsetsGeometry?>? padding, ValueGetter<bool?>? disableHoverEffect, ValueGetter<bool?>? canUnselect, ValueGetter<bool?>? autoClosePopover});
  bool operator ==(Object other);
  int get hashCode;
}
/// Controller for managing [ControlledSelect] state programmatically.
///
/// Extends [ValueNotifier] to provide reactive state management for select
/// components. Can be used to programmatically change selection, listen to
/// state changes, and integrate with forms and other reactive systems.
///
/// Example:
/// ```dart
/// final controller = SelectController<String>('initial');
///
/// // Listen to changes
/// controller.addListener(() {
///   print('Selection changed to: ${controller.value}');
/// });
///
/// // Update selection
/// controller.value = 'new_value';
/// ```
class SelectController<T> extends ValueNotifier<T?> with ComponentController<T?> {
/// Creates a [SelectController] with an optional initial value.
///
/// The [value] parameter sets the initial selected item. Can be null
/// to start with no selection.
///
/// Parameters:
/// - [value] (T?, optional): Initial selected value
  SelectController([super.value]);
}
/// Reactive single-selection dropdown with automatic state management.
///
/// A high-level select widget that provides automatic state management through
/// the controlled component pattern. Supports both controller-based and callback-based
/// state management with comprehensive customization options for item presentation,
/// popup behavior, and interaction handling.
///
/// ## Features
///
/// - **Flexible item rendering**: Custom builders for complete visual control over items
/// - **Popup positioning**: Configurable alignment and constraints for the dropdown
/// - **Keyboard navigation**: Full keyboard support with arrow keys and Enter/Escape
/// - **Form integration**: Automatic validation and form field registration
/// - **Unselection support**: Optional ability to deselect the current selection
///
/// ## Usage Patterns
///
/// **Controller-based (recommended for complex state):**
/// ```dart
/// final controller = SelectController<String>('apple');
///
/// ControlledSelect<String>(
///   controller: controller,
///   items: ['apple', 'banana', 'cherry'],
///   itemBuilder: (context, item) => Text(item),
///   placeholder: Text('Choose fruit'),
/// )
/// ```
///
/// **Callback-based (simple state management):**
/// ```dart
/// String? selectedFruit;
///
/// ControlledSelect<String>(
///   initialValue: selectedFruit,
///   onChanged: (fruit) => setState(() => selectedFruit = fruit),
///   items: ['apple', 'banana', 'cherry'],
///   itemBuilder: (context, item) => Text(item),
/// )
/// ```
class ControlledSelect<T> extends StatelessWidget with ControlledComponent<T?>, SelectBase<T> {
  T? initialValue;
  ValueChanged<T?>? onChanged;
  bool enabled;
  SelectController<T>? controller;
  Widget? placeholder;
  bool filled;
  FocusNode? focusNode;
  BoxConstraints? constraints;
  BoxConstraints? popupConstraints;
  PopoverConstraint popupWidthConstraint;
  BorderRadiusGeometry? borderRadius;
  EdgeInsetsGeometry? padding;
  AlignmentGeometry popoverAlignment;
  AlignmentGeometry? popoverAnchorAlignment;
  bool disableHoverEffect;
  bool canUnselect;
  bool autoClosePopover;
  SelectPopupBuilder popup;
  SelectValueBuilder<T> itemBuilder;
  SelectValueSelectionHandler<T>? valueSelectionHandler;
  SelectValueSelectionPredicate<T>? valueSelectionPredicate;
  Predicate<T>? showValuePredicate;
/// Creates a [ControlledSelect].
///
/// Either [controller] or [onChanged] should be provided for interactivity.
/// The widget supports both controller-based and callback-based state management
/// patterns depending on application architecture needs.
///
/// Parameters:
/// - [controller] (`SelectController<T>?`, optional): external state controller
/// - [initialValue] (T?, optional): starting selection when no controller
/// - [onChanged] (`ValueChanged<T?>?`, optional): selection change callback
/// - [enabled] (bool, default: true): whether select is interactive
/// - [placeholder] (Widget?, optional): widget shown when no item selected
/// - [filled] (bool, default: false): whether to use filled appearance
/// - [focusNode] (FocusNode?, optional): custom focus node for keyboard handling
/// - [constraints] (BoxConstraints?, optional): size constraints for select widget
/// - [popupConstraints] (BoxConstraints?, optional): size constraints for popup
/// - [popupWidthConstraint] (PopoverConstraint, default: anchorFixedSize): popup width behavior
/// - [borderRadius] (BorderRadiusGeometry?, optional): override select border radius
/// - [padding] (EdgeInsetsGeometry?, optional): override internal padding
/// - [popoverAlignment] (AlignmentGeometry, default: topCenter): popup alignment
/// - [popoverAnchorAlignment] (AlignmentGeometry?, optional): anchor alignment
/// - [disableHoverEffect] (bool, default: false): disable item hover effects
/// - [canUnselect] (bool, default: false): allow deselecting current item
/// - [autoClosePopover] (bool, default: true): close popup after selection
/// - [popup] (SelectPopupBuilder, required): builder for popup content
/// - [itemBuilder] (`SelectItemBuilder<T>`, required): builder for individual items
/// - [valueSelectionHandler] (`SelectValueSelectionHandler<T>?`, optional): custom selection logic
/// - [valueSelectionPredicate] (`SelectValueSelectionPredicate<T>?`, optional): selection validation
/// - [showValuePredicate] (`Predicate<T>?`, optional): visibility filter for values
///
/// Example:
/// ```dart
/// ControlledSelect<String>(
///   controller: controller,
///   popup: (context, items) => ListView(children: items),
///   itemBuilder: (context, item, selected) => Text(item),
///   placeholder: Text('Select option'),
/// )
/// ```
  const ControlledSelect({super.key, this.controller, this.onChanged, this.enabled = true, this.initialValue, this.placeholder, this.filled = false, this.focusNode, this.constraints, this.popupConstraints, this.popupWidthConstraint = PopoverConstraint.anchorFixedSize, this.borderRadius, this.padding, this.popoverAlignment = Alignment.topCenter, this.popoverAnchorAlignment, this.disableHoverEffect = false, this.canUnselect = false, this.autoClosePopover = true, required this.popup, required this.itemBuilder, this.valueSelectionHandler, this.valueSelectionPredicate, this.showValuePredicate});
  Widget build(BuildContext context);
}
/// Controller for managing [ControlledMultiSelect] state programmatically.
///
/// Extends [SelectController] to provide reactive state management for multi-selection
/// components. Manages a collection of selected items with methods for adding,
/// removing, and bulk operations.
///
/// Example:
/// ```dart
/// final controller = MultiSelectController<String>(['apple', 'banana']);
///
/// // Listen to changes
/// controller.addListener(() {
///   print('Selection changed to: ${controller.value}');
/// });
///
/// // Update selection
/// controller.value = ['apple', 'cherry'];
/// ```
class MultiSelectController<T> extends SelectController<Iterable<T>> {
/// Creates a [MultiSelectController] with an optional initial selection.
///
/// The [value] parameter sets the initial selected items collection.
/// Can be null or empty to start with no selections.
///
/// Parameters:
/// - [value] (`Iterable<T>?`, optional): Initial selected items
  MultiSelectController([super.value]);
}
/// Reactive multi-selection dropdown with automatic state management.
///
/// A high-level multi-select widget that provides automatic state management through
/// the controlled component pattern. Supports both controller-based and callback-based
/// state management with comprehensive customization options for item presentation,
/// selection behavior, and popup management.
///
/// ## Features
///
/// - **Multiple selection**: Select and deselect multiple items simultaneously
/// - **Flexible item rendering**: Custom builders for complete visual control over items
/// - **Selection indicators**: Built-in checkboxes or custom selection indicators
/// - **Popup positioning**: Configurable alignment and constraints for the dropdown
/// - **Keyboard navigation**: Full keyboard support with Space for selection toggle
/// - **Form integration**: Automatic validation and form field registration
///
/// ## Usage Patterns
///
/// **Controller-based (recommended for complex state):**
/// ```dart
/// final controller = MultiSelectController<String>(['apple']);
///
/// ControlledMultiSelect<String>(
///   controller: controller,
///   items: ['apple', 'banana', 'cherry', 'date'],
///   itemBuilder: (context, item, selected) => ListTile(
///     leading: Checkbox(value: selected),
///     title: Text(item),
///   ),
///   placeholder: Text('Choose fruits'),
/// )
/// ```
///
/// **Callback-based (simple state management):**
/// ```dart
/// List<String> selectedFruits = [];
///
/// ControlledMultiSelect<String>(
///   initialValue: selectedFruits,
///   onChanged: (fruits) => setState(() => selectedFruits = fruits?.toList() ?? []),
///   items: ['apple', 'banana', 'cherry'],
///   itemBuilder: (context, item, selected) => Text(item),
/// )
/// ```
class ControlledMultiSelect<T> extends StatelessWidget with ControlledComponent<Iterable<T>?>, SelectBase<Iterable<T>> {
  Iterable<T>? initialValue;
  ValueChanged<Iterable<T>?>? onChanged;
  bool enabled;
  MultiSelectController<T>? controller;
  Widget? placeholder;
  bool filled;
  FocusNode? focusNode;
  BoxConstraints? constraints;
  BoxConstraints? popupConstraints;
  PopoverConstraint popupWidthConstraint;
  BorderRadiusGeometry? borderRadius;
  EdgeInsetsGeometry? padding;
  AlignmentGeometry popoverAlignment;
  AlignmentGeometry? popoverAnchorAlignment;
  bool disableHoverEffect;
  bool canUnselect;
  bool autoClosePopover;
  SelectPopupBuilder popup;
  SelectValueBuilder<Iterable<T>> get itemBuilder;
  SelectValueSelectionHandler<Iterable<T>>? valueSelectionHandler;
  SelectValueSelectionPredicate<Iterable<T>>? valueSelectionPredicate;
  Predicate<Iterable<T>>? showValuePredicate;
/// Builder for rendering individual items in multi-select mode.
  SelectValueBuilder<T> multiItemBuilder;
/// Creates a [ControlledMultiSelect].
///
/// Either [controller] or [onChanged] should be provided for interactivity.
/// The widget supports both controller-based and callback-based state management
/// patterns with multiple item selection capabilities.
///
/// Parameters:
/// - [controller] (`MultiSelectController<T>?`, optional): external state controller
/// - [initialValue] (`Iterable<T>?`, optional): starting selection when no controller
/// - [onChanged] (`ValueChanged<Iterable<T>?>?`, optional): selection change callback
/// - [enabled] (bool, default: true): whether select is interactive
/// - [placeholder] (Widget?, optional): widget shown when no items selected
/// - [filled] (bool, default: false): whether to use filled appearance
/// - [focusNode] (FocusNode?, optional): custom focus node for keyboard handling
/// - [constraints] (BoxConstraints?, optional): size constraints for select widget
/// - [popupConstraints] (BoxConstraints?, optional): size constraints for popup
/// - [popupWidthConstraint] (PopoverConstraint, default: anchorFixedSize): popup width behavior
/// - [borderRadius] (BorderRadiusGeometry?, optional): override select border radius
/// - [padding] (EdgeInsetsGeometry?, optional): override internal padding
/// - [popoverAlignment] (AlignmentGeometry, default: topCenter): popup alignment
/// - [popoverAnchorAlignment] (AlignmentGeometry?, optional): anchor alignment
/// - [disableHoverEffect] (bool, default: false): disable item hover effects
/// - [canUnselect] (bool, default: false): allow deselecting all items
/// - [autoClosePopover] (bool, default: false): close popup after each selection
/// - [popup] (SelectPopupBuilder, required): builder for popup content
/// - [itemBuilder] (`SelectItemBuilder<T>`, required): builder for individual items
/// - [multiItemBuilder] (`SelectValueBuilder<T>`, required): builder for selected items display
/// - [valueSelectionHandler] (`SelectValueSelectionHandler<Iterable<T>>?`, optional): custom selection logic
/// - [valueSelectionPredicate] (`SelectValueSelectionPredicate<Iterable<T>>?`, optional): selection validation
/// - [showValuePredicate] (`Predicate<Iterable<T>>?`, optional): visibility filter for values
///
/// Example:
/// ```dart
/// ControlledMultiSelect<String>(
///   controller: controller,
///   popup: (context, items) => ListView(children: items),
///   itemBuilder: (context, item, selected) => CheckboxListTile(
///     value: selected,
///     title: Text(item),
///   ),
///   multiItemBuilder: (context, items) => Wrap(
///     children: items.map((item) => Chip(label: Text(item))).toList(),
///   ),
/// )
/// ```
  const ControlledMultiSelect({super.key, this.controller, this.onChanged, this.enabled = true, this.initialValue, this.placeholder, this.filled = false, this.focusNode, this.constraints, this.popupConstraints, this.popupWidthConstraint = PopoverConstraint.anchorFixedSize, this.borderRadius, this.padding, this.popoverAlignment = Alignment.topCenter, this.popoverAnchorAlignment, this.disableHoverEffect = false, this.canUnselect = true, this.autoClosePopover = false, this.showValuePredicate, required this.popup, required SelectValueBuilder<T> itemBuilder, this.valueSelectionHandler, this.valueSelectionPredicate});
  Widget build(BuildContext context);
}
/// A button widget representing a selectable item in a dropdown menu.
///
/// Used within select dropdowns to create clickable option items.
class SelectItemButton<T> extends StatelessWidget {
/// The value this item represents.
  T value;
/// The child widget to display as the item content.
  Widget child;
/// The button style for this item.
  AbstractButtonStyle style;
/// Whether this item is enabled.
  bool? enabled;
/// Creates a select item button.
  const SelectItemButton({super.key, required this.value, required this.child, this.enabled, this.style = const ButtonStyle.ghost()});
  Widget build(BuildContext context);
}
/// A container for grouping related select items with optional headers and footers.
///
/// Organizes select menu items into logical sections with optional header
/// and footer widgets.
class SelectGroup extends StatelessWidget {
/// Optional header widgets displayed above the group.
  List<Widget>? headers;
/// The list of select items in this group.
  List<Widget> children;
/// Optional footer widgets displayed below the group.
  List<Widget>? footers;
/// Creates a select group.
  const SelectGroup({super.key, this.headers, this.footers, required this.children});
  Widget build(BuildContext context);
}
/// Represents a selectable item in a dropdown menu.
///
/// Used within select popups to define individual selectable options.
/// Automatically applies selected state styling when the item matches
/// the current selection.
///
/// Example:
/// ```dart
/// SelectItem(
///   value: 'option1',
///   builder: (context) => Text('Option 1'),
/// )
/// ```
class SelectItem extends StatelessWidget {
/// Builder for the item's content.
  WidgetBuilder builder;
/// The value associated with this item.
  Object? value;
/// Creates a [SelectItem].
///
/// Parameters:
/// - [value] (`Object?`, required): Item value.
/// - [builder] (`WidgetBuilder`, required): Content builder.
  const SelectItem({super.key, required this.value, required this.builder});
  Widget build(BuildContext context);
}
/// A label widget for grouping items in a select popup.
///
/// Displays a non-selectable label to organize dropdown items into categories.
///
/// Example:
/// ```dart
/// SelectLabel(
///   child: Text('Category Name'),
/// )
/// ```
class SelectLabel extends StatelessWidget {
/// The label content.
  Widget child;
/// Creates a [SelectLabel].
///
/// Parameters:
/// - [child] (`Widget`, required): Label content.
  const SelectLabel({super.key, required this.child});
  Widget build(BuildContext context);
}
/// Common interface for select components.
///
/// Defines the contract for both single and multi-select widgets, providing
/// properties for popup behavior, styling, and value handling.
mixin SelectBase<T> {
/// Callback when selection changes.
  ValueChanged<T?>? get onChanged;
/// Placeholder widget shown when nothing is selected.
  Widget? get placeholder;
/// Whether to use filled appearance style.
  bool get filled;
/// Focus node for keyboard navigation.
  FocusNode? get focusNode;
/// Size constraints for the select trigger.
  BoxConstraints? get constraints;
/// Size constraints for the popup menu.
  BoxConstraints? get popupConstraints;
/// How popup width should relate to trigger width.
  PopoverConstraint get popupWidthConstraint;
/// Border radius of the select trigger.
  BorderRadiusGeometry? get borderRadius;
/// Internal padding of the select trigger.
  EdgeInsetsGeometry? get padding;
/// Alignment of popup relative to trigger.
  AlignmentGeometry get popoverAlignment;
/// Alignment of anchor point for popup positioning.
  AlignmentGeometry? get popoverAnchorAlignment;
/// Whether to disable hover effects.
  bool get disableHoverEffect;
/// Whether clicking selected item deselects it.
  bool get canUnselect;
/// Whether popup auto-closes after selection.
  bool? get autoClosePopover;
/// Builder for popup content.
  SelectPopupBuilder get popup;
/// Builder for rendering selected values.
  SelectValueBuilder<T> get itemBuilder;
/// Custom selection handler logic.
  SelectValueSelectionHandler<T>? get valueSelectionHandler;
/// Predicate for testing selection state.
  SelectValueSelectionPredicate<T>? get valueSelectionPredicate;
/// Predicate for showing value in trigger.
  Predicate<T>? get showValuePredicate;
}
/// A customizable dropdown selection widget for single-value selection.
///
/// [Select] provides a comprehensive dropdown selection experience with support for
/// custom item rendering, keyboard navigation, search functionality, and extensive
/// customization options. It displays a trigger button that opens a popup containing
/// selectable options when activated.
///
/// Key features:
/// - Single-value selection with optional null/unselect capability
/// - Customizable item rendering through builder functions
/// - Keyboard navigation and accessibility support
/// - Configurable popup positioning and constraints
/// - Search and filtering capabilities
/// - Focus management and interaction handling
/// - Theming and visual customization
/// - Form integration and validation support
///
/// The widget supports various configuration modes:
/// - Filled or outlined appearance styles
/// - Custom popup positioning and alignment
/// - Conditional item visibility and selection
/// - Hover effects and interaction feedback
/// - Auto-closing popup behavior
///
/// Selection behavior can be customized through:
/// - [valueSelectionHandler]: Custom logic for handling selection
/// - [valueSelectionPredicate]: Conditions for allowing selection
/// - [showValuePredicate]: Conditions for displaying items
/// - [canUnselect]: Whether to allow deselecting the current value
///
/// Example:
/// ```dart
/// Select<String>(
///   value: selectedItem,
///   placeholder: Text('Choose an option'),
///   onChanged: (value) => setState(() => selectedItem = value),
///   popup: SelectPopup.menu(
///     children: [
///       SelectItem(value: 'option1', child: Text('Option 1')),
///       SelectItem(value: 'option2', child: Text('Option 2')),
///       SelectItem(value: 'option3', child: Text('Option 3')),
///     ],
///   ),
/// );
/// ```
class Select<T> extends StatefulWidget with SelectBase<T> {
/// Default maximum height for select popups in logical pixels.
  static const kDefaultSelectMaxHeight = 240.0;
  ValueChanged<T?>? onChanged;
  Widget? placeholder;
  bool filled;
  FocusNode? focusNode;
  BoxConstraints? constraints;
  BoxConstraints? popupConstraints;
  PopoverConstraint popupWidthConstraint;
/// The currently selected value.
  T? value;
  BorderRadiusGeometry? borderRadius;
  EdgeInsetsGeometry? padding;
  AlignmentGeometry popoverAlignment;
  AlignmentGeometry? popoverAnchorAlignment;
  bool disableHoverEffect;
  bool canUnselect;
  bool? autoClosePopover;
/// Whether the select is enabled for user interaction.
  bool? enabled;
  SelectPopupBuilder popup;
  SelectValueBuilder<T> itemBuilder;
  SelectValueSelectionHandler<T>? valueSelectionHandler;
  SelectValueSelectionPredicate<T>? valueSelectionPredicate;
  Predicate<T>? showValuePredicate;
/// Creates a single-selection dropdown widget.
///
/// The [popup] and [itemBuilder] parameters are required to define the
/// dropdown content and how selected values are displayed.
///
/// Parameters:
/// - [key] (Key?): Widget key for controlling widget identity
/// - [onChanged] (`ValueChanged<T?>?`): Callback when selection changes; if null, select is disabled
/// - [placeholder] (Widget?): Widget shown when no value is selected
/// - [filled] (bool): Whether to use filled background style, defaults to false
/// - [focusNode] (FocusNode?): Focus node for keyboard interaction
/// - [constraints] (BoxConstraints?): Size constraints for the select button
/// - [popupConstraints] (BoxConstraints?): Size constraints for the popup menu
/// - [popupWidthConstraint] (PopoverConstraint): Width constraint mode for popup, defaults to `PopoverConstraint.anchorFixedSize`
/// - [value] (T?): Currently selected value
/// - [disableHoverEffect] (bool): Whether to disable hover visual feedback, defaults to false
/// - [borderRadius] (BorderRadiusGeometry?): Custom border radius
/// - [padding] (EdgeInsetsGeometry?): Custom padding
/// - [popoverAlignment] (AlignmentGeometry): Popup alignment, defaults to `Alignment.topCenter`
/// - [popoverAnchorAlignment] (AlignmentGeometry?): Anchor alignment for popup positioning
/// - [canUnselect] (bool): Whether user can deselect current value, defaults to false
/// - [autoClosePopover] (bool?): Whether popup closes after selection, defaults to true
/// - [enabled] (bool?): Whether select is enabled for interaction
/// - [valueSelectionHandler] (`SelectValueSelectionHandler<T>?`): Custom selection logic
/// - [valueSelectionPredicate] (`SelectValueSelectionPredicate<T>?`): Predicate for allowing selection
/// - [showValuePredicate] (`Predicate<T>?`): Predicate for showing items
/// - [popup] (SelectPopupBuilder): Required builder for popup content
/// - [itemBuilder] (`SelectValueBuilder<T>`): Required builder for selected value display
  const Select({super.key, this.onChanged, this.placeholder, this.filled = false, this.focusNode, this.constraints, this.popupConstraints, this.popupWidthConstraint = PopoverConstraint.anchorFixedSize, this.value, this.disableHoverEffect = false, this.borderRadius, this.padding, this.popoverAlignment = Alignment.topCenter, this.popoverAnchorAlignment, this.canUnselect = false, this.autoClosePopover = true, this.enabled, this.valueSelectionHandler, this.valueSelectionPredicate, this.showValuePredicate, required this.popup, required this.itemBuilder});
  SelectState<T> createState();
}
/// State class for the [Select] widget managing selection and popup interactions.
///
/// This state class handles the select dropdown's internal state including:
/// - Focus management for keyboard navigation
/// - Popup controller for opening/closing the dropdown menu
/// - Value change notifications
/// - Theme integration
///
/// The state implements [FormValueSupplier] to integrate with form validation
/// and value management systems.
///
/// See also:
/// - [Select], the widget that uses this state
/// - [PopoverController], used to control the dropdown popup
/// - [FormValueSupplier], the mixin providing form integration
class SelectState<T> extends State<Select<T>> with FormValueSupplier<T, Select<T>> {
  void didChangeDependencies();
  void initState();
  void didUpdateWidget(Select<T> oldWidget);
  void didReplaceFormValue(T value);
  void dispose();
  Widget build(BuildContext context);
}
/// Chip widget designed for multi-select contexts with automatic removal functionality.
///
/// A specialized chip widget that integrates with multi-select components to display
/// selected items with built-in removal capabilities. Automatically detects its
/// multi-select context and provides appropriate removal behavior.
///
/// ## Features
///
/// - **Context-aware removal**: Automatically integrates with parent multi-select state
/// - **Visual feedback**: Clear visual indication of selected state
/// - **Interactive deletion**: Built-in X button for removing selections
/// - **Consistent styling**: Matches multi-select component design patterns
/// - **Accessibility**: Full screen reader support for selection management
///
/// This widget is typically used within multi-select components to represent
/// individual selected items with the ability to remove them from the selection.
///
/// Example:
/// ```dart
/// MultiSelectChip(
///   value: 'apple',
///   child: Text('Apple'),
///   style: ButtonStyle.secondary(),
/// );
/// ```
class MultiSelectChip extends StatelessWidget {
/// The value this chip represents in the selection.
  Object? value;
/// The content displayed inside the chip.
  Widget child;
/// The chip styling.
  AbstractButtonStyle style;
/// Creates a [MultiSelectChip].
///
/// Designed to be used within multi-select components where it automatically
/// integrates with the parent selection state for removal functionality.
///
/// Parameters:
/// - [value] (Object?, required): the value this chip represents in the selection
/// - [child] (Widget, required): content displayed inside the chip
/// - [style] (AbstractButtonStyle, default: primary): chip styling
///
/// Example:
/// ```dart
/// MultiSelectChip(
///   value: user.id,
///   child: Row(
///     children: [
///       Avatar(user: user),
///       Text(user.name),
///     ],
///   ),
///   style: ButtonStyle.secondary(),
/// )
/// ```
  const MultiSelectChip({super.key, this.style = const ButtonStyle.primary(), required this.value, required this.child});
  Widget build(BuildContext context);
}
/// A customizable dropdown selection widget for multi-value selection.
///
/// Extends the base select functionality to support selecting multiple items
/// simultaneously. Displays selected items as removable chips within the trigger.
///
/// Example:
/// ```dart
/// MultiSelect<String>(
///   value: selectedItems,
///   onChanged: (items) => setState(() => selectedItems = items),
///   popup: SelectPopup.menu(children: [...]),
///   multiItemBuilder: (context, item) => Text(item),
/// )
/// ```
class MultiSelect<T> extends StatelessWidget with SelectBase<Iterable<T>> {
  ValueChanged<Iterable<T>?>? onChanged;
  Widget? placeholder;
  bool filled;
  FocusNode? focusNode;
  BoxConstraints? constraints;
  BoxConstraints? popupConstraints;
  PopoverConstraint popupWidthConstraint;
/// The currently selected values.
  Iterable<T>? value;
  BorderRadiusGeometry? borderRadius;
  EdgeInsetsGeometry? padding;
  AlignmentGeometry popoverAlignment;
  AlignmentGeometry? popoverAnchorAlignment;
  bool disableHoverEffect;
  bool canUnselect;
  bool? autoClosePopover;
/// Whether the multi-select is enabled for user interaction.
  bool? enabled;
  SelectPopupBuilder popup;
  SelectValueBuilder<Iterable<T>> get itemBuilder;
  SelectValueSelectionHandler<Iterable<T>>? valueSelectionHandler;
  SelectValueSelectionPredicate<Iterable<T>>? valueSelectionPredicate;
/// Builder for rendering individual items in the chip display.
  SelectValueBuilder<T> multiItemBuilder;
  Predicate<Iterable<T>>? showValuePredicate;
/// Creates a multi-selection dropdown widget.
///
/// Allows selecting multiple items from a dropdown list, displaying them as chips.
/// The [value], [popup], and [itemBuilder] parameters are required.
///
/// Parameters:
/// - [key] (Key?): Widget key for controlling widget identity
/// - [onChanged] (`ValueChanged<Iterable<T>?>?`): Callback when selection changes; if null, widget is disabled
/// - [placeholder] (Widget?): Widget shown when no values are selected
/// - [filled] (bool): Whether to use filled background style, defaults to false
/// - [focusNode] (FocusNode?): Focus node for keyboard interaction
/// - [constraints] (BoxConstraints?): Size constraints for the select button
/// - [popupConstraints] (BoxConstraints?): Size constraints for the popup menu
/// - [popupWidthConstraint] (PopoverConstraint): Width constraint mode for popup, defaults to `PopoverConstraint.anchorFixedSize`
/// - [value] (`Iterable<T>`): Required currently selected values
/// - [disableHoverEffect] (bool): Whether to disable hover visual feedback, defaults to false
/// - [borderRadius] (BorderRadiusGeometry?): Custom border radius
/// - [padding] (EdgeInsetsGeometry?): Custom padding
/// - [popoverAlignment] (AlignmentGeometry): Popup alignment, defaults to `Alignment.topCenter`
/// - [popoverAnchorAlignment] (AlignmentGeometry?): Anchor alignment for popup positioning
/// - [canUnselect] (bool): Whether user can deselect items, defaults to true
/// - [autoClosePopover] (bool?): Whether popup closes after selection, defaults to false
/// - [enabled] (bool?): Whether multi-select is enabled for interaction
/// - [valueSelectionHandler] (`SelectValueSelectionHandler<Iterable<T>>?`): Custom selection logic
/// - [valueSelectionPredicate] (`SelectValueSelectionPredicate<Iterable<T>>?`): Predicate for allowing selection
/// - [showValuePredicate] (`Predicate<Iterable<T>>?`): Predicate for showing items
/// - [popup] (SelectPopupBuilder): Required builder for popup content
/// - [itemBuilder] (`SelectValueBuilder<T>`): Required builder for individual chip items
  const MultiSelect({super.key, this.onChanged, this.placeholder, this.filled = false, this.focusNode, this.constraints, this.popupConstraints, this.popupWidthConstraint = PopoverConstraint.anchorFixedSize, required this.value, this.disableHoverEffect = false, this.borderRadius, this.padding, this.popoverAlignment = Alignment.topCenter, this.popoverAnchorAlignment, this.canUnselect = true, this.autoClosePopover = false, this.enabled, this.valueSelectionHandler, this.valueSelectionPredicate, this.showValuePredicate, required this.popup, required SelectValueBuilder<T> itemBuilder});
  Widget build(BuildContext context);
}
/// Data class holding select dropdown state and configuration.
///
/// Contains selection state, callbacks, and display options for select popups.
class SelectData {
/// Whether to automatically close the popup after selection.
  bool? autoClose;
/// Predicate to check if a value is currently selected.
  Predicate<Object?> isSelected;
/// Callback invoked when selection changes.
  SelectValueChanged<Object?> onChanged;
/// Whether any items are currently selected.
  bool hasSelection;
/// Whether the select is enabled for interaction.
  bool enabled;
/// Creates select data.
  const SelectData({required this.autoClose, required this.isSelected, required this.onChanged, required this.hasSelection, required this.enabled});
  bool operator ==(Object other);
  int get hashCode;
}
/// A popup widget for displaying selectable items in a dropdown.
///
/// Provides a searchable, scrollable list of items with various display modes.
class SelectPopup<T> extends StatefulWidget {
/// Builder function for dynamically generating select items.
  SelectItemsBuilder<T>? builder;
/// Static list of select items to display.
  FutureOr<SelectItemDelegate?>? items;
/// Controller for the search input field.
  TextEditingController? searchController;
/// Placeholder widget for the search field.
  Widget? searchPlaceholder;
/// Builder for empty state display.
  WidgetBuilder? emptyBuilder;
/// Builder for loading state display.
  WidgetBuilder? loadingBuilder;
/// Builder for error state display.
  ErrorWidgetBuilder? errorBuilder;
/// Blur amount for the popup surface.
  double? surfaceBlur;
/// Opacity for the popup surface.
  double? surfaceOpacity;
/// Whether to auto-close the popup after selection.
  bool? autoClose;
/// Whether selected items can be unselected.
  bool? canUnselect;
/// Whether search functionality is enabled.
  bool enableSearch;
/// Controller for the items scroll view.
  ScrollController? scrollController;
/// Whether the list should shrink-wrap its contents.
  bool shrinkWrap;
/// Whether to disable item virtualization.
  bool disableVirtualization;
/// Creates a select popup with a dynamic builder.
  const SelectPopup.builder({super.key, required this.builder, this.searchController, this.searchPlaceholder, this.emptyBuilder, this.loadingBuilder, this.surfaceBlur, this.surfaceOpacity, this.autoClose, this.canUnselect, this.enableSearch = true, this.errorBuilder, this.scrollController});
/// Creates a select popup with static items.
  const SelectPopup({super.key, this.items, this.searchController, this.searchPlaceholder, this.emptyBuilder, this.loadingBuilder, this.errorBuilder, this.surfaceBlur, this.surfaceOpacity, this.autoClose, this.canUnselect, this.scrollController, this.shrinkWrap = true});
/// Creates a select popup without virtualization optimization.
  const SelectPopup.noVirtualization({super.key, FutureOr<SelectItemList?>? this.items, this.searchController, this.searchPlaceholder, this.emptyBuilder, this.loadingBuilder, this.errorBuilder, this.surfaceBlur, this.surfaceOpacity, this.autoClose, this.canUnselect, this.scrollController});
/// A method used to implement SelectPopupBuilder
  SelectPopup<T> call(BuildContext context);
  State<SelectPopup<T>> createState();
}
/// Mixin providing select popup interaction methods.
///
/// Allows widgets to check selection state and update selections.
mixin SelectPopupHandle {
/// Checks if the given value is currently selected.
  bool isSelected(Object? value);
/// Updates the selection state for the given value.
  void selectItem(Object? value, bool selected);
/// Whether any items are currently selected.
  bool get hasSelection;
/// Retrieves the nearest SelectPopupHandle from the widget tree.
  static SelectPopupHandle of(BuildContext context);
}
/// Abstract base class for building select item lists.
///
/// Provides interface for rendering select items with optional caching
/// and change detection.
abstract class SelectItemDelegate with CachedValue {
/// An empty select item delegate constant.
  static const empty = EmptySelectItem();
/// Creates a select item delegate.
  const SelectItemDelegate();
/// Builds a widget for the item at the given index.
  Widget? build(BuildContext context, int index);
/// Estimated number of children in this delegate.
  int? get estimatedChildCount;
  bool shouldRebuild(covariant SelectItemDelegate oldDelegate);
}
/// An empty select item delegate that renders no items.
class EmptySelectItem extends SelectItemDelegate {
/// Creates an empty select item.
  const EmptySelectItem();
  Widget? build(BuildContext context, int index);
  int get estimatedChildCount;
  bool shouldRebuild(covariant EmptySelectItem oldDelegate);
}
/// A select item delegate that uses a builder function.
///
/// Provides items through a builder function with optional child count.
class SelectItemBuilder extends SelectItemDelegate {
/// The builder function for creating item widgets.
  SelectItemWidgetBuilder builder;
/// The number of children this delegate can build.
  int? childCount;
/// Creates a select item builder.
  const SelectItemBuilder({required this.builder, this.childCount});
  Widget build(BuildContext context, int index);
  int? get estimatedChildCount;
  bool shouldRebuild(covariant SelectItemBuilder oldDelegate);
}
/// A select item delegate that uses a static list of children.
///
/// [SelectItemList] provides select items from a pre-defined list of widgets.
/// This is the simplest way to create a select dropdown with a fixed set of options.
///
/// Example:
/// ```dart
/// SelectItemList(
///   children: [
///     SelectItem(value: 1, child: Text('Option 1')),
///     SelectItem(value: 2, child: Text('Option 2')),
///     SelectItem(value: 3, child: Text('Option 3')),
///   ],
/// )
/// ```
class SelectItemList extends SelectItemDelegate {
/// The list of widgets to display as select items.
  List<Widget> children;
/// Creates a [SelectItemList] with the specified children.
  const SelectItemList({required this.children});
  Widget build(BuildContext context, int index);
  int get estimatedChildCount;
  bool shouldRebuild(covariant SelectItemList oldDelegate);
}
/// Theme configuration for [FormattedInput] widget styling.
///
/// Defines visual properties for formatted input components including
/// height and padding. Applied globally through [ComponentTheme] or per-instance.
class FormattedInputTheme extends ComponentThemeData {
/// The height of the formatted input.
  double? height;
/// Internal padding for the formatted input.
  EdgeInsetsGeometry? padding;
/// Creates a [FormattedInputTheme].
  const FormattedInputTheme({this.height, this.padding});
/// Creates a copy of this theme with specified properties overridden.
  FormattedInputTheme copyWith({ValueGetter<double?>? height, ValueGetter<EdgeInsetsGeometry?>? padding});
  bool operator ==(Object other);
  int get hashCode;
}
/// Abstract base class for parts of a formatted input.
///
/// [InputPart] defines the interface for components that make up a formatted
/// input field, such as static text, editable sections, or custom widgets.
/// Each part can be rendered and may optionally hold a value.
///
/// Example parts:
/// - Static text separators (e.g., "/", "-")
/// - Editable numeric fields (e.g., month, day, year)
/// - Custom widget decorations
abstract class InputPart implements FormattedValuePart {
/// Creates a static text part.
  factory InputPart.static(String text);
/// Creates an editable input part.
  factory InputPart.editable({required int length, bool obscureText, List<TextInputFormatter> inputFormatters, Widget? placeholder, required double width});
/// Creates a custom widget part.
  factory InputPart.widget(Widget widget);
/// Creates an [InputPart].
  const InputPart();
/// Builds the widget for this part.
  Widget build(BuildContext context, FormattedInputData data);
/// A unique key identifying this part.
  Object? get partKey;
/// Whether this part can hold a value.
  bool get canHaveValue;
/// The current value of this part, or null if it doesn't hold a value.
  String? get value;
/// Returns this part.
  InputPart get part;
/// Creates a copy of this part with the specified value.
  FormattedValuePart withValue(String value);
  bool operator ==(Object other);
  int get hashCode;
}
/// A part that displays a custom widget.
class WidgetPart extends InputPart {
/// The widget to display.
  Widget widget;
/// Creates a [WidgetPart] with the specified widget.
  const WidgetPart(this.widget);
  Widget build(BuildContext context, FormattedInputData data);
  Object? get partKey;
  bool operator ==(Object other);
  int get hashCode;
}
/// A part that displays static, non-editable text.
class StaticPart extends InputPart {
/// The static text to display.
  String text;
/// Creates a [StaticPart] with the specified static text.
///
/// Parameters:
/// - [text] (`String`, required): The immutable text content to display.
///
/// Example:
/// ```dart
/// const StaticPart('/')
/// ```
  const StaticPart(this.text);
  Widget build(BuildContext context, FormattedInputData data);
  String get partKey;
  String toString();
  bool operator ==(Object other);
  int get hashCode;
}
/// A part that represents an editable input field section.
///
/// [EditablePart] defines a user-editable portion of a formatted input,
/// such as a date component, time segment, or numeric field. Each editable
/// part can have a fixed length, input formatters, and optional obscuring.
///
/// Example:
/// ```dart
/// EditablePart(
///   length: 2,
///   width: 40.0,
///   inputFormatters: [FilteringTextInputFormatter.digitsOnly],
///   placeholder: Text('MM'),
/// )
/// ```
class EditablePart extends InputPart {
/// The maximum length of text this part can hold.
  int length;
/// Whether to obscure the text (e.g., for passwords).
  bool obscureText;
/// Input formatters to apply to this part.
  List<TextInputFormatter> inputFormatters;
/// The width of this input part.
  double width;
/// Optional placeholder widget to display when empty.
  Widget? placeholder;
/// Creates an [EditablePart] with the specified configuration.
  const EditablePart({required this.length, this.obscureText = false, this.inputFormatters = const [], this.placeholder, required this.width});
  Object? get partKey;
  bool get canHaveValue;
  Widget build(BuildContext context, FormattedInputData data);
  String toString();
  bool operator ==(Object other);
  int get hashCode;
}
/// Represents a part of a formatted value with its associated input part and value.
///
/// A [FormattedValuePart] pairs an [InputPart] definition with an optional
/// string value, used to represent user input or parsed data within a
/// formatted input field.
///
/// Example:
/// ```dart
/// final part = FormattedValuePart(DigitPart(), '5');
/// final updated = part.withValue('7');
/// ```
class FormattedValuePart {
/// The input part definition that this value belongs to.
  InputPart part;
/// The actual string value for this part, or null if not set.
  String? value;
/// Creates a [FormattedValuePart].
///
/// Parameters:
/// - [part] (`InputPart`, required): The input part definition.
/// - [value] (`String?`, optional): The value for this part.
  const FormattedValuePart(this.part, [this.value]);
/// Creates a copy of this part with a new value.
///
/// Parameters:
/// - [value] (`String`, required): The new value to associate with this part.
///
/// Returns: A new [FormattedValuePart] with the updated value.
///
/// Example:
/// ```dart
/// final original = FormattedValuePart(DigitPart(), '1');
/// final updated = original.withValue('2');
/// ```
  FormattedValuePart withValue(String value);
  String toString();
  bool operator ==(Object other);
  int get hashCode;
}
/// Represents a complete formatted value composed of multiple parts.
///
/// A [FormattedValue] holds a list of [FormattedValuePart] instances, where
/// each part represents either static text or editable fields. It provides
/// methods to access value parts (excluding static parts) and retrieve
/// individual parts by index.
///
/// Example:
/// ```dart
/// final value = FormattedValue([
///   FormattedValuePart(DigitPart(), '1'),
///   FormattedValuePart(StaticPart('/'), null),
///   FormattedValuePart(DigitPart(), '2'),
/// ]);
/// print(value.values.length); // 2 (only value parts)
/// ```
class FormattedValue {
/// The list of parts that make up this formatted value.
  List<FormattedValuePart> parts;
/// Creates a [FormattedValue].
///
/// Parameters:
/// - [parts] (`List<FormattedValuePart>`, default: `const []`): The parts
///   composing this value.
  const FormattedValue([this.parts = const []]);
/// Returns an iterable of only the parts that can hold values.
///
/// This excludes static parts like separators or fixed text.
  Iterable<FormattedValuePart> get values;
/// Retrieves the value part at the specified index.
///
/// This indexes only the parts that can hold values (excluding static parts).
///
/// Parameters:
/// - [index] (`int`, required): The zero-based index into value parts.
///
/// Returns: The [FormattedValuePart] at the index, or null if out of bounds.
///
/// Example:
/// ```dart
/// final value = FormattedValue([
///   FormattedValuePart(DigitPart(), '1'),
///   FormattedValuePart(StaticPart('/'), null),
///   FormattedValuePart(DigitPart(), '2'),
/// ]);
/// print(value[0]?.value); // '1'
/// print(value[1]?.value); // '2'
/// ```
  FormattedValuePart? operator [](int index);
  String toString();
  bool operator ==(Object other);
  int get hashCode;
}
/// A controller for managing [FormattedInput] values programmatically.
///
/// This controller extends `ValueNotifier<FormattedValue>` to provide reactive
/// state management for formatted input components. It implements [ComponentController]
/// to integrate with the controlled component system, allowing external control
/// and listening to formatted input changes.
///
/// Example:
/// ```dart
/// final controller = FormattedInputController(
///   FormattedValue([
///     FormattedValuePart.static('('),
///     FormattedValuePart.editable('', length: 3),
///     FormattedValuePart.static(') '),
///     FormattedValuePart.editable('', length: 3),
///     FormattedValuePart.static('-'),
///     FormattedValuePart.editable('', length: 4),
///   ])
/// );
/// ```
class FormattedInputController extends ValueNotifier<FormattedValue> with ComponentController<FormattedValue> {
/// Creates a [FormattedInputController] with an optional initial value.
///
/// Parameters:
/// - [value] (FormattedValue, default: empty): Initial formatted value
  FormattedInputController([super.value = const FormattedValue()]);
}
/// A controlled input widget for structured data entry with formatting.
///
/// This widget provides a sophisticated input system that combines static text
/// elements with editable fields in a single input interface. It's ideal for
/// formatted inputs like phone numbers, credit cards, dates, or any structured
/// data that requires specific formatting patterns.
///
/// The FormattedInput manages multiple editable segments, each with their own
/// validation, formatting, and input restrictions. It automatically handles
/// focus management between segments and provides a seamless user experience
/// with proper keyboard navigation.
///
/// Example:
/// ```dart
/// FormattedInput(
///   style: TextStyle(fontFamily: 'monospace'),
///   leading: Icon(Icons.phone),
///   initialValue: FormattedValue([
///     FormattedValuePart.static('('),
///     FormattedValuePart.editable('555', length: 3),
///     FormattedValuePart.static(') '),
///     FormattedValuePart.editable('123', length: 3),
///     FormattedValuePart.static('-'),
///     FormattedValuePart.editable('4567', length: 4),
///   ]),
/// );
/// ```
class FormattedInput extends StatefulWidget with ControlledComponent<FormattedValue> {
  FormattedValue? initialValue;
  ValueChanged<FormattedValue>? onChanged;
  bool enabled;
  FormattedInputController? controller;
/// Text style applied to all input segments.
///
/// This style affects both static text and editable input fields within
/// the formatted input. Using a monospace font family is recommended
/// for consistent character spacing across segments.
  TextStyle? style;
/// Widget displayed at the beginning of the input.
///
/// Commonly used for icons or labels that provide context for the input
/// content, such as a phone icon for phone number inputs.
  Widget? leading;
/// Widget displayed at the end of the input.
///
/// Can be used for action buttons, status indicators, or additional
/// context related to the input content.
  Widget? trailing;
/// Creates a [FormattedInput].
///
/// The input structure is defined by the [initialValue] or [controller]
/// value, which contains the mix of static text and editable segments.
/// Each editable segment can have its own length restrictions and formatting.
///
/// Parameters:
/// - [initialValue] (FormattedValue?, optional): Initial structure and values
/// - [onChanged] (`ValueChanged<FormattedValue>?`, optional): Callback for value changes
/// - [style] (TextStyle?, optional): Text styling for all segments
/// - [leading] (Widget?, optional): Widget displayed before the input
/// - [trailing] (Widget?, optional): Widget displayed after the input
/// - [enabled] (bool, default: true): Whether the input accepts user interaction
/// - [controller] (FormattedInputController?, optional): External controller for programmatic control
///
/// Example:
/// ```dart
/// FormattedInput(
///   initialValue: FormattedValue([
///     FormattedValuePart.static('$'),
///     FormattedValuePart.editable('0.00', length: 8),
///   ]),
///   leading: Icon(Icons.attach_money),
///   style: TextStyle(fontSize: 16),
/// );
/// ```
  const FormattedInput({super.key, this.initialValue, this.onChanged, this.style, this.leading, this.trailing, this.enabled = true, this.controller});
  State<FormattedInput> createState();
}
/// Internal data structure for formatted input parts.
///
/// [FormattedInputData] holds the state and configuration data needed
/// to render and manage an individual input part within a formatted input.
class FormattedInputData {
/// The index of this part in the formatted input.
  int partIndex;
/// The initial value for this part.
  String? initialValue;
/// Whether this part is enabled for editing.
  bool enabled;
/// The controller managing the overall formatted input.
  FormattedInputController? controller;
/// The focus node for this specific part.
  FocusNode? focusNode;
/// All focus nodes in the formatted input.
  List<FocusNode> focusNodes;
/// Creates a [FormattedInputData].
  FormattedInputData({required this.partIndex, required this.initialValue, required this.enabled, required this.controller, required this.focusNode, required this.focusNodes});
  bool operator ==(Object other);
  int get hashCode;
}
/// A formatted input widget that works with complex objects.
///
/// [FormattedObjectInput] extends formatted input functionality to handle
/// objects of type [T], converting between the object and its formatted
/// string representation. It can optionally display a popup for advanced editing.
///
/// Example:
/// ```dart
/// FormattedObjectInput<DateTime>(
///   converter: dateConverter,
///   parts: [
///     InputPart.editable(length: 2, width: 30), // Month
///     InputPart.static('/'),
///     InputPart.editable(length: 2, width: 30), // Day
///   ],
///   popupBuilder: (context, controller) => CalendarWidget(),
/// )
/// ```
class FormattedObjectInput<T> extends StatefulWidget with ControlledComponent<T?> {
/// The initial value of the input.
  T? initialValue;
/// Called when the value changes.
  ValueChanged<T?>? onChanged;
/// Called when the individual parts change.
  ValueChanged<List<String>>? onPartsChanged;
/// Builder for creating a custom popup widget.
  FormattedInputPopupBuilder<T>? popupBuilder;
/// Whether the input is enabled.
  bool enabled;
/// Optional controller for external control.
  ComponentController<T?>? controller;
/// Converter between the object type and string parts.
  BiDirectionalConvert<T?, List<String?>> converter;
/// The input parts that make up the formatted input.
  List<InputPart> parts;
/// Alignment of the popover relative to the anchor.
  AlignmentGeometry? popoverAlignment;
/// Anchor alignment for popover positioning.
  AlignmentGeometry? popoverAnchorAlignment;
/// Offset for the popover position.
  Offset? popoverOffset;
/// Icon displayed in the popover trigger.
  Widget? popoverIcon;
/// Creates a [FormattedObjectInput].
  const FormattedObjectInput({super.key, this.initialValue, this.onChanged, this.popupBuilder, this.enabled = true, this.controller, required this.converter, required this.parts, this.popoverAlignment, this.popoverAnchorAlignment, this.popoverOffset, this.popoverIcon, this.onPartsChanged});
  State<FormattedObjectInput<T>> createState();
}
/// A slider widget for adjusting HSV color components.
///
/// [HSVColorSlider] provides an interactive slider for modifying different
/// aspects of an HSV color (hue, saturation, value, and combinations).
/// The slider displays a gradient representing the selected color channel(s)
/// and allows users to drag to adjust values.
///
/// Example:
/// ```dart
/// HSVColorSlider(
///   value: HSVColor.fromColor(Colors.blue),
///   sliderType: HSVColorSliderType.hue,
///   onChanged: (newColor) {
///     print('New hue: ${newColor.hue}');
///   },
/// )
/// ```
class HSVColorSlider extends StatefulWidget {
/// The current HSV color value.
  HSVColor value;
/// Called while the slider is being dragged.
  ValueChanged<HSVColor>? onChanging;
/// Called when the slider interaction is complete.
  ValueChanged<HSVColor>? onChanged;
/// The type of HSV component(s) this slider controls.
  HSVColorSliderType sliderType;
/// Whether to reverse the slider direction.
  bool reverse;
/// Corner radius for the slider.
  Radius radius;
/// Padding around the slider.
  EdgeInsets padding;
/// Creates an [HSVColorSlider].
  const HSVColorSlider({super.key, required this.value, this.onChanging, this.onChanged, required this.sliderType, this.reverse = false, this.radius = const Radius.circular(0), this.padding = const EdgeInsets.all(0)});
  State<HSVColorSlider> createState();
}
/// A custom painter for rendering HSV color slider gradients.
///
/// [HSVColorSliderPainter] draws the gradient background for HSV color sliders,
/// showing the range of possible colors for the selected slider type. The
/// gradient updates based on the current color and slider configuration.
class HSVColorSliderPainter extends CustomPainter {
/// The type of slider being painted.
  HSVColorSliderType sliderType;
/// The current HSV color.
  HSVColor color;
/// Whether the gradient direction is reversed.
  bool reverse;
/// Creates an [HSVColorSliderPainter].
  HSVColorSliderPainter({required this.sliderType, required this.color, this.reverse = false});
  void paint(Canvas canvas, Size size);
  bool shouldRepaint(covariant HSVColorSliderPainter oldDelegate);
}
/// A custom painter that draws a checkboard pattern for alpha/transparency visualization.
///
/// [AlphaPainter] renders a two-tone checkerboard pattern typically used behind
/// semi-transparent colors to make the transparency visible. This is a common
/// pattern in color pickers and image editors.
class AlphaPainter extends CustomPainter {
/// Primary color for the checkerboard pattern.
  static const Color checkboardPrimary = Color(0xFFE0E0E0);
/// Secondary color for the checkerboard pattern.
  static const Color checkboardSecondary = Color(0xFFB0B0B0);
/// Size of each checkerboard square.
  static const double checkboardSize = 8.0;
  void paint(Canvas canvas, Size size);
  bool shouldRepaint(covariant AlphaPainter oldDelegate);
}
/// A slider widget for adjusting HSL color components.
///
/// [HSLColorSlider] provides an interactive slider for modifying different
/// aspects of an HSL color (hue, saturation, lightness, and combinations).
/// The slider displays a gradient representing the selected color channel(s)
/// and allows users to drag to adjust values.
///
/// Example:
/// ```dart
/// HSLColorSlider(
///   color: HSLColor.fromColor(Colors.blue),
///   sliderType: HSLColorSliderType.hue,
///   onChanged: (newColor) {
///     print('New hue: ${newColor.hue}');
///   },
/// )
/// ```
class HSLColorSlider extends StatefulWidget {
/// The current HSL color value.
  HSLColor color;
/// Called while the slider is being dragged.
  ValueChanged<HSLColor>? onChanging;
/// Called when the slider interaction is complete.
  ValueChanged<HSLColor>? onChanged;
/// The type of HSL component(s) this slider controls.
  HSLColorSliderType sliderType;
/// Whether to reverse the slider direction.
  bool reverse;
/// Corner radius for the slider.
  Radius radius;
/// Padding around the slider.
  EdgeInsets padding;
/// Creates an [HSLColorSlider].
  const HSLColorSlider({super.key, required this.color, this.onChanging, this.onChanged, required this.sliderType, this.reverse = false, this.radius = const Radius.circular(0), this.padding = const EdgeInsets.all(0)});
  State<HSLColorSlider> createState();
}
/// A custom painter for rendering HSL color slider gradients.
///
/// [HSLColorSliderPainter] draws the gradient background for HSL color sliders,
/// showing the range of possible colors for the selected slider type. The
/// gradient updates based on the current color and slider configuration.
class HSLColorSliderPainter extends CustomPainter {
/// The type of slider being painted.
  HSLColorSliderType sliderType;
/// The current HSL color.
  HSLColor color;
/// Whether the gradient direction is reversed.
  bool reverse;
/// Creates an [HSLColorSliderPainter].
  HSLColorSliderPainter({required this.sliderType, required this.color, this.reverse = false});
  void paint(Canvas canvas, Size size);
  bool shouldRepaint(covariant HSLColorSliderPainter oldDelegate);
}
/// Theme configuration for [ColorInput] widget styling and behavior.
///
/// Defines the visual properties and default behaviors for color input components
/// including popover presentation, picker modes, and interaction features. Applied
/// globally through [ComponentTheme] or per-instance for customization.
///
/// Supports comprehensive customization of color picker appearance, positioning,
/// and functionality to match application design requirements.
class ColorInputTheme extends ComponentThemeData {
/// Whether to display alpha (transparency) controls by default.
///
/// When true, color pickers include alpha/opacity sliders and inputs.
/// When false, only RGB/HSV controls are shown. Individual components
/// can override this theme setting.
  bool? showAlpha;
/// Alignment point on the popover for anchor attachment.
///
/// Determines where the color picker popover positions itself relative
/// to the anchor widget. When null, uses framework default alignment.
  AlignmentGeometry? popoverAlignment;
/// Alignment point on the anchor widget for popover positioning.
///
/// Specifies which part of the trigger widget the popover should align to.
/// When null, uses framework default anchor alignment.
  AlignmentGeometry? popoverAnchorAlignment;
/// Internal padding applied to the color picker popover content.
///
/// Controls spacing around the color picker interface within the popover
/// container. When null, uses framework default padding.
  EdgeInsetsGeometry? popoverPadding;
/// Default interaction mode for color input triggers.
///
/// Determines whether color selection opens a popover or modal dialog.
/// When null, uses framework default prompt mode behavior.
  PromptMode? mode;
/// Default color picker interface type.
///
/// Specifies whether to use HSV, HSL, or other color picker implementations.
/// When null, uses framework default picker mode.
  ColorPickerMode? pickerMode;
/// Whether to enable screen color sampling functionality.
///
/// When true, color pickers include tools to sample colors directly from
/// the screen. Platform support varies. When null, uses framework default.
  bool? enableEyeDropper;
/// Whether to display color value labels in picker interfaces.
///
/// When true, shows numeric color values (hex, RGB, HSV, etc.) alongside
/// visual color pickers. When null, uses framework default label visibility.
  bool? showLabel;
/// The orientation of the color input layout.
  Axis? orientation;
/// Whether to show the color history panel.
  bool? showHistory;
/// Creates a [ColorInputTheme].
///
/// All parameters are optional and fall back to framework defaults when null.
/// The theme can be applied globally or to specific color input instances.
  const ColorInputTheme({this.showAlpha, this.popoverAlignment, this.popoverAnchorAlignment, this.popoverPadding, this.mode, this.pickerMode, this.enableEyeDropper, this.showLabel, this.orientation, this.showHistory});
/// Creates a copy of this theme with specified properties overridden.
///
/// Each parameter function is called only if provided, allowing selective
/// overrides while preserving existing values for unspecified properties.
  ColorInputTheme copyWith({ValueGetter<bool?>? showAlpha, ValueGetter<AlignmentGeometry?>? popoverAlignment, ValueGetter<AlignmentGeometry?>? popoverAnchorAlignment, ValueGetter<EdgeInsetsGeometry?>? popoverPadding, ValueGetter<PromptMode?>? mode, ValueGetter<ColorPickerMode?>? pickerMode, ValueGetter<bool?>? enableEyeDropper, ValueGetter<bool?>? showLabel, ValueGetter<Axis?>? orientation, ValueGetter<bool?>? showHistory});
  bool operator ==(Object other);
  int get hashCode;
}
/// A color input widget that allows users to select and edit colors.
///
/// [ColorInput] provides a comprehensive color selection interface with support
/// for multiple color spaces (HSV, HSL), alpha channel control, and eye dropper
/// functionality. The widget can be displayed in a popover or modal dialog.
///
/// The color picker supports:
/// - Multiple color representation modes (HSV, HSL)
/// - Optional alpha/opacity control
/// - Screen color sampling with eye dropper
/// - Customizable layout orientation
/// - Flexible positioning via popovers or dialogs
///
/// Example:
/// ```dart
/// ColorInput(
///   value: ColorDerivative.fromColor(Colors.blue),
///   onChanged: (color) {
///     print('Selected color: ${color.toColor()}');
///   },
///   showAlpha: true,
///   enableEyeDropper: true,
/// )
/// ```
class ColorInput extends StatefulWidget {
/// The current color value.
  ColorDerivative value;
/// Called when the color is being changed (while dragging sliders, etc.).
  ValueChanged<ColorDerivative>? onChanging;
/// Called when the color change is complete (after releasing sliders, etc.).
  ValueChanged<ColorDerivative>? onChanged;
/// Whether to show alpha (opacity) controls.
  bool? showAlpha;
/// The initial color picker mode (HSV, HSL, etc.).
  ColorPickerMode? initialMode;
/// Whether to enable the eye dropper (screen color sampling) feature.
  bool? enableEyeDropper;
/// The alignment of the popover relative to the anchor.
  AlignmentGeometry? popoverAlignment;
/// The alignment point on the anchor widget for popover positioning.
  AlignmentGeometry? popoverAnchorAlignment;
/// Internal padding for the popover content.
  EdgeInsetsGeometry? popoverPadding;
/// Widget displayed when no color is selected.
  Widget? placeholder;
/// The mode for presenting the color picker (popover or modal).
  PromptMode? promptMode;
/// Title widget for the dialog when using modal mode.
  Widget? dialogTitle;
/// Whether to show color value labels.
  bool? showLabel;
/// Whether the color input is enabled.
  bool? enabled;
/// The layout orientation of the color input.
  Axis? orientation;
/// Whether to show the color history button.
  bool showHistory;
/// Creates a [ColorInput] widget.
  const ColorInput({super.key, required this.value, this.onChanging, this.onChanged, this.showAlpha, this.initialMode, this.enableEyeDropper = true, this.popoverAlignment, this.popoverAnchorAlignment, this.popoverPadding, this.placeholder, this.promptMode, this.dialogTitle, this.showLabel, this.orientation, this.enabled, this.showHistory = true});
  State<ColorInput> createState();
}
/// Reactive controller for managing color input state with color operations.
///
/// Extends [ValueNotifier] to provide state management for color input widgets
/// using [ColorDerivative] values that support multiple color space representations.
/// Enables programmatic color changes while maintaining color space fidelity.
///
/// The controller manages [ColorDerivative] objects which preserve original
/// color space information (HSV, HSL, RGB) for accurate color manipulations
/// and prevents precision loss during color space conversions.
///
/// Example:
/// ```dart
/// final controller = ColorInputController(
///   ColorDerivative.fromColor(Colors.blue),
/// );
///
/// // React to changes
/// controller.addListener(() {
///   print('Color changed to: ${controller.value.color}');
/// });
///
/// // Programmatic control
/// controller.value = ColorDerivative.fromHSV(HSVColor.fromColor(Colors.red));
/// ```
class ColorInputController extends ValueNotifier<ColorDerivative> with ComponentController<ColorDerivative> {
/// Creates a [ColorInputController] with the specified initial color.
///
/// The [value] parameter provides the initial color as a [ColorDerivative].
/// The controller notifies listeners when the color changes through any
/// method calls or direct value assignment.
///
/// Example:
/// ```dart
/// final controller = ColorInputController(
///   ColorDerivative.fromColor(Colors.green),
/// );
/// ```
  ColorInputController(super.value);
/// Sets the color to a new [Color] value.
///
/// Converts the color to a [ColorDerivative] preserving RGB color space
/// information. Notifies listeners of the change.
  void setColor(Color color);
/// Sets the color to a new HSV color value.
///
/// Uses [ColorDerivative.fromHSV] to preserve HSV color space information
/// for accurate hue, saturation, and value manipulations.
  void setHSVColor(HSVColor hsvColor);
/// Sets the color to a new HSL color value.
///
/// Uses [ColorDerivative.fromHSL] to preserve HSL color space information
/// for accurate hue, saturation, and lightness manipulations.
  void setHSLColor(HSLColor hslColor);
/// Gets the current color as a standard [Color] object.
  Color get color;
/// Gets the current color as an HSV color representation.
  HSVColor get hsvColor;
/// Gets the current color as an HSL color representation.
  HSLColor get hslColor;
}
/// A controlled color input widget integrating with form state management.
///
/// Implements [ControlledComponent] to provide automatic form integration,
/// validation, and state management for color selection.
class ControlledColorInput extends StatelessWidget with ControlledComponent<ColorDerivative> {
  ColorDerivative initialValue;
  ValueChanged<ColorDerivative>? onChanged;
  bool enabled;
  ColorInputController? controller;
/// Whether to show alpha channel controls.
  bool? showAlpha;
/// Alignment of the popover relative to the anchor.
  AlignmentGeometry? popoverAlignment;
/// Anchor alignment for the popover.
  AlignmentGeometry? popoverAnchorAlignment;
/// Padding inside the popover.
  EdgeInsetsGeometry? popoverPadding;
/// Placeholder widget when no color is selected.
  Widget? placeholder;
/// The prompt display mode for the color picker.
  PromptMode? promptMode;
/// Title widget for the dialog mode.
  Widget? dialogTitle;
/// Whether to show color labels.
  bool? showLabel;
/// Orientation of color controls.
  Axis? orientation;
/// Whether to enable the eye dropper tool.
  bool? enableEyeDropper;
/// The initial color picker mode to display.
  ColorPickerMode? initialMode;
/// Callback invoked while the color is being changed (live updates).
  ValueChanged<ColorDerivative>? onChanging;
/// Creates a controlled color input.
  const ControlledColorInput({super.key, required this.initialValue, this.onChanged, this.enabled = true, this.controller, this.showAlpha, this.popoverAlignment, this.popoverAnchorAlignment, this.popoverPadding, this.placeholder, this.promptMode, this.dialogTitle, this.showLabel, this.orientation, this.enableEyeDropper, this.initialMode, this.onChanging});
  Widget build(BuildContext context);
}
/// A grid widget that displays a history of previously used colors.
///
/// [ColorHistoryGrid] presents colors from a [ColorHistoryStorage] in a grid
/// layout, allowing users to quickly reuse recently selected colors. The grid
/// can highlight the currently selected color and supports custom layouts.
///
/// Example:
/// ```dart
/// ColorHistoryGrid(
///   storage: myColorHistory,
///   onColorPicked: (color) {
///     print('Selected from history: $color');
///   },
///   crossAxisCount: 8,
/// )
/// ```
class ColorHistoryGrid extends StatelessWidget {
/// The storage containing the color history.
  ColorHistoryStorage storage;
/// Called when a color from the history is picked.
  ValueChanged<Color>? onColorPicked;
/// Spacing between grid items.
  double? spacing;
/// Number of columns in the grid.
  int crossAxisCount;
/// The currently selected color to highlight.
  Color? selectedColor;
/// The amount of colors to display in the history.
  int? maxTotalColors;
/// Creates a [ColorHistoryGrid].
  const ColorHistoryGrid({super.key, required this.storage, this.onColorPicked, this.spacing, this.crossAxisCount = 10, this.selectedColor, this.maxTotalColors});
  Widget build(BuildContext context);
}
/// An abstract interface for storing and managing color history.
///
/// [ColorHistoryStorage] defines the contract for color history management,
/// including adding new colors, clearing history, and accessing recent colors.
/// Implementations should provide storage mechanisms (in-memory, persistent, etc.).
abstract class ColorHistoryStorage implements Listenable {
/// Adds a color to the history.
///
/// Parameters:
/// - [color]: The color to add to the history.
  void addHistory(Color color);
/// Replaces the entire color history with a new list.
///
/// Parameters:
/// - [colors]: The new list of colors to set as the history.
  void setHistory(List<Color> colors);
/// Clears all colors from the history.
  void clear();
/// The maximum number of colors that can be stored in the history.
  int get capacity;
/// The list of recent colors, ordered from most to least recent.
  List<Color> get recentColors;
/// Finds and listens the [ColorHistoryStorage] in the widget tree.
  static ColorHistoryStorage of(BuildContext context);
/// Finds the [ColorHistoryStorage] in the widget tree.
  static ColorHistoryStorage find(BuildContext context);
}
/// Provides color history storage in the widget tree.
///
/// [RecentColorsScope] manages a list of recently used colors and makes it
/// available to descendant widgets through [ColorHistoryStorage]. It supports
/// a configurable maximum capacity and notifies listeners of changes.
///
/// Example:
/// ```dart
/// RecentColorsScope(
///   maxRecentColors: 20,
///   onRecentColorsChanged: (colors) {
///     // Save colors to persistent storage
///   },
///   child: MyColorPicker(),
/// )
/// ```
class RecentColorsScope extends StatefulWidget {
/// Initial colors to populate the history.
  List<Color> initialRecentColors;
/// Maximum number of colors to keep in the history.
  int maxRecentColors;
/// Called when the recent colors list changes.
  ValueChanged<List<Color>>? onRecentColorsChanged;
/// The child widget.
  Widget child;
/// Creates a [RecentColorsScope].
  const RecentColorsScope({super.key, this.initialRecentColors = const [], this.maxRecentColors = 50, this.onRecentColorsChanged, required this.child});
  State<RecentColorsScope> createState();
}
/// State class for [RecentColorsScope] implementing color history storage.
///
/// Manages the list of recently used colors and provides storage functionality
/// for color history tracking.
class RecentColorsScopeState extends State<RecentColorsScope> implements ColorHistoryStorage {
  int get capacity;
  void initState();
  List<Color> get recentColors;
  void addHistory(Color color);
  void dispose();
  void clear();
  void setHistory(List<Color> colors);
  Widget build(BuildContext context);
  void addListener(VoidCallback listener);
  void removeListener(VoidCallback listener);
}
/// A layer widget that provides eye dropper (color picking) functionality.
///
/// [EyeDropperLayer] wraps its child widget and enables screen color sampling.
/// When active, it displays a magnified preview of the area under the cursor
/// and allows users to pick colors directly from the screen.
///
/// Features:
/// - Magnified preview of screen area
/// - Customizable preview size and scale
/// - Optional color label display
/// - Flexible preview positioning
///
/// Example:
/// ```dart
/// EyeDropperLayer(
///   child: MyApp(),
///   showPreview: true,
///   previewScale: 10,
///   previewLabelBuilder: (context, color) {
///     return Text('Color: ${colorToHex(color)}');
///   },
/// )
/// ```
class EyeDropperLayer extends StatefulWidget {
/// The child widget to wrap.
  Widget child;
/// Alignment of the preview overlay.
  AlignmentGeometry? previewAlignment;
/// Whether to show the magnified preview.
  bool showPreview;
/// Size of the preview overlay.
  Size? previewSize;
/// Magnification scale of the preview.
  double previewScale;
/// Builder for custom preview label widgets.
  PreviewLabelBuilder? previewLabelBuilder;
/// Creates an [EyeDropperLayer].
  const EyeDropperLayer({super.key, required this.child, this.previewAlignment, this.showPreview = true, this.previewSize, this.previewScale = 8, this.previewLabelBuilder});
  State<EyeDropperLayer> createState();
}
/// Prompts the user to pick a color from the screen using an eye dropper tool.
///
/// Returns the selected color, or null if the operation was cancelled.
/// Optionally stores the selected color in the provided [storage].
Future<Color?> pickColorFromScreen(BuildContext context, [ColorHistoryStorage? storage]);
/// Provides access to eye dropper functionality in the widget tree.
///
/// [EyeDropperLayerScope] is an abstract interface that allows widgets to
/// request color picking functionality from an ancestor [EyeDropperLayer].
/// Use the static methods to find the scope in the widget tree.
abstract class EyeDropperLayerScope {
/// Prompts the user to pick a color from the screen.
///
/// Parameters:
/// - [historyStorage]: Optional storage for color picking history.
///
/// Returns: A [Future] that completes with the picked color, or null if cancelled.
  Future<Color?> promptPickColor([ColorHistoryStorage? historyStorage]);
/// Finds the root [EyeDropperLayerScope] in the widget tree.
///
/// Searches up the tree to find the topmost eye dropper scope.
  static EyeDropperLayerScope findRoot(BuildContext context);
/// Finds the nearest [EyeDropperLayerScope] in the widget tree.
///
/// Searches up the tree to find the closest eye dropper scope.
  static EyeDropperLayerScope find(BuildContext context);
}
/// Represents the result of an eye dropper color picking operation.
///
/// [EyeDropperResult] contains the picked color along with all colors
/// captured in the sampling area. This allows for accessing individual
/// pixels from the captured region.
class EyeDropperResult {
/// The size of the captured area.
  Size size;
/// All colors in the captured area, stored row by row.
  List<Color> colors;
/// The specific color that was picked by the user.
  Color pickedColor;
/// Creates an [EyeDropperResult].
  const EyeDropperResult(this.colors, this.size, this.pickedColor);
/// Gets the color at the specified position in the captured area.
///
/// Parameters:
/// - [position]: The offset position within the captured area.
///
/// Returns: The color at that position.
  Color operator [](Offset position);
}
/// Defines the color representation mode for color pickers.
///
/// Specifies which color model and input controls to display in the color picker
/// interface. Each mode provides different controls optimized for that color space.
enum ColorPickerMode { rgb, hsl, hsv, hex }
/// Defines available slider types for HSV color pickers.
///
/// Each slider type controls different aspects of the HSV color model,
/// allowing fine-tuned control over hue, saturation, value, and alpha channels.
enum HSVColorSliderType { hue, hueSat, hueVal, hueAlpha, sat, satVal, satAlpha, val, valAlpha, alpha }
/// Defines available slider types for HSL color pickers.
///
/// Each slider type controls different aspects of the HSL color model,
/// allowing fine-tuned control over hue, saturation, luminance, and alpha channels.
enum HSLColorSliderType { hue, hueSat, hueLum, hueAlpha, sat, satLum, satAlpha, lum, lumAlpha, alpha }
/// Theme configuration for [ColorPicker] widget styling and layout.
///
/// Defines visual and layout properties for color picker components including
/// spacing, orientation, and feature availability. Applied globally through
/// [ComponentTheme] or per-instance.
class ColorPickerTheme extends ComponentThemeData {
/// Spacing between major color picker sections.
  double? spacing;
/// Spacing between individual controls within sections.
  double? controlSpacing;
/// Layout orientation (horizontal or vertical).
  Axis? orientation;
/// Whether to enable the eye dropper feature.
  bool? enableEyeDropper;
/// The size of color sliders.
  double? sliderSize;
/// Creates a [ColorPickerTheme].
  const ColorPickerTheme({this.spacing, this.controlSpacing, this.orientation, this.enableEyeDropper, this.sliderSize});
/// Creates a copy of this theme with specified properties overridden.
  ColorPickerTheme copyWith({ValueGetter<double?>? spacing, ValueGetter<double?>? controlSpacing, ValueGetter<Axis?>? orientation, ValueGetter<bool?>? enableEyeDropper, ValueGetter<double?>? sliderSize});
  bool operator ==(Object other);
  int get hashCode;
}
/// A comprehensive color picker widget with multiple color mode support.
///
/// [ColorPicker] provides an interactive interface for selecting colors using
/// various color representation models (RGB, HSL, HSV, HEX). It supports alpha
/// channel control, eye dropper functionality, and customizable layout.
///
/// Features:
/// - Multiple color modes (RGB, HSL, HSV, HEX)
/// - Optional alpha/opacity control
/// - Screen color sampling with eye dropper
/// - Flexible layout orientation
/// - Real-time color updates
/// - Mode switching during use
///
/// Example:
/// ```dart
/// ColorPicker(
///   value: ColorDerivative.fromColor(Colors.blue),
///   onChanged: (color) {
///     print('Selected: ${color.toColor()}');
///   },
///   showAlpha: true,
///   initialMode: ColorPickerMode.hsv,
///   enableEyeDropper: true,
/// )
/// ```
class ColorPicker extends StatefulWidget {
/// The current color value.
  ColorDerivative value;
/// Called when the color is finalized.
  ValueChanged<ColorDerivative>? onChanged;
/// Called continuously while the color is being changed.
  ValueChanged<ColorDerivative>? onChanging;
/// Whether to show alpha (opacity) controls.
  bool showAlpha;
/// Whether to show the color history button.
  bool showHistoryButton;
/// Whether to show the color history panel initially.
  bool initialShowHistory;
/// The initial color picker mode.
  ColorPickerMode initialMode;
/// Called when the color picker mode changes.
  ValueChanged<ColorPickerMode>? onModeChanged;
/// Called when the eye dropper button is pressed.
  VoidCallback? onEyeDropperRequested;
/// Whether to enable the eye dropper feature.
  bool? enableEyeDropper;
/// Layout orientation of the color picker.
  Axis? orientation;
/// Spacing between major sections.
  double? spacing;
/// Spacing between individual controls.
  double? controlSpacing;
/// Size of the color sliders.
  double? sliderSize;
/// Creates a [ColorPicker] widget.
  const ColorPicker({super.key, required this.value, this.onChanged, this.onChanging, this.showAlpha = false, this.initialMode = ColorPickerMode.rgb, this.onModeChanged, this.enableEyeDropper, this.onEyeDropperRequested, this.orientation, this.spacing, this.controlSpacing, this.sliderSize, this.showHistoryButton = true, this.initialShowHistory = false});
  State<ColorPicker> createState();
}
/// Widget providing color input controls with multiple color space modes.
///
/// Displays inputs for editing colors in RGB, HSL, HSV, or HEX formats
/// with optional alpha channel and eye dropper tool support.
class ColorControls extends StatelessWidget {
/// The current color value.
  ColorDerivative value;
/// Callback invoked when the color is changed.
  ValueChanged<ColorDerivative>? onChanged;
/// Callback invoked while the color is being changed (live updates).
  ValueChanged<ColorDerivative>? onChanging;
/// Callback invoked when the color picker mode changes.
  ValueChanged<ColorPickerMode>? onModeChanged;
/// Whether to show alpha channel controls.
  bool showAlpha;
/// The current color picker mode (RGB, HSL, HSV, or HEX).
  ColorPickerMode mode;
/// Spacing between control elements.
  double? controlSpacing;
/// Whether to enable the eye dropper tool.
  bool? enableEyeDropper;
/// Callback invoked when the eye dropper tool is requested.
  VoidCallback? onEyeDropperRequested;
/// Whether the color history panel is shown.
  bool showHistory;
/// Callback invoked when the color history panel visibility changes.
  ValueChanged<bool>? onShowHistoryChanged;
/// Whether to show the color history button.
  bool showHistoryButton;
/// Creates color controls.
  const ColorControls({super.key, required this.value, this.onChanged, this.onChanging, this.onModeChanged, this.showAlpha = false, this.mode = ColorPickerMode.rgb, this.enableEyeDropper, this.onEyeDropperRequested, this.controlSpacing, this.showHistory = false, this.onShowHistoryChanged, this.showHistoryButton = true});
  Widget build(BuildContext context);
/// Builds the input widgets based on the current color picker mode.
  List<Widget> buildInputs(BuildContext context);
/// Builds RGB color input widgets.
  List<Widget> buildRGBInputs(BuildContext context);
/// Builds HSL color input widgets.
  List<Widget> buildHSLInputs(BuildContext context);
/// Builds HSV color input widgets.
  List<Widget> buildHSVInputs(BuildContext context);
/// Builds HEX color input widgets.
  List<Widget> buildHEXInputs(BuildContext context);
}
/// Converts a [Color] to its hexadecimal string representation.
///
/// This function transforms a Flutter [Color] object into a hex string format
/// commonly used in CSS and design tools. The output can optionally include
/// the alpha (transparency) channel and a hash (#) prefix.
///
/// Parameters:
/// - [color]: The color to convert to hexadecimal format.
/// - [showAlpha]: Whether to include the alpha channel in the output. Defaults to `false`.
///   When `true`, the alpha value is prepended to the RGB values (ARGB format).
/// - [hashPrefix]: Whether to prefix the output with '#'. Defaults to `true`.
///
/// Returns:
/// A hexadecimal string representation of the color. Format varies based on parameters:
/// - With alpha and hash: `#AARRGGBB` (e.g., `#FF0080FF`)
/// - Without alpha, with hash: `#RRGGBB` (e.g., `#0080FF`)
/// - With alpha, no hash: `AARRGGBB`
/// - Without alpha, no hash: `RRGGBB`
///
/// Example:
/// ```dart
/// final color = Color.fromARGB(255, 0, 128, 255);
/// print(colorToHex(color)); // Output: #0080FF
/// print(colorToHex(color, true)); // Output: #FF0080FF
/// print(colorToHex(color, false, false)); // Output: 0080FF
/// ```
String colorToHex(Color color, [bool showAlpha = false, bool hashPrefix = true]);
/// An abstract base class representing a color that can be transformed between different color spaces.
///
/// [ColorDerivative] provides a unified interface for working with colors in various color spaces
/// (HSV, HSL, RGB) while maintaining transformation capabilities. This is particularly useful
/// in color picker implementations where users may want to work with different color models.
///
/// The class supports:
/// - Conversion between HSV, HSL, and RGB color spaces
/// - Individual channel manipulation (hue, saturation, value/lightness, red, green, blue, opacity)
/// - Preserving the internal color representation when transforming
///
/// Example:
/// ```dart
/// // Create from a Flutter Color
/// final derivative = ColorDerivative.fromColor(Colors.blue);
///
/// // Modify saturation
/// final desaturated = derivative.changeToHSVSaturation(0.5);
///
/// // Convert back to Color
/// final newColor = desaturated.toColor();
/// ```
abstract class ColorDerivative {
/// Creates a [ColorDerivative] from a Flutter [Color] using HSV color space internally.
  static ColorDerivative fromColor(Color color);
/// Creates a [ColorDerivative] from an [HSVColor].
  factory ColorDerivative.fromHSV(HSVColor color);
/// Creates a [ColorDerivative] from an [HSLColor].
  factory ColorDerivative.fromHSL(HSLColor color);
/// Creates a const [ColorDerivative].
  const ColorDerivative();
/// Converts this color derivative to a Flutter [Color].
  Color toColor();
/// Converts this color derivative to an [HSVColor].
  HSVColor toHSVColor();
/// Converts this color derivative to an [HSLColor].
  HSLColor toHSLColor();
/// Gets the opacity (alpha) value of this color, ranging from 0.0 to 1.0.
  double get opacity;
/// Gets the hue component in HSL color space, ranging from 0.0 to 360.0.
  double get hslHue;
/// Gets the saturation component in HSL color space, ranging from 0.0 to 1.0.
  double get hslSat;
/// Gets the lightness component in HSL color space, ranging from 0.0 to 1.0.
  double get hslVal;
/// Gets the hue component in HSV color space, ranging from 0.0 to 360.0.
  double get hsvHue;
/// Gets the saturation component in HSV color space, ranging from 0.0 to 1.0.
  double get hsvSat;
/// Gets the value (brightness) component in HSV color space, ranging from 0.0 to 1.0.
  double get hsvVal;
/// Gets the red component in RGB color space, ranging from 0 to 255.
  int get red;
/// Gets the green component in RGB color space, ranging from 0 to 255.
  int get green;
/// Gets the blue component in RGB color space, ranging from 0 to 255.
  int get blue;
/// Transforms this color derivative to match the internal representation of [old].
///
/// This method preserves the color space representation (HSV or HSL) used by [old]
/// while applying the color values from this derivative. This is useful when
/// maintaining consistency in color space during transformations.
  ColorDerivative transform(ColorDerivative old);
/// Changes the opacity (alpha) value of this color.
///
/// Parameters:
/// - [alpha]: The new opacity value, ranging from 0.0 (fully transparent) to 1.0 (fully opaque).
///
/// Returns: A new [ColorDerivative] with the updated opacity.
  ColorDerivative changeToOpacity(double alpha);
/// Changes this color to the specified [color] while preserving the internal color space representation.
///
/// Parameters:
/// - [color]: The target color to change to.
///
/// Returns: A new [ColorDerivative] with the new color value.
  ColorDerivative changeToColor(Color color);
/// Changes this color to the specified [color] in HSV color space.
///
/// Parameters:
/// - [color]: The target HSV color to change to.
///
/// Returns: A new [ColorDerivative] with the new HSV color value.
  ColorDerivative changeToHSV(HSVColor color);
/// Changes this color to the specified [color] in HSL color space.
///
/// Parameters:
/// - [color]: The target HSL color to change to.
///
/// Returns: A new [ColorDerivative] with the new HSL color value.
  ColorDerivative changeToHSL(HSLColor color);
/// Changes the red component of this color in RGB color space.
///
/// Parameters:
/// - [red]: The new red value, ranging from 0.0 to 255.0.
///
/// Returns: A new [ColorDerivative] with the updated red component.
  ColorDerivative changeToColorRed(double red);
/// Changes the green component of this color in RGB color space.
///
/// Parameters:
/// - [green]: The new green value, ranging from 0.0 to 255.0.
///
/// Returns: A new [ColorDerivative] with the updated green component.
  ColorDerivative changeToColorGreen(double green);
/// Changes the blue component of this color in RGB color space.
///
/// Parameters:
/// - [blue]: The new blue value, ranging from 0.0 to 255.0.
///
/// Returns: A new [ColorDerivative] with the updated blue component.
  ColorDerivative changeToColorBlue(double blue);
/// Changes the hue component of this color in HSV color space.
///
/// Parameters:
/// - [hue]: The new hue value, ranging from 0.0 to 360.0 degrees.
///
/// Returns: A new [ColorDerivative] with the updated HSV hue.
  ColorDerivative changeToHSVHue(double hue);
/// Changes the saturation component of this color in HSV color space.
///
/// Parameters:
/// - [saturation]: The new saturation value, ranging from 0.0 to 1.0.
///
/// Returns: A new [ColorDerivative] with the updated HSV saturation.
  ColorDerivative changeToHSVSaturation(double saturation);
/// Changes the value (brightness) component of this color in HSV color space.
///
/// Parameters:
/// - [value]: The new value component, ranging from 0.0 to 1.0.
///
/// Returns: A new [ColorDerivative] with the updated HSV value.
  ColorDerivative changeToHSVValue(double value);
/// Changes the alpha (opacity) component of this color in HSV color space.
///
/// Parameters:
/// - [alpha]: The new alpha value, ranging from 0.0 (fully transparent) to 1.0 (fully opaque).
///
/// Returns: A new [ColorDerivative] with the updated HSV alpha.
  ColorDerivative changeToHSVAlpha(double alpha);
/// Changes the hue component of this color in HSL color space.
///
/// Parameters:
/// - [hue]: The new hue value, ranging from 0.0 to 360.0 degrees.
///
/// Returns: A new [ColorDerivative] with the updated HSL hue.
  ColorDerivative changeToHSLHue(double hue);
/// Changes the saturation component of this color in HSL color space.
///
/// Parameters:
/// - [saturation]: The new saturation value, ranging from 0.0 to 1.0.
///
/// Returns: A new [ColorDerivative] with the updated HSL saturation.
  ColorDerivative changeToHSLSaturation(double saturation);
/// Changes the lightness component of this color in HSL color space.
///
/// Parameters:
/// - [lightness]: The new lightness value, ranging from 0.0 to 1.0.
///
/// Returns: A new [ColorDerivative] with the updated HSL lightness.
  ColorDerivative changeToHSLLightness(double lightness);
}
/// An abstract base class representing a color gradient with multiple color stops.
///
/// [ColorGradient] provides a common interface for working with gradients that can
/// have colors added, modified, or removed at specific positions. This is useful
/// for creating custom gradient pickers and editors.
///
/// Implementations should handle the gradient type (linear, radial, sweep, etc.)
/// and provide methods to manipulate color stops and their positions.
abstract class ColorGradient {
/// Creates a const [ColorGradient].
  const ColorGradient();
/// Creates a copy of this gradient with optional modifications.
///
/// Returns: A new [ColorGradient] instance.
  ColorGradient copyWith();
/// Changes the color at the specified [index].
///
/// Parameters:
/// - [index]: The zero-based index of the color stop to modify.
/// - [color]: The new color for the stop.
///
/// Returns: A new [ColorGradient] with the updated color.
  ColorGradient changeColorAt(int index, ColorDerivative color);
/// Changes the position of the color stop at the specified [index].
///
/// Parameters:
/// - [index]: The zero-based index of the color stop to modify.
/// - [position]: The new position for the stop, typically ranging from 0.0 to 1.0.
///
/// Returns: A new [ColorGradient] with the updated position.
  ColorGradient changePositionAt(int index, double position);
/// Changes both the color and position at the specified [index].
///
/// Parameters:
/// - [index]: The zero-based index of the color stop to modify.
/// - [color]: The new color for the stop.
/// - [position]: The new position for the stop, typically ranging from 0.0 to 1.0.
///
/// Returns: A new [ColorGradient] with both values updated.
  ColorGradient changeColorAndPositionAt(int index, ColorDerivative color, double position);
/// Inserts a new color stop at a specific position in the gradient.
///
/// Parameters:
/// - [color]: The color to insert.
/// - [position]: The offset position where the color should be inserted.
/// - [size]: The size of the gradient area.
/// - [textDirection]: The text direction for resolving directional alignments.
///
/// Returns: A record containing the updated gradient and the index where the color was inserted.
  ({ColorGradient gradient, int index}) insertColorAt(ColorDerivative color, Offset position, Size size, TextDirection textDirection);
/// Converts this color gradient to a Flutter [Gradient].
///
/// Returns: A [Gradient] object that can be used in Flutter painting operations.
  Gradient toGradient();
}
/// Represents a color stop in a gradient with a specific color and position.
///
/// A color stop defines where a particular color appears along a gradient.
/// The position is typically a value between 0.0 (start) and 1.0 (end).
///
/// Example:
/// ```dart
/// const stop = ColorStop(
///   color: ColorDerivative.fromColor(Colors.blue),
///   position: 0.5, // Middle of the gradient
/// );
/// ```
class ColorStop {
/// The color at this stop.
  ColorDerivative color;
/// The position of this stop along the gradient, typically from 0.0 to 1.0.
  double position;
/// Creates a [ColorStop] with the specified [color] and [position].
  const ColorStop({required this.color, required this.position});
}
/// An abstract base class for representing gradient angles with alignment geometry.
///
/// [GradientAngleGeometry] provides an interface for converting between angular
/// representation and alignment-based gradients. It supports both directional
/// (text-direction-aware) and non-directional gradient angles.
///
/// Subclasses should implement how to calculate begin and end alignments based
/// on the angle value.
abstract class GradientAngleGeometry {
/// Creates a const [GradientAngleGeometry].
  const GradientAngleGeometry();
/// The angle of the gradient in radians.
  double get angle;
/// The beginning alignment of the gradient.
  AlignmentGeometry get begin;
/// The ending alignment of the gradient.
  AlignmentGeometry get end;
/// Converts this to a directional gradient angle.
///
/// Returns: A [DirectionalGradientAngle] based on this angle.
  DirectionalGradientAngle toDirectional();
/// Converts this to a non-directional gradient angle.
///
/// Returns: A [GradientAngle] based on this angle.
  GradientAngle toNonDirectional();
}
/// A directional gradient angle that is aware of text direction.
///
/// [DirectionalGradientAngle] uses [AlignmentDirectional] for its alignments,
/// making it responsive to the text direction (LTR or RTL). The angle is specified
/// in radians and determines the direction of the gradient.
///
/// Example:
/// ```dart
/// const angle = DirectionalGradientAngle(0.0); // 0 radians (horizontal)
/// final begin = angle.begin; // Start alignment
/// final end = angle.end;     // End alignment
/// ```
class DirectionalGradientAngle extends GradientAngleGeometry {
/// The angle of the gradient in radians.
  double angle;
/// Creates a [DirectionalGradientAngle] with the specified [angle] in radians.
  const DirectionalGradientAngle(this.angle);
/// The beginning alignment calculated from the angle.
  AlignmentGeometry get begin;
/// The ending alignment calculated from the angle.
  AlignmentGeometry get end;
}
/// A non-directional gradient angle that uses standard [Alignment].
///
/// Unlike [DirectionalGradientAngle], this class uses non-directional [Alignment]
/// and is not affected by text direction. The angle is specified in radians.
///
/// Example:
/// ```dart
/// const angle = GradientAngle(pi / 4); // 45 degrees
/// final begin = angle.begin;
/// final end = angle.end;
/// ```
class GradientAngle extends GradientAngleGeometry {
/// The angle of the gradient in radians.
  double angle;
/// Creates a [GradientAngle] with the specified [angle] in radians.
  const GradientAngle(this.angle);
/// The beginning alignment calculated from the angle.
  AlignmentGeometry get begin;
/// The ending alignment calculated from the angle.
  AlignmentGeometry get end;
}
/// A linear gradient implementation of [ColorGradient].
///
/// [LinearColorGradient] represents a gradient that transitions linearly between
/// colors along a specified angle. It supports multiple color stops and different
/// tile modes for how the gradient repeats beyond its bounds.
///
/// Example:
/// ```dart
/// final gradient = LinearColorGradient(
///   colors: [
///     ColorStop(color: ColorDerivative.fromColor(Colors.red), position: 0.0),
///     ColorStop(color: ColorDerivative.fromColor(Colors.blue), position: 1.0),
///   ],
///   angle: const GradientAngle(0.0),
/// );
/// ```
class LinearColorGradient extends ColorGradient {
/// The list of color stops in the gradient.
  List<ColorStop> colors;
/// The angle of the gradient.
  GradientAngleGeometry angle;
/// How the gradient repeats beyond its bounds.
  TileMode tileMode;
/// Creates a [LinearColorGradient] with the specified parameters.
  const LinearColorGradient({required this.colors, this.angle = const DirectionalGradientAngle(0), this.tileMode = TileMode.clamp});
  LinearColorGradient copyWith({List<ColorStop>? colors, GradientAngleGeometry? angle, TileMode? tileMode});
  LinearColorGradient changeColorAt(int index, ColorDerivative color);
  LinearColorGradient changePositionAt(int index, double position);
  LinearColorGradient changeColorAndPositionAt(int index, ColorDerivative color, double position);
  ({LinearColorGradient gradient, int index}) insertColorAt(ColorDerivative color, Offset position, Size size, TextDirection textDirection);
  LinearGradient toGradient();
}
/// A radial gradient for color values.
///
/// Creates a circular gradient radiating from a center point.
class RadialColorGradient extends ColorGradient {
/// The color stops defining the gradient.
  List<ColorStop> colors;
/// How the gradient tiles beyond its bounds.
  TileMode tileMode;
/// The center point of the gradient.
  AlignmentGeometry center;
/// The focal point of the gradient (for elliptical gradients).
  AlignmentGeometry? focal;
/// The radius of the gradient (0.0 to 1.0).
  double radius;
/// The focal radius for elliptical gradients.
  double focalRadius;
/// Creates a radial color gradient.
  const RadialColorGradient({required this.colors, this.tileMode = TileMode.clamp, this.center = Alignment.center, this.focal, this.radius = 0.5, this.focalRadius = 0.0});
  RadialColorGradient copyWith({List<ColorStop>? colors, TileMode? tileMode, AlignmentGeometry? center, AlignmentGeometry? focal, double? radius, double? focalRadius});
  RadialColorGradient changeColorAt(int index, ColorDerivative color);
  RadialColorGradient changePositionAt(int index, double position);
  RadialColorGradient changeColorAndPositionAt(int index, ColorDerivative color, double position);
  ({RadialColorGradient gradient, int index}) insertColorAt(ColorDerivative color, Offset position, Size size, TextDirection textDirection);
  RadialGradient toGradient();
}
/// A sweep (angular/conical) gradient for color values.
///
/// Creates a gradient that sweeps around a center point.
class SweepColorGradient extends ColorGradient {
/// The color stops defining the gradient.
  List<ColorStop> colors;
/// How the gradient tiles beyond its bounds.
  TileMode tileMode;
/// The center point of the gradient.
  AlignmentGeometry center;
/// The starting angle in radians.
  double startAngle;
/// The ending angle in radians.
  double endAngle;
/// Creates a sweep color gradient.
  const SweepColorGradient({required this.colors, this.tileMode = TileMode.clamp, this.center = Alignment.center, this.startAngle = 0.0, this.endAngle = pi * 2});
  SweepColorGradient copyWith({List<ColorStop>? colors, TileMode? tileMode, AlignmentGeometry? center, double? startAngle, double? endAngle});
  SweepColorGradient changeColorAt(int index, ColorDerivative color);
  SweepColorGradient changePositionAt(int index, double position);
  SweepColorGradient changeColorAndPositionAt(int index, ColorDerivative color, double position);
  ({SweepColorGradient gradient, int index}) insertColorAt(ColorDerivative color, Offset position, Size size, TextDirection textDirection);
  SweepGradient toGradient();
}
/// Constrains the text selection to fit within the new text length.
///
/// Helper function that ensures selection offsets don't exceed the bounds
/// of the updated text.
TextSelection contraintToNewText(TextEditingValue newValue, String newText);
/// Provides factory methods for common text input formatters.
///
/// [TextInputFormatters] is a utility class that creates various pre-configured
/// [TextInputFormatter] instances for common formatting needs like uppercase/lowercase
/// conversion, numeric input, time formatting, and more.
///
/// Example:
/// ```dart
/// TextField(
///   inputFormatters: [
///     TextInputFormatters.toUpperCase,
///     TextInputFormatters.integerOnly(min: 0, max: 100),
///   ],
/// )
/// ```
class TextInputFormatters {
/// Converts all input text to uppercase.
  static const TextInputFormatter toUpperCase = _ToUpperCaseTextFormatter();
/// Converts all input text to lowercase.
  static const TextInputFormatter toLowerCase = _ToLowerCaseTextFormatter();
/// Creates a formatter for time input with leading zeros.
///
/// Parameters:
/// - [length]: The fixed length of the time string.
  static TextInputFormatter time({required int length});
/// Creates a formatter that only allows integer input with optional min/max bounds.
///
/// Parameters:
/// - [min]: Optional minimum value.
/// - [max]: Optional maximum value.
  static TextInputFormatter integerOnly({int? min, int? max});
/// Creates a formatter that only allows decimal numeric input.
///
/// Parameters:
/// - [min]: Optional minimum value.
/// - [max]: Optional maximum value.
/// - [decimalDigits]: Optional fixed number of decimal places.
  static TextInputFormatter digitsOnly({double? min, double? max, int? decimalDigits});
/// Creates a formatter that evaluates mathematical expressions.
///
/// Parameters:
/// - [context]: Optional context variables for expression evaluation.
  static TextInputFormatter mathExpression({Map<String, dynamic>? context});
/// Creates a formatter for hexadecimal input.
///
/// Parameters:
/// - [hashPrefix]: Whether to require/add a '#' prefix.
  static TextInputFormatter hex({bool hashPrefix = false});
}
/// Standard duration for switch state transitions and animations.
const kSwitchDuration = Duration(milliseconds: 100);
/// Theme configuration for [Switch] widget styling and visual appearance.
///
/// Defines the visual properties used by switch components including colors,
/// spacing, and border styling for different switch states. All properties are
/// optional and fall back to framework defaults when not specified.
///
/// Supports comprehensive customization of switch appearance including track
/// colors, thumb colors, and layout properties to match application design.
class SwitchTheme extends ComponentThemeData {
/// Color of the switch track when in the active/on state.
///
/// Applied as the background color of the switch track when toggled on.
/// When null, uses the theme's primary color for visual consistency.
  Color? activeColor;
/// Color of the switch track when in the inactive/off state.
///
/// Applied as the background color of the switch track when toggled off.
/// When null, uses the theme's muted color for visual hierarchy.
  Color? inactiveColor;
/// Color of the switch thumb when in the active/on state.
///
/// Applied to the circular thumb element when the switch is toggled on.
/// When null, uses the theme's primary foreground color for contrast.
  Color? activeThumbColor;
/// Color of the switch thumb when in the inactive/off state.
///
/// Applied to the circular thumb element when the switch is toggled off.
/// When null, uses a contrasting color against the inactive track.
  Color? inactiveThumbColor;
/// Spacing between the switch and its leading/trailing widgets.
///
/// Applied on both sides of the switch when leading or trailing widgets
/// are provided. When null, defaults to framework spacing standards.
  double? gap;
/// Border radius applied to the switch track corners.
///
/// Creates rounded corners on the switch track container. When null,
/// uses a fully rounded appearance typical of toggle switches.
  BorderRadiusGeometry? borderRadius;
/// Creates a [SwitchTheme].
///
/// All parameters are optional and will use framework defaults when null.
/// The theme can be applied to individual switches or globally through
/// the component theme system.
  const SwitchTheme({this.activeColor, this.inactiveColor, this.activeThumbColor, this.inactiveThumbColor, this.gap, this.borderRadius});
/// Returns a copy of this theme with the given fields replaced.
  SwitchTheme copyWith({ValueGetter<Color?>? activeColor, ValueGetter<Color?>? inactiveColor, ValueGetter<Color?>? activeThumbColor, ValueGetter<Color?>? inactiveThumbColor, ValueGetter<double?>? gap, ValueGetter<BorderRadiusGeometry?>? borderRadius});
  bool operator ==(Object other);
  int get hashCode;
}
/// Controller for managing switch state.
///
/// Extends [ValueNotifier] with [bool] values to provide state management
/// for switch widgets. Includes a convenience [toggle] method for flipping
/// the switch state.
///
/// Example:
/// ```dart
/// final controller = SwitchController(true);
/// controller.toggle(); // Now false
/// ```
class SwitchController extends ValueNotifier<bool> with ComponentController<bool> {
/// Creates a [SwitchController].
///
/// Parameters:
/// - [value] (`bool`, default: `false`): Initial switch state.
  SwitchController([super.value = false]);
/// Toggles the switch state between `true` and `false`.
  void toggle();
}
/// A controlled switch widget with automatic state management.
///
/// Manages its state either through an external [controller] or internal
/// state with [initialValue]. Provides a toggle interface for boolean values
/// with customizable appearance including colors, icons, and layout options.
///
/// Example:
/// ```dart
/// ControlledSwitch(
///   initialValue: true,
///   onChanged: (value) => print('Switched to: $value'),
///   leading: Icon(Icons.wifi),
///   activeColor: Colors.green,
/// )
/// ```
class ControlledSwitch extends StatelessWidget with ControlledComponent<bool> {
  bool initialValue;
  ValueChanged<bool>? onChanged;
  bool enabled;
  SwitchController? controller;
/// Optional leading widget displayed before the switch.
///
/// Typically an icon or text label.
  Widget? leading;
/// Optional trailing widget displayed after the switch.
///
/// Typically an icon or text label.
  Widget? trailing;
/// Spacing between the switch and [leading]/[trailing] widgets.
///
/// If `null`, uses the default gap from the theme.
  double? gap;
/// Color of the switch when in the active (on) state.
///
/// If `null`, uses the theme's primary color.
  Color? activeColor;
/// Color of the switch when in the inactive (off) state.
///
/// If `null`, uses a default inactive color from the theme.
  Color? inactiveColor;
/// Color of the thumb (knob) when the switch is active.
///
/// If `null`, uses a default thumb color.
  Color? activeThumbColor;
/// Color of the thumb (knob) when the switch is inactive.
///
/// If `null`, uses a default thumb color.
  Color? inactiveThumbColor;
/// Border radius for the switch track.
///
/// If `null`, uses the default border radius from the theme.
  BorderRadiusGeometry? borderRadius;
/// Creates a [ControlledSwitch].
  const ControlledSwitch({super.key, this.controller, this.initialValue = false, this.onChanged, this.enabled = true, this.leading, this.trailing, this.gap, this.activeColor, this.inactiveColor, this.activeThumbColor, this.inactiveThumbColor, this.borderRadius});
  Widget build(BuildContext context);
}
/// A Material Design switch for toggling boolean values.
///
/// Provides a sliding toggle control for selecting between two states (on/off).
/// Supports customization of colors, leading/trailing widgets, and appearance
/// options. Unlike [ControlledSwitch], this widget requires explicit state
/// management.
///
/// Example:
/// ```dart
/// Switch(
///   value: isEnabled,
///   onChanged: (value) => setState(() => isEnabled = value),
///   activeColor: Colors.blue,
///   leading: Text('Enable feature'),
/// )
/// ```
class Switch extends StatefulWidget {
/// The current state of the switch.
  bool value;
/// Callback invoked when the switch state changes.
///
/// If `null`, the switch is disabled.
  ValueChanged<bool>? onChanged;
/// Optional leading widget displayed before the switch.
///
/// Typically an icon or text label.
  Widget? leading;
/// Optional trailing widget displayed after the switch.
///
/// Typically an icon or text label.
  Widget? trailing;
/// Whether the switch is interactive.
///
/// When `false`, the switch is disabled. Defaults to `true`.
  bool? enabled;
/// Spacing between the switch and [leading]/[trailing] widgets.
///
/// If `null`, uses the default gap from the theme.
  double? gap;
/// Color of the switch when in the active (on) state.
///
/// If `null`, uses the theme's primary color.
  Color? activeColor;
/// Color of the switch when in the inactive (off) state.
///
/// If `null`, uses a default inactive color from the theme.
  Color? inactiveColor;
/// Color of the thumb (knob) when the switch is active.
///
/// If `null`, uses a default thumb color.
  Color? activeThumbColor;
/// Color of the thumb (knob) when the switch is inactive.
///
/// If `null`, uses a default thumb color.
  Color? inactiveThumbColor;
/// Border radius for the switch track.
///
/// If `null`, uses the default border radius from the theme.
  BorderRadiusGeometry? borderRadius;
/// Creates a [Switch].
  const Switch({super.key, required this.value, required this.onChanged, this.leading, this.trailing, this.enabled = true, this.gap, this.activeColor, this.inactiveColor, this.activeThumbColor, this.inactiveThumbColor, this.borderRadius});
  State<Switch> createState();
}
/// Theme configuration for [AutoComplete] widget styling and behavior.
///
/// Defines the visual appearance and positioning of the autocomplete popover
/// that displays suggestions. All properties are optional and will fall back
/// to sensible defaults when not specified.
///
/// This theme can be applied globally through [ComponentTheme] or passed
/// directly to individual [AutoComplete] widgets for per-instance customization.
class AutoCompleteTheme extends ComponentThemeData {
/// Constraints applied to the autocomplete popover container.
///
/// Controls the maximum/minimum dimensions of the suggestion list popover.
/// Defaults to a maximum height of 300 logical pixels when null.
  BoxConstraints? popoverConstraints;
/// Width constraint strategy for the autocomplete popover.
///
/// Determines how the popover width relates to its anchor (the text field).
/// Options include matching anchor width, flexible sizing, or fixed dimensions.
  PopoverConstraint? popoverWidthConstraint;
/// Alignment point on the anchor widget where the popover attaches.
///
/// Specifies which edge/corner of the text field the popover should align to.
/// Defaults to bottom-start (bottom-left in LTR, bottom-right in RTL).
  AlignmentDirectional? popoverAnchorAlignment;
/// Alignment point on the popover that aligns with the anchor point.
///
/// Specifies which edge/corner of the popover aligns with the anchor alignment.
/// Defaults to top-start (top-left in LTR, top-right in RTL).
  AlignmentDirectional? popoverAlignment;
/// Default mode for how suggestions are applied to text fields.
///
/// Controls the text replacement strategy when a suggestion is selected.
/// Defaults to [AutoCompleteMode.replaceWord] when null.
  AutoCompleteMode? mode;
/// Creates an [AutoCompleteTheme].
///
/// All parameters are optional and will use framework defaults when null.
  const AutoCompleteTheme({this.popoverConstraints, this.popoverWidthConstraint, this.popoverAnchorAlignment, this.popoverAlignment, this.mode});
/// Creates a copy of this theme with specified properties overridden.
///
/// Each parameter function is called only if provided, allowing selective
/// overrides while preserving existing values for unspecified properties.
  AutoCompleteTheme copyWith({ValueGetter<BoxConstraints?>? popoverConstraints, ValueGetter<PopoverConstraint?>? popoverWidthConstraint, ValueGetter<AlignmentDirectional?>? popoverAnchorAlignment, ValueGetter<AlignmentDirectional?>? popoverAlignment, ValueGetter<AutoCompleteMode?>? mode});
  bool operator ==(Object other);
  int get hashCode;
}
/// Intelligent autocomplete functionality with customizable suggestion handling.
///
/// Provides real-time autocomplete suggestions in a popover overlay when used
/// with text input widgets. Supports multiple text replacement modes, keyboard
/// navigation, and theming customization. The widget wraps a child (typically
/// a text field) and displays filtered suggestions based on user input.
///
/// ## Features
///
/// - **Multiple completion modes**: append, replace word, or replace all text
/// - **Keyboard navigation**: arrow keys to navigate, tab/enter to accept
/// - **Customizable presentation**: popover positioning, sizing, and constraints
/// - **Smart suggestion filtering**: automatically manages suggestion visibility
/// - **Accessibility support**: proper focus management and keyboard shortcuts
///
/// The autocomplete behavior is controlled by the [mode] property and can be
/// customized per-instance or globally through [AutoCompleteTheme].
///
/// Example:
/// ```dart
/// AutoComplete(
///   suggestions: ['apple', 'apricot', 'banana', 'cherry'],
///   mode: AutoCompleteMode.replaceWord,
///   child: TextField(
///     decoration: InputDecoration(
///       hintText: 'Type to search fruits...',
///     ),
///   ),
/// )
/// ```
class AutoComplete extends StatefulWidget {
/// List of suggestions to display in the autocomplete popover.
///
/// When non-empty, triggers the popover to appear with selectable options.
/// The suggestions are filtered and managed externally - this widget only
/// handles the presentation and selection logic.
  List<String> suggestions;
/// The child widget that receives autocomplete functionality.
///
/// Typically a [TextField] or similar text input widget. The autocomplete
/// popover will be positioned relative to this widget, and keyboard actions
/// will be applied to the focused text field within this child tree.
  Widget child;
/// Constraints applied to the autocomplete popover container.
///
/// Overrides the theme default. Controls maximum/minimum dimensions of the
/// suggestion list. When null, uses theme value or framework default.
  BoxConstraints? popoverConstraints;
/// Width constraint strategy for the autocomplete popover.
///
/// Overrides the theme default. Determines how popover width relates to
/// the anchor widget. When null, uses theme value or matches anchor width.
  PopoverConstraint? popoverWidthConstraint;
/// Alignment point on the anchor widget for popover attachment.
///
/// Overrides the theme default. Specifies which edge/corner of the child
/// widget the popover aligns to. When null, uses theme or bottom-start.
  AlignmentDirectional? popoverAnchorAlignment;
/// Alignment point on the popover for anchor attachment.
///
/// Overrides the theme default. Specifies which edge/corner of the popover
/// aligns with the anchor point. When null, uses theme or top-start.
  AlignmentDirectional? popoverAlignment;
/// Text replacement strategy when a suggestion is selected.
///
/// Overrides the theme default. Controls how selected suggestions modify
/// the text field content. When null, uses theme or [AutoCompleteMode.replaceWord].
  AutoCompleteMode? mode;
/// Function to customize suggestion text before application.
///
/// Called when a suggestion is selected, allowing modification of the final
/// text inserted into the field. Useful for adding prefixes, suffixes, or
/// formatting. Defaults to returning the suggestion unchanged.
  AutoCompleteCompleter completer;
/// Creates an [AutoComplete] widget.
///
/// Wraps the provided [child] with autocomplete functionality using the
/// given [suggestions] list. The popover appearance and behavior can be
/// customized through the optional positioning and constraint parameters.
///
/// Parameters:
/// - [suggestions] (`List<String>`, required): available autocomplete options
/// - [child] (Widget, required): widget to receive autocomplete functionality
/// - [popoverConstraints] (BoxConstraints?, optional): popover size limits
/// - [popoverWidthConstraint] (PopoverConstraint?, optional): width strategy
/// - [popoverAnchorAlignment] (AlignmentDirectional?, optional): anchor point
/// - [popoverAlignment] (AlignmentDirectional?, optional): popover align point
/// - [mode] (AutoCompleteMode?, optional): text replacement strategy
/// - [completer] (AutoCompleteCompleter, default: identity): suggestion processor
///
/// Example:
/// ```dart
/// AutoComplete(
///   suggestions: suggestions,
///   mode: AutoCompleteMode.append,
///   completer: (text) => '$text ',
///   child: TextField(),
/// )
/// ```
  const AutoComplete({super.key, required this.suggestions, required this.child, this.popoverConstraints, this.popoverWidthConstraint, this.popoverAnchorAlignment, this.popoverAlignment, this.mode, this.completer = _defaultCompleter});
  State<AutoComplete> createState();
}
/// An intent representing an autocomplete suggestion selection.
///
/// Used by the autocomplete system to handle suggestion selections
/// with different modes of completion.
class AutoCompleteIntent extends Intent {
/// The suggestion text to be completed.
  String suggestion;
/// The mode determining how the completion should be applied.
  AutoCompleteMode mode;
/// Creates an autocomplete intent with the specified suggestion and mode.
  const AutoCompleteIntent(this.suggestion, this.mode);
}
/// Text replacement strategies for autocomplete suggestion application.
///
/// Defines how selected autocomplete suggestions modify the existing text
/// field content. Each mode provides different behavior for integrating
/// suggestions with current text.
enum AutoCompleteMode { append, replaceWord, replaceAll }
/// Intent for navigating through autocomplete suggestions via keyboard.
///
/// Used internally by [AutoComplete] to handle arrow key navigation within
/// the suggestion list. The [direction] indicates movement direction where
/// positive values move down and negative values move up.
class NavigateSuggestionIntent extends Intent {
/// Direction of navigation through suggestions.
///
/// Positive values move down in the list, negative values move up.
/// The magnitude is typically 1 for single-step navigation.
  int direction;
/// Creates a navigation intent with the specified [direction].
  const NavigateSuggestionIntent(this.direction);
}
/// Intent for accepting the currently selected autocomplete suggestion.
///
/// Used internally by [AutoComplete] to handle suggestion acceptance via
/// keyboard shortcuts (typically Tab or Enter). Triggers the completion
/// logic to apply the selected suggestion to the text field.
class AcceptSuggestionIntent extends Intent {
/// Creates an accept suggestion intent.
  const AcceptSuggestionIntent();
}
/// Defines how a form field editor is presented to the user.
///
/// [PromptMode] determines whether the field editor appears in a modal
/// dialog or a popover overlay.
enum PromptMode { dialog, popover }
/// A form field widget for complex object values.
///
/// [ObjectFormField] provides a button-like trigger that opens an editor
/// (in a dialog or popover) for selecting/editing complex values. The field
/// displays the selected value using a custom builder.
///
/// Useful for date pickers, color pickers, file selectors, and other
/// complex input scenarios where a simple text field isn't sufficient.
///
/// Example:
/// ```dart
/// ObjectFormField<DateTime>(
///   value: selectedDate,
///   placeholder: Text('Select date'),
///   builder: (context, date) => Text(formatDate(date)),
///   editorBuilder: (context, handler) => CalendarWidget(),
///   mode: PromptMode.dialog,
/// )
/// ```
class ObjectFormField<T> extends StatefulWidget {
/// The current value of the field.
  T? value;
/// Called when the value changes.
  ValueChanged<T?>? onChanged;
/// Widget displayed when no value is selected.
  Widget placeholder;
/// Builds the display for the selected value.
  Widget Function(BuildContext context, T value) builder;
/// Optional leading widget (e.g., icon).
  Widget? leading;
/// Optional trailing widget (e.g., dropdown arrow).
  Widget? trailing;
/// How the editor is presented (dialog or popover).
  PromptMode mode;
/// Builds the editor widget.
  Widget Function(BuildContext context, ObjectFormHandler<T> handler) editorBuilder;
/// Popover alignment relative to the trigger.
  AlignmentGeometry? popoverAlignment;
/// Anchor alignment for popover positioning.
  AlignmentGeometry? popoverAnchorAlignment;
/// Padding inside the popover.
  EdgeInsetsGeometry? popoverPadding;
/// Title for the dialog mode.
  Widget? dialogTitle;
/// Button size for the trigger.
  ButtonSize? size;
/// Button density for the trigger.
  ButtonDensity? density;
/// Button shape for the trigger.
  ButtonShape? shape;
/// Custom dialog action buttons.
  List<Widget> Function(BuildContext context, ObjectFormHandler<T> handler)? dialogActions;
/// Whether the field is enabled.
  bool? enabled;
/// Whether to show the field decoration.
  bool decorate;
/// Whether to inform value change callback immediately upon user interaction with the editor.
/// If null, defaults to true for popover mode and false for dialog mode.
  bool? immediateValueChange;
/// Creates an [ObjectFormField].
  const ObjectFormField({super.key, required this.value, this.onChanged, required this.placeholder, required this.builder, this.leading, this.trailing, this.mode = PromptMode.dialog, required this.editorBuilder, this.popoverAlignment, this.popoverAnchorAlignment, this.popoverPadding, this.dialogTitle, this.size, this.density, this.shape, this.dialogActions, this.enabled, this.decorate = true, this.immediateValueChange});
  State<ObjectFormField<T>> createState();
}
/// Abstract interface for controlling an object form field's state.
///
/// [ObjectFormHandler] provides methods to interact with an object form field,
/// including getting/setting values and controlling the editor visibility.
abstract class ObjectFormHandler<T> {
/// Gets the current value.
  T? get value;
/// Sets the current value.
  set value(T? value);
/// Opens the editor with an optional initial value.
  void prompt([T? value]);
/// Closes the editor.
  Future<void> close();
/// Finds the [ObjectFormHandler] in the widget tree.
  static ObjectFormHandler<T> of<T>(BuildContext context);
/// Finds the [ObjectFormHandler] in the widget tree (alternative method).
  static ObjectFormHandler<T> find<T>(BuildContext context);
}
/// State class for [ObjectFormField] managing form value and user interactions.
///
/// Handles value updates, popover/dialog display, and integrates with the
/// form validation system. This state also determines whether the field is
/// enabled based on the presence of an `onChanged` callback.
class ObjectFormFieldState<T> extends State<ObjectFormField<T>> with FormValueSupplier<T, ObjectFormField<T>> {
  void initState();
/// Gets the current form value.
///
/// Returns: The current value of type `T?`.
  T? get value;
/// Sets a new form value and notifies listeners.
///
/// Parameters:
/// - [value] (`T?`, required): The new value to set.
  set value(T? value);
  void didReplaceFormValue(T value);
  void didUpdateWidget(covariant ObjectFormField<T> oldWidget);
/// Whether this field is enabled.
///
/// Returns true if explicitly enabled or if an `onChanged` callback exists.
  bool get enabled;
  void dispose();
/// Prompts the user to select or edit a value via dialog or popover.
///
/// Displays the appropriate UI based on the configured [PromptMode].
///
/// Parameters:
/// - [value] (`T?`, optional): An initial value to display in the prompt.
///
/// Example:
/// ```dart
/// fieldState.prompt(initialValue);
/// ```
  void prompt([T? value]);
  Widget build(BuildContext context);
}
/// Holds the result value from an object form field dialog.
///
/// Used to pass the selected or edited value back from a dialog prompt.
///
/// Example:
/// ```dart
/// final result = ObjectFormFieldDialogResult<DateTime>(DateTime.now());
/// Navigator.of(context).pop(result);
/// ```
class ObjectFormFieldDialogResult<T> {
/// The value selected or edited by the user.
  T? value;
/// Creates an [ObjectFormFieldDialogResult].
///
/// Parameters:
/// - [value] (`T?`, required): The result value.
  ObjectFormFieldDialogResult(this.value);
}
/// Provides customizable file icons in the widget tree.
///
/// [FileIconProvider] allows applications to define custom file icons based on
/// file extensions. Icons can be provided either through a builder function or
/// a static map of extensions to widgets.
///
/// Example using builder:
/// ```dart
/// FileIconProvider.builder(
///   builder: (extension) {
///     if (extension == 'txt') return Icon(Icons.text_snippet);
///     return Icon(Icons.insert_drive_file);
///   },
///   child: MyFileList(),
/// )
/// ```
///
/// Example using icon map:
/// ```dart
/// FileIconProvider(
///   icons: {
///     'pdf': Icon(Icons.picture_as_pdf),
///     'jpg': Icon(Icons.image),
///   },
///   child: MyFileList(),
/// )
/// ```
class FileIconProvider extends StatelessWidget {
/// Builder function for creating file icons.
  FileIconBuilder? builder;
/// Map of file extensions to icon widgets.
  Map<String, Widget>? icons;
/// The child widget.
  Widget child;
/// Creates a [FileIconProvider] using a builder function.
  const FileIconProvider.builder({super.key, FileIconBuilder this.builder = _buildFileIcon, required this.child});
/// Creates a [FileIconProvider] using a static icon map.
  const FileIconProvider({super.key, required this.icons, required this.child});
  Widget build(BuildContext context);
/// Builds a file icon for the given extension using the configured provider.
///
/// Parameters:
/// - [context]: The build context to find the provider.
/// - [extension]: The file extension (without the dot).
///
/// Returns: The appropriate icon widget for the file type.
  static Widget buildIcon(BuildContext context, String extension);
}
/// Internal data class for [FileIconProvider].
///
/// Stores the configuration for file icon provision and provides
/// a method to build icons based on file extensions.
class FileIconProviderData {
/// Optional builder function for icons.
  FileIconBuilder? builder;
/// Optional map of extension to icon widgets.
  Map<String, Widget>? icons;
/// Builds an icon for the given file extension.
///
/// Uses the builder if provided, otherwise checks the icons map,
/// and falls back to the default icon builder.
  Widget buildIcon(String extension);
}
/// Theme configuration for [Checkbox] widget styling and visual appearance.
///
/// Defines the visual properties used by checkbox components including colors,
/// dimensions, spacing, and border styling. All properties are optional and
/// fall back to framework defaults when not specified.
///
/// Can be applied globally through [ComponentTheme] or used to override
/// specific checkbox instances with custom styling.
class CheckboxTheme extends ComponentThemeData {
/// Color of the checkbox background when in unchecked state.
///
/// Applied as the background color when the checkbox is unchecked.
/// When null, uses a semi-transparent version of the theme's input background color.
  Color? backgroundColor;
/// Color of the checkbox background when in checked state.
///
/// Applied as both background and border color when the checkbox is checked.
/// When null, uses the theme's primary color.
  Color? activeColor;
/// Color of the checkbox border when in unchecked state.
///
/// Only visible when the checkbox is unchecked or in indeterminate state.
/// When null, uses the theme's border color.
  Color? borderColor;
/// Size of the checkbox square in logical pixels.
///
/// Controls both width and height of the checkbox square. The checkmark
/// and indeterminate indicator are scaled proportionally. When null,
/// defaults to 16 logical pixels scaled by theme scaling factor.
  double? size;
/// Spacing between the checkbox and its leading/trailing widgets.
///
/// Applied on both sides of the checkbox square when leading or trailing
/// widgets are provided. When null, defaults to 8 logical pixels scaled
/// by theme scaling factor.
  double? gap;
/// Border radius applied to the checkbox square corners.
///
/// Creates rounded corners on the checkbox container. When null, uses
/// the theme's small border radius (typically 4 logical pixels).
  BorderRadiusGeometry? borderRadius;
/// Creates a [CheckboxTheme].
///
/// All parameters are optional and will use framework defaults when null.
/// The theme can be applied to individual checkboxes or globally through
/// the component theme system.
  const CheckboxTheme({this.backgroundColor, this.activeColor, this.borderColor, this.size, this.gap, this.borderRadius});
/// Creates a copy of this theme with specified properties overridden.
///
/// Each parameter function is called only if provided, allowing selective
/// overrides while preserving existing values for unspecified properties.
///
/// Example:
/// ```dart
/// final newTheme = theme.copyWith(
///   activeColor: () => Colors.green,
///   size: () => 20.0,
/// );
/// ```
  CheckboxTheme copyWith({ValueGetter<Color?>? backgroundColor, ValueGetter<Color?>? activeColor, ValueGetter<Color?>? borderColor, ValueGetter<double?>? size, ValueGetter<double?>? gap, ValueGetter<BorderRadiusGeometry?>? borderRadius});
  bool operator ==(Object other);
  int get hashCode;
}
/// Reactive controller for managing checkbox state with convenient methods.
///
/// Extends [ValueNotifier] to provide state management for checkbox widgets
/// with built-in methods for common state transitions. Supports all three
/// checkbox states: checked, unchecked, and indeterminate.
///
/// The controller can be used with [ControlledCheckbox] for reactive state
/// management or manually to coordinate checkbox behavior across widgets.
///
/// Example:
/// ```dart
/// final controller = CheckboxController(CheckboxState.unchecked);
///
/// // React to changes
/// controller.addListener(() {
///   print('Checkbox is now: ${controller.value}');
/// });
///
/// // Programmatic control
/// controller.toggle(); // unchecked -> checked
/// controller.indeterminate(); // -> indeterminate
/// ```
class CheckboxController extends ValueNotifier<CheckboxState> with ComponentController<CheckboxState> {
/// Creates a [CheckboxController] with the specified initial [value].
///
/// The controller will notify listeners whenever the checkbox state changes
/// through any of the provided methods or direct value assignment.
  CheckboxController(super.value);
/// Sets the checkbox state to checked.
///
/// Notifies listeners of the state change. Equivalent to setting
/// `value = CheckboxState.checked`.
  void check();
/// Sets the checkbox state to unchecked.
///
/// Notifies listeners of the state change. Equivalent to setting
/// `value = CheckboxState.unchecked`.
  void uncheck();
/// Sets the checkbox state to indeterminate.
///
/// Notifies listeners of the state change. Used for tri-state checkboxes
/// to indicate a partially selected or mixed state.
  void indeterminate();
/// Toggles between checked and unchecked states.
///
/// If currently checked, becomes unchecked. If currently unchecked or
/// indeterminate, becomes checked. Does not cycle through indeterminate state.
  void toggle();
/// Cycles through all three states in order: checked -> unchecked -> indeterminate.
///
/// Provides complete tri-state cycling behavior. Use this instead of [toggle]
/// when working with tri-state checkboxes that need to support indeterminate state.
  void toggleTristate();
/// Returns true if the checkbox is currently checked.
  bool get isChecked;
/// Returns true if the checkbox is currently unchecked.
  bool get isUnchecked;
/// Returns true if the checkbox is currently in indeterminate state.
  bool get isIndeterminate;
}
/// Reactive checkbox with automatic state management and controller support.
///
/// A higher-level checkbox widget that provides automatic state management
/// through the controlled component pattern. Can be used with an external
/// [CheckboxController] for programmatic control or with callback-based
/// state management.
///
/// Supports all checkbox features including tri-state behavior, leading/trailing
/// widgets, and comprehensive theming. The widget automatically handles focus,
/// enabled states, and form integration.
///
/// ## Usage Patterns
///
/// **Controller-based (recommended for complex state management):**
/// ```dart
/// final controller = CheckboxController(CheckboxState.unchecked);
///
/// ControlledCheckbox(
///   controller: controller,
///   tristate: true,
///   leading: Text('Accept terms'),
/// )
/// ```
///
/// **Callback-based (simple state management):**
/// ```dart
/// bool checked = false;
///
/// ControlledCheckbox(
///   initialValue: checked ? CheckboxState.checked : CheckboxState.unchecked,
///   onChanged: (state) => setState(() {
///     checked = state == CheckboxState.checked;
///   }),
///   trailing: Text('Newsletter subscription'),
/// )
/// ```
class ControlledCheckbox extends StatelessWidget with ControlledComponent<CheckboxState> {
/// External controller for programmatic state management.
///
/// When provided, takes precedence over [initialValue] and [onChanged].
/// The controller's state changes are automatically reflected in the widget.
  CheckboxController? controller;
/// Initial checkbox state when no controller is provided.
///
/// Used only when [controller] is null. Defaults to [CheckboxState.unchecked].
  CheckboxState initialValue;
/// Callback fired when the checkbox state changes.
///
/// Called with the new [CheckboxState] when user interaction occurs.
/// If both [controller] and [onChanged] are provided, both will receive updates.
  ValueChanged<CheckboxState>? onChanged;
/// Whether the checkbox is interactive.
///
/// When false, the checkbox becomes read-only and visually disabled.
/// When null, automatically determines enabled state based on [onChanged] or [controller].
  bool enabled;
/// Optional widget displayed before the checkbox square.
///
/// Commonly used for labels or icons. Automatically styled with small and
/// medium text styles for consistency.
  Widget? leading;
/// Optional widget displayed after the checkbox square.
///
/// Commonly used for labels, descriptions, or additional controls.
/// Automatically styled with small and medium text styles for consistency.
  Widget? trailing;
/// Whether the checkbox supports three states including indeterminate.
///
/// When true, clicking cycles through: checked -> unchecked -> indeterminate -> checked.
/// When false, only toggles between checked and unchecked. Defaults to false.
  bool tristate;
/// Override size of the checkbox square in logical pixels.
///
/// When null, uses the theme size or framework default (16px scaled).
  double? size;
/// Override spacing between checkbox and leading/trailing widgets.
///
/// When null, uses the theme gap or framework default (8px scaled).
  double? gap;
/// Override color of the checkbox background when in unchecked state.
///
/// When null, uses a semi-transparent version of the theme's input background color.
  Color? backgroundColor;
/// Override color of the checkbox when checked.
///
/// When null, uses the theme active color or primary color.
  Color? activeColor;
/// Override color of the checkbox border when unchecked.
///
/// When null, uses the theme border color or framework border color.
  Color? borderColor;
/// Override border radius of the checkbox square.
///
/// When null, uses the theme border radius or small radius (4px).
  BorderRadiusGeometry? borderRadius;
/// Creates a [ControlledCheckbox].
///
/// Either [controller] or [onChanged] should be provided for interactivity.
/// The widget supports both controller-based and callback-based state management
/// patterns depending on application architecture needs.
///
/// Parameters:
/// - [controller] (CheckboxController?, optional): external state controller
/// - [initialValue] (CheckboxState, default: unchecked): starting state when no controller
/// - [onChanged] (`ValueChanged<CheckboxState>?`, optional): state change callback
/// - [enabled] (bool, default: true): whether checkbox is interactive
/// - [leading] (Widget?, optional): widget displayed before checkbox
/// - [trailing] (Widget?, optional): widget displayed after checkbox
/// - [tristate] (bool, default: false): whether to support indeterminate state
/// - [size] (double?, optional): override checkbox square size
/// - [gap] (double?, optional): override spacing around checkbox
/// - [backgroundColor] (Color?, optional): override unchecked state color
/// - [activeColor] (Color?, optional): override checked state color
/// - [borderColor] (Color?, optional): override border color
/// - [borderRadius] (BorderRadiusGeometry?, optional): override corner radius
///
/// Example:
/// ```dart
/// ControlledCheckbox(
///   controller: controller,
///   tristate: true,
///   leading: Icon(Icons.star),
///   trailing: Text('Favorite'),
/// )
/// ```
  const ControlledCheckbox({super.key, this.controller, this.initialValue = CheckboxState.unchecked, this.onChanged, this.enabled = true, this.leading, this.trailing, this.tristate = false, this.size, this.gap, this.backgroundColor, this.activeColor, this.borderColor, this.borderRadius});
  Widget build(BuildContext context);
}
/// Represents the possible states of a checkbox widget.
///
/// Supports the standard checked/unchecked binary states as well as an
/// indeterminate state commonly used to represent partial selection in
/// hierarchical or grouped checkbox scenarios.
///
/// The enum implements [Comparable] to provide consistent ordering:
/// checked < unchecked < indeterminate (based on declaration order).
enum CheckboxState { checked, unchecked, indeterminate }
/// Core checkbox widget with comprehensive theming and interaction support.
///
/// A low-level checkbox implementation that provides direct state control
/// and extensive customization options. Supports all three checkbox states,
/// smooth animations, accessibility features, and form integration.
///
/// ## Features
///
/// - **Tri-state support**: checked, unchecked, and indeterminate states
/// - **Smooth animations**: animated checkmark drawing and state transitions
/// - **Comprehensive theming**: colors, sizing, spacing, and border customization
/// - **Accessibility**: proper semantics, focus management, and keyboard support
/// - **Form integration**: automatic form field registration and validation support
/// - **Layout flexibility**: leading/trailing widgets with automatic styling
///
/// For most use cases, consider [ControlledCheckbox] which provides higher-level
/// state management. Use this widget directly when you need fine-grained control
/// over the checkbox behavior and lifecycle.
///
/// Example:
/// ```dart
/// Checkbox(
///   state: CheckboxState.checked,
///   onChanged: (newState) {
///     setState(() => currentState = newState);
///   },
///   tristate: true,
///   leading: Icon(Icons.security),
///   trailing: Text('Enable security features'),
/// )
/// ```
class Checkbox extends StatefulWidget {
/// Current state of the checkbox.
///
/// Must be one of [CheckboxState.checked], [CheckboxState.unchecked], or
/// [CheckboxState.indeterminate]. The widget rebuilds when this changes
/// to reflect the new visual state with appropriate animations.
  CheckboxState state;
/// Callback fired when the user interacts with the checkbox.
///
/// Called with the new [CheckboxState] that should be applied. When null,
/// the checkbox becomes non-interactive and visually disabled.
///
/// The callback is responsible for updating the parent widget's state
/// to reflect the change - this widget does not manage its own state.
  ValueChanged<CheckboxState>? onChanged;
/// Optional widget displayed before the checkbox square.
///
/// Commonly used for icons or primary labels. The widget is automatically
/// styled with small and medium text styles for visual consistency.
/// Spacing between leading widget and checkbox is controlled by [gap].
  Widget? leading;
/// Optional widget displayed after the checkbox square.
///
/// Commonly used for labels, descriptions, or secondary information.
/// The widget is automatically styled with small and medium text styles
/// for visual consistency. Spacing is controlled by [gap].
  Widget? trailing;
/// Whether the checkbox supports indeterminate state cycling.
///
/// When true, user interaction cycles through: checked -> unchecked -> indeterminate.
/// When false, only toggles between checked and unchecked states.
/// The indeterminate state can still be set programmatically regardless of this setting.
  bool tristate;
/// Whether the checkbox is interactive and enabled.
///
/// When false, the checkbox becomes visually disabled and non-interactive.
/// When null, the enabled state is automatically determined from the presence
/// of an [onChanged] callback.
  bool? enabled;
/// Size of the checkbox square in logical pixels.
///
/// Overrides the theme default. When null, uses [CheckboxTheme.size] or
/// framework default (16 logical pixels scaled by theme scaling factor).
  double? size;
/// Spacing between the checkbox and its leading/trailing widgets.
///
/// Overrides the theme default. Applied on both sides when leading or trailing
/// widgets are present. When null, uses [CheckboxTheme.gap] or framework default.
  double? gap;
/// Color of the checkbox background when in unchecked state.
///
/// Overrides the theme default. Applied as the background color when unchecked.
/// When null, uses a semi-transparent version of the theme's input background color.
  Color? backgroundColor;
/// Color used for the checkbox when in checked state.
///
/// Overrides the theme default. Applied as both background and border color
/// when checked. When null, uses [CheckboxTheme.activeColor] or theme primary color.
  Color? activeColor;
/// Color used for the checkbox border when unchecked or indeterminate.
///
/// Overrides the theme default. Only visible in unchecked state as checked
/// state uses [activeColor]. When null, uses [CheckboxTheme.borderColor] or theme border color.
  Color? borderColor;
/// Border radius applied to the checkbox square.
///
/// Overrides the theme default. Creates rounded corners on the checkbox container.
/// When null, uses [CheckboxTheme.borderRadius] or theme small radius.
  BorderRadiusGeometry? borderRadius;
/// Creates a [Checkbox] widget.
///
/// The [state] and [onChanged] parameters work together to provide controlled
/// component behavior - the widget displays the provided state and notifies
/// of user interactions through the callback.
///
/// Parameters:
/// - [state] (CheckboxState, required): current checkbox state to display
/// - [onChanged] (`ValueChanged<CheckboxState>?`, required): interaction callback
/// - [leading] (Widget?, optional): widget displayed before checkbox
/// - [trailing] (Widget?, optional): widget displayed after checkbox
/// - [tristate] (bool, default: false): enable indeterminate state cycling
/// - [enabled] (bool?, optional): override interactivity (null = auto-detect)
/// - [size] (double?, optional): override checkbox square size
/// - [gap] (double?, optional): override spacing around checkbox
/// - [backgroundColor] (Color?, optional): override unchecked state color
/// - [activeColor] (Color?, optional): override checked state color
/// - [borderColor] (Color?, optional): override border color
/// - [borderRadius] (BorderRadiusGeometry?, optional): override corner radius
///
/// Example:
/// ```dart
/// Checkbox(
///   state: isAccepted ? CheckboxState.checked : CheckboxState.unchecked,
///   onChanged: (state) => setState(() {
///     isAccepted = state == CheckboxState.checked;
///   }),
///   trailing: Text('I accept the terms and conditions'),
/// )
/// ```
  const Checkbox({super.key, required this.state, required this.onChanged, this.leading, this.trailing, this.tristate = false, this.enabled, this.size, this.gap, this.backgroundColor, this.activeColor, this.borderColor, this.borderRadius});
  State<Checkbox> createState();
}
/// Custom painter for drawing animated checkmarks in checkboxes.
///
/// Renders a smooth checkmark animation that draws progressively from left to right
/// in two stroke segments. The animation provides visual feedback when transitioning
/// to the checked state, creating a satisfying user experience.
///
/// The checkmark is drawn as two connected line segments: a shorter diagonal line
/// from bottom-left toward center, and a longer diagonal line from center to top-right.
/// The [progress] parameter controls how much of the checkmark is visible.
///
/// Used internally by [Checkbox] - not typically instantiated directly by consumers.
class AnimatedCheckPainter extends CustomPainter {
/// Animation progress from 0.0 to 1.0 controlling checkmark visibility.
///
/// At 0.0, no checkmark is visible. At 1.0, the complete checkmark is drawn.
/// Values between 0.0 and 1.0 show partial drawing progress with smooth transitions.
  double progress;
/// Color used to draw the checkmark strokes.
///
/// Typically the primary foreground color to provide contrast against
/// the checkbox's active background color.
  Color color;
/// Width of the checkmark stroke lines in logical pixels.
///
/// Controls the thickness of the drawn checkmark. Usually scaled with
/// the theme's scaling factor for consistent appearance across screen densities.
  double strokeWidth;
/// Creates an [AnimatedCheckPainter].
///
/// All parameters are required as they directly control the checkmark appearance
/// and animation state. The painter should be recreated when any parameter changes.
///
/// Parameters:
/// - [progress] (double, required): animation progress 0.0-1.0
/// - [color] (Color, required): checkmark stroke color
/// - [strokeWidth] (double, required): stroke thickness in logical pixels
///
/// Example usage within CustomPaint:
/// ```dart
/// CustomPaint(
///   painter: AnimatedCheckPainter(
///     progress: animationValue,
///     color: theme.primaryForeground,
///     strokeWidth: 2.0,
///   ),
/// )
/// ```
  AnimatedCheckPainter({required this.progress, required this.color, required this.strokeWidth});
  void paint(Canvas canvas, Size size);
  bool shouldRepaint(covariant AnimatedCheckPainter oldDelegate);
}
/// Theme data for [MultipleChoice] and [MultipleAnswer].
class MultipleChoiceTheme extends ComponentThemeData {
/// Whether selections can be unselected.
  bool? allowUnselect;
/// Creates a [MultipleChoiceTheme].
  const MultipleChoiceTheme({this.allowUnselect});
/// Returns a copy of this theme with the given fields replaced by the
/// non-null parameters.
  MultipleChoiceTheme copyWith({ValueGetter<bool?>? allowUnselect});
  bool operator ==(Object other);
  int get hashCode;
  String toString();
}
/// A mixin that provides choice selection functionality.
///
/// [Choice] defines the interface for widgets that support item selection,
/// typically used in multiple choice or single choice scenarios. It provides
/// static methods to interact with choice widgets in the widget tree.
mixin Choice<T> {
/// Selects an item in the nearest [Choice] ancestor.
///
/// Parameters:
/// - [context]: The build context to search for Choice widget.
/// - [item]: The item to select.
  static void choose<T>(BuildContext context, T item);
/// Gets the current selected value(s) from the nearest [Choice] ancestor.
///
/// Returns: The currently selected items, or null if none selected.
  static Iterable<T>? getValue<T>(BuildContext context);
/// Selects the specified item.
  void selectItem(T item);
/// Gets the currently selected items.
  Iterable<T>? get value;
}
/// A controller for managing [ControlledMultipleAnswer] selections programmatically.
///
/// This controller extends `ValueNotifier<Iterable<T>?>` to provide reactive
/// state management for multiple selection components. It implements [ComponentController]
/// to integrate with the controlled component system, allowing external control
/// and listening to selection changes.
///
/// Example:
/// ```dart
/// final controller = MultipleAnswerController<String>(['option1', 'option2']);
/// controller.addListener(() {
///   print('Selected items: ${controller.value}');
/// });
/// ```
class MultipleAnswerController<T> extends ValueNotifier<Iterable<T>?> with ComponentController<Iterable<T>?> {
/// Creates a [MultipleAnswerController] with an optional initial selection.
///
/// Parameters:
/// - [value] (`Iterable<T>?`, optional): Initial selection of items
  MultipleAnswerController([super.value]);
}
/// A controller for managing [ControlledMultipleChoice] selection programmatically.
///
/// This controller extends `ValueNotifier<T?>` to provide reactive state
/// management for single-choice components. It implements [ComponentController]
/// to integrate with the controlled component system, allowing external control
/// and listening to selection changes.
///
/// Example:
/// ```dart
/// final controller = MultipleChoiceController<String>('option1');
/// controller.addListener(() {
///   print('Selected item: ${controller.value}');
/// });
/// ```
class MultipleChoiceController<T> extends ValueNotifier<T?> with ComponentController<T?> {
/// Creates a [MultipleChoiceController] with an optional initial selection.
///
/// Parameters:
/// - [value] (T?, optional): Initial selected item
  MultipleChoiceController([super.value]);
}
/// A controlled widget for managing multiple item selections with external state management.
///
/// This widget provides a container for multiple selection interfaces where users
/// can select multiple items from a set of choices. It integrates with the controlled
/// component system to provide external state management, form integration, and
/// programmatic control of selections.
///
/// The component maintains a collection of selected items and provides callbacks
/// for selection changes. Child widgets can use the [Choice.choose] method to
/// register item selections and [Choice.getValue] to access current selections.
///
/// Example:
/// ```dart
/// ControlledMultipleAnswer<String>(
///   initialValue: ['apple', 'banana'],
///   onChanged: (selections) {
///     print('Selected: ${selections?.join(', ')}');
///   },
///   child: Column(
///     children: [
///       ChoiceItem(value: 'apple', child: Text('Apple')),
///       ChoiceItem(value: 'banana', child: Text('Banana')),
///       ChoiceItem(value: 'orange', child: Text('Orange')),
///     ],
///   ),
/// );
/// ```
class ControlledMultipleAnswer<T> extends StatelessWidget with ControlledComponent<Iterable<T>?> {
  MultipleAnswerController<T>? controller;
  Iterable<T>? initialValue;
  ValueChanged<Iterable<T>?>? onChanged;
  bool enabled;
/// Whether selected items can be deselected by selecting them again.
///
/// When true, users can toggle selections by clicking selected items to
/// deselect them. When false, items remain selected once chosen.
  bool? allowUnselect;
/// The widget subtree containing selectable choice items.
///
/// Child widgets should provide choice items that use [Choice.choose]
/// to register selections and [Choice.getValue] to access current state.
  Widget child;
/// Creates a [ControlledMultipleAnswer].
///
/// Either [controller] or [initialValue] should be provided to establish
/// the initial selection state. The [child] should contain choice items
/// that integrate with the multiple selection system.
///
/// Parameters:
/// - [controller] (`MultipleAnswerController<T>?`, optional): External controller for programmatic control
/// - [initialValue] (`Iterable<T>?`, optional): Initial selection when no controller provided
/// - [onChanged] (`ValueChanged<Iterable<T>?>?`, optional): Callback for selection changes
/// - [enabled] (bool, default: true): Whether selections can be modified
/// - [allowUnselect] (bool?, optional): Whether items can be deselected by re-selection
/// - [child] (Widget, required): Container with selectable choice items
///
/// Example:
/// ```dart
/// ControlledMultipleAnswer<int>(
///   initialValue: [1, 3],
///   allowUnselect: true,
///   onChanged: (values) => print('Selected: $values'),
///   child: ChoiceList(items: [1, 2, 3, 4, 5]),
/// );
/// ```
  const ControlledMultipleAnswer({super.key, this.controller, this.onChanged, this.initialValue, this.enabled = true, this.allowUnselect, required this.child});
  Widget build(BuildContext context);
}
/// A controlled widget for managing single item selection with external state management.
///
/// This widget provides a container for single-choice selection interfaces where
/// users can select one item from a set of choices. It integrates with the controlled
/// component system to provide external state management, form integration, and
/// programmatic control of the selection.
///
/// The component maintains a single selected item and provides callbacks for
/// selection changes. Child widgets can use the [Choice.choose] method to
/// register item selections and [Choice.getValue] to access the current selection.
///
/// Example:
/// ```dart
/// ControlledMultipleChoice<String>(
///   initialValue: 'medium',
///   onChanged: (selection) {
///     print('Selected size: $selection');
///   },
///   child: Column(
///     children: [
///       ChoiceItem(value: 'small', child: Text('Small')),
///       ChoiceItem(value: 'medium', child: Text('Medium')),
///       ChoiceItem(value: 'large', child: Text('Large')),
///     ],
///   ),
/// );
/// ```
class ControlledMultipleChoice<T> extends StatelessWidget with ControlledComponent<T?> {
  MultipleChoiceController<T>? controller;
  T? initialValue;
  ValueChanged<T?>? onChanged;
  bool enabled;
/// Whether the selected item can be deselected by selecting it again.
///
/// When true, users can deselect the current selection by clicking it again,
/// setting the value to null. When false, once an item is selected, it
/// remains selected until another item is chosen.
  bool? allowUnselect;
/// The widget subtree containing selectable choice items.
///
/// Child widgets should provide choice items that use [Choice.choose]
/// to register selections and [Choice.getValue] to access current state.
  Widget child;
/// Creates a [ControlledMultipleChoice].
///
/// Either [controller] or [initialValue] should be provided to establish
/// the initial selection state. The [child] should contain choice items
/// that integrate with the single selection system.
///
/// Parameters:
/// - [controller] (`MultipleChoiceController<T>?`, optional): External controller for programmatic control
/// - [initialValue] (T?, optional): Initial selection when no controller provided
/// - [onChanged] (`ValueChanged<T?>?`, optional): Callback for selection changes
/// - [enabled] (bool, default: true): Whether selection can be modified
/// - [allowUnselect] (bool?, optional): Whether selection can be cleared by re-selection
/// - [child] (Widget, required): Container with selectable choice items
///
/// Example:
/// ```dart
/// ControlledMultipleChoice<Theme>(
///   initialValue: Theme.dark,
///   allowUnselect: false,
///   onChanged: (theme) => setAppTheme(theme),
///   child: ThemeSelector(),
/// );
/// ```
  const ControlledMultipleChoice({super.key, this.controller, this.onChanged, this.initialValue, this.enabled = true, this.allowUnselect, required this.child});
  Widget build(BuildContext context);
}
/// A widget for single-selection choice scenarios.
///
/// [MultipleChoice] manages a single selected value from multiple options.
/// It prevents multiple selections and optionally allows deselecting the
/// current choice by clicking it again.
///
/// This widget is typically used with choice items like [ChoiceChip] or
/// [ChoiceButton] which integrate with the inherited [Choice] data.
///
/// Example:
/// ```dart
/// MultipleChoice<String>(
///   value: selectedOption,
///   onChanged: (value) => setState(() => selectedOption = value),
///   child: Wrap(
///     children: [
///       ChoiceChip(value: 'A', child: Text('Option A')),
///       ChoiceChip(value: 'B', child: Text('Option B')),
///     ],
///   ),
/// )
/// ```
class MultipleChoice<T> extends StatefulWidget {
/// The child widget tree containing choice items.
  Widget child;
/// The currently selected value.
  T? value;
/// Callback when the selection changes.
  ValueChanged<T?>? onChanged;
/// Whether choices are enabled.
  bool? enabled;
/// Whether the current selection can be unselected.
  bool? allowUnselect;
/// Creates a [MultipleChoice].
///
/// Parameters:
/// - [child] (`Widget`, required): Widget tree with choice items.
/// - [value] (`T?`, optional): Currently selected value.
/// - [onChanged] (`ValueChanged<T?>?`, optional): Selection callback.
/// - [enabled] (`bool?`, optional): Whether choices are enabled.
/// - [allowUnselect] (`bool?`, optional): Allow deselecting the current choice.
  const MultipleChoice({super.key, required this.child, this.value, this.onChanged, this.enabled, this.allowUnselect});
  State<MultipleChoice<T>> createState();
}
/// A widget for multiple-selection choice scenarios.
///
/// [MultipleAnswer] manages multiple selected values from a set of options.
/// It allows users to select and deselect multiple items independently.
///
/// This widget is typically used with choice items like [ChoiceChip] or
/// [ChoiceButton] which integrate with the inherited [Choice] data.
///
/// Example:
/// ```dart
/// MultipleAnswer<String>(
///   value: selectedOptions,
///   onChanged: (values) => setState(() => selectedOptions = values),
///   child: Wrap(
///     children: [
///       ChoiceChip(value: 'A', child: Text('Option A')),
///       ChoiceChip(value: 'B', child: Text('Option B')),
///       ChoiceChip(value: 'C', child: Text('Option C')),
///     ],
///   ),
/// )
/// ```
class MultipleAnswer<T> extends StatefulWidget {
/// The child widget tree containing choice items.
  Widget child;
/// The currently selected values.
  Iterable<T>? value;
/// Callback when the selection changes.
  ValueChanged<Iterable<T>?>? onChanged;
/// Whether choices are enabled.
  bool? enabled;
/// Whether all selections can be unselected.
  bool? allowUnselect;
/// Creates a [MultipleAnswer].
///
/// Parameters:
/// - [child] (`Widget`, required): Widget tree with choice items.
/// - [value] (`Iterable<T>?`, optional): Currently selected values.
/// - [onChanged] (`ValueChanged<Iterable<T>?>?`, optional): Selection callback.
/// - [enabled] (`bool?`, optional): Whether choices are enabled.
/// - [allowUnselect] (`bool?`, optional): Allow deselecting all choices.
  const MultipleAnswer({super.key, required this.child, this.value, this.onChanged, this.enabled, this.allowUnselect});
  State<MultipleAnswer<T>> createState();
}
/// A widget that displays validation feedback for form entries.
///
/// Wraps a form entry with a custom builder that receives validation results,
/// allowing you to customize the visual presentation of validation errors and
/// success states.
///
/// Example:
/// ```dart
/// Validated<String>(
///   validator: (value) => value.isEmpty ? ValidationResult.error('Required') : null,
///   builder: (context, error, child) {
///     return Column(
///       children: [
///         child!,
///         if (error != null) Text(error.message, style: TextStyle(color: Colors.red)),
///       ],
///     );
///   },
///   child: TextField(),
/// )
/// ```
class Validated<T> extends StatefulWidget {
/// Builder function that creates the widget based on validation state.
  ValidatedBuilder builder;
/// The validator to apply to the form entry.
  Validator<T> validator;
/// Optional child widget to display.
  Widget? child;
/// Creates a [Validated].
///
/// Parameters:
/// - [builder] (`ValidatedBuilder`, required): Builds widget with validation feedback.
/// - [validator] (`Validator<T>`, required): Validation logic.
/// - [child] (`Widget?`, optional): Child widget to wrap.
  const Validated({super.key, required this.builder, required this.validator, this.child});
  State<Validated> createState();
}
/// A widget for selecting items from a collection using various presentation modes.
///
/// This widget provides a flexible item selection interface that can display
/// items in different layouts (grid, list) and presentation modes (dialog, popover).
/// It's suitable for scenarios where users need to pick from a predefined set
/// of items like colors, icons, templates, or any custom objects.
///
/// The ItemPicker uses a delegate pattern to provide items, allowing for both
/// static lists and dynamic item generation. Items are displayed using a
/// custom builder function that determines how each item appears in the picker.
///
/// Example:
/// ```dart
/// ItemPicker<Color>(
///   items: ItemList([Colors.red, Colors.green, Colors.blue]),
///   value: Colors.red,
///   builder: (context, color, isSelected) {
///     return Container(
///       width: 40,
///       height: 40,
///       decoration: BoxDecoration(
///         color: color,
///         shape: BoxShape.circle,
///         border: isSelected ? Border.all(width: 2) : null,
///       ),
///     );
///   },
///   onChanged: (color) => print('Selected color: $color'),
/// );
/// ```
class ItemPicker<T> extends StatelessWidget {
/// Delegate providing the collection of items to display for selection.
///
/// This delegate abstracts the item source, supporting both static lists
/// through [ItemList] and dynamic generation through [ItemBuilder].
  ItemChildDelegate<T> items;
/// Builder function that creates the visual representation of each item.
///
/// Called for each item to create its visual representation in the picker.
/// The builder receives the item value and selection state, allowing
/// customized appearance based on the current selection.
  ItemPickerBuilder<T> builder;
/// The currently selected item, if any.
///
/// When null, no item is selected. The picker highlights this item
/// visually to indicate the current selection state.
  T? value;
/// Callback invoked when the user selects a different item.
///
/// Called when the user taps on an item in the picker. The callback
/// receives the selected item, or null if the selection is cleared.
  ValueChanged<T?>? onChanged;
/// Layout style for arranging items in the picker interface.
///
/// Determines how items are arranged within the picker container,
/// such as grid or list layout. Defaults to grid layout.
  ItemPickerLayout? layout;
/// Widget displayed when no item is currently selected.
///
/// Shown in the picker trigger button when [value] is null.
/// Provides visual feedback that no selection has been made yet.
  Widget? placeholder;
/// Optional title widget for the picker interface.
///
/// Displayed at the top of the picker when shown in dialog mode,
/// providing context about what the user is selecting.
  Widget? title;
/// Presentation mode for the item picker interface.
///
/// Controls whether the picker appears as a modal dialog or a popover
/// dropdown. Defaults to dialog mode for better item visibility.
  PromptMode? mode;
/// Size constraints for the picker interface container.
///
/// Controls the dimensions of the picker when displayed, allowing
/// customization of the available space for item display.
  BoxConstraints? constraints;
/// Creates an [ItemPicker].
///
/// The [items] delegate provides the selectable items, and the [builder]
/// function determines how each item is visually represented. Various
/// options control the picker's layout and presentation style.
///
/// Parameters:
/// - [items] (`ItemChildDelegate<T>`, required): Source of items for selection
/// - [builder] (`ItemPickerBuilder<T>`, required): Function to build item representations
/// - [value] (T?, optional): Currently selected item
/// - [onChanged] (`ValueChanged<T?>?`, optional): Callback for selection changes
/// - [layout] (ItemPickerLayout?, optional): Arrangement style for items
/// - [placeholder] (Widget?, optional): Content shown when no item is selected
/// - [title] (Widget?, optional): Title for the picker interface
/// - [mode] (PromptMode?, optional): Presentation style (dialog or popover)
/// - [constraints] (BoxConstraints?, optional): Size constraints for the picker
///
/// Example:
/// ```dart
/// ItemPicker<IconData>(
///   items: ItemList([Icons.home, Icons.star, Icons.favorite]),
///   layout: ItemPickerLayout.grid,
///   mode: PromptMode.dialog,
///   builder: (context, icon, selected) => Icon(icon),
///   onChanged: (icon) => updateIcon(icon),
/// );
/// ```
  const ItemPicker({super.key, required this.items, required this.builder, this.value, this.onChanged, this.layout, this.placeholder, this.title, this.mode, this.constraints});
  Widget build(BuildContext context);
}
/// Abstract delegate for providing items to an item picker.
///
/// Defines an interface for accessing items by index, used by [ItemPickerLayout]
/// to build the list or grid of items. Concrete implementations include
/// [ItemList] for fixed arrays and [ItemBuilder] for lazy generation.
///
/// See also:
/// - [ItemList], which wraps a fixed list of items.
/// - [ItemBuilder], which generates items on demand.
abstract class ItemChildDelegate<T> {
/// Creates an [ItemChildDelegate].
  const ItemChildDelegate();
/// The total number of items, or null if infinite or unknown.
  int? get itemCount;
/// Retrieves the item at the specified index.
///
/// Parameters:
/// - [index] (`int`, required): The index of the item.
///
/// Returns: The item at the index, or null if not available.
  T? operator [](int index);
}
/// A delegate that wraps a fixed list of items.
///
/// Provides items from a pre-defined `List<T>`.
///
/// Example:
/// ```dart
/// ItemList<String>(['Apple', 'Banana', 'Cherry'])
/// ```
class ItemList<T> extends ItemChildDelegate<T> {
/// The list of items.
  List<T> items;
/// Creates an [ItemList].
///
/// Parameters:
/// - [items] (`List<T>`, required): The items to provide.
  const ItemList(this.items);
  int get itemCount;
  T operator [](int index);
}
/// A delegate that builds items on demand using a builder function.
///
/// Allows lazy generation of items, useful for large or infinite lists.
///
/// Example:
/// ```dart
/// ItemBuilder<int>(
///   itemCount: 100,
///   itemBuilder: (index) => index * 2,
/// )
/// ```
class ItemBuilder<T> extends ItemChildDelegate<T> {
/// The total number of items, or null if infinite.
  int? itemCount;
/// Builder function that returns an item for the given index.
  T? Function(int index) itemBuilder;
/// Creates an [ItemBuilder].
///
/// Parameters:
/// - [itemCount] (`int?`, optional): Number of items, or null if infinite.
/// - [itemBuilder] (`T? Function(int)`, required): Function to build items.
  const ItemBuilder({this.itemCount, required this.itemBuilder});
  T? operator [](int index);
}
/// Abstract base class for item picker layout strategies.
///
/// Defines how items are displayed in an item picker, such as in a list
/// or grid. Provides factory constants for common layouts.
///
/// See also:
/// - [ListItemPickerLayout], which displays items in a vertical list.
/// - [GridItemPickerLayout], which displays items in a grid.
abstract class ItemPickerLayout {
/// A list layout for item pickers.
  static const ListItemPickerLayout list = ListItemPickerLayout();
/// A grid layout for item pickers (4 columns by default).
  static const GridItemPickerLayout grid = GridItemPickerLayout();
/// Creates an [ItemPickerLayout].
  const ItemPickerLayout();
/// Builds the widget for displaying items.
///
/// Parameters:
/// - [context] (`BuildContext`, required): The build context.
/// - [items] (`ItemChildDelegate`, required): Delegate providing items.
/// - [builder] (`ItemPickerBuilder`, required): Function to build each item.
///
/// Returns: A widget displaying the items in this layout.
  Widget build(BuildContext context, ItemChildDelegate items, ItemPickerBuilder builder);
}
/// A list-based layout for item pickers.
///
/// Displays items in a vertical scrolling list using [ListView.builder].
///
/// Example:
/// ```dart
/// const ListItemPickerLayout()
/// ```
class ListItemPickerLayout extends ItemPickerLayout {
/// Creates a [ListItemPickerLayout].
  const ListItemPickerLayout();
  Widget build(BuildContext context, ItemChildDelegate items, ItemPickerBuilder builder);
}
/// A grid-based layout for item pickers.
///
/// Displays items in a scrollable grid using [GridView.builder]. The number
/// of columns can be configured via [crossAxisCount].
///
/// Example:
/// ```dart
/// GridItemPickerLayout(crossAxisCount: 3)
/// ```
class GridItemPickerLayout extends ItemPickerLayout {
/// Number of columns in the grid.
  int crossAxisCount;
/// Creates a [GridItemPickerLayout].
///
/// Parameters:
/// - [crossAxisCount] (`int`, default: `4`): The number of grid columns.
  const GridItemPickerLayout({this.crossAxisCount = 4});
/// Creates a copy of this layout with a different column count.
///
/// Parameters:
/// - [crossAxisCount] (`int`, default: `4`): The new column count.
///
/// Returns: A new [GridItemPickerLayout] with the specified columns.
  ItemPickerLayout call({int crossAxisCount = 4});
  Widget build(BuildContext context, ItemChildDelegate items, ItemPickerBuilder builder);
}
/// Shows an item picker in a popover overlay.
///
/// Displays a popover with items arranged according to the specified layout,
/// allowing the user to select one item. The popover closes when an item
/// is selected.
///
/// Parameters:
/// - [context] (`BuildContext`, required): The build context.
/// - [items] (`ItemChildDelegate<T>`, required): Delegate providing items.
/// - [builder] (`ItemPickerBuilder<T>`, required): Builds each item widget.
/// - [initialValue] (`T?`, optional): Initially selected item.
/// - [layout] (`ItemPickerLayout`, default: `GridItemPickerLayout()`): Layout strategy.
/// - [alignment] (`AlignmentGeometry?`, optional): Popover alignment.
/// - [anchorAlignment] (`AlignmentGeometry?`, optional): Anchor alignment.
/// - [constraints] (`BoxConstraints?`, optional): Size constraints for the popover.
/// - [offset] (`Offset?`, optional): Offset from anchor.
/// - [title] (`Widget?`, optional): Optional title widget.
///
/// Returns: A `Future<T?>` that completes with the selected item or null.
///
/// Example:
/// ```dart
/// final color = await showItemPicker<Color>(
///   context,
///   items: ItemList([Colors.red, Colors.green, Colors.blue]),
///   builder: (context, color) => ColorTile(color),
/// );
/// ```
Future<T?> showItemPicker<T>(BuildContext context, {required ItemChildDelegate<T> items, required ItemPickerBuilder<T> builder, T? initialValue, ItemPickerLayout layout = const GridItemPickerLayout(), AlignmentGeometry? alignment, AlignmentGeometry? anchorAlignment, BoxConstraints? constraints, Offset? offset, Widget? title});
/// Shows an item picker in a modal dialog.
///
/// Displays a modal dialog with items arranged according to the specified layout,
/// allowing the user to select one item. The dialog closes when an item is selected.
///
/// Parameters:
/// - [context] (`BuildContext`, required): The build context.
/// - [items] (`ItemChildDelegate<T>`, required): Delegate providing items.
/// - [builder] (`ItemPickerBuilder<T>`, required): Builds each item widget.
/// - [layout] (`ItemPickerLayout`, default: `GridItemPickerLayout()`): Layout strategy.
/// - [initialValue] (`T?`, optional): Initially selected item.
/// - [constraints] (`BoxConstraints?`, optional): Size constraints for the dialog.
/// - [title] (`Widget`, required): Dialog title widget.
///
/// Returns: A `Future<T?>` that completes with the selected item or null.
///
/// Example:
/// ```dart
/// final icon = await showItemPickerDialog<IconData>(
///   context,
///   title: Text('Choose Icon'),
///   items: ItemList([Icons.home, Icons.star, Icons.settings]),
///   builder: (context, icon) => Icon(icon),
/// );
/// ```
Future<T?> showItemPickerDialog<T>(BuildContext context, {required ItemChildDelegate<T> items, required ItemPickerBuilder<T> builder, ItemPickerLayout layout = const GridItemPickerLayout(), T? initialValue, BoxConstraints? constraints, required Widget title});
/// A dialog widget for picking an item from a list or grid.
///
/// Internally used by [showItemPicker] and [showItemPickerDialog] to display
/// items and handle selection. Manages the selected value state and notifies
/// listeners when the selection changes.
///
/// Example:
/// ```dart
/// ItemPickerDialog<Color>(
///   items: ItemList([Colors.red, Colors.green]),
///   builder: (context, color) => ColorTile(color),
///   layout: ItemPickerLayout.grid,
///   onChanged: (color) => print(color),
/// )
/// ```
class ItemPickerDialog<T> extends StatefulWidget {
/// Delegate providing the items to display.
  ItemChildDelegate<T> items;
/// Builder function for rendering each item.
  ItemPickerBuilder<T> builder;
/// Layout strategy for displaying items.
  ItemPickerLayout layout;
/// Currently selected value.
  T? value;
/// Called when the selection changes.
  ValueChanged<T?>? onChanged;
/// Creates an [ItemPickerDialog].
///
/// Parameters:
/// - [items] (`ItemChildDelegate<T>`, required): Items to display.
/// - [builder] (`ItemPickerBuilder<T>`, required): Item widget builder.
/// - [layout] (`ItemPickerLayout`, default: `GridItemPickerLayout()`): Layout strategy.
/// - [value] (`T?`, optional): Selected value.
/// - [onChanged] (`ValueChanged<T?>?`, optional): Selection callback.
  const ItemPickerDialog({super.key, required this.items, required this.builder, this.value, this.onChanged, this.layout = const GridItemPickerLayout()});
  State<ItemPickerDialog<T>> createState();
}
/// Data provided by [ItemPickerDialog] to its descendants.
///
/// Contains the current selection value, change callback, and layout strategy.
/// Used internally for coordinating state across the item picker tree.
class ItemPickerData {
/// The currently selected value.
  Object? value;
/// Callback invoked when the selection changes.
  ValueChanged<Object?>? onChanged;
/// The layout strategy being used.
  ItemPickerLayout layout;
/// Creates an [ItemPickerData].
///
/// Parameters:
/// - [value] (`Object?`, optional): Current selection.
/// - [onChanged] (`ValueChanged<Object?>?`, optional): Change callback.
/// - [layout] (`ItemPickerLayout`, required): Layout strategy.
  const ItemPickerData({this.value, this.onChanged, required this.layout});
  bool operator ==(Object other);
  int get hashCode;
}
/// A selectable option within an item picker.
///
/// Wraps an item with selection behavior, applying different styles based on
/// whether it's currently selected. Commonly used inside [ItemPickerDialog]
/// to create selectable items.
///
/// Example:
/// ```dart
/// ItemPickerOption<Color>(
///   value: Colors.red,
///   child: Container(color: Colors.red, width: 50, height: 50),
/// )
/// ```
class ItemPickerOption<T> extends StatelessWidget {
/// The value this option represents.
  T value;
/// Optional label widget displayed with the option.
  Widget? label;
/// The main child widget representing the option.
  Widget child;
/// Custom style for the option when not selected.
  AbstractButtonStyle? style;
/// Custom style for the option when selected.
  AbstractButtonStyle? selectedStyle;
/// Creates an [ItemPickerOption].
///
/// Parameters:
/// - [value] (`T`, required): The value this option represents.
/// - [child] (`Widget`, required): The widget to display.
/// - [style] (`AbstractButtonStyle?`, optional): Style when not selected.
/// - [selectedStyle] (`AbstractButtonStyle?`, optional): Style when selected.
/// - [label] (`Widget?`, optional): Optional label widget.
  const ItemPickerOption({super.key, required this.value, required this.child, this.style, this.selectedStyle, this.label});
  Widget build(BuildContext context);
}
/// Reactive controller for managing slider state with value operations.
///
/// Extends [ValueNotifier] to provide state management for slider widgets
/// using [SliderValue] objects that support both single and range slider
/// configurations. Enables programmatic slider value changes and provides
/// convenient methods for common slider operations.
///
/// The controller manages [SliderValue] objects which can represent either
/// single values or dual-thumb range values, providing unified state management
/// for different slider types.
///
/// Example:
/// ```dart
/// final controller = SliderController(SliderValue.single(0.5));
///
/// // React to changes
/// controller.addListener(() {
///   print('Slider value: ${controller.value}');
/// });
///
/// // Programmatic control
/// controller.setValue(0.75);
/// controller.setRange(0.2, 0.8);
/// ```
class SliderController extends ValueNotifier<SliderValue> with ComponentController<SliderValue> {
/// Creates a [SliderController] with the specified initial value.
///
/// The [value] parameter provides the initial slider configuration as a
/// [SliderValue]. The controller notifies listeners when the value changes
/// through any method calls or direct value assignment.
///
/// Example:
/// ```dart
/// final controller = SliderController(SliderValue.single(0.3));
/// ```
  SliderController(super.value);
/// Sets the slider to a single value configuration.
///
/// Converts the slider to single-thumb mode with the specified [value].
/// The value should be within the slider's min/max bounds.
  void setValue(double value);
/// Sets the slider to a range value configuration.
///
/// Converts the slider to dual-thumb mode with the specified [start] and [end] values.
/// The values should be within the slider's min/max bounds with start <= end.
  void setRange(double start, double end);
/// Returns true if the slider is in single-value mode.
  bool get isSingle;
/// Returns true if the slider is in range mode.
  bool get isRanged;
/// Gets the current single value (valid only in single mode).
///
/// Throws an exception if called when the slider is in range mode.
  double get singleValue;
/// Gets the current range start value (valid only in range mode).
///
/// Throws an exception if called when the slider is in single mode.
  double get rangeStart;
/// Gets the current range end value (valid only in range mode).
///
/// Throws an exception if called when the slider is in single mode.
  double get rangeEnd;
}
/// Reactive slider with automatic state management and controller support.
///
/// A high-level slider widget that provides automatic state management through
/// the controlled component pattern. Supports both single-value and range sliders
/// with comprehensive customization options for styling, behavior, and interaction.
///
/// ## Features
///
/// - **Single and range modes**: Unified interface for different slider types
/// - **Discrete divisions**: Optional snap-to-value behavior with tick marks
/// - **Keyboard navigation**: Full arrow key support with custom step sizes
/// - **Hint values**: Visual preview of suggested or default values
/// - **Accessibility support**: Screen reader compatibility and semantic labels
/// - **Form integration**: Automatic validation and form field registration
///
/// ## Usage Patterns
///
/// **Controller-based (recommended for complex state):**
/// ```dart
/// final controller = SliderController(SliderValue.single(0.5));
///
/// ControlledSlider(
///   controller: controller,
///   min: 0.0,
///   max: 100.0,
///   divisions: 100,
/// )
/// ```
///
/// **Callback-based (simple state management):**
/// ```dart
/// double currentValue = 50.0;
///
/// ControlledSlider(
///   initialValue: SliderValue.single(currentValue),
///   onChanged: (value) => setState(() => currentValue = value.single),
///   min: 0.0,
///   max: 100.0,
/// )
/// ```
class ControlledSlider extends StatelessWidget with ControlledComponent<SliderValue> {
  SliderValue initialValue;
  ValueChanged<SliderValue>? onChanged;
  SliderController? controller;
  bool enabled;
/// Callback invoked when the user starts changing the slider value.
///
/// Called once when the user begins dragging the slider thumb or interacting
/// with the slider track. Receives the initial [SliderValue] at the start of
/// the interaction.
  ValueChanged<SliderValue>? onChangeStart;
/// Callback invoked when the user finishes changing the slider value.
///
/// Called once when the user releases the slider thumb or completes the
/// interaction. Receives the final [SliderValue] at the end of the interaction.
  ValueChanged<SliderValue>? onChangeEnd;
/// The minimum value the slider can represent.
///
/// Defaults to `0`. Must be less than [max].
  double min;
/// The maximum value the slider can represent.
///
/// Defaults to `1`. Must be greater than [min].
  double max;
/// The number of discrete divisions the slider range is divided into.
///
/// If `null`, the slider is continuous. If non-null, the slider will snap to
/// discrete values in the range `[min, max]`.
  int? divisions;
/// An optional hint value displayed on the slider track.
///
/// Provides visual feedback showing a target or reference value. The hint is
/// typically rendered as a subtle marker on the track.
  SliderValue? hintValue;
/// The step size for keyboard increment actions.
///
/// When the user presses the increase key, the slider value will increase by
/// this amount. If `null`, a default increment is used.
  double? increaseStep;
/// The step size for keyboard decrement actions.
///
/// When the user presses the decrease key, the slider value will decrease by
/// this amount. If `null`, a default decrement is used.
  double? decreaseStep;
/// Creates a [ControlledSlider].
///
/// A controlled slider that manages its state either through an external
/// [controller] or internal state with [initialValue]. Use this when you need
/// programmatic control over the slider value.
///
/// Parameters:
/// - [controller] (`SliderController?`, optional): External controller for
///   managing slider state. If provided, it becomes the source of truth.
/// - [initialValue] (`SliderValue`, default: `SliderValue.single(0)`): Initial
///   value when no controller is provided.
/// - [onChanged] (`ValueChanged<SliderValue>?`, optional): Called when the
///   slider value changes during interaction.
/// - [onChangeStart] (`ValueChanged<SliderValue>?`, optional): Called when the
///   user begins interaction.
/// - [onChangeEnd] (`ValueChanged<SliderValue>?`, optional): Called when the
///   user completes interaction.
/// - [min] (`double`, default: `0`): Minimum slider value.
/// - [max] (`double`, default: `1`): Maximum slider value.
/// - [divisions] (`int?`, optional): Number of discrete divisions. If `null`,
///   the slider is continuous.
/// - [hintValue] (`SliderValue?`, optional): Visual hint marker on the track.
/// - [increaseStep] (`double?`, optional): Keyboard increment step size.
/// - [decreaseStep] (`double?`, optional): Keyboard decrement step size.
/// - [enabled] (`bool`, default: `true`): Whether the slider is interactive.
///
/// Example:
/// ```dart
/// final controller = SliderController(SliderValue.single(0.5));
///
/// ControlledSlider(
///   controller: controller,
///   min: 0.0,
///   max: 100.0,
///   divisions: 100,
///   onChanged: (value) => print('Value: $value'),
/// )
/// ```
  const ControlledSlider({super.key, this.controller, this.initialValue = const SliderValue.single(0), this.onChanged, this.onChangeStart, this.onChangeEnd, this.min = 0, this.max = 1, this.divisions, this.hintValue, this.increaseStep, this.decreaseStep, this.enabled = true});
  Widget build(BuildContext context);
}
/// Represents a slider value, supporting both single and range configurations.
///
/// A [SliderValue] can represent either a single point value or a dual-thumb
/// range with start and end values. Use [SliderValue.single] for single-thumb
/// sliders and [SliderValue.ranged] for range sliders.
///
/// This class provides value interpolation, division rounding, and comparison
/// operations needed for slider animations and discrete value snapping.
///
/// Example:
/// ```dart
/// // Single value slider
/// final single = SliderValue.single(0.5);
/// print(single.value); // 0.5
///
/// // Range slider
/// final range = SliderValue.ranged(0.2, 0.8);
/// print(range.start); // 0.2
/// print(range.end);   // 0.8
/// ```
class SliderValue {
/// Linearly interpolates between two [SliderValue] objects.
///
/// Returns `null` if either [a] or [b] is `null`, or if the values have
/// mismatched types (one single, one ranged). Otherwise, interpolates between
/// the values using the interpolation factor [t] (typically 0.0 to 1.0).
///
/// Parameters:
/// - [a] (`SliderValue?`, optional): Start value for interpolation.
/// - [b] (`SliderValue?`, optional): End value for interpolation.
/// - [t] (`double`, required): Interpolation factor, where 0.0 returns [a]
///   and 1.0 returns [b].
///
/// Returns: `SliderValue?` ‚Äî interpolated value, or `null` if incompatible.
  static SliderValue? lerp(SliderValue? a, SliderValue? b, double t);
/// Creates a single-value [SliderValue] with the specified [value].
///
/// Use this constructor for standard single-thumb sliders. The slider will
/// have one draggable thumb and a clickable track.
///
/// Parameters:
/// - [value] (`double`, required): The slider value position.
///
/// Example:
/// ```dart
/// final slider = SliderValue.single(0.75);
/// ```
  const SliderValue.single(double value);
/// Creates a range [SliderValue] with start and end positions.
///
/// Use this constructor for dual-thumb range sliders. The slider will have
/// two draggable thumbs but a non-clickable track.
///
/// Parameters:
/// - [_start] (`double`, required): The start position of the range.
/// - [_end] (`double`, required): The end position of the range.
///
/// Example:
/// ```dart
/// final range = SliderValue.ranged(0.2, 0.8);
/// ```
  const SliderValue.ranged(double this._start, this._end);
/// Whether this is a range slider value (dual-thumb).
///
/// Returns `true` if created with [SliderValue.ranged], `false` if created
/// with [SliderValue.single].
  bool get isRanged;
/// The start position of the slider value.
///
/// For ranged sliders, returns the actual start position. For single-value
/// sliders, returns the same as [value].
  double get start;
/// The end position of the slider value.
///
/// For ranged sliders, returns the end position. For single-value sliders,
/// returns the same as [value].
  double get end;
/// The value position for single-value sliders.
///
/// Always returns the end position. For single-value sliders, this is the
/// primary value. For ranged sliders, this returns the end of the range.
  double get value;
  bool operator ==(Object other);
  int get hashCode;
/// Rounds the slider value to discrete divisions.
///
/// Snaps the value(s) to the nearest division point based on the specified
/// number of [divisions]. Useful for creating discrete stepped sliders.
///
/// Parameters:
/// - [divisions] (`int`, required): Number of discrete steps.
///
/// Returns: `SliderValue` ‚Äî rounded value.
///
/// Example:
/// ```dart
/// final value = SliderValue.single(0.333);
/// final rounded = value.roundToDivisions(10);
/// // Results in SliderValue.single(0.3)
/// ```
  SliderValue roundToDivisions(int divisions);
}
/// Theme for [Slider].
class SliderTheme extends ComponentThemeData {
/// Height of the track.
  double? trackHeight;
/// Color of the inactive track.
  Color? trackColor;
/// Color of the active portion of the track.
  Color? valueColor;
/// Color of the inactive track when disabled.
  Color? disabledTrackColor;
/// Color of the active track when disabled.
  Color? disabledValueColor;
/// Background color of the thumb.
  Color? thumbColor;
/// Border color of the thumb.
  Color? thumbBorderColor;
/// Border color of the thumb when focused.
  Color? thumbFocusedBorderColor;
/// Size of the thumb.
  double? thumbSize;
/// Creates a [SliderTheme].
  const SliderTheme({this.trackHeight, this.trackColor, this.valueColor, this.disabledTrackColor, this.disabledValueColor, this.thumbColor, this.thumbBorderColor, this.thumbFocusedBorderColor, this.thumbSize});
/// Returns a copy of this theme with the given fields replaced.
  SliderTheme copyWith({ValueGetter<double?>? trackHeight, ValueGetter<Color?>? trackColor, ValueGetter<Color?>? valueColor, ValueGetter<Color?>? disabledTrackColor, ValueGetter<Color?>? disabledValueColor, ValueGetter<Color?>? thumbColor, ValueGetter<Color?>? thumbBorderColor, ValueGetter<Color?>? thumbFocusedBorderColor, ValueGetter<double?>? thumbSize});
  bool operator ==(Object other);
  int get hashCode;
}
/// Intent for increasing the slider value via keyboard shortcuts.
///
/// Used with Flutter's shortcuts and actions system to handle keyboard
/// input for incrementing slider values. Typically bound to arrow keys.
class IncreaseSliderValue extends Intent {
/// Creates an [IncreaseSliderValue] intent.
  const IncreaseSliderValue();
}
/// Intent for decreasing the slider value via keyboard shortcuts.
///
/// Used with Flutter's shortcuts and actions system to handle keyboard
/// input for decrementing slider values. Typically bound to arrow keys.
class DecreaseSliderValue extends Intent {
/// Creates a [DecreaseSliderValue] intent.
  const DecreaseSliderValue();
}
/// A Material Design slider widget for selecting values or ranges.
///
/// A highly customizable slider supporting both single-value and range
/// selection modes. Provides keyboard navigation, discrete divisions,
/// hint values, and comprehensive theming options.
///
/// Unlike [ControlledSlider], this widget is uncontrolled and requires
/// explicit value management through [onChanged]. For a controlled
/// alternative with automatic state management, use [ControlledSlider].
///
/// Example:
/// ```dart
/// Slider(
///   value: SliderValue.single(0.5),
///   min: 0.0,
///   max: 1.0,
///   divisions: 10,
///   onChanged: (newValue) {
///     setState(() => value = newValue);
///   },
/// )
/// ```
class Slider extends StatefulWidget {
/// The current value of the slider.
///
/// Can be either a single value or a range. The slider's visual state
/// reflects this value.
  SliderValue value;
/// Callback invoked when the slider value changes.
///
/// Called repeatedly during slider interaction as the user drags the thumb
/// or clicks the track. Receives the new [SliderValue].
  ValueChanged<SliderValue>? onChanged;
/// Callback invoked when the user starts changing the slider value.
///
/// Called once when interaction begins. Receives the initial [SliderValue].
  ValueChanged<SliderValue>? onChangeStart;
/// Callback invoked when the user finishes changing the slider value.
///
/// Called once when interaction ends. Receives the final [SliderValue].
  ValueChanged<SliderValue>? onChangeEnd;
/// The minimum value the slider can represent.
///
/// Defaults to `0`. Must be less than [max].
  double min;
/// The maximum value the slider can represent.
///
/// Defaults to `1`. Must be greater than [min].
  double max;
/// The number of discrete divisions the slider range is divided into.
///
/// If `null`, the slider is continuous. If specified, the slider snaps to
/// discrete values.
  int? divisions;
/// An optional hint value displayed on the slider track.
///
/// Renders as a visual marker showing a target or reference position.
  SliderValue? hintValue;
/// The step size for keyboard increment actions.
///
/// Used when the user triggers increase actions via keyboard. If `null`,
/// a default step is calculated based on the slider range.
  double? increaseStep;
/// The step size for keyboard decrement actions.
///
/// Used when the user triggers decrease actions via keyboard. If `null`,
/// a default step is calculated based on the slider range.
  double? decreaseStep;
/// Whether the slider is interactive.
///
/// When `false` or `null` with no [onChanged] callback, the slider is
/// displayed in a disabled state and does not respond to user input.
  bool? enabled;
/// Creates a [Slider].
///
/// Parameters:
/// - [value] (`SliderValue`, required): Current slider value.
/// - [onChanged] (`ValueChanged<SliderValue>?`, optional): Value change callback.
/// - [onChangeStart] (`ValueChanged<SliderValue>?`, optional): Interaction start callback.
/// - [onChangeEnd] (`ValueChanged<SliderValue>?`, optional): Interaction end callback.
/// - [min] (`double`, default: `0`): Minimum value.
/// - [max] (`double`, default: `1`): Maximum value.
/// - [divisions] (`int?`, optional): Number of discrete divisions.
/// - [hintValue] (`SliderValue?`, optional): Visual hint marker.
/// - [increaseStep] (`double?`, optional): Keyboard increment step.
/// - [decreaseStep] (`double?`, optional): Keyboard decrement step.
/// - [enabled] (`bool?`, optional): Whether interactive.
///
/// Example:
/// ```dart
/// Slider(
///   value: SliderValue.ranged(0.2, 0.8),
///   min: 0.0,
///   max: 1.0,
///   onChanged: (value) => print('Range: ${value.start}-${value.end}'),
/// )
/// ```
  const Slider({super.key, required this.value, this.onChanged, this.onChangeStart, this.onChangeEnd, this.min = 0, this.max = 1, this.divisions, this.hintValue, this.increaseStep, this.decreaseStep, this.enabled = true});
  State<Slider> createState();
}
/// Theme data for customizing [Radio] widget appearance.
///
/// This class defines the visual properties that can be applied to
/// [Radio] widgets, including colors for different states and sizing.
/// These properties can be set at the theme level to provide consistent
/// styling across the application.
///
/// The theme affects the radio button's visual appearance in both
/// selected and unselected states, including border, background,
/// and active indicator colors.
class RadioTheme extends ComponentThemeData {
/// Color of the radio indicator when selected.
  Color? activeColor;
/// Border color of the radio button.
  Color? borderColor;
/// Background color of the radio button.
  Color? backgroundColor;
/// Size of the radio button.
  double? size;
/// Creates a [RadioTheme].
///
/// Parameters:
/// - [activeColor] (`Color?`, optional): Selected indicator color.
/// - [borderColor] (`Color?`, optional): Border color.
/// - [backgroundColor] (`Color?`, optional): Background color.
/// - [size] (`double?`, optional): Radio button size.
  const RadioTheme({this.activeColor, this.borderColor, this.size, this.backgroundColor});
/// Creates a copy of this theme with the given fields replaced.
///
/// Parameters:
/// - [activeColor] (`ValueGetter<Color?>?`, optional): New active color.
/// - [borderColor] (`ValueGetter<Color?>?`, optional): New border color.
/// - [backgroundColor] (`ValueGetter<Color?>?`, optional): New background color.
/// - [size] (`ValueGetter<double?>?`, optional): New size.
///
/// Returns: A new [RadioTheme] with updated properties.
  RadioTheme copyWith({ValueGetter<Color?>? activeColor, ValueGetter<Color?>? borderColor, ValueGetter<double?>? size, ValueGetter<Color?>? backgroundColor});
  bool operator ==(Object other);
  int get hashCode;
}
/// A radio button widget that displays a circular selection indicator.
///
/// [Radio] provides a visual representation of a selectable option within
/// a radio group. It displays as a circular button with an inner dot when
/// selected and an empty circle when unselected. The widget supports focus
/// indication and customizable colors and sizing.
///
/// The radio button animates smoothly between selected and unselected states,
/// providing visual feedback to user interactions. It integrates with the
/// focus system to provide accessibility support and keyboard navigation.
///
/// Typically used within [RadioItem] or [RadioGroup] components rather than
/// standalone, as it only provides the visual representation without the
/// interaction logic.
///
/// Example:
/// ```dart
/// Radio(
///   value: isSelected,
///   focusing: hasFocus,
///   size: 20,
///   activeColor: Colors.blue,
/// );
/// ```
class Radio extends StatelessWidget {
/// Whether this radio button is selected.
///
/// When true, displays the inner selection indicator.
/// When false, shows only the outer circle border.
  bool value;
/// Whether this radio button currently has focus.
///
/// When true, displays a focus outline around the radio button
/// for accessibility and keyboard navigation indication.
  bool focusing;
/// Size of the radio button in logical pixels.
///
/// Controls both the width and height of the circular radio button.
/// If null, uses the size from the current [RadioTheme].
  double? size;
/// Color of the inner selection indicator when selected.
///
/// Applied to the inner dot that appears when [value] is true.
/// If null, uses the activeColor from the current [RadioTheme].
  Color? activeColor;
/// Color of the outer border circle.
///
/// Applied to the border of the radio button in both selected and
/// unselected states. If null, uses the borderColor from the current [RadioTheme].
  Color? borderColor;
/// Background color of the radio button circle.
///
/// Applied as the fill color behind the border. If null, uses the
/// backgroundColor from the current [RadioTheme].
  Color? backgroundColor;
/// Creates a [Radio] with the specified selection state and styling.
///
/// The [value] parameter is required and determines whether the radio
/// appears selected. All other parameters are optional and will fall
/// back to theme values when not specified.
///
/// Parameters:
/// - [value] (bool, required): Whether the radio button is selected
/// - [focusing] (bool, default: false): Whether the radio has focus
/// - [size] (double?, optional): Size of the radio button in pixels
/// - [activeColor] (Color?, optional): Color of the selection indicator
/// - [borderColor] (Color?, optional): Color of the outer border
/// - [backgroundColor] (Color?, optional): Color of the background fill
///
/// Example:
/// ```dart
/// Radio(
///   value: selectedValue == itemValue,
///   focusing: focusNode.hasFocus,
///   size: 18,
/// );
/// ```
  const Radio({super.key, required this.value, this.focusing = false, this.size, this.activeColor, this.borderColor, this.backgroundColor});
  Widget build(BuildContext context);
}
/// Intent for navigating to the next item in a radio group.
class NextItemIntent extends Intent {
/// Creates a next item intent.
  const NextItemIntent();
}
/// Intent for navigating to the previous item in a radio group.
class PreviousItemIntent extends Intent {
/// Creates a previous item intent.
  const PreviousItemIntent();
}
/// A radio button item with optional leading and trailing widgets.
///
/// Used within a [RadioGroup] to create selectable radio button options.
class RadioItem<T> extends StatefulWidget {
/// Optional widget displayed before the radio button.
  Widget? leading;
/// Optional widget displayed after the radio button.
  Widget? trailing;
/// The value represented by this radio item.
  T value;
/// Whether this radio item is enabled.
  bool enabled;
/// Focus node for keyboard navigation.
  FocusNode? focusNode;
/// Creates a radio item.
  const RadioItem({super.key, this.leading, this.trailing, required this.value, this.enabled = true, this.focusNode});
  State<RadioItem<T>> createState();
}
/// A card-style radio button with custom content.
///
/// Provides a larger, card-like selection area within a [RadioGroup].
class RadioCard<T> extends StatefulWidget {
/// The child widget displayed in the card.
  Widget child;
/// The value represented by this radio card.
  T value;
/// Whether this radio card is enabled.
  bool enabled;
/// Whether the selected card uses a filled background.
///
/// When true, the selected card fills with 50% opacity of the primary color.
  bool filled;
/// Focus node for keyboard navigation.
  FocusNode? focusNode;
/// Creates a radio card.
  const RadioCard({super.key, required this.child, required this.value, this.enabled = true, this.filled = false, this.focusNode});
  State<RadioCard<T>> createState();
}
/// Theme data for the [RadioCard] widget.
class RadioCardTheme extends ComponentThemeData {
/// The cursor to use when the radio card is enabled.
  MouseCursor? enabledCursor;
/// The cursor to use when the radio card is disabled.
  MouseCursor? disabledCursor;
/// The color to use when the radio card is hovered over.
  Color? hoverColor;
/// The default color to use.
  Color? color;
/// The width of the border of the radio card.
  double? borderWidth;
/// The width of the border of the radio card when selected.
  double? selectedBorderWidth;
/// The radius of the border of the radio card.
  BorderRadiusGeometry? borderRadius;
/// The padding of the radio card.
  EdgeInsetsGeometry? padding;
/// The color of the border.
  Color? borderColor;
/// The color of the border when selected.
  Color? selectedBorderColor;
/// Theme data for the [RadioCard] widget.
  const RadioCardTheme({this.enabledCursor, this.disabledCursor, this.hoverColor, this.color, this.borderWidth, this.selectedBorderWidth, this.borderRadius, this.padding, this.borderColor, this.selectedBorderColor});
  String toString();
/// Creates a copy of this [RadioCardTheme] but with the given fields replaced with the new values.
  RadioCardTheme copyWith({ValueGetter<MouseCursor?>? enabledCursor, ValueGetter<MouseCursor?>? disabledCursor, ValueGetter<Color?>? hoverColor, ValueGetter<Color?>? color, ValueGetter<double?>? borderWidth, ValueGetter<double?>? selectedBorderWidth, ValueGetter<BorderRadiusGeometry?>? borderRadius, ValueGetter<EdgeInsetsGeometry?>? padding, ValueGetter<Color?>? borderColor, ValueGetter<Color?>? selectedBorderColor});
  bool operator ==(Object other);
  int get hashCode;
}
/// Controller for managing [ControlledRadioGroup] state programmatically.
///
/// Extends [ValueNotifier] to provide reactive state management for radio group
/// components. Can be used to programmatically change selection, listen to
/// state changes, and integrate with forms and other reactive systems.
///
/// Example:
/// ```dart
/// final controller = RadioGroupController<String>('option1');
///
/// // Listen to changes
/// controller.addListener(() {
///   print('Selection changed to: ${controller.value}');
/// });
///
/// // Update selection
/// controller.value = 'option2';
/// ```
class RadioGroupController<T> extends ValueNotifier<T?> with ComponentController<T?> {
/// Creates a [RadioGroupController] with an optional initial value.
///
/// The [value] parameter sets the initial selected option. Can be null
/// to start with no selection.
///
/// Parameters:
/// - [value] (T?, optional): Initial selected value
  RadioGroupController([super.value]);
}
/// Reactive radio button group with automatic state management and exclusivity.
///
/// A high-level radio group widget that provides automatic state management through
/// the controlled component pattern. Manages mutual exclusion between radio options
/// and supports both controller-based and callback-based state management.
///
/// ## Features
///
/// - **Mutual exclusion**: Automatically ensures only one radio button is selected
/// - **Flexible layout**: Works with any child layout (Column, Row, Wrap, etc.)
/// - **Keyboard navigation**: Full keyboard support with arrow keys and Space
/// - **Form integration**: Automatic validation and form field registration
/// - **State synchronization**: Keeps all radio buttons in sync automatically
///
/// ## Usage Patterns
///
/// **Controller-based (recommended for complex state):**
/// ```dart
/// final controller = RadioGroupController<String>('small');
///
/// ControlledRadioGroup<String>(
///   controller: controller,
///   child: Column(
///     children: [
///       Radio<String>(value: 'small', label: Text('Small')),
///       Radio<String>(value: 'medium', label: Text('Medium')),
///       Radio<String>(value: 'large', label: Text('Large')),
///     ],
///   ),
/// )
/// ```
///
/// **Callback-based (simple state management):**
/// ```dart
/// String? selectedSize;
///
/// ControlledRadioGroup<String>(
///   initialValue: selectedSize,
///   onChanged: (size) => setState(() => selectedSize = size),
///   child: Column(
///     children: [
///       Radio<String>(value: 'small', label: Text('Small')),
///       Radio<String>(value: 'medium', label: Text('Medium')),
///       Radio<String>(value: 'large', label: Text('Large')),
///     ],
///   ),
/// )
/// ```
class ControlledRadioGroup<T> extends StatelessWidget with ControlledComponent<T?> {
  T? initialValue;
  ValueChanged<T?>? onChanged;
  bool enabled;
  RadioGroupController<T?>? controller;
/// Child widget containing the radio buttons.
///
/// Usually a layout widget like Column, Row, or Wrap containing multiple
/// [Radio] widgets. The radio group will manage the selection state
/// of all descendant radio buttons automatically.
  Widget child;
/// Creates a [ControlledRadioGroup].
///
/// Either [controller] or [onChanged] should be provided for interactivity.
/// The widget supports both controller-based and callback-based state management
/// patterns with automatic mutual exclusion between radio options.
///
/// Parameters:
/// - [controller] (`RadioGroupController<T>?`, optional): external state controller
/// - [initialValue] (T?, optional): starting selection when no controller
/// - [onChanged] (`ValueChanged<T?>?`, optional): selection change callback
/// - [enabled] (bool, default: true): whether radio group is interactive
/// - [child] (Widget, required): layout containing radio buttons
///
/// Example:
/// ```dart
/// ControlledRadioGroup<String>(
///   controller: controller,
///   child: Column(
///     children: [
///       Radio<String>(value: 'option1', label: Text('Option 1')),
///       Radio<String>(value: 'option2', label: Text('Option 2')),
///     ],
///   ),
/// )
/// ```
  const ControlledRadioGroup({super.key, this.controller, this.initialValue, this.onChanged, this.enabled = true, required this.child});
  Widget build(BuildContext context);
}
/// A group of radio buttons for single-selection input.
///
/// Manages the selection state and provides context for child radio items.
class RadioGroup<T> extends StatefulWidget {
/// The child widget containing radio items.
  Widget child;
/// The currently selected value.
  T? value;
/// Callback invoked when the selection changes.
  ValueChanged<T>? onChanged;
/// Whether the radio group is enabled.
  bool? enabled;
/// Creates a radio group.
  const RadioGroup({super.key, required this.child, this.value, this.onChanged, this.enabled});
  RadioGroupState<T> createState();
}
/// Data class holding radio group state information.
///
/// Contains the selected item and enabled state for a radio group.
class RadioGroupData<T> {
/// The currently selected item value.
  T? selectedItem;
/// Whether the radio group is enabled.
  bool enabled;
/// Creates radio group data.
  RadioGroupData(this.selectedItem, this.enabled);
  bool operator ==(Object other);
  int get hashCode;
}
/// State class for [RadioGroup] with form integration.
///
/// Manages selection state and integrates with the form validation system.
class RadioGroupState<T> extends State<RadioGroup<T>> with FormValueSupplier<T, RadioGroup<T>> {
/// Whether the radio group is currently enabled.
  bool get enabled;
  void initState();
  void didUpdateWidget(covariant RadioGroup<T> oldWidget);
  void didReplaceFormValue(T value);
  Widget build(BuildContext context);
}
/// Theme configuration for [NavigationMenu] components.
///
/// Defines visual properties for navigation menu popovers including
/// surface appearance, positioning, and spacing. This theme controls
/// how navigation menu content is displayed when triggered.
///
/// The theme can be applied through [ComponentTheme] or passed directly
/// to individual [NavigationMenu] widgets for customization.
class NavigationMenuTheme extends ComponentThemeData {
/// Opacity of the popover surface.
  double? surfaceOpacity;
/// Blur amount of the popover surface.
  double? surfaceBlur;
/// Margin applied to the popover.
  EdgeInsetsGeometry? margin;
/// Offset for the popover relative to the trigger.
  Offset? offset;
/// Creates a [NavigationMenuTheme] with the specified appearance properties.
///
/// All parameters are optional and will fall back to default values
/// when not provided. This allows for partial customization while
/// maintaining consistent defaults.
///
/// Parameters:
/// - [surfaceOpacity] (double?, optional): Opacity level for popover background
/// - [surfaceBlur] (double?, optional): Blur effect intensity for popover
/// - [margin] (EdgeInsetsGeometry?, optional): Space around the popover
/// - [offset] (Offset?, optional): Position offset relative to trigger
///
/// Example:
/// ```dart
/// NavigationMenuTheme(
///   surfaceOpacity: 0.9,
///   surfaceBlur: 8.0,
///   margin: EdgeInsets.all(16.0),
///   offset: Offset(0, 8),
/// )
/// ```
  const NavigationMenuTheme({this.surfaceOpacity, this.surfaceBlur, this.margin, this.offset});
/// Returns a copy of this theme with the given fields replaced.
  NavigationMenuTheme copyWith({ValueGetter<double?>? surfaceOpacity, ValueGetter<double?>? surfaceBlur, ValueGetter<EdgeInsetsGeometry?>? margin, ValueGetter<Offset?>? offset});
  bool operator ==(Object other);
  int get hashCode;
}
/// An individual menu item within a [NavigationMenu].
///
/// Represents a single interactive element in a navigation menu structure.
/// Each item can function as either a standalone action button or a trigger
/// for displaying additional content in a popover. When content is provided,
/// the item shows a chevron indicator and triggers the popover on interaction.
///
/// The item automatically integrates with its parent [NavigationMenu] to
/// manage popover state, hover interactions, and visual feedback. Items
/// with content become active when hovered or clicked, displaying their
/// associated content in the navigation menu's popover.
///
/// Example:
/// ```dart
/// NavigationMenuItem(
///   onPressed: () => print('Item pressed'),
///   content: NavigationMenuContent(
///     title: Text('Products'),
///     content: Text('Browse our product catalog'),
///   ),
///   child: Text('Products'),
/// )
/// ```
class NavigationMenuItem extends StatefulWidget {
/// Callback invoked when this menu item is pressed.
///
/// Called when the user taps or clicks on the menu item. This action
/// is independent of content display - items with content can still
/// have onPressed callbacks for additional behavior like navigation.
  VoidCallback? onPressed;
/// The content to display in the navigation menu popover.
///
/// When provided, this widget is rendered in the navigation menu's
/// popover when the item is activated. The item shows a chevron
/// indicator and responds to hover/click interactions to display
/// this content. If null, the item functions as a simple action button.
  Widget? content;
/// The main visual content of the menu item.
///
/// This widget is always displayed as the item's label or trigger.
/// It should clearly represent the item's purpose or destination
/// and is typically a [Text] widget or icon combination.
  Widget child;
/// Creates a [NavigationMenuItem] with the specified properties.
///
/// The [child] parameter is required as it provides the visible
/// content for the menu item. Either [onPressed] or [content]
/// should be provided to make the item interactive.
///
/// Parameters:
/// - [onPressed] (VoidCallback?, optional): Action when item is pressed
/// - [content] (Widget?, optional): Content for navigation popover
/// - [child] (Widget, required): The visible menu item content
///
/// Example:
/// ```dart
/// NavigationMenuItem(
///   onPressed: _handleNavigation,
///   child: Row(
///     children: [Icon(Icons.home), Text('Home')],
///   ),
/// )
/// ```
  const NavigationMenuItem({super.key, this.onPressed, this.content, required this.child});
  State<NavigationMenuItem> createState();
}
/// State class for [NavigationMenuItem] widget.
///
/// Manages the lifecycle and interaction of a single navigation menu item.
class NavigationMenuItemState extends State<NavigationMenuItem> {
  void didChangeDependencies();
  void didUpdateWidget(covariant NavigationMenuItem oldWidget);
  void dispose();
  Widget build(BuildContext context);
}
/// A content item displayed within a navigation menu popover.
///
/// Provides a structured layout for navigation menu content with support
/// for titles, descriptions, leading/trailing widgets, and interactive behavior.
/// This widget is designed to be used within [NavigationMenuItem] content
/// to create rich, informative menu options.
///
/// The content displays as a button with optional leading icon, title text,
/// descriptive content, and trailing elements. When pressed, it can trigger
/// custom actions while maintaining the navigation menu's visual consistency.
///
/// Example:
/// ```dart
/// NavigationMenuContent(
///   leading: Icon(Icons.dashboard),
///   title: Text('Dashboard'),
///   content: Text('View project analytics and metrics'),
///   onPressed: () => Navigator.pushNamed(context, '/dashboard'),
/// )
/// ```
class NavigationMenuContent extends StatelessWidget {
/// The primary title text for this content item.
///
/// Displayed prominently as the main label for this navigation option.
/// Should clearly indicate the destination or action this item represents.
  Widget title;
/// Optional descriptive content shown below the title.
///
/// Provides additional context or explanation for the navigation option.
/// Rendered in a muted text style to maintain visual hierarchy.
  Widget? content;
/// Optional widget displayed before the title.
///
/// Commonly used for icons or other visual indicators that help
/// identify the navigation option at a glance.
  Widget? leading;
/// Optional widget displayed after the title and content.
///
/// Can be used for badges, indicators, or additional actions
/// related to this navigation option.
  Widget? trailing;
/// Callback invoked when this content item is pressed.
///
/// Called when the user taps or clicks on the content item.
/// Typically used for navigation or other actions.
  VoidCallback? onPressed;
/// Creates a [NavigationMenuContent] with the specified properties.
///
/// The [title] parameter is required as it provides the primary
/// label for the navigation option. All other parameters are
/// optional and enhance the content's functionality and appearance.
///
/// Parameters:
/// - [title] (Widget, required): The primary title text
/// - [content] (Widget?, optional): Descriptive text below title
/// - [leading] (Widget?, optional): Icon or widget before title
/// - [trailing] (Widget?, optional): Widget after title and content
/// - [onPressed] (VoidCallback?, optional): Action when item is pressed
///
/// Example:
/// ```dart
/// NavigationMenuContent(
///   leading: Icon(Icons.settings),
///   title: Text('Settings'),
///   content: Text('Manage application preferences'),
///   trailing: Icon(Icons.arrow_forward_ios, size: 16),
///   onPressed: _openSettings,
/// )
/// ```
  const NavigationMenuContent({super.key, required this.title, this.content, this.leading, this.trailing, this.onPressed});
  Widget build(BuildContext context);
}
/// A grid layout container for organizing navigation menu content items.
///
/// Provides flexible grid-based layout for multiple [NavigationMenuContent]
/// items within a navigation menu popover. The layout arranges items in
/// columns and rows with customizable spacing and supports responsive
/// organization of navigation options.
///
/// The grid layout adapts to the number of items and specified column count,
/// creating a structured presentation for complex navigation menus with
/// multiple categories or sections of content.
///
/// Example:
/// ```dart
/// NavigationMenuContentList(
///   crossAxisCount: 2,
///   spacing: 16.0,
///   runSpacing: 12.0,
///   children: [
///     NavigationMenuContent(title: Text('Dashboard'), onPressed: _openDashboard),
///     NavigationMenuContent(title: Text('Analytics'), onPressed: _openAnalytics),
///     NavigationMenuContent(title: Text('Settings'), onPressed: _openSettings),
///   ],
/// )
/// ```
class NavigationMenuContentList extends StatelessWidget {
/// The list of widgets to arrange in the grid layout.
///
/// Typically contains [NavigationMenuContent] items or other
/// navigation-related widgets that should be organized in a grid.
  List<Widget> children;
/// Number of items to display in each row of the grid.
///
/// Controls the grid's column count and affects how items are
/// distributed across rows. Default value is 3 columns.
  int crossAxisCount;
/// Spacing between items within the same row.
///
/// Controls horizontal spacing between grid items. If not specified,
/// uses a default value based on the theme's scaling factor.
  double? spacing;
/// Spacing between rows in the grid.
///
/// Controls vertical spacing between grid rows. If not specified,
/// uses a default value based on the theme's scaling factor.
  double? runSpacing;
/// Whether to reverse the order of columns in each row.
///
/// When true, items are arranged in reverse order within their rows.
/// This can be useful for RTL layouts or specific design requirements.
  bool reverse;
/// Creates a [NavigationMenuContentList] with the specified layout properties.
///
/// The [children] parameter is required and should contain the items
/// to be arranged in the grid. The layout properties control the
/// grid's appearance and spacing.
///
/// Parameters:
/// - [children] (`List<Widget>`, required): Items to arrange in grid
/// - [crossAxisCount] (int, default: 3): Number of columns per row
/// - [spacing] (double?, optional): Horizontal spacing between items
/// - [runSpacing] (double?, optional): Vertical spacing between rows
/// - [reverse] (bool, default: false): Whether to reverse column order
///
/// Example:
/// ```dart
/// NavigationMenuContentList(
///   crossAxisCount: 2,
///   spacing: 20.0,
///   children: menuItems,
/// )
/// ```
  const NavigationMenuContentList({super.key, required this.children, this.crossAxisCount = 3, this.spacing, this.runSpacing, this.reverse = false});
  Widget build(BuildContext context);
}
/// A horizontal navigation menu with dropdown content support.
///
/// Provides a sophisticated navigation component that displays menu items
/// in a horizontal layout with support for dropdown content. When menu items
/// have associated content, hovering or clicking reveals a popover with
/// additional navigation options or information.
///
/// The navigation menu manages popover state, hover interactions, and smooth
/// transitions between different content sections. It supports both simple
/// action items and complex content-rich dropdown menus with animated
/// transitions and responsive behavior.
///
/// The menu uses a popover overlay to display content, which automatically
/// positions itself relative to the trigger and handles edge cases for
/// viewport constraints and user interactions.
///
/// Example:
/// ```dart
/// NavigationMenu(
///   surfaceOpacity: 0.95,
///   surfaceBlur: 8.0,
///   children: [
///     NavigationMenuItem(
///       child: Text('Products'),
///       content: NavigationMenuContentList(
///         children: [
///           NavigationMenuContent(title: Text('Web Apps')),
///           NavigationMenuContent(title: Text('Mobile Apps')),
///         ],
///       ),
///     ),
///     NavigationMenuItem(
///       child: Text('About'),
///       onPressed: () => Navigator.pushNamed(context, '/about'),
///     ),
///   ],
/// )
/// ```
class NavigationMenu extends StatefulWidget {
/// Opacity level for the popover surface background.
///
/// Controls the transparency of the dropdown content's background.
/// Values range from 0.0 (fully transparent) to 1.0 (fully opaque).
/// If not specified, uses the theme's default surface opacity.
  double? surfaceOpacity;
/// Blur effect intensity for the popover surface.
///
/// Controls the backdrop blur effect applied behind the dropdown content.
/// Higher values create more blur. If not specified, uses the theme's
/// default surface blur setting.
  double? surfaceBlur;
/// The list of menu items to display in the navigation menu.
///
/// Each item should be a [NavigationMenuItem] that defines the
/// menu's structure and behavior. Items can have content for
/// dropdown functionality or simple press actions.
  List<Widget> children;
/// Creates a [NavigationMenu] with the specified items and appearance.
///
/// The [children] parameter is required and should contain
/// [NavigationMenuItem] widgets that define the menu structure.
/// Appearance properties are optional and will use theme defaults.
///
/// Parameters:
/// - [surfaceOpacity] (double?, optional): Popover background opacity
/// - [surfaceBlur] (double?, optional): Popover backdrop blur intensity
/// - [children] (`List<Widget>`, required): Menu items to display
///
/// Example:
/// ```dart
/// NavigationMenu(
///   surfaceOpacity: 0.9,
///   children: [
///     NavigationMenuItem(child: Text('Home'), onPressed: _goHome),
///     NavigationMenuItem(child: Text('About'), onPressed: _showAbout),
///   ],
/// )
/// ```
  const NavigationMenu({super.key, this.surfaceOpacity, this.surfaceBlur, required this.children});
  State<NavigationMenu> createState();
}
/// State class for [NavigationMenu] managing menu interactions and timing.
///
/// Handles hover debouncing, popover control, active menu item tracking,
/// and content builder management for navigation menu items.
class NavigationMenuState extends State<NavigationMenu> {
/// Debounce duration for hover interactions to prevent flickering.
  static const Duration kDebounceDuration = Duration(milliseconds: 200);
/// Checks if the given menu item is currently active.
///
/// Parameters:
/// - [item] (`NavigationMenuItemState`, required): the menu item to check
///
/// Returns: `bool` ‚Äî true if the item is active and popover is open
  bool isActive(NavigationMenuItemState item);
  void dispose();
/// Finds a navigation menu item state by its widget.
///
/// Parameters:
/// - [widget] (`Widget`, required): the widget to search for
///
/// Returns: `NavigationMenuItemState?` ‚Äî the state if found, null otherwise
  NavigationMenuItemState? findByWidget(Widget widget);
/// Builds the content for the menu item at the given index.
///
/// Parameters:
/// - [index] (`int`, required): index of the menu item
///
/// Returns: `Widget` ‚Äî the content widget
  Widget buildContent(int index);
/// Closes the currently open popover menu.
  void close();
/// Builds the popover widget for the navigation menu.
///
/// Parameters:
/// - [context] (`BuildContext`, required): build context
///
/// Returns: `Widget` ‚Äî the popover widget
  Widget buildPopover(BuildContext context);
/// Calculates the margin for the popover based on current widget position.
///
/// Returns: `EdgeInsets?` ‚Äî calculated margin or null if render box not available
  EdgeInsets? requestMargin();
  Widget build(BuildContext context);
}
/// {@template menu_theme}
/// Styling options for menu widgets such as [MenuGroup] and [MenuButton].
/// {@endtemplate}
class MenuTheme extends ComponentThemeData {
/// Default padding applied to each menu item.
  EdgeInsets? itemPadding;
/// Offset applied when showing a submenu.
  Offset? subMenuOffset;
/// {@macro menu_theme}
  const MenuTheme({this.itemPadding, this.subMenuOffset});
/// Creates a copy of this theme but with the given fields replaced.
  MenuTheme copyWith({ValueGetter<EdgeInsets?>? itemPadding, ValueGetter<Offset?>? subMenuOffset});
  int get hashCode;
  bool operator ==(Object other);
  String toString();
}
/// Displays a keyboard shortcut in a menu.
///
/// Renders the visual representation of a keyboard shortcut, typically
/// displayed on the right side of menu items.
///
/// Example:
/// ```dart
/// MenuShortcut(
///   activator: SingleActivator(LogicalKeyboardKey.keyS, control: true),
/// )
/// ```
class MenuShortcut extends StatelessWidget {
/// The keyboard shortcut to display.
  ShortcutActivator activator;
/// Widget to display between multiple keys.
  Widget? combiner;
/// Creates a [MenuShortcut].
///
/// Parameters:
/// - [activator] (`ShortcutActivator`, required): The shortcut to display.
/// - [combiner] (`Widget?`, optional): Separator between keys (default: " + ").
  const MenuShortcut({super.key, required this.activator, this.combiner});
  Widget build(BuildContext context);
}
/// Abstract base class for menu item widgets.
///
/// All menu items (buttons, checkboxes, radio buttons, dividers, etc.) must
/// implement this interface. Menu items can be placed within menu groups and
/// support features like leading icons and popover controllers.
///
/// See also:
/// - [MenuButton], clickable menu item
/// - [MenuCheckbox], checkbox menu item
/// - [MenuRadio], radio button menu item
/// - [MenuDivider], divider between menu items
abstract class MenuItem extends Widget {
/// Creates a menu item.
  const MenuItem({super.key});
/// Whether this menu item has a leading widget (icon, checkbox indicator, etc.).
  bool get hasLeading;
/// Optional popover controller for submenu functionality.
  PopoverController? get popoverController;
}
/// Radio button group container for menu items.
///
/// Groups multiple [MenuRadio] items together with shared selection state.
/// Only one radio button in the group can be selected at a time.
///
/// Example:
/// ```dart
/// MenuRadioGroup<String>(
///   value: selectedOption,
///   onChanged: (context, value) => setState(() => selectedOption = value),
///   children: [
///     MenuRadio(value: 'option1', child: Text('Option 1')),
///     MenuRadio(value: 'option2', child: Text('Option 2')),
///   ],
/// )
/// ```
class MenuRadioGroup<T> extends StatelessWidget implements MenuItem {
/// Currently selected value.
  T? value;
/// Callback when selection changes.
  ContextedValueChanged<T>? onChanged;
/// List of [MenuRadio] children.
  List<Widget> children;
/// Creates a radio group for menu items.
///
/// Parameters:
/// - [value] (T?): Currently selected value
/// - [onChanged] (`ContextedValueChanged<T>?`): Selection change callback
/// - [children] (`List<Widget>`): Radio button children
  const MenuRadioGroup({super.key, required this.value, required this.onChanged, required this.children});
  bool get hasLeading;
  PopoverController? get popoverController;
  Widget build(BuildContext context);
}
/// Individual radio button item within a [MenuRadioGroup].
///
/// Displays a radio button indicator when selected and integrates with
/// the parent radio group for selection management.
class MenuRadio<T> extends StatelessWidget {
/// The value this radio button represents.
  T value;
/// Content widget displayed for this option.
  Widget child;
/// Optional trailing widget (e.g., keyboard shortcut).
  Widget? trailing;
/// Focus node for keyboard navigation.
  FocusNode? focusNode;
/// Whether this radio button is enabled.
  bool enabled;
/// Whether selecting this radio closes the menu automatically.
  bool autoClose;
/// Creates a radio button menu item.
///
/// Must be a child of [MenuRadioGroup].
///
/// Parameters:
/// - [value] (T, required): Value for this option
/// - [child] (Widget, required): Display content
/// - [trailing] (Widget?): Optional trailing widget
/// - [focusNode] (FocusNode?): Focus node for navigation
/// - [enabled] (bool): Whether enabled, defaults to true
/// - [autoClose] (bool): Whether to auto-close menu, defaults to true
  const MenuRadio({super.key, required this.value, required this.child, this.trailing, this.focusNode, this.enabled = true, this.autoClose = true});
  Widget build(BuildContext context);
}
/// Visual divider between menu items.
///
/// Renders a horizontal or vertical line to separate groups of menu items.
/// Automatically adapts direction based on the parent menu's orientation.
///
/// Example:
/// ```dart
/// MenuGroup(
///   children: [
///     MenuButton(child: Text('Cut')),
///     MenuButton(child: Text('Copy')),
///     MenuDivider(), // Separator
///     MenuButton(child: Text('Paste')),
///   ],
/// )
/// ```
class MenuDivider extends StatelessWidget implements MenuItem {
/// Creates a menu divider.
  const MenuDivider({super.key});
  Widget build(BuildContext context);
  bool get hasLeading;
  PopoverController? get popoverController;
}
/// Spacing gap between menu items.
///
/// Creates empty vertical or horizontal space within a menu, based on
/// the menu's direction. Useful for visually grouping related items.
class MenuGap extends StatelessWidget implements MenuItem {
/// Size of the gap in logical pixels.
  double size;
/// Creates a menu gap.
///
/// Parameters:
/// - [size] (double, required): Gap size in logical pixels
  const MenuGap(this.size, {super.key});
  Widget build(BuildContext context);
  bool get hasLeading;
  PopoverController? get popoverController;
}
/// Clickable button menu item with optional submenu support.
///
/// Primary menu item type that responds to user interaction. Can display
/// leading icons, trailing widgets (shortcuts), and nested submenus.
///
/// Example:
/// ```dart
/// MenuButton(
///   leading: Icon(Icons.cut),
///   trailing: Text('Ctrl+X').textSmall().muted(),
///   onPressed: (context) => _handleCut(),
///   child: Text('Cut'),
/// )
/// ```
class MenuButton extends StatefulWidget implements MenuItem {
/// Content widget displayed in the button.
  Widget child;
/// Optional submenu items shown on hover or click.
  List<MenuItem>? subMenu;
/// Callback when button is pressed.
  ContextedCallback? onPressed;
/// Optional trailing widget (e.g., keyboard shortcut indicator).
  Widget? trailing;
/// Optional leading widget (e.g., icon).
  Widget? leading;
/// Whether the button is enabled for interaction.
  bool enabled;
/// Focus node for keyboard navigation.
  FocusNode? focusNode;
/// Whether selecting this button closes the menu automatically.
  bool autoClose;
  PopoverController? popoverController;
/// Creates a menu button.
///
/// Parameters:
/// - [child] (Widget, required): Main content
/// - [subMenu] (`List<MenuItem>?`): Optional nested submenu
/// - [onPressed] (ContextedCallback?): Click handler
/// - [trailing] (Widget?): Trailing widget
/// - [leading] (Widget?): Leading icon or widget
/// - [enabled] (bool): Whether enabled, defaults to true
/// - [focusNode] (FocusNode?): Focus node
/// - [autoClose] (bool): Auto-close behavior, defaults to true
/// - [popoverController] (PopoverController?): Optional popover controller
  const MenuButton({super.key, required this.child, this.subMenu, this.onPressed, this.trailing, this.leading, this.enabled = true, this.focusNode, this.autoClose = true, this.popoverController});
  State<MenuButton> createState();
  bool get hasLeading;
}
/// Non-interactive label menu item.
///
/// Displays text or content without click handlers. Useful for section
/// headers or informational text within menus.
///
/// Example:
/// ```dart
/// MenuLabel(
///   leading: Icon(Icons.settings),
///   child: Text('Settings').semiBold(),
/// )
/// ```
class MenuLabel extends StatelessWidget implements MenuItem {
/// Content widget displayed in the label.
  Widget child;
/// Optional trailing widget.
  Widget? trailing;
/// Optional leading widget (e.g., icon).
  Widget? leading;
/// Creates a menu label.
///
/// Parameters:
/// - [child] (Widget, required): Main content
/// - [trailing] (Widget?): Trailing widget
/// - [leading] (Widget?): Leading icon or widget
  const MenuLabel({super.key, required this.child, this.trailing, this.leading});
  bool get hasLeading;
  PopoverController? get popoverController;
  Widget build(BuildContext context);
}
/// Checkbox menu item with checked/unchecked state.
///
/// Displays a checkmark when selected. Used for togglable menu options.
///
/// Example:
/// ```dart
/// MenuCheckbox(
///   value: showToolbar,
///   onChanged: (context, value) => setState(() => showToolbar = value),
///   child: Text('Show Toolbar'),
/// )
/// ```
class MenuCheckbox extends StatelessWidget implements MenuItem {
/// Current checked state.
  bool value;
/// Callback when checkbox state changes.
  ContextedValueChanged<bool>? onChanged;
/// Content widget displayed for this option.
  Widget child;
/// Optional trailing widget (e.g., keyboard shortcut).
  Widget? trailing;
/// Whether this checkbox is enabled.
  bool enabled;
/// Whether checking this box closes the menu automatically.
  bool autoClose;
/// Creates a checkbox menu item.
///
/// Parameters:
/// - [value] (bool): Current checked state, defaults to false
/// - [onChanged] (`ContextedValueChanged<bool>?`): State change callback
/// - [child] (Widget, required): Display content
/// - [trailing] (Widget?): Optional trailing widget
/// - [enabled] (bool): Whether enabled, defaults to true
/// - [autoClose] (bool): Whether to auto-close menu, defaults to true
  const MenuCheckbox({super.key, this.value = false, this.onChanged, required this.child, this.trailing, this.enabled = true, this.autoClose = true});
  bool get hasLeading;
  PopoverController? get popoverController;
  Widget build(BuildContext context);
}
/// Data class containing menu group state and configuration.
///
/// Manages the hierarchical structure of menu groups, tracking parent-child
/// relationships, popover state, and layout properties. Used internally by
/// the menu system to coordinate behavior across nested menus.
class MenuGroupData {
/// Parent menu group, null for root menus.
  MenuGroupData? parent;
/// Child menu items' data.
  List<MenuData> children;
/// Whether any child items have leading widgets.
  bool hasLeading;
/// Offset for positioning submenus relative to parent.
  Offset? subMenuOffset;
/// Callback when menu is dismissed.
  VoidCallback? onDismissed;
/// Region group ID for tap region management.
  Object? regionGroupId;
/// Layout direction (horizontal or vertical).
  Axis direction;
/// Padding around menu items.
  EdgeInsets itemPadding;
/// Focus scope state for keyboard navigation.
  SubFocusScopeState focusScope;
/// Creates menu group data.
///
/// Parameters:
/// - [parent] (MenuGroupData?): Parent group
/// - [children] (`List<MenuData>`): Child items
/// - [hasLeading] (bool): Whether items have leading widgets
/// - [subMenuOffset] (Offset?): Submenu offset
/// - [onDismissed] (VoidCallback?): Dismissal callback
/// - [regionGroupId] (Object?): Region group ID
/// - [direction] (Axis): Layout direction
/// - [itemPadding] (EdgeInsets): Item padding
/// - [focusScope] (SubFocusScopeState): Focus scope
  MenuGroupData(this.parent, this.children, this.hasLeading, this.subMenuOffset, this.onDismissed, this.regionGroupId, this.direction, this.itemPadding, this.focusScope);
/// Checks if any child menu items have open popovers.
///
/// Returns true if at least one child has an open submenu popover.
  bool get hasOpenPopovers;
/// Closes all open popovers in child menu items.
///
/// Iterates through children and closes any open submenu popovers.
  void closeOthers();
/// Closes all menus in the hierarchy by bubbling up to root.
///
/// Recursively closes popovers in parent groups and invokes the
/// dismissal callback at the root level.
  void closeAll();
  bool operator ==(Object other);
/// Gets the root menu group in the hierarchy.
///
/// Traverses up the parent chain to find the topmost menu group.
///
/// Returns the root [MenuGroupData].
  MenuGroupData get root;
  int get hashCode;
  String toString();
}
/// Data container for individual menu item state.
///
/// Wraps a popover controller for each menu item, managing submenu
/// display and interaction state.
class MenuData {
/// Controller for this item's submenu popover.
  PopoverController popoverController;
/// Creates menu item data.
///
/// Parameters:
/// - [popoverController] (PopoverController?): Optional controller, creates default if null
  MenuData({PopoverController? popoverController});
}
/// Container widget for organizing menu items into a group.
///
/// Provides layout, focus management, and keyboard navigation for a collection
/// of menu items. Supports both horizontal and vertical orientations, nested
/// submenus, and customizable actions.
///
/// Example:
/// ```dart
/// MenuGroup(
///   direction: Axis.vertical,
///   builder: (context, children) => Column(children: children),
///   children: [
///     MenuButton(child: Text('Cut')),
///     MenuButton(child: Text('Copy')),
///     MenuDivider(),
///     MenuButton(child: Text('Paste')),
///   ],
/// )
/// ```
class MenuGroup extends StatefulWidget {
/// List of menu item widgets.
  List<MenuItem> children;
/// Builder function that layouts the menu items.
  Widget Function(BuildContext context, List<Widget> children) builder;
/// Parent menu group for nested submenus.
  MenuGroupData? parent;
/// Offset for positioning submenus.
  Offset? subMenuOffset;
/// Callback when menu is dismissed.
  VoidCallback? onDismissed;
/// Region group ID for tap region management.
  Object? regionGroupId;
/// Layout direction (horizontal or vertical).
  Axis direction;
/// Custom keyboard actions.
  Map<Type, Action> actions;
/// Padding around menu items.
  EdgeInsets? itemPadding;
/// Whether to autofocus on mount.
  bool autofocus;
/// Optional focus node for keyboard navigation.
  FocusNode? focusNode;
/// Creates a menu group.
///
/// Parameters:
/// - [children] (`List<MenuItem>`, required): Menu items
/// - [builder] (Function, required): Layout builder
/// - [direction] (Axis, required): Layout direction
/// - [parent] (MenuGroupData?): Parent group for nesting
/// - [subMenuOffset] (Offset?): Submenu positioning offset
/// - [onDismissed] (VoidCallback?): Dismissal callback
/// - [regionGroupId] (Object?): Tap region group ID
/// - [actions] (`Map<Type, Action>`): Custom actions, defaults to empty
/// - [itemPadding] (EdgeInsets?): Item padding
/// - [autofocus] (bool): Auto-focus behavior, defaults to true
/// - [focusNode] (FocusNode?): Focus node
  const MenuGroup({super.key, required this.children, required this.builder, this.parent, this.subMenuOffset, this.onDismissed, this.regionGroupId, this.actions = const {}, required this.direction, this.itemPadding, this.autofocus = true, this.focusNode});
  State<MenuGroup> createState();
}
/// Intent for closing the current menu via keyboard action.
///
/// Used with keyboard shortcuts to dismiss open menus.
class CloseMenuIntent extends Intent {
/// Creates a close menu intent.
  const CloseMenuIntent();
}
/// Intent for opening a submenu via keyboard action.
///
/// Triggers submenu expansion when navigating with keyboard.
class OpenSubMenuIntent extends Intent {
/// Creates an open submenu intent.
  const OpenSubMenuIntent();
}
/// Intent for moving focus to next/previous menu item.
///
/// Used for keyboard navigation within menus (Tab/Shift+Tab).
class NextMenuFocusIntent extends Intent {
/// Whether to move focus forward (true) or backward (false).
  bool forward;
/// Creates a next menu focus intent.
///
/// Parameters:
/// - [forward] (bool, required): Direction of focus movement
  const NextMenuFocusIntent(this.forward);
}
/// Overlay handler specialized for menu popover display.
///
/// Delegates to an [OverlayManager] to show menu popovers with
/// appropriate positioning, transitions, and dismissal behavior.
class MenuOverlayHandler extends OverlayHandler {
/// The overlay manager handling menu display.
  OverlayManager manager;
/// Creates a menu overlay handler.
///
/// Parameters:
/// - [manager] (OverlayManager, required): Overlay manager for menu display
  const MenuOverlayHandler(this.manager);
  OverlayCompleter<T?> show<T>({required BuildContext context, required AlignmentGeometry alignment, required WidgetBuilder builder, Offset? position, AlignmentGeometry? anchorAlignment, PopoverConstraint widthConstraint = PopoverConstraint.flexible, PopoverConstraint heightConstraint = PopoverConstraint.flexible, Key? key, bool rootOverlay = true, bool modal = true, bool barrierDismissable = true, Clip clipBehavior = Clip.none, Object? regionGroupId, Offset? offset, AlignmentGeometry? transitionAlignment, EdgeInsetsGeometry? margin, bool follow = true, bool consumeOutsideTaps = true, ValueChanged<PopoverOverlayWidgetState>? onTickFollow, bool allowInvertHorizontal = true, bool allowInvertVertical = true, bool dismissBackdropFocus = true, Duration? showDuration, Duration? dismissDuration, OverlayBarrier? overlayBarrier, LayerLink? layerLink});
}
/// Intent for directional focus traversal within menus.
///
/// Used for arrow key navigation (up, down, left, right) within menu structures.
class DirectionalMenuFocusIntent extends Intent {
/// Direction of focus traversal.
  TraversalDirection direction;
/// Creates a directional menu focus intent.
///
/// Parameters:
/// - [direction] (TraversalDirection, required): Traversal direction
  const DirectionalMenuFocusIntent(this.direction);
}
/// Theme configuration for [Menubar] appearance and layout.
///
/// MenubarTheme defines the visual styling for menubar components including
/// borders, colors, positioning, and spacing. All properties are optional
/// and fall back to theme defaults when not specified.
///
/// The theme controls both the menubar container appearance and the behavior
/// of submenu positioning when menu items are opened.
///
/// Example:
/// ```dart
/// ComponentTheme<MenubarTheme>(
///   data: MenubarTheme(
///     border: true,
///     backgroundColor: Colors.white,
///     borderColor: Colors.grey,
///     borderRadius: BorderRadius.circular(8),
///     padding: EdgeInsets.symmetric(horizontal: 8, vertical: 4),
///     subMenuOffset: Offset(0, 8),
///   ),
///   child: Menubar(...),
/// )
/// ```
/// Theme for [Menubar].
class MenubarTheme extends ComponentThemeData {
/// Whether to draw a border around the menubar container.
///
/// Type: `bool?`. If null, uses the widget's border property. When true,
/// the menubar is wrapped with an outlined container with customizable
/// border color and radius.
  bool? border;
/// Positioning offset for submenu popovers when menu items are opened.
///
/// Type: `Offset?`. If null, uses calculated defaults based on border
/// presence. Controls where submenus appear relative to their parent items.
  Offset? subMenuOffset;
/// Internal padding within the menubar container.
///
/// Type: `EdgeInsetsGeometry?`. If null, uses 4 logical pixels on all sides
/// scaled by theme scaling. Applied inside the border when present.
  EdgeInsetsGeometry? padding;
/// Color of the border when [border] is enabled.
///
/// Type: `Color?`. If null, uses the theme's border color. Only visible
/// when [border] is true.
  Color? borderColor;
/// Background color of the menubar container.
///
/// Type: `Color?`. If null, uses the theme's background color. Applied
/// to the menubar's container element.
  Color? backgroundColor;
/// Border radius for the menubar container corners.
///
/// Type: `BorderRadiusGeometry?`. If null, uses the theme's medium border
/// radius. Only visible when [border] is true.
  BorderRadiusGeometry? borderRadius;
/// Creates a [MenubarTheme].
  const MenubarTheme({this.border, this.subMenuOffset, this.padding, this.borderColor, this.backgroundColor, this.borderRadius});
/// Returns a copy of this theme with the given fields replaced.
  MenubarTheme copyWith({ValueGetter<bool?>? border, ValueGetter<Offset?>? subMenuOffset, ValueGetter<EdgeInsetsGeometry?>? padding, ValueGetter<Color?>? borderColor, ValueGetter<Color?>? backgroundColor, ValueGetter<BorderRadiusGeometry?>? borderRadius});
  bool operator ==(Object other);
  int get hashCode;
}
/// A horizontal menubar widget for displaying application menus and menu items.
///
/// Menubar provides a classic application-style menu interface with horizontal
/// layout and dropdown submenu support. It organizes menu items in a row format
/// similar to traditional desktop application menubars, with each item capable
/// of revealing dropdown menus when activated.
///
/// The menubar supports hierarchical menu structures through MenuItem widgets
/// that can contain nested menu items. It handles focus management, keyboard
/// navigation, and proper popover positioning for submenu display.
///
/// Features:
/// - Horizontal layout of top-level menu items
/// - Dropdown submenu support with configurable positioning
/// - Optional border and styling customization
/// - Keyboard navigation and accessibility support
/// - Focus region management for proper menu behavior
/// - Automatic sizing and layout adaptation
/// - Theme-aware styling with comprehensive customization options
///
/// The widget integrates with the MenuGroup system to provide consistent
/// menu behavior across different contexts and supports both bordered and
/// borderless display modes.
///
/// Example:
/// ```dart
/// Menubar(
///   border: true,
///   children: [
///     MenuItem(
///       title: Text('File'),
///       children: [
///         MenuItem(
///           title: Text('New'),
///           onPressed: () => createNewFile(),
///         ),
///         MenuItem(
///           title: Text('Open'),
///           onPressed: () => openFile(),
///         ),
///         MenuDivider(),
///         MenuItem(
///           title: Text('Exit'),
///           onPressed: () => exitApp(),
///         ),
///       ],
///     ),
///     MenuItem(
///       title: Text('Edit'),
///       children: [
///         MenuItem(title: Text('Cut')),
///         MenuItem(title: Text('Copy')),
///         MenuItem(title: Text('Paste')),
///       ],
///     ),
///   ],
/// )
/// ```
class Menubar extends StatefulWidget {
/// List of menu items to display in the menubar.
///
/// Type: `List<MenuItem>`. Each MenuItem represents a top-level menu that
/// can contain nested menu items for dropdown functionality. Items are
/// displayed horizontally in the order provided.
  List<MenuItem> children;
/// Positioning offset for submenu popovers when items are opened.
///
/// Type: `Offset?`. If null, uses theme defaults or calculated values based
/// on border presence. Controls where dropdown menus appear relative to
/// their parent menu items.
  Offset? popoverOffset;
/// Whether to draw a border around the menubar container.
///
/// Type: `bool`, default: `true`. When true, the menubar is wrapped with
/// an outlined container using theme colors and border radius.
  bool border;
/// Creates a [Menubar] with horizontal menu layout.
///
/// Configures a horizontal menubar that displays menu items and supports
/// dropdown submenus with customizable styling and positioning.
///
/// Parameters:
/// - [key] (Key?): Widget identifier for the widget tree
/// - [children] (`List<MenuItem>`, required): Menu items to display horizontally
/// - [popoverOffset] (Offset?, optional): Positioning offset for dropdown menus
/// - [border] (bool, default: true): Whether to show a border around the menubar
///
/// Example:
/// ```dart
/// Menubar(
///   border: true,
///   popoverOffset: Offset(0, 8),
///   children: [
///     MenuItem(
///       title: Text('View'),
///       children: [
///         MenuItem(title: Text('Zoom In')),
///         MenuItem(title: Text('Zoom Out')),
///         MenuDivider(),
///         MenuItem(title: Text('Full Screen')),
///       ],
///     ),
///     MenuItem(
///       title: Text('Tools'),
///       children: [
///         MenuItem(title: Text('Preferences')),
///         MenuItem(title: Text('Extensions')),
///       ],
///     ),
///   ],
/// )
/// ```
  const Menubar({super.key, this.popoverOffset, this.border = true, required this.children});
  State<Menubar> createState();
}
/// State class for [Menubar] widget.
///
/// Manages the rendering and theming of the menubar container.
class MenubarState extends State<Menubar> {
  Widget build(BuildContext context);
/// Builds the container widget for the menubar.
///
/// Parameters:
/// - [context] (`BuildContext`, required): build context
/// - [theme] (`ThemeData`, required): theme data
/// - [subMenuOffset] (`Offset?`, optional): offset for submenu positioning
/// - [border] (`bool`, required): whether to show border
///
/// Returns: `Widget` ‚Äî container with menu items
  Widget buildContainer(BuildContext context, ThemeData theme, Offset? subMenuOffset, bool border);
}
/// A theme for [MenuPopup].
class MenuPopupTheme extends ComponentThemeData {
/// The opacity of the surface.
  double? surfaceOpacity;
/// The blur applied to the surface.
  double? surfaceBlur;
/// The padding inside the popup.
  EdgeInsetsGeometry? padding;
/// The background color of the popup.
  Color? fillColor;
/// The border color of the popup.
  Color? borderColor;
/// The border radius of the popup.
  BorderRadiusGeometry? borderRadius;
/// Creates a [MenuPopupTheme].
  const MenuPopupTheme({this.surfaceOpacity, this.surfaceBlur, this.padding, this.fillColor, this.borderColor, this.borderRadius});
/// Returns a copy of this theme with the given fields replaced.
  MenuPopupTheme copyWith({ValueGetter<double?>? surfaceOpacity, ValueGetter<double?>? surfaceBlur, ValueGetter<EdgeInsetsGeometry?>? padding, ValueGetter<Color?>? fillColor, ValueGetter<Color?>? borderColor, ValueGetter<BorderRadiusGeometry?>? borderRadius});
  bool operator ==(Object other);
  int get hashCode;
}
/// A styled container widget for displaying popup menus.
///
/// Provides a consistent visual container for menu items with customizable
/// appearance including background, borders, padding, and surface effects.
/// Automatically adapts its layout based on context (sheet overlay, dialog, etc.).
///
/// Features:
/// - **Surface Effects**: Configurable opacity and blur for backdrop
/// - **Styled Border**: Custom border color and radius
/// - **Flexible Layout**: Automatically adjusts for vertical/horizontal menus
/// - **Scrollable**: Content scrolls when it exceeds available space
/// - **Themeable**: Integrates with component theming system
///
/// Typically used as a container for menu items within dropdown menus,
/// context menus, or other popup menu components.
///
/// Example:
/// ```dart
/// MenuPopup(
///   padding: EdgeInsets.all(8),
///   fillColor: Colors.white,
///   borderRadius: BorderRadius.circular(8),
///   children: [
///     MenuItem(title: Text('Option 1')),
///     MenuItem(title: Text('Option 2')),
///     MenuItem(title: Text('Option 3')),
///   ],
/// )
/// ```
///
/// See also:
/// - [MenuPopupTheme] for theming options
/// - [MenuItem] for individual menu items
/// - [DropdownMenu] for complete dropdown menu implementation
class MenuPopup extends StatelessWidget {
/// Opacity of the surface blur effect.
///
/// Controls the transparency of the backdrop blur. Higher values make
/// the blur more visible. If `null`, uses theme default.
  double? surfaceOpacity;
/// Amount of blur to apply to the surface behind the popup.
///
/// Higher values create more blur effect. If `null`, uses theme default.
  double? surfaceBlur;
/// Internal padding around the menu items.
///
/// Defines the space between the popup's border and its content.
/// If `null`, uses theme default or adaptive default based on overlay type.
  EdgeInsetsGeometry? padding;
/// Background fill color of the popup.
///
/// If `null`, uses the theme's popover color.
  Color? fillColor;
/// Border color of the popup.
///
/// If `null`, uses the theme's border color.
  Color? borderColor;
/// Corner radius of the popup border.
///
/// If `null`, uses the theme's medium border radius.
  BorderRadiusGeometry? borderRadius;
/// The menu items to display inside the popup.
///
/// Typically a list of [MenuItem] widgets or similar menu components.
  List<Widget> children;
/// Creates a menu popup container.
///
/// Parameters:
/// - [children]: Menu items to display (required)
/// - [surfaceOpacity]: Backdrop blur opacity
/// - [surfaceBlur]: Amount of surface blur
/// - [padding]: Internal padding
/// - [fillColor]: Background color
/// - [borderColor]: Border color
/// - [borderRadius]: Corner radius
  const MenuPopup({super.key, this.surfaceOpacity, this.surfaceBlur, this.padding, this.fillColor, this.borderColor, this.borderRadius, required this.children});
  Widget build(BuildContext context);
}
/// Shows a dropdown menu overlay at a specified position or anchored to a widget.
///
/// Creates and displays a dropdown menu as an overlay, with full control over
/// positioning, alignment, sizing, and behavior. Returns an [OverlayCompleter]
/// that resolves when the menu is dismissed, optionally with a selected value.
///
/// This is a low-level function typically used by higher-level dropdown components.
/// For most use cases, prefer using [DropdownMenu] or similar widgets.
///
/// Key Features:
/// - **Flexible Positioning**: Anchor to widget or absolute position
/// - **Auto-sizing**: Constraint-based width/height
/// - **Smart Alignment**: Auto-inverts to stay on screen
/// - **Following**: Menu follows anchor when it moves
/// - **Modal/Non-modal**: Configurable interaction blocking
///
/// Parameters:
/// - [context]: Build context for overlay insertion (required)
/// - [builder]: Widget builder for menu content (required)
/// - [position]: Absolute position override
/// - [anchorAlignment]: Alignment on the anchor widget
/// - [widthConstraint]: Width sizing behavior (defaults to flexible)
/// - [heightConstraint]: Height sizing behavior (defaults to flexible)
/// - [key]: Key for the overlay widget
/// - [rootOverlay]: Use root overlay vs nearest (defaults to `true`)
/// - [modal]: Block interactions outside menu (defaults to `true`)
/// - [clipBehavior]: How to clip overflow (defaults to [Clip.none])
/// - [regionGroupId]: Grouping ID for related overlays
/// - [offset]: Additional offset from anchor
/// - [transitionAlignment]: Alignment for show/hide transitions
/// - [alignment]: Menu alignment relative to anchor
/// - [margin]: Outer margin around menu
/// - [follow]: Track anchor movement (defaults to `true`)
/// - [consumeOutsideTaps]: Dismiss on outside taps (defaults to `false`)
/// - [onTickFollow]: Callback during follow updates
/// - [allowInvertHorizontal]: Allow horizontal flip to stay on screen (defaults to `true`)
/// - [allowInvertVertical]: Allow vertical flip to stay on screen (defaults to `true`)
/// - [dismissBackdropFocus]: Dismiss when clicking backdrop (defaults to `true`)
/// - [showDuration]: Custom show animation duration
/// - [dismissDuration]: Custom dismiss animation duration
///
/// Returns an [OverlayCompleter] that resolves to the selected value when dismissed.
///
/// Example:
/// ```dart
/// final result = showDropdown<String>(
///   context: context,
///   builder: (context) => DropdownMenu(
///     children: [
///       MenuItem(title: Text('Option 1'), onTap: () => Navigator.pop(context, 'opt1')),
///       MenuItem(title: Text('Option 2'), onTap: () => Navigator.pop(context, 'opt2')),
///     ],
///   ),
/// );
/// final selected = await result.future;
/// print('Selected: $selected');
/// ```
OverlayCompleter<T?> showDropdown<T>({required BuildContext context, required WidgetBuilder builder, Offset? position, AlignmentGeometry? anchorAlignment, PopoverConstraint widthConstraint = PopoverConstraint.flexible, PopoverConstraint heightConstraint = PopoverConstraint.flexible, Key? key, bool rootOverlay = true, bool modal = true, Clip clipBehavior = Clip.none, Object? regionGroupId, Offset? offset, AlignmentGeometry? transitionAlignment, AlignmentGeometry? alignment, EdgeInsetsGeometry? margin, bool follow = true, bool consumeOutsideTaps = false, ValueChanged<PopoverOverlayWidgetState>? onTickFollow, bool allowInvertHorizontal = true, bool allowInvertVertical = true, bool dismissBackdropFocus = true, Duration? showDuration, Duration? dismissDuration});
/// Internal data class for dropdown menu context.
///
/// Holds shared data for dropdown menu implementation, including a unique
/// key for region grouping and overlay coordination.
///
/// This is typically used internally by the dropdown menu system and not
/// intended for direct use in application code.
class DropdownMenuData {
/// Unique key identifying this dropdown menu instance.
///
/// Used for coordinating overlays and region-based interactions.
  GlobalKey key;
/// Creates dropdown menu data with the specified key.
  DropdownMenuData(this.key);
}
/// Theme for [DropdownMenu].
class DropdownMenuTheme extends ComponentThemeData {
/// Surface opacity for the popup container.
  double? surfaceOpacity;
/// Surface blur for the popup container.
  double? surfaceBlur;
/// Creates a [DropdownMenuTheme].
  const DropdownMenuTheme({this.surfaceOpacity, this.surfaceBlur});
/// Returns a copy of this theme with the given fields replaced.
  DropdownMenuTheme copyWith({ValueGetter<double?>? surfaceOpacity, ValueGetter<double?>? surfaceBlur});
  bool operator ==(Object other);
  int get hashCode;
}
/// A dropdown menu widget that displays a list of menu items in a popup.
///
/// Provides a styled dropdown menu with vertical layout, automatic sizing,
/// and theme integration. Wraps menu items in a [MenuPopup] container with
/// appropriate padding and spacing for dropdown contexts.
///
/// Features:
/// - **Vertical Layout**: Displays menu items in a column
/// - **Auto-sizing**: Minimum width constraint of 192px
/// - **Surface Effects**: Configurable backdrop blur and opacity
/// - **Nested Menus**: Supports sub-menus with proper offset
/// - **Sheet Adaptation**: Adjusts padding for sheet overlay contexts
/// - **Auto-dismiss**: Closes when items are selected
///
/// Typically used with [showDropdown] function or as part of dropdown
/// button implementations. Menu items are provided as [MenuItem] widgets.
///
/// Example:
/// ```dart
/// DropdownMenu(
///   children: [
///     MenuItem(
///       title: Text('New File'),
///       leading: Icon(Icons.add),
///       onTap: () => createFile(),
///     ),
///     MenuItem(
///       title: Text('Open'),
///       trailing: Text('Ctrl+O'),
///       onTap: () => openFile(),
///     ),
///     MenuItem.divider(),
///     MenuItem(
///       title: Text('Exit'),
///       onTap: () => exit(),
///     ),
///   ],
/// )
/// ```
///
/// See also:
/// - [MenuItem] for individual menu items
/// - [MenuPopup] for the popup container
/// - [showDropdown] for displaying dropdowns programmatically
class DropdownMenu extends StatefulWidget {
/// Opacity of the surface blur effect.
///
/// If `null`, uses theme default.
  double? surfaceOpacity;
/// Amount of blur to apply to the surface.
///
/// If `null`, uses theme default.
  double? surfaceBlur;
/// Menu items to display in the dropdown.
///
/// Each item should be a [MenuItem] or similar menu component.
  List<MenuItem> children;
/// Creates a dropdown menu.
///
/// Parameters:
/// - [children]: Menu items to display (required)
/// - [surfaceOpacity]: Backdrop blur opacity
/// - [surfaceBlur]: Amount of surface blur
  const DropdownMenu({super.key, this.surfaceOpacity, this.surfaceBlur, required this.children});
  State<DropdownMenu> createState();
}
/// Theme for [ContextMenuPopup] and context menu widgets.
class ContextMenuTheme extends ComponentThemeData {
/// Surface opacity for the popup container.
  double? surfaceOpacity;
/// Surface blur for the popup container.
  double? surfaceBlur;
/// Creates a [ContextMenuTheme].
  const ContextMenuTheme({this.surfaceOpacity, this.surfaceBlur});
/// Returns a copy of this theme with the given fields replaced.
  ContextMenuTheme copyWith({ValueGetter<double?>? surfaceOpacity, ValueGetter<double?>? surfaceBlur});
  bool operator ==(Object other);
  int get hashCode;
}
/// Context menu for editable text fields on desktop platforms.
///
/// Provides standard text editing actions like cut, copy, paste, select all,
/// and undo/redo. Automatically integrates with EditableText state.
///
/// Typically used internally by text input widgets.
class DesktopEditableTextContextMenu extends StatelessWidget {
/// Build context for positioning the menu.
  BuildContext anchorContext;
/// State of the editable text field.
  EditableTextState editableTextState;
/// Optional controller for undo/redo functionality.
  UndoHistoryController? undoHistoryController;
/// Creates a [DesktopEditableTextContextMenu].
///
/// Parameters:
/// - [anchorContext] (`BuildContext`, required): Anchor context.
/// - [editableTextState] (`EditableTextState`, required): Text field state.
/// - [undoHistoryController] (`UndoHistoryController?`, optional): Undo controller.
  const DesktopEditableTextContextMenu({super.key, required this.anchorContext, required this.editableTextState, this.undoHistoryController});
  Widget build(BuildContext context);
}
/// Context menu for editable text fields on mobile platforms.
///
/// Similar to [DesktopEditableTextContextMenu] but optimized for mobile
/// with horizontal layout and no keyboard shortcuts displayed.
///
/// Typically used internally by text input widgets on mobile platforms.
class MobileEditableTextContextMenu extends StatelessWidget {
/// Build context for positioning the menu.
  BuildContext anchorContext;
/// State of the editable text field.
  EditableTextState editableTextState;
/// Optional controller for undo/redo functionality.
  UndoHistoryController? undoHistoryController;
/// Creates a [MobileEditableTextContextMenu].
///
/// Parameters:
/// - [anchorContext] (`BuildContext`, required): Anchor context.
/// - [editableTextState] (`EditableTextState`, required): Text field state.
/// - [undoHistoryController] (`UndoHistoryController?`, optional): Undo controller.
  const MobileEditableTextContextMenu({super.key, required this.anchorContext, required this.editableTextState, this.undoHistoryController});
  Widget build(BuildContext context);
}
/// Builds an appropriate context menu for editable text based on platform.
///
/// Automatically selects between desktop and mobile context menu implementations
/// based on the current platform.
///
/// Parameters:
/// - [innerContext] (`BuildContext`, required): Build context.
/// - [editableTextState] (`EditableTextState`, required): Text field state.
/// - [undoHistoryController] (`UndoHistoryController?`, optional): Undo controller.
/// - [platform] (`TargetPlatform?`, optional): Override platform detection.
///
/// Note: If [platform] is not provided, it will be inferred from the theme, and
/// on web, it may be treated as mobile on small screens (width < height * 0.8).
///
/// Returns: Platform-appropriate context menu widget.
Widget buildEditableTextContextMenu(BuildContext innerContext, EditableTextState editableTextState, {UndoHistoryController? undoHistoryController, TargetPlatform? platform});
/// A widget that shows a context menu when right-clicked or long-pressed.
///
/// Wraps a child widget and displays a customizable menu on context menu triggers.
///
/// Example:
/// ```dart
/// ContextMenu(
///   items: [
///     MenuButton(onPressed: (_) => print('Edit'), child: Text('Edit')),
///     MenuButton(onPressed: (_) => print('Delete'), child: Text('Delete')),
///   ],
///   child: Container(child: Text('Right-click me')),
/// )
/// ```
class ContextMenu extends StatefulWidget {
/// The child widget that triggers the context menu.
  Widget child;
/// Menu items to display in the context menu.
  List<MenuItem> items;
/// How hit testing behaves for the child.
  HitTestBehavior behavior;
/// Direction to lay out menu items.
  Axis direction;
/// Whether the context menu is enabled.
  bool enabled;
/// Creates a [ContextMenu].
///
/// Parameters:
/// - [child] (`Widget`, required): Widget that triggers menu.
/// - [items] (`List<MenuItem>`, required): Menu items.
/// - [behavior] (`HitTestBehavior`, optional): Hit test behavior.
/// - [direction] (`Axis`, optional): Menu layout direction.
/// - [enabled] (`bool`, optional): Whether menu is enabled.
  const ContextMenu({super.key, required this.child, required this.items, this.behavior = HitTestBehavior.translucent, this.direction = Axis.vertical, this.enabled = true});
  State<ContextMenu> createState();
}
/// Internal widget for rendering a context menu popup.
///
/// Displays the actual menu content in an overlay with positioning and theming.
/// Typically used internally by [ContextMenu].
class ContextMenuPopup extends StatelessWidget {
/// Build context for anchoring the popup.
  BuildContext anchorContext;
/// Position to display the popup.
  Offset position;
/// Menu items to display.
  List<MenuItem> children;
/// Captured themes for consistent styling.
  CapturedThemes? themes;
/// Direction to lay out menu items.
  Axis direction;
/// Callback when popup follows the anchor.
  ValueChanged<PopoverOverlayWidgetState>? onTickFollow;
/// Size of the anchor widget.
  Size? anchorSize;
/// Creates a [ContextMenuPopup].
///
/// Parameters:
/// - [anchorContext] (`BuildContext`, required): Anchor context.
/// - [position] (`Offset`, required): Popup position.
/// - [children] (`List<MenuItem>`, required): Menu items.
/// - [themes] (`CapturedThemes?`, optional): Captured themes.
/// - [direction] (`Axis`, default: `Axis.vertical`): Layout direction.
/// - [onTickFollow] (`ValueChanged<PopoverOverlayWidgetState>?`, optional): Follow callback.
/// - [anchorSize] (`Size?`, optional): Anchor size.
  const ContextMenuPopup({super.key, required this.anchorContext, required this.position, required this.children, this.themes, this.direction = Axis.vertical, this.onTickFollow, this.anchorSize});
  Widget build(BuildContext context);
}
/// Theme data for customizing [Pagination] widget appearance.
///
/// This class defines the visual and behavioral properties that can be applied to
/// [Pagination] widgets, including spacing between controls and label display
/// preferences. These properties can be set at the theme level to provide
/// consistent styling across the application.
class PaginationTheme extends ComponentThemeData {
/// The spacing between pagination controls.
  double? gap;
/// Whether to show the previous/next labels.
  bool? showLabel;
/// Creates a [PaginationTheme].
  const PaginationTheme({this.gap, this.showLabel});
/// Returns a copy of this theme with the given fields replaced.
  PaginationTheme copyWith({ValueGetter<double?>? gap, ValueGetter<bool?>? showLabel});
  bool operator ==(Object other);
  int get hashCode;
}
/// A navigation widget for paginated content with comprehensive page controls.
///
/// [Pagination] provides an intuitive interface for navigating through paginated
/// content such as search results, data tables, or article lists. It displays
/// page numbers, navigation arrows, and skip-to-edge controls with intelligent
/// page range management to handle large page counts elegantly.
///
/// Key features:
/// - Page number display with intelligent range selection
/// - Previous/next navigation arrows
/// - Skip to first/last page controls
/// - Configurable maximum visible page numbers
/// - Automatic page range calculation for large datasets
/// - Optional label display for Previous/Next buttons
/// - Customizable spacing and appearance
/// - Theme integration for consistent styling
///
/// Page display strategies:
/// - Small page counts: Show all page numbers
/// - Large page counts: Show current page with surrounding context
/// - Edge handling: Adjust range when near first or last page
/// - Current page highlighting: Visual indication of active page
///
/// Navigation behaviors:
/// - Direct page selection by tapping page numbers
/// - Sequential navigation with previous/next buttons
/// - Quick jump to first/last pages
/// - Conditional hiding of controls at boundaries
/// - Callback-based page change notification
///
/// The widget automatically calculates the optimal page number range to display
/// based on the current page and total page count, ensuring users always have
/// context about their position in the dataset.
///
/// Example:
/// ```dart
/// Pagination(
///   page: currentPage,
///   totalPages: totalPageCount,
///   maxPages: 5, // Show up to 5 page numbers
///   onPageChanged: (page) => setState(() {
///     currentPage = page;
///     _loadPageData(page);
///   }),
///   showSkipToFirstPage: true,
///   showSkipToLastPage: true,
///   hidePreviousOnFirstPage: true,
///   hideNextOnLastPage: true,
/// );
/// ```
class Pagination extends StatelessWidget {
/// The current active page number (1-indexed).
///
/// Must be between 1 and [totalPages] inclusive.
  int page;
/// The total number of pages available.
///
/// Must be >= 1.
  int totalPages;
/// Callback invoked when the page changes.
///
/// Called with the new page number (1-indexed) when user navigates.
  ValueChanged<int> onPageChanged;
/// The maximum number of page buttons to show.
///
/// When total pages exceed this number, pagination shows a subset
/// centered around the current page. Defaults to 3.
  int maxPages;
/// Whether to show a button to skip to the first page.
///
/// Displays a "first page" button when `true`. Defaults to `true`.
  bool showSkipToFirstPage;
/// Whether to show a button to skip to the last page.
///
/// Displays a "last page" button when `true`. Defaults to `true`.
  bool showSkipToLastPage;
/// Whether to hide the previous button on the first page.
///
/// When `true`, hides the "previous" button when [page] is 1.
/// Defaults to `false`.
  bool hidePreviousOnFirstPage;
/// Whether to hide the next button on the last page.
///
/// When `true`, hides the "next" button when [page] equals [totalPages].
/// Defaults to `false`.
  bool hideNextOnLastPage;
/// Whether to show text labels on previous/next buttons.
///
/// When `true`, shows "Previous" and "Next" text along with icons.
/// When `false`, shows only icons. If `null`, uses theme default.
  bool? showLabel;
/// Spacing between pagination controls in logical pixels.
///
/// If `null`, uses theme default spacing.
  double? gap;
/// Creates a pagination widget.
///
/// Parameters:
/// - [page]: Current page number (required, 1-indexed)
/// - [totalPages]: Total page count (required, >= 1)
/// - [onPageChanged]: Page change callback (required)
/// - [maxPages]: Max visible page buttons (defaults to 3)
/// - [showSkipToFirstPage]: Show first-page button (defaults to `true`)
/// - [showSkipToLastPage]: Show last-page button (defaults to `true`)
/// - [hidePreviousOnFirstPage]: Hide previous on page 1 (defaults to `false`)
/// - [hideNextOnLastPage]: Hide next on last page (defaults to `false`)
/// - [showLabel]: Show button labels (optional, uses theme default)
/// - [gap]: Spacing between controls (optional, uses theme default)
  const Pagination({super.key, required this.page, required this.totalPages, required this.onPageChanged, this.maxPages = 3, this.showSkipToFirstPage = true, this.showSkipToLastPage = true, this.hidePreviousOnFirstPage = false, this.hideNextOnLastPage = false, this.showLabel, this.gap});
/// Whether there is a previous page available.
///
/// Returns `true` if [page] > 1, indicating backward navigation is possible.
  bool get hasPrevious;
/// Whether there is a next page available.
///
/// Returns `true` if [page] < [totalPages], indicating forward navigation is possible.
  bool get hasNext;
/// The sequence of page numbers to display.
///
/// Generates an optimized list of page numbers based on [maxPages] and
/// the current [page]. For small page counts, shows all pages. For large
/// counts, shows a centered window around the current page.
  Iterable<int> get pages;
/// The first page number currently being displayed.
///
/// In the visible page range, this is the lowest page number shown.
/// Used to determine if there are more pages before the visible range.
  int get firstShownPage;
/// The last page number currently being displayed.
///
/// In the visible page range, this is the highest page number shown.
/// Used to determine if there are more pages after the visible range.
  int get lastShownPage;
/// Whether there are pages before the first shown page.
///
/// Returns `true` if [firstShownPage] > 1, indicating truncated previous pages.
  bool get hasMorePreviousPages;
/// Whether there are pages after the last shown page.
///
/// Returns `true` if [lastShownPage] < [totalPages], indicating truncated next pages.
  bool get hasMoreNextPages;
  Widget build(BuildContext context);
}
/// Hierarchical focus management system for complex widget trees.
///
/// Creates a focus scope that manages keyboard navigation and focus traversal
/// for child widgets. Provides centralized control over which child widget
/// has focus and handles focus navigation between multiple focusable elements.
///
/// Key Features:
/// - **Focus Hierarchy**: Manages focus relationships between parent and child widgets
/// - **Keyboard Navigation**: Handles arrow key and tab navigation between elements
/// - **Action Delegation**: Routes keyboard actions to currently focused child
/// - **Auto-focus Support**: Automatically focuses first child when enabled
/// - **Focus State Management**: Tracks and updates focus state across widget rebuilds
/// - **Scroll Integration**: Ensures focused elements remain visible in scrollable areas
///
/// The scope maintains a list of attached [SubFocus] widgets and manages which
/// one currently has focus. It handles focus traversal, action routing, and
/// ensures focused widgets remain visible through scroll positioning.
///
/// Used commonly in:
/// - Lists with keyboard navigation
/// - Form field traversal
/// - Menu and dropdown navigation
/// - Tree view navigation
/// - Tab panel systems
///
/// Example:
/// ```dart
/// SubFocusScope(
///   autofocus: true,
///   builder: (context, state) => Column(
///     children: [
///       SubFocus(
///         builder: (context, focusState) => Container(
///           color: focusState.isFocused ? Colors.blue : Colors.grey,
///           child: Text('Item 1'),
///         ),
///       ),
///       SubFocus(
///         builder: (context, focusState) => Container(
///           color: focusState.isFocused ? Colors.blue : Colors.grey,
///           child: Text('Item 2'),
///         ),
///       ),
///     ],
///   ),
/// )
/// ```
class SubFocusScope extends StatefulWidget {
/// Builder function that creates the widget tree for this scope.
///
/// Called with the build context and the scope's state for managing
/// focus within child widgets. If `null`, the scope acts as an invisible
/// wrapper without building additional UI.
  SubFocusScopeBuilder? builder;
/// Whether the first child should automatically receive focus.
///
/// When `true`, the first attached [SubFocus] widget will automatically
/// gain focus when the scope is built. Defaults to `false`.
  bool autofocus;
/// Creates a sub-focus scope.
///
/// Parameters:
/// - [builder]: Widget builder with scope state (optional)
/// - [autofocus]: Auto-focus first child (defaults to `false`)
  const SubFocusScope({super.key, this.builder, this.autofocus = false});
  State<SubFocusScope> createState();
}
/// Mixin providing focus scope state management capabilities.
///
/// Defines the interface for interacting with a [SubFocusScope], including
/// methods for focus management, child attachment/detachment, and action routing.
///
/// This mixin is implemented by internal scope state classes and provides
/// the public API for focus operations within a scope.
mixin SubFocusScopeState {
/// Invokes an action on the currently focused child widget.
///
/// Routes keyboard shortcuts or other intents to the focused child.
/// Returns the result of the action, or `null` if no child is focused
/// or the action is not handled.
///
/// Parameters:
/// - [intent]: The intent/action to invoke
///
/// Returns the action result or `null`.
  Object? invokeActionOnFocused(Intent intent);
/// Moves focus to the next child in the specified direction.
///
/// Traverses the focus order in the given direction, wrapping around
/// at the edges if needed. Returns `true` if focus was successfully
/// moved, `false` otherwise (e.g., no children available).
///
/// Parameters:
/// - [direction]: Direction to traverse (defaults to [TraversalDirection.down])
///
/// Returns `true` if focus moved successfully.
  bool nextFocus([TraversalDirection direction = TraversalDirection.down]);
/// Retrieves the nearest [SubFocusScopeState] from the widget tree.
///
/// Searches up the widget tree for an ancestor [SubFocusScope] and
/// returns its state. Returns `null` if no scope is found.
///
/// Parameters:
/// - [context]: Build context to search from
///
/// Returns the scope state or `null`.
  static SubFocusScopeState? maybeOf(BuildContext context);
/// Detaches a child focus state from this scope.
///
/// Called when a [SubFocus] widget is disposed or removed from the tree.
/// Removes the child from the scope's managed focus list.
///
/// Parameters:
/// - [child]: The child state to detach
  void detach(SubFocusState child);
/// Attaches a child focus state to this scope.
///
/// Called when a [SubFocus] widget is initialized. Adds the child to
/// the scope's managed focus list and may auto-focus it if configured.
///
/// Parameters:
/// - [child]: The child state to attach
///
/// Returns `true` if attachment succeeded.
  bool attach(SubFocusState child);
/// Requests focus for a specific child.
///
/// Transfers focus to the specified child, unfocusing the previously
/// focused child if any. Updates visual state and ensures the focused
/// widget is scrolled into view if needed.
///
/// Parameters:
/// - [child]: The child to receive focus
///
/// Returns `true` if focus was granted successfully.
  bool requestFocus(SubFocusState child);
/// Removes focus from a specific child.
///
/// If the specified child currently has focus, clears the focus state.
/// Otherwise, does nothing.
///
/// Parameters:
/// - [child]: The child to unfocus
///
/// Returns `true` if the child was unfocused, `false` if it didn't have focus.
  bool unfocus(SubFocusState child);
}
/// Individual focusable widget within a SubFocusScope hierarchy.
///
/// Creates a single focusable element that can receive keyboard focus and respond
/// to user interactions within a [SubFocusScope]. Provides focus state information
/// and handles focus-related behaviors like visibility scrolling and action routing.
///
/// Key Features:
/// - **Focus State**: Tracks and reports whether this widget currently has focus
/// - **Focus Request**: Can programmatically request focus from its parent scope
/// - **Action Handling**: Receives and processes keyboard actions when focused
/// - **Scroll Integration**: Automatically scrolls to ensure visibility when focused
/// - **State Tracking**: Maintains focus count and state across widget lifecycle
/// - **Enable/Disable**: Can be temporarily disabled to prevent focus acquisition
///
/// The widget uses a builder pattern to provide focus state to child widgets,
/// allowing them to update their appearance and behavior based on focus status.
/// This enables rich visual feedback for focused states.
///
/// Common Use Cases:
/// - List items in navigable lists
/// - Form fields in keyboard-navigable forms
/// - Menu items in dropdown menus
/// - Tree nodes in tree views
/// - Tab headers in tab panels
///
/// Example:
/// ```dart
/// SubFocus(
///   enabled: true,
///   builder: (context, state) => GestureDetector(
///     onTap: () => state.requestFocus(),
///     child: Container(
///       padding: EdgeInsets.all(8),
///       decoration: BoxDecoration(
///         color: state.isFocused ? Colors.blue : Colors.transparent,
///         border: Border.all(
///           color: state.isFocused ? Colors.blue : Colors.grey,
///         ),
///       ),
///       child: Text(
///         'Focusable Item',
///         style: TextStyle(
///           color: state.isFocused ? Colors.white : Colors.black,
///         ),
///       ),
///     ),
///   ),
/// )
/// ```
class SubFocus extends StatefulWidget {
/// Builder function that creates the widget tree with focus state.
///
/// Called with the build context and focus state, allowing the widget
/// to update its appearance and behavior based on the current focus status.
  SubFocusBuilder builder;
/// Whether this focusable element is enabled.
///
/// When `false`, the element cannot receive focus and is excluded from
/// the focus traversal order. Defaults to `true`.
  bool enabled;
/// Creates a focusable widget.
///
/// Parameters:
/// - [builder]: Widget builder with focus state (required)
/// - [enabled]: Whether focus is enabled (defaults to `true`)
  const SubFocus({super.key, required this.builder, this.enabled = true});
  State<SubFocus> createState();
}
/// Mixin providing focus state and control capabilities for focusable widgets.
///
/// Defines the interface for interacting with a [SubFocus] widget, including
/// methods for focus management, visibility control, and action handling.
///
/// This mixin is implemented by internal focus state classes and provides
/// the public API for focus operations on individual focusable elements.
mixin SubFocusState {
/// Retrieves the render box for this focusable element.
///
/// Used for positioning and scroll calculations. Returns `null` if
/// the widget is not currently rendered.
///
/// Returns the [RenderBox] or `null`.
  RenderBox? findRenderObject();
/// Scrolls the widget into view within its scrollable ancestor.
///
/// Ensures the focused widget is visible by scrolling its nearest
/// [Scrollable] ancestor. Useful when focus moves to an off-screen element.
///
/// Parameters:
/// - [alignmentPolicy]: How to align the widget when scrolling
  void ensureVisible({ScrollPositionAlignmentPolicy alignmentPolicy = ScrollPositionAlignmentPolicy.explicit});
/// Whether this element currently has focus.
///
/// Returns `true` if this is the focused element in its parent scope.
  bool get isFocused;
/// Requests focus for this element.
///
/// Asks the parent scope to transfer focus to this element. Returns
/// `true` if focus was successfully acquired, `false` otherwise.
///
/// Returns `true` on success.
  bool requestFocus();
/// Invokes an action/intent on this focused element.
///
/// Routes keyboard shortcuts or other actions to this widget's
/// action handlers. Returns the action result or `null` if not handled.
///
/// Parameters:
/// - [intent]: The intent/action to invoke
///
/// Returns the action result or `null`.
  Object? invokeAction(Intent intent);
/// The number of times this element has received focus.
///
/// Increments each time [requestFocus] succeeds. Useful for analytics
/// or behavior tracking.
  int get focusCount;
/// Marks this element as focused or unfocused (internal method).
///
/// Called by the parent scope to update focus state. Should not be
/// called directly by application code.
///
/// Parameters:
/// - [focused]: Whether the element should be focused
  void markFocused(bool focused);
/// Removes focus from this element.
///
/// Asks the parent scope to clear focus from this element. Returns
/// `true` if focus was successfully removed, `false` if it didn't have focus.
///
/// Returns `true` on success.
  bool unfocus();
}
/// A swipeable container that transitions between multiple child widgets.
///
/// [Switcher] provides smooth animated transitions between different views
/// with gesture-based navigation. Users can swipe to change the active view,
/// and the component supports all four axis directions for transitions.
///
/// Features include:
/// - Gesture-based drag navigation between views
/// - Smooth animated transitions with configurable duration and curve
/// - Support for all axis directions (up, down, left, right)
/// - Automatic snapping to the nearest index after dragging
/// - Programmatic control via index changes
///
/// The component uses a custom render object to handle smooth interpolation
/// between child sizes and positions during transitions.
///
/// **Note: This component is experimental and may change in future versions.**
///
/// Example:
/// ```dart
/// Switcher(
///   index: currentIndex,
///   direction: AxisDirection.right,
///   onIndexChanged: (newIndex) => setState(() => currentIndex = newIndex),
///   children: [
///     Container(color: Colors.red, child: Center(child: Text('Page 1'))),
///     Container(color: Colors.blue, child: Center(child: Text('Page 2'))),
///     Container(color: Colors.green, child: Center(child: Text('Page 3'))),
///   ],
/// );
/// ```
class Switcher extends StatefulWidget {
/// Current active child index.
  int index;
/// Callback invoked when the active index changes through gestures.
  ValueChanged<int>? onIndexChanged;
/// Direction of the swipe transition animation.
  AxisDirection direction;
/// List of child widgets to switch between.
  List<Widget> children;
/// Duration of the transition animation.
  Duration duration;
/// Animation curve for the transition.
  Curve curve;
/// Creates a [Switcher].
///
/// The [direction] and [children] parameters are required. The [index]
/// determines which child is initially visible.
///
/// Parameters:
/// - [index] (int, default: 0): initial active child index
/// - [direction] (AxisDirection, required): swipe transition direction
/// - [children] (`List<Widget>`, required): child widgets to switch between
/// - [onIndexChanged] (`ValueChanged<int>?`): called when index changes
/// - [duration] (Duration, default: 300ms): transition animation duration
/// - [curve] (Curve, default: Curves.easeInOut): transition animation curve
///
/// Example:
/// ```dart
/// Switcher(
///   index: 0,
///   direction: AxisDirection.left,
///   duration: Duration(milliseconds: 250),
///   curve: Curves.easeOut,
///   onIndexChanged: (index) => print('Switched to $index'),
///   children: [
///     Text('First view'),
///     Text('Second view'),
///     Text('Third view'),
///   ],
/// );
/// ```
  const Switcher({super.key, this.index = 0, required this.direction, required this.children, this.onIndexChanged, this.duration = const Duration(milliseconds: 300), this.curve = Curves.easeInOut});
  State<Switcher> createState();
}
/// Theme configuration for [TabList] appearance and behavior.
///
/// TabListTheme defines the visual styling for tab list components including
/// border colors, indicator styling, and dimensional properties. All properties
/// are optional and fall back to theme defaults when not specified.
///
/// Example:
/// ```dart
/// ComponentTheme<TabListTheme>(
///   data: TabListTheme(
///     borderColor: Colors.grey,
///     borderWidth: 2.0,
///     indicatorColor: Colors.blue,
///     indicatorHeight: 3.0,
///   ),
///   child: TabList(...),
/// )
/// ```
class TabListTheme extends ComponentThemeData {
/// Color of the bottom border line separating tabs from content.
///
/// Type: `Color?`. If null, uses the theme's border color. This creates
/// visual separation between the tab bar and the content area.
  Color? borderColor;
/// Width of the bottom border line in logical pixels.
///
/// Type: `double?`. If null, uses 1 logical pixel scaled by theme scaling.
/// The border provides structure and visual hierarchy to the tab interface.
  double? borderWidth;
/// Color of the active tab indicator line.
///
/// Type: `Color?`. If null, uses the theme's primary color. The indicator
/// clearly shows which tab is currently active.
  Color? indicatorColor;
/// Height of the active tab indicator line in logical pixels.
///
/// Type: `double?`. If null, uses 2 logical pixels scaled by theme scaling.
/// The indicator appears at the bottom of the active tab.
  double? indicatorHeight;
/// Creates a [TabListTheme].
///
/// All parameters are optional and allow customization of tab list appearance.
///
/// Parameters:
/// - [borderColor] (`Color?`, optional): Color of the tab list border.
/// - [borderWidth] (`double?`, optional): Width of the tab list border.
/// - [indicatorColor] (`Color?`, optional): Color of the active tab indicator.
/// - [indicatorHeight] (`double?`, optional): Height of the active tab indicator.
///
/// Example:
/// ```dart
/// const TabListTheme(
///   borderColor: Colors.grey,
///   borderWidth: 1.0,
///   indicatorColor: Colors.blue,
///   indicatorHeight: 2.0,
/// )
/// ```
  const TabListTheme({this.borderColor, this.borderWidth, this.indicatorColor, this.indicatorHeight});
/// Creates a copy with specified fields replaced.
///
/// Parameters:
/// - [borderColor] (`ValueGetter<Color?>?`, optional): new border color getter
/// - [borderWidth] (`ValueGetter<double?>?`, optional): new border width getter
/// - [indicatorColor] (`ValueGetter<Color?>?`, optional): new indicator color getter
/// - [indicatorHeight] (`ValueGetter<double?>?`, optional): new indicator height getter
///
/// Returns: `TabListTheme` ‚Äî new theme with updated values
  TabListTheme copyWith({ValueGetter<Color?>? borderColor, ValueGetter<double?>? borderWidth, ValueGetter<Color?>? indicatorColor, ValueGetter<double?>? indicatorHeight});
  bool operator ==(Object other);
  int get hashCode;
}
/// A horizontal tab list widget for selecting between multiple tab content areas.
///
/// TabList provides a classic tab interface with a horizontal row of tab buttons
/// and an active tab indicator. It handles tab selection state and provides visual
/// feedback for the currently active tab through styling and an indicator line.
///
/// The widget automatically manages the appearance of tab buttons, applying
/// appropriate styling for active and inactive states. The active tab is
/// highlighted with foreground styling and an indicator line at the bottom.
///
/// Features:
/// - Horizontal row of selectable tab buttons
/// - Visual active tab indicator with customizable styling
/// - Automatic tab button state management (active/inactive)
/// - Theme-aware styling with customizable colors and dimensions
/// - Integration with TabContainer for coordinated tab management
///
/// The TabList works as part of a complete tab system, typically used with
/// corresponding content areas that show/hide based on the selected tab.
///
/// Example:
/// ```dart
/// TabList(
///   index: currentTabIndex,
///   onChanged: (index) => setState(() => currentTabIndex = index),
///   children: [
///     TabChild(child: Text('Tab 1')),
///     TabChild(child: Text('Tab 2')),
///     TabChild(child: Text('Tab 3')),
///   ],
/// )
/// ```
class TabList extends StatelessWidget {
/// List of tab child widgets to display in the tab list.
///
/// Type: `List<TabChild>`. Each TabChild represents one selectable tab
/// with its own label and optional content. The tabs are displayed in
/// the order provided in the list.
  List<TabChild> children;
/// Index of the currently active/selected tab.
///
/// Type: `int`. Zero-based index indicating which tab is currently active.
/// Must be within the bounds of the [children] list. The active tab
/// receives special styling and the indicator line.
  int index;
/// Callback invoked when a tab is selected.
///
/// Type: `ValueChanged<int>?`. Called with the index of the newly selected
/// tab when the user taps on a tab button. If null, tabs are not interactive.
  ValueChanged<int>? onChanged;
/// Creates a [TabList] with horizontal tab selection.
///
/// Configures a tab list widget that displays a horizontal row of selectable
/// tab buttons with visual feedback for the active tab.
///
/// Parameters:
/// - [key] (Key?): Widget identifier for the widget tree
/// - [children] (`List<TabChild>`, required): List of tab items to display
/// - [index] (int, required): Index of the currently active tab
/// - [onChanged] (`ValueChanged<int>?`, required): Callback for tab selection
///
/// Example:
/// ```dart
/// TabList(
///   index: selectedIndex,
///   onChanged: (newIndex) {
///     setState(() {
///       selectedIndex = newIndex;
///       // Update content based on new tab selection
///     });
///   },
///   children: [
///     TabChild(child: Text('Overview')),
///     TabChild(child: Text('Details')),
///     TabChild(child: Text('Settings')),
///   ],
/// )
/// ```
  const TabList({super.key, required this.children, required this.index, required this.onChanged});
  Widget build(BuildContext context);
}
/// Theme configuration for [TabPane] appearance and layout.
///
/// TabPaneTheme defines the visual styling for tab pane components including
/// borders, background colors, dimensions, and corner rounding. All properties
/// are optional and fall back to theme defaults when not specified.
///
/// Example:
/// ```dart
/// ComponentTheme<TabPaneTheme>(
///   data: TabPaneTheme(
///     borderRadius: BorderRadius.circular(12),
///     backgroundColor: Colors.white,
///     border: BorderSide(color: Colors.grey),
///     barHeight: 40.0,
///   ),
///   child: TabPane(...),
/// )
/// ```
/// Theme for [TabPane].
class TabPaneTheme extends ComponentThemeData {
/// Border radius for the tab pane container and individual tabs.
///
/// Type: `BorderRadiusGeometry?`. If null, uses the theme's large border radius.
/// This affects both the main content area and the tab button appearance.
  BorderRadiusGeometry? borderRadius;
/// Background color for the tab pane content area and active tabs.
///
/// Type: `Color?`. If null, uses the theme's card color. This provides
/// the background for both the main content area and highlighted tabs.
  Color? backgroundColor;
/// Border styling for the tab pane container.
///
/// Type: `BorderSide?`. If null, uses the theme's default border. This
/// creates the outline around the entire tab pane component.
  BorderSide? border;
/// Height of the tab bar area in logical pixels.
///
/// Type: `double?`. If null, uses 32 logical pixels scaled by theme scaling.
/// This determines the vertical space allocated for the tab buttons.
  double? barHeight;
/// Creates a [TabPaneTheme].
///
/// All parameters are optional and allow customization of tab pane appearance.
///
/// Parameters:
/// - [borderRadius] (`BorderRadiusGeometry?`, optional): Border radius for the tab pane container.
/// - [backgroundColor] (`Color?`, optional): Background color of the tab pane.
/// - [border] (`BorderSide?`, optional): Border styling for the tab pane.
/// - [barHeight] (`double?`, optional): Height of the tab bar area.
///
/// Example:
/// ```dart
/// const TabPaneTheme(
///   borderRadius: BorderRadius.circular(8),
///   backgroundColor: Colors.white,
///   border: BorderSide(color: Colors.grey),
///   barHeight: 32.0,
/// )
/// ```
  const TabPaneTheme({this.borderRadius, this.backgroundColor, this.border, this.barHeight});
/// Creates a copy with specified fields replaced.
///
/// Parameters:
/// - [borderRadius] (`ValueGetter<BorderRadiusGeometry?>?`, optional): new border radius getter
/// - [backgroundColor] (`ValueGetter<Color?>?`, optional): new background color getter
/// - [border] (`ValueGetter<BorderSide?>?`, optional): new border getter
/// - [barHeight] (`ValueGetter<double?>?`, optional): new bar height getter
///
/// Returns: `TabPaneTheme` ‚Äî new theme with updated values
  TabPaneTheme copyWith({ValueGetter<BorderRadiusGeometry?>? borderRadius, ValueGetter<Color?>? backgroundColor, ValueGetter<BorderSide?>? border, ValueGetter<double?>? barHeight});
  bool operator ==(Object other);
  int get hashCode;
}
/// Data wrapper for tab pane items that extends sortable functionality.
///
/// TabPaneData extends SortableData to provide drag-and-drop reordering
/// capabilities for tab pane items. Each tab item is wrapped in this data
/// structure to enable sorting operations.
///
/// Example:
/// ```dart
/// TabPaneData<String>('tab_content')
/// TabPaneData<TabInfo>(TabInfo(title: 'Tab 1', content: widget))
/// ```
class TabPaneData<T> extends SortableData<T> {
/// Creates a [TabPaneData] wrapper for tab content.
///
/// Wraps the provided data for use in sortable tab pane operations.
///
/// Parameters:
/// - [data] (T): The data to associate with this tab item
  const TabPaneData(super.data);
}
/// A comprehensive tab pane widget with sortable tabs and integrated content display.
///
/// TabPane provides a complete tab interface that combines a sortable tab bar with
/// a content display area. It supports drag-and-drop reordering of tabs, scrollable
/// tab overflow, and customizable leading/trailing elements in the tab bar.
///
/// The widget manages both the tab selection state and the tab ordering, providing
/// callbacks for both focus changes and sort operations. The tab bar is horizontally
/// scrollable when tabs exceed the available width, with fade effects at the edges.
///
/// Features:
/// - Drag-and-drop sortable tabs with visual feedback
/// - Horizontal scrolling with edge fade effects for tab overflow
/// - Integrated content area with customizable styling
/// - Leading and trailing widget support in the tab bar
/// - Custom tab rendering through builder patterns
/// - Comprehensive theming and styling options
/// - Automatic focus management during sorting operations
///
/// The content area is styled as a card-like container that appears above the
/// tab bar, creating a cohesive tabbed interface suitable for complex applications.
///
/// Example:
/// ```dart
/// TabPane<String>(
///   items: [
///     TabPaneData('tab1'),
///     TabPaneData('tab2'),
///     TabPaneData('tab3'),
///   ],
///   focused: currentTab,
///   onFocused: (index) => setState(() => currentTab = index),
///   onSort: (newOrder) => setState(() => tabOrder = newOrder),
///   itemBuilder: (context, item, index) => TabChild(
///     child: Text(item.data),
///   ),
///   child: IndexedStack(
///     index: currentTab,
///     children: tabContent,
///   ),
/// )
/// ```
class TabPane<T> extends StatefulWidget {
/// List of tab data items to display in the tab pane.
///
/// Type: `List<TabPaneData<T>>`. Each item contains the data for one tab
/// and will be passed to the [itemBuilder] to create the visual representation.
  List<TabPaneData<T>> items;
/// Builder function to create tab child widgets from data items.
///
/// Type: `TabPaneItemBuilder<T>`. Called for each tab item to create the
/// visual representation in the tab bar. Should return a TabChild widget.
  TabPaneItemBuilder<T> itemBuilder;
/// Callback invoked when tabs are reordered through drag-and-drop.
///
/// Type: `ValueChanged<List<TabPaneData<T>>>?`. Called with the new tab
/// order when sorting operations complete. If null, sorting is disabled.
  ValueChanged<List<TabPaneData<T>>>? onSort;
/// Index of the currently focused/selected tab.
///
/// Type: `int`. Zero-based index of the active tab. The focused tab receives
/// special visual styling and its content is typically displayed.
  int focused;
/// Callback invoked when the focused tab changes.
///
/// Type: `ValueChanged<int>`. Called when a tab is selected either through
/// user interaction or programmatic changes during sorting operations.
  ValueChanged<int> onFocused;
/// Widgets displayed at the leading edge of the tab bar.
///
/// Type: `List<Widget>`, default: `[]`. These widgets appear before the
/// scrollable tab area, useful for controls or branding elements.
  List<Widget> leading;
/// Widgets displayed at the trailing edge of the tab bar.
///
/// Type: `List<Widget>`, default: `[]`. These widgets appear after the
/// scrollable tab area, useful for actions or controls.
  List<Widget> trailing;
/// Border radius for the tab pane container.
///
/// Type: `BorderRadiusGeometry?`. If null, uses the theme's large border
/// radius. Applied to both the content area and tab styling.
  BorderRadiusGeometry? borderRadius;
/// Background color for the content area and active tabs.
///
/// Type: `Color?`. If null, uses the theme's card background color.
/// Provides consistent styling across the tab pane components.
  Color? backgroundColor;
/// Border styling for the tab pane container.
///
/// Type: `BorderSide?`. If null, uses theme defaults for border appearance
/// around the entire tab pane structure.
  BorderSide? border;
/// The main content widget displayed in the content area.
///
/// Type: `Widget`. This widget fills the content area above the tab bar
/// and typically shows content related to the currently focused tab.
  Widget child;
/// Height of the tab bar area in logical pixels.
///
/// Type: `double?`. If null, uses 32 logical pixels scaled by theme scaling.
/// Determines the vertical space allocated for tab buttons.
  double? barHeight;
/// Creates a [TabPane] with sortable tabs and integrated content display.
///
/// Configures a comprehensive tab interface that combines sortable tab management
/// with a content display area, providing a complete tabbed user interface.
///
/// Parameters:
/// - [key] (Key?): Widget identifier for the widget tree
/// - [items] (`List<TabPaneData<T>>`, required): Tab data items to display
/// - [itemBuilder] (`TabPaneItemBuilder<T>`, required): Builder for tab widgets
/// - [focused] (int, default: 0): Index of the currently focused tab
/// - [onFocused] (`ValueChanged<int>`, required): Callback for focus changes
/// - [child] (Widget, required): Content widget for the main display area
/// - [onSort] (`ValueChanged<List<TabPaneData<T>>>?`, optional): Callback for tab reordering
/// - [leading] (`List<Widget>`, default: []): Widgets before the tab area
/// - [trailing] (`List<Widget>`, default: []): Widgets after the tab area
/// - [borderRadius] (BorderRadiusGeometry?, optional): Border radius override
/// - [backgroundColor] (Color?, optional): Background color override
/// - [border] (BorderSide?, optional): Border styling override
/// - [barHeight] (double?, optional): Tab bar height override
///
/// Example:
/// ```dart
/// TabPane<DocumentTab>(
///   items: documentTabs.map(TabPaneData.new).toList(),
///   focused: activeDocumentIndex,
///   onFocused: switchToDocument,
///   onSort: reorderDocuments,
///   leading: [IconButton(icon: Icon(Icons.add), onPressed: newDocument)],
///   trailing: [IconButton(icon: Icon(Icons.settings), onPressed: showSettings)],
///   itemBuilder: (context, item, index) => TabChild(
///     child: Row(
///       children: [
///         Text(item.data.title),
///         IconButton(icon: Icon(Icons.close), onPressed: () => closeTab(index)),
///       ],
///     ),
///   ),
///   child: DocumentEditor(document: documents[activeDocumentIndex]),
/// )
/// ```
  const TabPane({super.key, required this.items, required this.itemBuilder, this.focused = 0, required this.onFocused, this.leading = const [], this.trailing = const [], this.borderRadius, this.backgroundColor, this.border, this.onSort, required this.child, this.barHeight});
  State<TabPane<T>> createState();
}
/// State class for [TabPane] widget.
///
/// Manages the scrolling and rendering of tab pane content.
class TabPaneState<T> extends State<TabPane<T>> {
/// Drag gesture identifier for tab interactions.
  static const kTabDrag = #tabDrag;
  Widget build(BuildContext context);
}
/// Theme data for customizing [Tabs] widget appearance.
///
/// This class defines the visual properties that can be applied to
/// [Tabs] widgets, including padding for the container and individual tabs,
/// background colors, and border radius styling. These properties can be
/// set at the theme level to provide consistent styling across the application.
class TabsTheme extends ComponentThemeData {
/// Padding around the entire tabs container.
///
/// Defines the outer spacing for the tabs widget. If `null`,
/// uses the theme's default container padding.
  EdgeInsetsGeometry? containerPadding;
/// Padding inside individual tab headers.
///
/// Defines the spacing within each tab button. If `null`,
/// uses the theme's default tab padding.
  EdgeInsetsGeometry? tabPadding;
/// Background color for the tabs container.
///
/// Applied to the tabs bar background. If `null`,
/// uses the theme's default background color.
  Color? backgroundColor;
/// Corner radius for the tabs container.
///
/// Defines rounded corners for the tabs widget. If `null`,
/// uses the theme's default border radius.
  BorderRadiusGeometry? borderRadius;
/// Creates a tabs theme.
///
/// All parameters are optional and default to theme values when `null`.
  const TabsTheme({this.containerPadding, this.tabPadding, this.backgroundColor, this.borderRadius});
/// Creates a copy of this theme with optionally replaced values.
///
/// Uses [ValueGetter] functions to allow nullable value replacement.
/// Properties not provided retain their current values.
///
/// Parameters:
/// - [containerPadding]: Optional getter for new container padding
/// - [tabPadding]: Optional getter for new tab padding
/// - [backgroundColor]: Optional getter for new background color
/// - [borderRadius]: Optional getter for new border radius
///
/// Returns a new [TabsTheme] with updated values.
  TabsTheme copyWith({ValueGetter<EdgeInsetsGeometry?>? containerPadding, ValueGetter<EdgeInsetsGeometry?>? tabPadding, ValueGetter<Color?>? backgroundColor, ValueGetter<BorderRadiusGeometry?>? borderRadius});
  bool operator ==(Object other);
  int get hashCode;
}
/// A tabbed interface widget for organizing content into switchable panels.
///
/// [Tabs] provides a clean and intuitive way to organize related content into
/// separate panels that users can switch between by tapping tab headers. It manages
/// the selection state and provides visual feedback for the active tab while
/// handling the display of corresponding content.
///
/// Key features:
/// - Tab-based content organization with header and panel areas
/// - Active tab highlighting with smooth transitions
/// - Customizable tab styling through theming
/// - Gesture-based tab switching with tap support
/// - Flexible content management through TabChild system
/// - Integration with the shadcn_flutter design system
/// - Responsive layout adaptation
/// - Keyboard navigation support
///
/// The widget works with [TabChild] elements that define both the tab header
/// and the associated content panel. Each tab can contain any widget content,
/// from simple text to complex layouts.
///
/// Tab organization:
/// - Headers: Displayed in a horizontal row for tab selection
/// - Content: The active tab's content is shown in the main area
/// - Selection: Visual indication of the currently active tab
/// - Transitions: Smooth animations between tab switches
///
/// Example:
/// ```dart
/// Tabs(
///   index: currentTabIndex,
///   onChanged: (index) => setState(() => currentTabIndex = index),
///   children: [
///     TabChild(
///       tab: Text('Overview'),
///       child: Center(child: Text('Overview content')),
///     ),
///     TabChild(
///       tab: Text('Details'),
///       child: Center(child: Text('Details content')),
///     ),
///     TabChild(
///       tab: Text('Settings'),
///       child: Center(child: Text('Settings content')),
///     ),
///   ],
/// );
/// ```
class Tabs extends StatelessWidget {
/// The index of the currently selected tab (0-indexed).
///
/// Must be between 0 and `children.length - 1` inclusive.
  int index;
/// Used to expand children horizontally
  bool expand;
/// Callback invoked when the user selects a different tab.
///
/// Called with the new tab index when the user taps a tab header.
  ValueChanged<int> onChanged;
/// List of tab children defining tab headers and content.
///
/// Each [TabChild] contains a tab header widget and the associated
/// content panel widget. The list must not be empty.
  List<TabChild> children;
/// Optional padding around individual tabs.
///
/// Overrides the theme's tab padding if provided. If `null`,
/// uses the padding from [TabsTheme].
  EdgeInsetsGeometry? padding;
/// Creates a tabs widget.
///
/// Parameters:
/// - [index]: Currently selected tab index (required)
/// - [onChanged]: Tab selection callback (required)
/// - [children]: List of tab children (required, non-empty)
/// - [padding]: Custom tab padding (optional)
  const Tabs({super.key, required this.index, required this.onChanged, required this.children, this.padding, this.expand = false});
  Widget build(BuildContext context);
}
/// {@template tab_container_theme}
/// Theme data for [TabContainer] providing default builders.
/// {@endtemplate}
class TabContainerTheme extends ComponentThemeData {
/// Default builder for laying out tab children.
  TabBuilder? builder;
/// Default builder for wrapping each tab child.
  TabChildBuilder? childBuilder;
/// {@macro tab_container_theme}
  const TabContainerTheme({this.builder, this.childBuilder});
/// Creates a copy of this theme with the given fields replaced.
  TabContainerTheme copyWith({ValueGetter<TabBuilder?>? builder, ValueGetter<TabChildBuilder?>? childBuilder});
  int get hashCode;
  bool operator ==(Object other);
  String toString();
}
/// Internal data class holding tab container state and callbacks.
///
/// Provides context information to child tabs including the current
/// selection state, tab index, and selection callback. Used internally
/// by the tab system to coordinate between container and children.
///
/// Accessed via [TabContainerData.of] from within tab child widgets.
class TabContainerData {
/// Retrieves the nearest [TabContainerData] from the widget tree.
///
/// Throws an assertion error if no [TabContainer] is found in the
/// ancestor chain, as tab children must be descendants of a tab container.
///
/// Parameters:
/// - [context]: Build context to search from
///
/// Returns the container data.
  static TabContainerData of(BuildContext context);
/// The index of this tab within the container (0-indexed).
  int index;
/// The index of the currently selected tab.
  int selected;
/// Callback to invoke when this tab should be selected.
///
/// Called with the tab's index when the user interacts with the tab.
  ValueChanged<int>? onSelect;
/// Builder function for wrapping tab child content.
///
/// Applies consistent styling or layout to tab children.
  TabChildBuilder childBuilder;
/// Creates tab container data.
///
/// Parameters:
/// - [index]: This tab's index (required)
/// - [selected]: Currently selected tab index (required)
/// - [onSelect]: Selection callback (required)
/// - [childBuilder]: Child wrapping builder (required)
  TabContainerData({required this.index, required this.selected, required this.onSelect, required this.childBuilder});
  bool operator ==(Object other);
  int get hashCode;
}
/// Mixin for widgets that can be used as tab children.
///
/// Provides the interface for tab child widgets, indicating whether
/// the child participates in indexed tab selection.
mixin TabChild on Widget {
/// Whether this tab child uses indexed positioning.
///
/// When `true`, the tab's position in the list determines its index.
/// When `false`, the tab may use a custom key for identification.
  bool get indexed;
}
/// Mixin for keyed tab children that use custom keys for identification.
///
/// Extends [TabChild] to support tab children identified by custom keys
/// of type [T] rather than positional indices.
///
/// Type parameter [T] is the type of the key used to identify this tab.
mixin KeyedTabChild<T> on TabChild {
/// The unique key identifying this tab.
///
/// Used instead of positional index for tab selection and tracking.
  T get tabKey;
}
/// A simple tab child widget wrapping arbitrary content.
///
/// Implements [TabChild] to make any widget usable within a tab container.
/// The wrapped child is rendered directly without additional decoration.
class TabChildWidget extends StatelessWidget with TabChild {
/// The child widget to display.
  Widget child;
/// Whether this tab uses indexed positioning.
///
/// Defaults to `false` unless specified in the constructor.
  bool indexed;
/// Creates a tab child widget.
///
/// Parameters:
/// - [child]: The widget to wrap (required)
/// - [indexed]: Whether to use indexed positioning (defaults to `false`)
  const TabChildWidget({super.key, required this.child, this.indexed = false});
  Widget build(BuildContext context);
}
/// A keyed tab child widget identified by a custom key value.
///
/// Extends [TabChildWidget] with [KeyedTabChild] to support tab identification
/// via custom keys rather than positional indices. The key value determines
/// tab selection and tracking.
///
/// Type parameter [T] is the type of the key value.
class KeyedTabChildWidget<T> extends TabChildWidget with KeyedTabChild<T> {
/// Creates a keyed tab child widget.
///
/// Parameters:
/// - [key]: The unique key value for this tab (required)
/// - [child]: The widget to wrap (required)
/// - [indexed]: Whether to use indexed positioning (optional)
  KeyedTabChildWidget({required T key, required super.child, super.indexed});
  ValueKey<T> get key;
  T get tabKey;
}
/// A basic tab item widget.
///
/// Represents a single tab item with content that can be displayed
/// in a [TabContainer].
class TabItem extends StatelessWidget with TabChild {
/// Content widget for this tab.
  Widget child;
/// Creates a [TabItem].
///
/// Parameters:
/// - [child] (`Widget`, required): content to display in this tab
  const TabItem({super.key, required this.child});
  bool get indexed;
  Widget build(BuildContext context);
}
/// A keyed tab item widget.
///
/// Similar to [TabItem] but includes a unique key for identification.
class KeyedTabItem<T> extends TabItem with KeyedTabChild<T> {
/// Creates a [KeyedTabItem].
///
/// Parameters:
/// - [key] (`T`, required): unique key for this tab
/// - [child] (`Widget`, required): content to display in this tab
  KeyedTabItem({required T key, required super.child});
  ValueKey<T> get key;
  T get tabKey;
}
/// Container widget for managing multiple tabs.
///
/// Provides tab selection and content display with customizable builders.
class TabContainer extends StatelessWidget {
/// Currently selected tab index.
  int selected;
/// Callback when tab selection changes.
  ValueChanged<int>? onSelect;
/// List of tab children to display.
  List<TabChild> children;
/// Optional custom tab layout builder.
  TabBuilder? builder;
/// Optional custom child widget builder.
  TabChildBuilder? childBuilder;
/// Creates a [TabContainer].
///
/// Parameters:
/// - [selected] (`int`, required): index of the selected tab
/// - [onSelect] (`ValueChanged<int>?`, optional): callback when tab changes
/// - [children] (`List<TabChild>`, required): list of tab items
/// - [builder] (`TabBuilder?`, optional): custom tab layout builder
/// - [childBuilder] (`TabChildBuilder?`, optional): custom child builder
  const TabContainer({super.key, required this.selected, required this.onSelect, required this.children, this.builder, this.childBuilder});
  Widget build(BuildContext context);
}
/// Enumeration defining alignment options for navigation bar items.
///
/// This enum provides various alignment strategies for positioning navigation
/// items within the available space, corresponding to Flutter's MainAxisAlignment
/// options but specifically tailored for navigation contexts.
enum NavigationBarAlignment { start, center, end, spaceBetween, spaceAround, spaceEvenly }
/// Enumeration defining alignment options for navigation rail items.
///
/// This enum provides alignment strategies specifically for navigation rails,
/// which are typically vertical navigation components.
enum NavigationRailAlignment { start, center, end }
/// Enumeration defining the type of navigation container.
///
/// This enum identifies the different navigation layout modes available,
/// each with distinct visual presentations and interaction patterns.
enum NavigationContainerType { rail, bar, sidebar }
/// Determines when labels are shown in navigation items.
enum NavigationLabelType { none, selected, all, tooltip, expanded }
/// Position of navigation item labels relative to icons.
enum NavigationLabelPosition { start, end, top, bottom }
/// Size variant for navigation item labels.
enum NavigationLabelSize { small, large }
/// Data class containing navigation control configuration and state.
///
/// Manages layout, styling, and interaction settings for navigation
/// containers and their children. Used internally to coordinate
/// behavior across navigation items.
class NavigationControlData {
/// Type of navigation container (bar, rail, etc.).
  NavigationContainerType containerType;
/// Label display type from parent container.
  NavigationLabelType parentLabelType;
/// Label position relative to icon from parent.
  NavigationLabelPosition parentLabelPosition;
/// Label size variant from parent.
  NavigationLabelSize parentLabelSize;
/// Padding applied by parent container.
  EdgeInsets parentPadding;
/// Layout direction (horizontal or vertical).
  Axis direction;
/// Currently selected item key (null if none selected).
  Key? selectedKey;
/// Total number of child items.
  int childCount;
/// Callback when an item is selected.
  ValueChanged<Key?>? onSelected;
/// Whether the navigation is expanded to fill available space.
  bool expanded;
/// Spacing between navigation items.
  double spacing;
/// Whether to maintain cross-axis size constraints.
  bool keepCrossAxisSize;
/// Whether to maintain main-axis size constraints.
  bool keepMainAxisSize;
/// Computed label direction based on parent label position.
///
/// Returns horizontal for start/end positions, vertical for top/bottom.
  Axis get labelDirection;
/// Creates navigation control data.
///
/// Parameters:
/// - [containerType] (NavigationContainerType, required): Container type
/// - [parentLabelType] (NavigationLabelType, required): Label display type
/// - [parentLabelPosition] (NavigationLabelPosition, required): Label position
/// - [parentLabelSize] (NavigationLabelSize, required): Label size variant
/// - [parentPadding] (EdgeInsets, required): Container padding
/// - [direction] (Axis, required): Layout direction
/// - [selectedKey] (Key?): Selected item key
/// - [onSelected] (`ValueChanged<Key>`, required): Selection callback
/// - [expanded] (bool, required): Whether expanded
/// - [childCount] (int, required): Number of children
/// - [spacing] (double, required): Item spacing
/// - [keepCrossAxisSize] (bool, required): Maintain cross-axis size
/// - [keepMainAxisSize] (bool, required): Maintain main-axis size
  NavigationControlData({required this.containerType, required this.parentLabelType, required this.parentLabelPosition, required this.parentLabelSize, required this.parentPadding, required this.direction, this.selectedKey, this.onSelected, required this.expanded, required this.childCount, required this.spacing, required this.keepCrossAxisSize, required this.keepMainAxisSize});
  bool operator ==(Object other);
  int get hashCode;
}
/// A standard navigation rail component for sidebar-style navigation.
///
/// Provides a compact vertical navigation bar (rail) typically used on the side
/// of a screen. It can be configured with or without labels, support multiple
/// alignment modes, and manage its own selection state. Navigation items
/// are defined through the [children] and [footer] properties.
///
/// Features:
/// - Supports both vertical and horizontal orientations
/// - Configurable alignment (start, center, end)
/// - Flexible label display modes (always, never, selected)
/// - Optional header and footer sections
/// - Built-in expansion and collapse animations
/// - Customizable background, surface effects, and constraints
///
/// Example:
/// ```dart
/// NavigationRail(
///   selectedKey: ValueKey('home'),
///   onSelected: (key) => setState(() => selectedKey = key),
///   children: [
///     NavigationItem(
///       key: ValueKey('home'),
///       icon: Icon(Icons.home),
///       label: Text('Home'),
///     ),
///     NavigationItem(
///       key: ValueKey('search'),
///       icon: Icon(Icons.search),
///       label: Text('Search'),
///     ),
///   ],
/// )
/// ```
class NavigationRail extends StatefulWidget {
/// Background color of the navigation rail.
  Color? backgroundColor;
/// Alignment of navigation items along the main axis.
  NavigationRailAlignment alignment;
/// Layout direction (horizontal or vertical).
  Axis direction;
/// Spacing between navigation items.
  double? spacing;
/// Type of label display behavior.
  NavigationLabelType labelType;
/// Position of labels relative to icons.
  NavigationLabelPosition labelPosition;
/// Size variant for labels.
  NavigationLabelSize labelSize;
/// Internal padding of the navigation rail.
  EdgeInsetsGeometry? padding;
/// Constraints for the navigation rail container.
  BoxConstraints? constraints;
/// Cross-axis size when the rail is expanded.
  double? expandedSize;
/// Cross-axis size when the rail is collapsed.
  double? collapsedSize;
/// Surface opacity effect for the background.
  double? surfaceOpacity;
/// Surface blur effect for the background.
  double? surfaceBlur;
/// Whether the rail is in its expanded state.
  bool expanded;
/// Whether to maintain intrinsic size along the main axis.
  bool keepMainAxisSize;
/// Whether to maintain intrinsic size along the cross axis.
  bool keepCrossAxisSize;
/// Optional header widget displayed at the start of the rail.
  List<Widget>? header;
/// Optional footer widget displayed at the end of the rail.
  List<Widget>? footer;
/// List of navigation items to display.
  List<Widget> children;
/// Currently selected item key.
  Key? selectedKey;
/// Callback when an item is selected.
  ValueChanged<Key?>? onSelected;
/// Creates a [NavigationRail] with the specified configuration and items.
///
/// The [children] parameter is required and should contain [NavigationBarItem]
/// widgets that define the navigation destinations. Other parameters control
/// the rail's appearance, behavior, and layout characteristics.
///
/// Default values provide a sensible vertical rail configuration suitable
/// for most sidebar navigation scenarios. Customization allows adaptation
/// to specific layout requirements and design systems.
///
/// Parameters:
/// - [children] (`List<Widget>`, required): Navigation destinations
/// - [alignment] (NavigationRailAlignment, default: center): Item alignment along main axis
/// - [direction] (Axis, default: vertical): Layout orientation of the rail
/// - [labelType] (NavigationLabelType, default: selected): When to show labels
/// - [labelPosition] (NavigationLabelPosition, default: bottom): Label positioning
/// - [selectedKey] (Key?, optional): Currently selected item key
/// - [onSelected] (`ValueChanged<Key?>?`, optional): Selection change callback
  const NavigationRail({super.key, this.backgroundColor, this.alignment = NavigationRailAlignment.center, this.direction = Axis.vertical, this.spacing, this.labelType = NavigationLabelType.selected, this.labelPosition = NavigationLabelPosition.bottom, this.labelSize = NavigationLabelSize.small, this.padding, this.constraints, this.expandedSize, this.collapsedSize, this.surfaceOpacity, this.surfaceBlur, this.expanded = true, this.keepMainAxisSize = false, this.keepCrossAxisSize = false, this.header, this.footer, this.selectedKey, this.onSelected, required this.children});
  State<NavigationRail> createState();
}
/// Returns the padding at the start of the axis.
double startPadding(EdgeInsets padding, Axis direction);
/// Returns the padding at the end of the axis.
double endPadding(EdgeInsets padding, Axis direction);
/// Spacing gap between navigation items.
///
/// Creates empty space in navigation bars or sidebars. Automatically
/// uses appropriate gap type based on container (Gap for boxes, SliverGap for slivers).
class NavigationGap extends StatelessWidget {
/// Size of the gap in logical pixels.
  double gap;
/// Creates a navigation gap.
///
/// Parameters:
/// - [gap] (double, required): Gap size in logical pixels
  const NavigationGap(this.gap, {super.key});
/// Builds the gap widget for box-based navigation containers.
///
/// Returns a [Gap] widget with the specified gap size.
  Widget buildBox(BuildContext context);
/// Builds the gap widget for sliver-based navigation containers.
///
/// Returns a [SliverGap] widget with the specified gap size.
  Widget buildSliver(BuildContext context);
  Widget build(BuildContext context);
}
/// Visual divider between navigation items.
///
/// Renders a horizontal or vertical line separator in navigation bars.
/// Automatically adapts direction based on navigation orientation.
class NavigationDivider extends StatelessWidget {
/// Optional thickness of the divider line.
  double? thickness;
/// Optional color for the divider.
  Color? color;
/// Creates a navigation divider.
///
/// Parameters:
/// - [thickness] (double?): Line thickness
/// - [color] (Color?): Divider color
  const NavigationDivider({super.key, this.thickness, this.color});
  Widget build(BuildContext context);
}
/// Internal widget that handles label positioning and expansion animation.
class NavigationLabeled extends StatelessWidget {
/// The main content widget.
  Widget child;
/// The label widget.
  Widget label;
/// Where to position the label relative to the child.
  NavigationLabelPosition position;
/// Spacing between label and child.
  double spacing;
/// Whether to show the label.
  bool showLabel;
/// Type of label presentation.
  NavigationLabelType labelType;
/// Layout direction of the navigation.
  Axis direction;
/// Whether to maintain cross axis size when hidden.
  bool keepCrossAxisSize;
/// Whether to maintain main axis size when hidden.
  bool keepMainAxisSize;
/// Creates a [NavigationLabeled].
  const NavigationLabeled({super.key, required this.child, required this.label, required this.spacing, required this.position, required this.showLabel, required this.labelType, required this.direction, required this.keepCrossAxisSize, required this.keepMainAxisSize});
  Widget build(BuildContext context);
}
/// Overflow behavior for navigation item labels.
enum NavigationOverflow { clip, marquee, ellipsis, none }
/// Multi-purpose navigation group that organizes children with a label.
///
/// Replaces the standalone `NavigationLabel`. In sidebars, it organizes
/// items into a scrollable group using `SliverMainAxisGroup`, optionally
/// with a floating or pinned label header.
class NavigationGroup extends StatelessWidget {
/// Label widget to display for the group.
  Widget label;
/// The child items within this group.
  List<Widget> children;
/// Position of the label relative to the children.
  NavigationLabelPosition labelPosition;
/// Alignment of the label content.
  AlignmentGeometry? labelAlignment;
/// Padding around the label.
  EdgeInsetsGeometry? labelPadding;
/// How to handle label text overflow.
  NavigationOverflow labelOverflow;
/// Whether the label floats when scrolling (sidebar only).
  bool labelFloating;
/// Whether the label is pinned when scrolling (sidebar only).
  bool labelPinned;
/// Creates a new navigation group.
  const NavigationGroup({super.key, required this.label, this.children = const [], this.labelPosition = NavigationLabelPosition.top, this.labelAlignment, this.labelPadding, this.labelOverflow = NavigationOverflow.clip, this.labelFloating = false, this.labelPinned = true});
  Widget build(BuildContext context);
/// Builds the label content with appropriate styles and expansion handling.
  Widget buildLabelChild(BuildContext context, NavigationControlData? data);
/// Builds a SliverPersistentHeader for the label and a SliverMainAxisGroup for the children.
  Widget buildSliverLabelChild(BuildContext context, NavigationControlData? data);
/// Builds a column with the label and children. (Non-sidebar context)
  Widget buildBox(BuildContext context, NavigationControlData? data);
/// Builds a SliverMainAxisGroup containing the label and children. (Sidebar/Sliver context)
  Widget buildSliver(BuildContext context, NavigationControlData? data);
}
/// Internal widget that handles label overflow based on [NavigationOverflow].
class NavigationChildOverflowHandle extends StatelessWidget {
/// How to handle overflow.
  NavigationOverflow overflow;
/// The content that might overflow.
  Widget child;
/// Creates a [NavigationChildOverflowHandle].
  const NavigationChildOverflowHandle({super.key, required this.overflow, required this.child});
  Widget build(BuildContext context);
}
/// Custom widget wrapper for navigation items.
///
/// Allows inserting custom widgets into navigation containers with optional
/// selection tracking. Can be used with a static child or a builder that
/// responds to selection state.
///
/// Example:
/// ```dart
/// NavigationWidget(
///   key: ValueKey('custom_builder'),
///   builder: (context, selected) => CustomItem(
///     highlighted: selected,
///   ),
/// )
/// ```
class NavigationWidget extends StatelessWidget {
/// Builder function that receives selection state.
  NavigationWidgetBuilder builder;
/// Creates a navigation widget with a selection-aware builder.
///
/// Parameters:
/// - [builder] (NavigationWidgetBuilder, required): Builder receiving selection state
  const NavigationWidget({super.key, required this.builder});
  Widget build(BuildContext context);
}
/// A navigation header/footer item with configurable content.
///
/// Designed for navigation header and footer sections. The layout adapts to
/// the navigation expansion state and keeps a compact density when collapsed.
class NavigationSlot extends StatelessWidget {
/// Leading widget (usually an icon or avatar).
  Widget leading;
/// Primary title widget.
  Widget title;
/// Optional subtitle widget shown under the title.
  Widget? subtitle;
/// Optional trailing widget (often a chevron or action icon).
  Widget? trailing;
/// Gap multiplier between the text block and trailing widget.
  double? trailingGap;
/// Callback for press interactions.
  VoidCallback? onPressed;
/// Alignment for the button content.
  AlignmentGeometry? alignment;
/// Creates a [NavigationSlot].
  const NavigationSlot({super.key, required this.leading, required this.title, this.subtitle, this.trailing, this.trailingGap, this.onPressed, this.alignment});
  Widget build(BuildContext context);
}
/// A navigation item that can expand to reveal nested navigation items.
///
/// Provides a labeled header row that toggles visibility of sub-items. Intended
/// for hierarchical navigation structures, especially in vertical sidebars or
/// rails.
class NavigationCollapsible extends StatefulWidget {
/// Optional leading widget for the group header.
  Widget? leading;
/// Label widget for the group header.
  Widget label;
/// The nested navigation items for this group.
  List<Widget> children;
/// Whether the group is expanded (controlled mode).
  bool? expanded;
/// Initial expanded state when uncontrolled.
  bool initialExpanded;
/// Callback when expansion state changes.
  ValueChanged<bool>? onExpandedChanged;
/// Custom style when the group header is selected.
  AbstractButtonStyle? selectedStyle;
/// Whether the group header is currently selected.
  bool? selected;
/// Callback when header selection changes.
  ValueChanged<bool>? onChanged;
/// Optional button style for the header.
  AbstractButtonStyle? style;
/// Optional custom trailing widget for the expand indicator.
  Widget? trailing;
/// Indentation applied to nested items.
  double? childIndent;
/// Branch line style for connecting group items.
  BranchLine? branchLine;
/// Spacing between leading widget and label.
  double? spacing;
/// Content alignment within the header button.
  AlignmentGeometry? alignment;
/// Whether the header is enabled for interaction.
  bool? enabled;
/// How to handle label overflow.
  NavigationOverflow overflow;
/// Creates a [NavigationCollapsible].
  const NavigationCollapsible({super.key, this.leading, required this.label, required this.children, this.expanded, this.initialExpanded = false, this.onExpandedChanged, this.selectedStyle, this.selected, this.onChanged, this.style, this.trailing, this.childIndent, this.branchLine, this.spacing, this.alignment, this.enabled, this.overflow = NavigationOverflow.marquee});
  State<NavigationCollapsible> createState();
}
/// Theme data for customizing [NavigationBar] widget appearance.
///
/// This class defines the visual and behavioral properties that can be applied to
/// [NavigationBar] widgets, including background colors, alignment, spacing,
/// label presentation, and padding. These properties can be set at the theme level
/// to provide consistent styling across the application.
class NavigationBarTheme extends ComponentThemeData {
/// Background color of the navigation bar.
  Color? backgroundColor;
/// Alignment of navigation items.
  NavigationBarAlignment? alignment;
/// Layout direction (horizontal or vertical).
  Axis? direction;
/// Spacing between navigation items.
  double? spacing;
/// Type of label display (e.g., always show, hide, etc.).
  NavigationLabelType? labelType;
/// Position of labels relative to icons.
  NavigationLabelPosition? labelPosition;
/// Size variant for labels.
  NavigationLabelSize? labelSize;
/// Internal padding of the navigation bar.
  EdgeInsetsGeometry? padding;
/// Creates a [NavigationBarTheme].
///
/// Parameters:
/// - [backgroundColor] (`Color?`, optional): Background color.
/// - [alignment] (`NavigationBarAlignment?`, optional): Item alignment.
/// - [direction] (`Axis?`, optional): Layout direction.
/// - [spacing] (`double?`, optional): Item spacing.
/// - [labelType] (`NavigationLabelType?`, optional): Label display type.
/// - [labelPosition] (`NavigationLabelPosition?`, optional): Label position.
/// - [labelSize] (`NavigationLabelSize?`, optional): Label size.
/// - [padding] (`EdgeInsetsGeometry?`, optional): Internal padding.
  const NavigationBarTheme({this.backgroundColor, this.alignment, this.direction, this.spacing, this.labelType, this.labelPosition, this.labelSize, this.padding});
/// Creates a copy of this theme with the given fields replaced.
///
/// Parameters:
/// - [backgroundColor] (`ValueGetter<Color?>?`, optional): New background color.
/// - [alignment] (`ValueGetter<NavigationBarAlignment?>?`, optional): New alignment.
/// - [direction] (`ValueGetter<Axis?>?`, optional): New direction.
/// - [spacing] (`ValueGetter<double?>?`, optional): New spacing.
/// - [labelType] (`ValueGetter<NavigationLabelType?>?`, optional): New label type.
/// - [labelPosition] (`ValueGetter<NavigationLabelPosition?>?`, optional): New label position.
/// - [labelSize] (`ValueGetter<NavigationLabelSize?>?`, optional): New label size.
/// - [padding] (`ValueGetter<EdgeInsetsGeometry?>?`, optional): New padding.
///
/// Returns: A new [NavigationBarTheme] with updated properties.
  NavigationBarTheme copyWith({ValueGetter<Color?>? backgroundColor, ValueGetter<NavigationBarAlignment?>? alignment, ValueGetter<Axis?>? direction, ValueGetter<double?>? spacing, ValueGetter<NavigationLabelType?>? labelType, ValueGetter<NavigationLabelPosition?>? labelPosition, ValueGetter<NavigationLabelSize?>? labelSize, ValueGetter<EdgeInsetsGeometry?>? padding});
  bool operator ==(Object other);
  int get hashCode;
}
/// A full-width navigation sidebar component for comprehensive navigation.
///
/// Provides an expanded navigation interface designed for sidebar layouts
/// with full-width items and extensive labeling support. Unlike [NavigationRail],
/// the sidebar is optimized for detailed navigation with prominent labels,
/// descriptions, and expanded interactive areas.
///
/// The sidebar always displays labels and typically occupies a dedicated
/// sidebar area in layouts. Items are arranged vertically with generous
/// spacing and padding to create a comfortable navigation experience.
/// Supports badges, icons, and detailed labeling for complex navigation hierarchies.
///
/// Integrates with responsive layout systems and can be combined with
/// collapsible containers or drawer systems for adaptive navigation
/// experiences across different screen sizes and device types.
///
/// Example:
/// ```dart
/// NavigationSidebar(
///   backgroundColor: Colors.grey.shade50,
///   labelType: NavigationLabelType.all,
///   selectedKey: ValueKey('dashboard'),
///   onSelected: (key) => _navigateToPage(key),
///   children: [
///     NavigationItem(
///       key: ValueKey('dashboard'),
///       icon: Icon(Icons.dashboard),
///       label: Text('Dashboard'),
///       badge: Badge(child: Text('New')),
///     ),
///     NavigationItem(
///       key: ValueKey('analytics'),
///       icon: Icon(Icons.analytics),
///       label: Text('Analytics'),
///     ),
///     NavigationItem(
///       key: ValueKey('settings'),
///       icon: Icon(Icons.settings),
///       label: Text('Settings'),
///     ),
///   ],
/// )
/// ```
class NavigationSidebar extends StatefulWidget {
/// Background color for the navigation sidebar surface.
///
/// Sets the sidebar's background color to provide visual separation
/// from content areas. When null, uses the theme's default surface color.
  Color? backgroundColor;
/// List of navigation items to display in the sidebar.
///
/// Each item should be a widget that defines the navigation
/// destination. Items are arranged vertically with full-width presentation.
  List<Widget> children;
/// Optional fixed header items displayed before the scrollable content.
  List<Widget>? header;
/// Optional fixed footer items displayed after the scrollable content.
  List<Widget>? footer;
/// Spacing between navigation items.
///
/// Controls the vertical gap between adjacent navigation items.
/// Larger values create more breathing room in the navigation list.
  double? spacing;
/// Label display behavior for navigation items.
///
/// Determines how labels are presented in the sidebar. Sidebars typically
/// use expanded label types to show comprehensive navigation information.
  NavigationLabelType labelType;
/// Position of labels relative to icons within items.
///
/// Controls label placement within each navigation item. Sidebars
/// commonly position labels to the end (right in LTR layouts) of icons.
  NavigationLabelPosition labelPosition;
/// Size variant for label text and item dimensions.
///
/// Affects text size and overall item scale. Larger sizes improve
/// accessibility and visual prominence in sidebar contexts.
  NavigationLabelSize labelSize;
/// Internal padding applied within the navigation sidebar.
///
/// Provides space around navigation items, preventing them from
/// touching the sidebar's edges and creating visual comfort.
  EdgeInsetsGeometry? padding;
/// Size constraints for the navigation sidebar container.
///
/// Defines width and height bounds for the sidebar. Useful for
/// responsive layouts and consistent sidebar sizing.
  BoxConstraints? constraints;
/// Key of the currently selected navigation item.
///
/// Highlights the corresponding item with selected styling.
/// When null, no item appears selected.
  Key? selectedKey;
/// Callback invoked when a navigation item is selected.
///
/// Called with the key of the selected item. Use this to update
/// the selection state and handle navigation actions.
  ValueChanged<Key?>? onSelected;
/// Opacity level for surface background effects.
///
/// Controls transparency of background overlays and blur effects.
/// Values range from 0.0 (transparent) to 1.0 (opaque).
  double? surfaceOpacity;
/// Blur intensity for surface background effects.
///
/// Controls backdrop blur effects behind the sidebar surface.
/// Higher values create more pronounced blur effects.
  double? surfaceBlur;
/// Whether the sidebar should expand to fill available width.
///
/// When true, the sidebar uses all available horizontal space.
/// When false, the sidebar sizes itself to its content width.
  bool expanded;
/// Whether to maintain intrinsic size along the cross axis.
///
/// Controls width sizing behavior when the sidebar's width
/// constraints are unconstrained.
  bool keepCrossAxisSize;
/// Whether to maintain intrinsic size along the main axis.
///
/// Controls height sizing behavior when the sidebar's height
/// constraints are unconstrained.
  bool keepMainAxisSize;
/// Creates a [NavigationSidebar] with the specified configuration and items.
///
/// Parameters:
/// - [children] (`List<Widget>`, required): Navigation destinations
/// - [labelType] (NavigationLabelType, default: expanded): Label display behavior
/// - [labelPosition] (NavigationLabelPosition, default: end): Label positioning
/// - [labelSize] (NavigationLabelSize, default: large): Size variant for items
/// - [selectedKey] (Key?, optional): Currently selected item key
/// - [onSelected] (`ValueChanged<Key?>?`, optional): Selection change callback
/// - [expanded] (bool, default: true): Whether to fill available width
  const NavigationSidebar({super.key, this.backgroundColor, this.spacing, this.labelType = NavigationLabelType.expanded, this.labelPosition = NavigationLabelPosition.end, this.labelSize = NavigationLabelSize.large, this.padding, this.constraints, this.selectedKey, this.onSelected, this.surfaceOpacity, this.surfaceBlur, this.expanded = true, this.keepCrossAxisSize = false, this.keepMainAxisSize = false, this.header, this.footer, required this.children});
  State<NavigationSidebar> createState();
}
/// Selectable navigation item with selection state management.
///
/// Represents a clickable navigation item that can be selected. Supports
/// custom styling for selected/unselected states, labels, and icons.
///
/// Example:
/// ```dart
/// NavigationItem(
///   key: ValueKey('home'),
///   label: Text('Home'),
///   child: Icon(Icons.home),
///   selected: selectedKey == ValueKey('home'),
///   onChanged: (selected) => setState(() => selectedKey = ValueKey('home')),
/// )
/// )
/// ```
class NavigationItem extends AbstractNavigationButton {
/// Custom style when item is selected.
  AbstractButtonStyle? selectedStyle;
/// Whether this item is currently selected.
  bool? selected;
/// Callback when selection state changes.
  ValueChanged<bool>? onChanged;
/// Creates a navigation item.
///
/// Parameters:
/// - [child] (Widget, required): Icon or content widget
/// - [selectedStyle] (AbstractButtonStyle?): Style when selected
/// - [selected] (bool?): Current selection state
/// - [onChanged] (`ValueChanged<bool>?`): Selection change callback
/// - [label] (Widget?): Optional label text
/// - [spacing] (double?): Space between icon and label
/// - [style] (AbstractButtonStyle?): Default style
/// - [alignment] (AlignmentGeometry?): Content alignment
/// - [enabled] (bool?): Whether enabled for interaction
/// - [overflow] (NavigationOverflow): Overflow behavior
/// - [marginAlignment] (AlignmentGeometry?): Margin alignment
  const NavigationItem({super.key, this.selectedStyle, this.selected, this.onChanged, super.label, super.spacing, super.style, super.alignment, super.enabled, super.overflow, super.marginAlignment, required super.child});
  State<AbstractNavigationButton> createState();
}
/// Non-selectable navigation button for actions.
///
/// Similar to [NavigationItem] but without selection state. Used for
/// action buttons in navigation (e.g., settings, logout) that trigger
/// callbacks rather than changing navigation state.
///
/// Example:
/// ```dart
/// NavigationButton(
///   label: Text('Settings'),
///   child: Icon(Icons.settings),
///   onPressed: () => _openSettings(),
/// )
/// ```
class NavigationButton extends AbstractNavigationButton {
/// Callback when button is pressed.
  VoidCallback? onPressed;
/// Whether to enable haptic feedback.
  bool? enableFeedback;
/// Creates a navigation button.
///
/// Parameters:
/// - [child] (Widget, required): Icon or content widget
/// - [enableFeedback] (bool?) : Whether to enable haptic feedback
/// - [onPressed] (VoidCallback?): Press callback
/// - [label] (Widget?): Optional label text
/// - [spacing] (double?): Space between icon and label
/// - [style] (AbstractButtonStyle?): Button style
/// - [alignment] (AlignmentGeometry?): Content alignment
/// - [enabled] (bool?): Whether enabled for interaction
/// - [overflow] (TextOverflow?): Label overflow behavior
/// - [marginAlignment] (AlignmentGeometry?): Margin alignment
  const NavigationButton({super.key, this.onPressed, this.enableFeedback = true, super.label, super.spacing, super.style, super.alignment, super.enabled, super.overflow, super.marginAlignment, required super.child});
  State<AbstractNavigationButton> createState();
}
/// Abstract base class for navigation button widgets.
///
/// Provides common properties and behavior for navigation items and buttons.
/// Subclasses include [NavigationItem] and [NavigationButton].
///
/// Handles layout, labels, styling, and integration with navigation containers.
abstract class AbstractNavigationButton extends StatefulWidget {
/// Main content widget (typically an icon).
  Widget child;
/// Optional label text widget.
  Widget? label;
/// Spacing between icon and label.
  double? spacing;
/// Custom button style.
  AbstractButtonStyle? style;
/// Content alignment within the button.
  AlignmentGeometry? alignment;
/// Whether the button is enabled for interaction.
  bool? enabled;
/// How to handle label overflow.
  NavigationOverflow overflow;
/// Alignment for margins.
  AlignmentGeometry? marginAlignment;
/// Creates an abstract navigation button.
///
/// Parameters:
/// - [child] (Widget, required): Main content (icon)
/// - [spacing] (double?): Icon-label spacing
/// - [label] (Widget?): Label widget
/// - [style] (AbstractButtonStyle?): Button style
/// - [alignment] (AlignmentGeometry?): Content alignment
/// - [enabled] (bool?): Enabled state
/// - [overflow] (NavigationOverflow): Overflow behavior, defaults to marquee
/// - [marginAlignment] (AlignmentGeometry?): Margin alignment
  const AbstractNavigationButton({super.key, this.spacing, this.label, this.style, this.alignment, this.enabled, this.overflow = NavigationOverflow.marquee, this.marginAlignment, required this.child});
  State<AbstractNavigationButton> createState();
}
/// A flexible navigation container widget for organizing navigation items.
///
/// [NavigationBar] provides a comprehensive navigation solution that can be configured
/// for various layouts including horizontal bars, vertical rails, and expandable sidebars.
/// It manages navigation item presentation, selection states, and provides extensive
/// customization options for different navigation patterns.
///
/// Key features:
/// - Flexible layout orientation (horizontal/vertical)
/// - Multiple alignment strategies for item positioning
/// - Configurable label presentation and positioning
/// - Selection state management with callbacks
/// - Surface effects for glassmorphism styling
/// - Responsive behavior with expansion options
/// - Theme integration for consistent styling
/// - Support for gaps, dividers, and custom widgets
///
/// Navigation layout modes:
/// - **Bar**: Standard horizontal or vertical bar with items arranged linearly.
/// - **Rail**: Compact sidebar-style navigation typically used on screen edges.
/// - **Sidebar**: Full-featured expandable sidebar for complex navigation hierarchies.
class NavigationBar extends StatefulWidget {
/// The list of navigation items, dividers, or gaps to display.
  List<Widget> children;
/// The alignment of items within the navigation bar.
  NavigationBarAlignment alignment;
/// The layout orientation of the navigation bar.
///
/// If null, defaults to [Axis.horizontal].
  Axis? direction;
/// When labels should be displayed for the items.
  NavigationLabelType labelType;
/// The relative position of labels to their corresponding icons.
  NavigationLabelPosition labelPosition;
/// The size variant for label text.
  NavigationLabelSize labelSize;
/// The background color of the navigation bar.
  Color? backgroundColor;
/// Internal padding for the navigation bar content.
  EdgeInsetsGeometry? padding;
/// Opacity of the background surface (0.0 to 1.0).
  double? surfaceOpacity;
/// Blur intensity for glassmorphic surface effects.
  double? surfaceBlur;
/// The key of the currently selected navigation item.
  Key? selectedKey;
/// Callback invoked when a navigation item selection changes.
  ValueChanged<Key?>? onSelected;
/// Whether the navigation bar should expand to fill available space.
  bool expanded;
/// Whether to maintain the cross-axis size based on intrinsic content size.
  bool? keepCrossAxisSize;
/// Whether to maintain the main-axis size based on intrinsic content size.
  bool? keepMainAxisSize;
/// Cross-axis size when the bar is in an expanded state.
  double? expandedSize;
/// Cross-axis size when the bar is in a collapsed state.
  double? collapsedSize;
/// The spacing between navigation items.
  double? spacing;
/// Creates a [NavigationBar] with the specified configuration.
  const NavigationBar({super.key, required this.children, this.alignment = NavigationBarAlignment.start, this.direction, this.labelType = NavigationLabelType.all, this.labelPosition = NavigationLabelPosition.bottom, this.labelSize = NavigationLabelSize.small, this.backgroundColor, this.padding, this.surfaceOpacity, this.surfaceBlur, this.selectedKey, this.onSelected, this.expanded = false, this.keepCrossAxisSize, this.keepMainAxisSize, this.expandedSize, this.collapsedSize, this.spacing});
  State<NavigationBar> createState();
}
/// Handles overlay presentation for popover components.
///
/// Manages the display, positioning, and lifecycle of popover overlays
/// with support for alignment, constraints, and modal behavior.
class PopoverOverlayHandler extends OverlayHandler {
/// Creates a [PopoverOverlayHandler].
  const PopoverOverlayHandler();
  OverlayCompleter<T> show<T>({required BuildContext context, required AlignmentGeometry alignment, required WidgetBuilder builder, ui.Offset? position, AlignmentGeometry? anchorAlignment, PopoverConstraint widthConstraint = PopoverConstraint.flexible, PopoverConstraint heightConstraint = PopoverConstraint.flexible, Key? key, bool rootOverlay = true, bool modal = true, bool barrierDismissable = true, ui.Clip clipBehavior = Clip.none, Object? regionGroupId, ui.Offset? offset, AlignmentGeometry? transitionAlignment, EdgeInsetsGeometry? margin, bool follow = true, bool consumeOutsideTaps = true, ValueChanged<PopoverOverlayWidgetState>? onTickFollow, bool allowInvertHorizontal = true, bool allowInvertVertical = true, bool dismissBackdropFocus = true, Duration? showDuration, Duration? dismissDuration, OverlayBarrier? overlayBarrier, LayerLink? layerLink});
}
/// Internal widget for rendering popover overlays.
///
/// Manages positioning, constraints, and lifecycle of popover content
/// relative to an anchor widget.
class PopoverOverlayWidget extends StatefulWidget {
/// Creates a [PopoverOverlayWidget].
  const PopoverOverlayWidget({super.key, required this.anchorContext, this.position, required this.alignment, this.themes, required this.builder, required this.animation, required this.anchorAlignment, this.widthConstraint = PopoverConstraint.flexible, this.heightConstraint = PopoverConstraint.flexible, this.anchorSize, this.onTapOutside, this.regionGroupId, this.offset, this.transitionAlignment, this.margin, this.follow = true, this.consumeOutsideTaps = true, this.onTickFollow, this.allowInvertHorizontal = true, this.allowInvertVertical = true, this.data, this.onClose, this.onImmediateClose, this.onCloseWithResult, this.layerLink});
/// Explicit position for the popover.
  Offset? position;
/// Alignment of the popover relative to the anchor.
  AlignmentGeometry alignment;
/// Alignment point on the anchor widget.
  AlignmentGeometry anchorAlignment;
/// Captured theme data from context.
  CapturedThemes? themes;
/// Captured inherited data from context.
  CapturedData? data;
/// Builder function for popover content.
  WidgetBuilder builder;
/// Size of the anchor widget.
  Size? anchorSize;
/// Animation controller for show/hide transitions.
  Animation<double> animation;
/// Width constraint mode for the popover.
  PopoverConstraint widthConstraint;
/// Height constraint mode for the popover.
  PopoverConstraint heightConstraint;
/// Callback when popover is closing.
  FutureVoidCallback? onClose;
/// Callback for immediate close without animation.
  VoidCallback? onImmediateClose;
/// Callback when user taps outside the popover.
  VoidCallback? onTapOutside;
/// Region group identifier for coordinating multiple overlays.
  Object? regionGroupId;
/// Additional offset applied to popover position.
  Offset? offset;
/// Alignment for transition animations.
  AlignmentGeometry? transitionAlignment;
/// Margin around the popover.
  EdgeInsetsGeometry? margin;
/// Whether popover follows anchor movement.
  bool follow;
/// Build context of the anchor widget.
  BuildContext anchorContext;
/// Whether to consume taps outside the popover.
  bool consumeOutsideTaps;
/// Callback on each frame when following anchor.
  ValueChanged<PopoverOverlayWidgetState>? onTickFollow;
/// Allow horizontal inversion when constrained.
  bool allowInvertHorizontal;
/// Allow vertical inversion when constrained.
  bool allowInvertVertical;
/// Callback when closing with a result value.
  PopoverFutureVoidCallback<Object?>? onCloseWithResult;
/// Layer link for positioning.
  LayerLink? layerLink;
  State<PopoverOverlayWidget> createState();
}
/// Size constraint strategies for popover overlays.
///
/// - `flexible`: Size flexibly based on content and available space
/// - `intrinsic`: Use intrinsic content size
/// - `anchorFixedSize`: Match anchor's exact size
/// - `anchorMinSize`: Use anchor size as minimum
/// - `anchorMaxSize`: Use anchor size as maximum
enum PopoverConstraint { flexible, intrinsic, anchorFixedSize, anchorMinSize, anchorMaxSize }
/// State class for [PopoverOverlayWidget] managing popover positioning and lifecycle.
///
/// Handles dynamic positioning, anchor tracking, size constraints, and
/// animation for popover overlays. Implements [OverlayHandlerStateMixin]
/// for standard overlay lifecycle management.
class PopoverOverlayWidgetState extends State<PopoverOverlayWidget> with SingleTickerProviderStateMixin, OverlayHandlerStateMixin {
  set offset(Offset? offset);
  void initState();
  Future<void> close([bool immediate = false]);
  void closeLater();
  void didUpdateWidget(covariant PopoverOverlayWidget oldWidget);
/// Gets the anchor widget's size.
  Size? get anchorSize;
/// Gets the anchor alignment for positioning.
  AlignmentGeometry get anchorAlignment;
/// Gets the explicit position offset.
  Offset? get position;
/// Gets the popover alignment.
  AlignmentGeometry get alignment;
/// Gets the width constraint strategy.
  PopoverConstraint get widthConstraint;
/// Gets the height constraint strategy.
  PopoverConstraint get heightConstraint;
/// Gets the position offset.
  Offset? get offset;
/// Gets the margin around the popover.
  EdgeInsetsGeometry? get margin;
/// Gets whether the popover follows the anchor on movement.
  bool get follow;
/// Gets the anchor build context.
  BuildContext get anchorContext;
/// Gets whether horizontal inversion is allowed.
  bool get allowInvertHorizontal;
/// Gets whether vertical inversion is allowed.
  bool get allowInvertVertical;
/// Gets the layer link for positioning.
  LayerLink? get layerLink;
/// Sets the layer link for positioning.
///
/// Updates the layer link and manages ticker state for anchor tracking.
  set layerLink(LayerLink? value);
  set alignment(AlignmentGeometry value);
/// Sets the popover position.
///
/// Updates the explicit position and triggers a rebuild.
  set position(Offset? value);
  set anchorAlignment(AlignmentGeometry value);
  set widthConstraint(PopoverConstraint value);
  set heightConstraint(PopoverConstraint value);
  set margin(EdgeInsetsGeometry? value);
  set follow(bool value);
  set anchorContext(BuildContext value);
  set allowInvertHorizontal(bool value);
  set allowInvertVertical(bool value);
  void dispose();
  Widget build(BuildContext context);
  Future<void> closeWithResult<X>([X? value]);
}
/// Closes the current popover overlay.
///
/// Deprecated: Use [closeOverlay] instead.
///
/// Parameters:
/// - [context] (`BuildContext`, required): Widget context.
/// - [result] (`T?`, optional): Result to return when closing.
///
/// Returns: `Future<void>` ‚Äî completes when popover is closed.
Future<void> closePopover<T>(BuildContext context, [T? result]);
/// Implementation of [OverlayCompleter] for popover overlays.
///
/// Manages the lifecycle of a popover overlay entry, tracking completion
/// state and handling overlay/barrier entry disposal.
class OverlayPopoverEntry<T> implements OverlayCompleter<T> {
/// Completer for the popover's result value.
  Completer<T?> completer;
/// Completer that tracks the popover's animation lifecycle.
///
/// Completes when the popover's entry and exit animations finish.
/// Used internally to coordinate animation timing and cleanup.
  Completer<T?> animationCompleter;
  bool get isCompleted;
/// Initializes the popover entry with overlay entries.
///
/// Must be called before the popover can be displayed.
///
/// Parameters:
/// - [overlayEntry] (OverlayEntry, required): Main overlay entry
/// - [barrierEntry] (OverlayEntry?): Optional barrier entry
  void initialize(OverlayEntry overlayEntry, [OverlayEntry? barrierEntry]);
  void remove();
  void dispose();
  Future<T?> get future;
  Future<T?> get animationFuture;
  bool get isAnimationCompleted;
}
/// Displays a popover overlay with specified alignment and behavior.
///
/// Parameters:
/// - [context] (`BuildContext`, required): Widget context.
/// - [alignment] (`AlignmentGeometry`, required): Popover alignment relative to anchor.
/// - [builder] (`WidgetBuilder`, required): Builds popover content.
/// - [position] (`Offset?`, optional): Explicit position.
/// - [anchorAlignment] (`AlignmentGeometry?`, optional): Anchor alignment point.
/// - [widthConstraint] (`PopoverConstraint`, optional): Width constraint mode. Default: flexible.
/// - [heightConstraint] (`PopoverConstraint`, optional): Height constraint mode. Default: flexible.
/// - [key] (`Key?`, optional): Widget key.
/// - [rootOverlay] (`bool`, optional): Use root overlay. Default: true.
/// - [modal] (`bool`, optional): Modal behavior. Default: true.
/// - [barrierDismissable] (`bool`, optional): Tap outside to dismiss. Default: true.
/// - [clipBehavior] (`Clip`, optional): Clipping behavior. Default: Clip.none.
/// - [regionGroupId] (`Object?`, optional): Region grouping identifier.
/// - [offset] (`Offset?`, optional): Additional offset.
/// - [transitionAlignment] (`AlignmentGeometry?`, optional): Transition origin.
/// - [margin] (`EdgeInsetsGeometry?`, optional): Popover margin.
/// - [follow] (`bool`, optional): Follow anchor movement. Default: true.
/// - [consumeOutsideTaps] (`bool`, optional): Consume outside taps. Default: true.
/// - [onTickFollow] (`ValueChanged<PopoverOverlayWidgetState>?`, optional): Follow callback.
/// - [allowInvertHorizontal] (`bool`, optional): Allow horizontal inversion. Default: true.
/// - [allowInvertVertical] (`bool`, optional): Allow vertical inversion. Default: true.
/// - [dismissBackdropFocus] (`bool`, optional): Dismiss on backdrop focus. Default: true.
/// - [showDuration] (`Duration?`, optional): Show animation duration.
/// - [dismissDuration] (`Duration?`, optional): Dismiss animation duration.
/// - [overlayBarrier] (`OverlayBarrier?`, optional): Custom barrier configuration.
/// - [handler] (`OverlayHandler?`, optional): Custom overlay handler.
///
/// Returns: `OverlayCompleter<T?>` ‚Äî handle to control the popover.
///
/// Example:
/// ```dart
/// showPopover(
///   context: context,
///   alignment: Alignment.bottomCenter,
///   builder: (context) => Text('Popover content'),
/// );
/// ```
OverlayCompleter<T?> showPopover<T>({required BuildContext context, required AlignmentGeometry alignment, required WidgetBuilder builder, Offset? position, AlignmentGeometry? anchorAlignment, PopoverConstraint widthConstraint = PopoverConstraint.flexible, PopoverConstraint heightConstraint = PopoverConstraint.flexible, Key? key, bool rootOverlay = true, bool modal = true, bool barrierDismissable = true, Clip clipBehavior = Clip.none, Object? regionGroupId, Offset? offset, AlignmentGeometry? transitionAlignment, EdgeInsetsGeometry? margin, bool follow = true, bool consumeOutsideTaps = true, ValueChanged<PopoverOverlayWidgetState>? onTickFollow, bool allowInvertHorizontal = true, bool allowInvertVertical = true, bool dismissBackdropFocus = true, Duration? showDuration, Duration? dismissDuration, OverlayBarrier? overlayBarrier, OverlayHandler? handler});
/// A comprehensive popover overlay system for displaying contextual content.
///
/// [Popover] provides a flexible foundation for creating overlay widgets that appear
/// relative to anchor elements. It handles positioning, layering, and lifecycle
/// management for temporary content displays such as dropdowns, menus, tooltips,
/// and dialogs. The system automatically manages positioning constraints and
/// viewport boundaries.
///
/// The popover system consists of:
/// - [Popover]: Individual popover instances with control methods
/// - [PopoverController]: Manager for multiple popovers with lifecycle control
/// - [PopoverLayout]: Positioning and constraint resolution
/// - Overlay integration for proper z-ordering and event handling
///
/// Key features:
/// - Intelligent positioning with automatic viewport constraint handling
/// - Multiple attachment points and alignment options
/// - Modal and non-modal display modes
/// - Animation and transition support
/// - Barrier dismissal with configurable behavior
/// - Follow-anchor behavior for responsive positioning
/// - Multi-popover management with close coordination
///
/// Positioning capabilities:
/// - Flexible alignment relative to anchor widgets
/// - Automatic inversion when space is constrained
/// - Custom offset adjustments
/// - Margin and padding controls
/// - Width and height constraint options
///
/// Example usage:
/// ```dart
/// final controller = PopoverController();
///
/// // Show a popover
/// final popover = await controller.show<String>(
///   context: context,
///   alignment: Alignment.bottomStart,
///   anchorAlignment: Alignment.topStart,
///   builder: (context) => PopoverMenu(
///     children: [
///       PopoverMenuItem(child: Text('Option 1')),
///       PopoverMenuItem(child: Text('Option 2')),
///     ],
///   ),
/// );
/// ```
class Popover {
/// Global key for accessing the overlay handler state.
  GlobalKey<OverlayHandlerStateMixin> key;
/// The overlay completer that manages this popover's lifecycle.
  OverlayCompleter entry;
/// Closes this popover with optional immediate dismissal.
///
/// If [immediate] is true, skips closing animations and removes the popover
/// immediately. Otherwise, plays the closing animation before removal.
///
/// Returns a Future that completes when the popover is fully dismissed.
///
/// Parameters:
/// - [immediate] (bool, default: false): Whether to skip closing animations
///
/// Example:
/// ```dart
/// await popover.close(); // Animated close
/// await popover.close(true); // Immediate close
/// ```
  Future<void> close([bool immediate = false]);
/// Schedules this popover to close after the current frame.
///
/// This method queues the close operation for the next frame, allowing
/// any current operations to complete before dismissing the popover.
  void closeLater();
/// Immediately removes this popover from the overlay without animations.
///
/// This method bypasses all closing animations and state management,
/// directly removing the popover from the overlay stack. Use with caution
/// as it may interrupt ongoing operations.
  void remove();
/// Gets the current overlay handler state if the popover is mounted.
///
/// Returns null if the popover has been disposed or is not currently
/// in the widget tree. Useful for checking popover status and accessing
/// advanced control methods.
  OverlayHandlerStateMixin? get currentState;
}
/// A controller for managing multiple popovers and their lifecycle.
///
/// [PopoverController] provides centralized management for popover instances,
/// including creation, lifecycle tracking, and coordination between multiple
/// popovers. It handles the complexity of overlay management and provides
/// a clean API for popover operations.
///
/// Key responsibilities:
/// - Creating and showing new popovers
/// - Tracking active popover instances
/// - Coordinating close operations across popovers
/// - Managing popover lifecycle states
/// - Providing status queries for open/mounted popovers
///
/// The controller maintains a list of active popovers and provides methods
/// to query their status, close them individually or collectively, and
/// coordinate their display behavior.
///
/// Example:
/// ```dart
/// class MyWidget extends StatefulWidget {
///   @override
///   _MyWidgetState createState() => _MyWidgetState();
/// }
///
/// class _MyWidgetState extends State<MyWidget> {
///   final PopoverController _popoverController = PopoverController();
///
///   @override
///   void dispose() {
///     _popoverController.dispose();
///     super.dispose();
///   }
///
///   void _showMenu() async {
///     await _popoverController.show(
///       context: context,
///       alignment: Alignment.bottomStart,
///       builder: (context) => MyPopoverContent(),
///     );
///   }
/// }
/// ```
class PopoverController extends ChangeNotifier {
/// Whether there are any open popovers that haven't completed.
///
/// Returns true if any popover is currently open and not yet completed.
  bool get hasOpenPopover;
/// Whether there are any mounted popovers with animations in progress.
///
/// Returns true if any popover is mounted and its animation hasn't completed.
  bool get hasMountedPopover;
/// Gets an unmodifiable view of currently open popovers.
///
/// Returns an iterable of [Popover] instances that are currently managed
/// by this controller.
  Iterable<Popover> get openPopovers;
/// Shows a popover with the specified configuration.
///
/// Creates and displays a popover overlay with extensive customization options.
/// If [closeOthers] is true, closes existing popovers before showing the new one.
///
/// Parameters:
/// - [context] (BuildContext, required): Build context
/// - [builder] (WidgetBuilder, required): Popover content builder
/// - [alignment] (AlignmentGeometry, required): Popover alignment
/// - [anchorAlignment] (AlignmentGeometry?): Anchor alignment
/// - [widthConstraint] (PopoverConstraint): Width constraint, defaults to flexible
/// - [heightConstraint] (PopoverConstraint): Height constraint, defaults to flexible
/// - [modal] (bool): Modal behavior, defaults to true
/// - [closeOthers] (bool): Close other popovers, defaults to true
/// - [offset] (Offset?): Position offset
/// - [key] (`GlobalKey<OverlayHandlerStateMixin>?`): Widget key
/// - [regionGroupId] (Object?): Region group ID
/// - [transitionAlignment] (AlignmentGeometry?): Transition alignment
/// - [consumeOutsideTaps] (bool): Consume outside taps, defaults to true
/// - [margin] (EdgeInsetsGeometry?): Popover margin
/// - [onTickFollow] (`ValueChanged<PopoverOverlayWidgetState>?`): Follow tick callback
/// - [follow] (bool): Follow anchor on move, defaults to true
/// - [allowInvertHorizontal] (bool): Allow horizontal inversion, defaults to true
/// - [allowInvertVertical] (bool): Allow vertical inversion, defaults to true
/// - [dismissBackdropFocus] (bool): Dismiss on backdrop focus, defaults to true
/// - [showDuration] (Duration?): Show animation duration
/// - [hideDuration] (Duration?): Hide animation duration
/// - [overlayBarrier] (OverlayBarrier?): Custom barrier configuration
/// - [handler] (OverlayHandler?): Custom overlay handler
///
/// Returns a [Future] that completes with the popover result when dismissed.
  Future<T?> show<T>({required BuildContext context, required WidgetBuilder builder, required AlignmentGeometry alignment, AlignmentGeometry? anchorAlignment, PopoverConstraint widthConstraint = PopoverConstraint.flexible, PopoverConstraint heightConstraint = PopoverConstraint.flexible, bool modal = true, bool closeOthers = true, Offset? offset, GlobalKey<OverlayHandlerStateMixin>? key, Object? regionGroupId, AlignmentGeometry? transitionAlignment, bool consumeOutsideTaps = true, EdgeInsetsGeometry? margin, ValueChanged<PopoverOverlayWidgetState>? onTickFollow, bool follow = true, bool allowInvertHorizontal = true, bool allowInvertVertical = true, bool dismissBackdropFocus = true, Duration? showDuration, Duration? hideDuration, OverlayBarrier? overlayBarrier, OverlayHandler? handler});
/// Closes all managed popovers.
///
/// Closes all popovers managed by this controller. If [immediate] is true,
/// closes without animation.
///
/// Parameters:
/// - [immediate] (bool): Skip animation if true, defaults to false
  void close([bool immediate = false]);
/// Schedules closure of all popovers for the next frame.
///
/// Defers closing to avoid issues when called during widget builds.
  void closeLater();
  set anchorContext(BuildContext value);
  set alignment(AlignmentGeometry value);
  set anchorAlignment(AlignmentGeometry value);
  set widthConstraint(PopoverConstraint value);
  set heightConstraint(PopoverConstraint value);
  set margin(EdgeInsets value);
  set follow(bool value);
  set offset(Offset? value);
  set allowInvertHorizontal(bool value);
  set allowInvertVertical(bool value);
/// Disposes all managed popovers.
///
/// Schedules closure of all popovers. Called automatically when the
/// controller is disposed.
  void disposePopovers();
  void dispose();
}
/// Custom layout widget for positioning popover content.
///
/// Handles popover positioning with alignment, sizing constraints, and
/// automatic inversion when content would overflow screen bounds.
class PopoverLayout extends SingleChildRenderObjectWidget {
/// Popover alignment relative to anchor.
  Alignment alignment;
/// Anchor alignment for positioning.
  Alignment anchorAlignment;
/// Explicit position offset (overrides alignment).
  Offset? position;
/// Size of the anchor widget.
  Size? anchorSize;
/// Width constraint strategy.
  PopoverConstraint widthConstraint;
/// Height constraint strategy.
  PopoverConstraint heightConstraint;
/// Additional offset from computed position.
  Offset? offset;
/// Margin around the popover.
  EdgeInsets margin;
/// Scale factor for the popover.
  double scale;
/// Alignment point for scaling transformation.
  Alignment scaleAlignment;
/// Filter quality for scaled content.
  FilterQuality? filterQuality;
/// Whether to allow horizontal position inversion.
  bool allowInvertHorizontal;
/// Whether to allow vertical position inversion.
  bool allowInvertVertical;
/// Creates a popover layout widget.
  const PopoverLayout({super.key, required this.alignment, required this.position, required this.anchorAlignment, required this.widthConstraint, required this.heightConstraint, this.anchorSize, this.offset, required this.margin, required Widget super.child, required this.scale, required this.scaleAlignment, this.filterQuality, this.allowInvertHorizontal = true, this.allowInvertVertical = true});
  RenderObject createRenderObject(BuildContext context);
  void updateRenderObject(BuildContext context, covariant PopoverLayoutRender renderObject);
}
/// Custom render object for popover layout positioning.
///
/// Handles the low-level layout calculations for positioning popover content
/// relative to an anchor with automatic constraint adjustments and inversion
/// when the popover would overflow the viewport.
class PopoverLayoutRender extends RenderShiftedBox {
/// Creates a popover layout render object.
///
/// All parameters control how the popover is positioned and sized relative
/// to its anchor.
  PopoverLayoutRender({RenderBox? child, required Alignment alignment, required Offset? position, required Alignment anchorAlignment, required PopoverConstraint widthConstraint, required PopoverConstraint heightConstraint, Size? anchorSize, Offset? offset, EdgeInsets margin = const EdgeInsets.all(8), required double scale, required Alignment scaleAlignment, FilterQuality? filterQuality, bool allowInvertHorizontal = true, bool allowInvertVertical = true});
  Size computeDryLayout(covariant BoxConstraints constraints);
  bool hitTest(BoxHitTestResult result, {required Offset position});
  bool hitTestChildren(BoxHitTestResult result, {required Offset position});
  void applyPaintTransform(RenderBox child, Matrix4 transform);
  bool get alwaysNeedsCompositing;
  void paint(PaintingContext context, Offset offset);
/// Computes appropriate box constraints for the popover child.
///
/// Applies width and height constraint strategies to the child based on
/// anchor size, viewport constraints, and margin settings.
///
/// Parameters:
/// - [constraints]: The incoming constraints from parent
///
/// Returns box constraints with min/max values for width and height.
  BoxConstraints getConstraintsForChild(BoxConstraints constraints);
  void performLayout();
}
/// Theme data for customizing [TooltipContainer] widget appearance.
///
/// This class defines the visual properties that can be applied to
/// tooltip containers, including surface effects, padding, colors,
/// and border styling. These properties can be set at the theme level
/// to provide consistent styling across the application.
class TooltipTheme extends ComponentThemeData {
/// Opacity applied to the tooltip surface color.
  double? surfaceOpacity;
/// Blur amount for the tooltip surface.
  double? surfaceBlur;
/// Padding around the tooltip content.
  EdgeInsetsGeometry? padding;
/// Background color of the tooltip.
  Color? backgroundColor;
/// Border radius of the tooltip container.
  BorderRadiusGeometry? borderRadius;
/// Creates a [TooltipTheme].
  const TooltipTheme({this.surfaceOpacity, this.surfaceBlur, this.padding, this.backgroundColor, this.borderRadius});
/// Creates a copy of this theme but with the given fields replaced.
  TooltipTheme copyWith({ValueGetter<double?>? surfaceOpacity, ValueGetter<double?>? surfaceBlur, ValueGetter<EdgeInsetsGeometry?>? padding, ValueGetter<Color?>? backgroundColor, ValueGetter<BorderRadiusGeometry?>? borderRadius});
  bool operator ==(Object other);
  int get hashCode;
}
/// A styled container widget for tooltip content.
///
/// Provides consistent visual styling for tooltip popups with customizable
/// background, opacity, blur, padding, and border radius. Integrates with
/// the tooltip theme system while allowing per-instance overrides.
class TooltipContainer extends StatelessWidget {
/// The tooltip content widget.
  Widget child;
/// Opacity applied to the background surface (0.0 to 1.0).
  double? surfaceOpacity;
/// Blur radius applied to the background surface.
  double? surfaceBlur;
/// Padding around the tooltip content.
  EdgeInsetsGeometry? padding;
/// Background color of the tooltip container.
  Color? backgroundColor;
/// Border radius for rounded corners.
  BorderRadiusGeometry? borderRadius;
/// Creates a [TooltipContainer].
///
/// All styling parameters are optional and fall back to theme defaults.
///
/// Parameters:
/// - [child] (`Widget`, required): Content to display in the tooltip.
/// - [surfaceOpacity] (`double?`, optional): Background opacity (0.0-1.0).
/// - [surfaceBlur] (`double?`, optional): Background blur radius.
/// - [padding] (`EdgeInsetsGeometry?`, optional): Content padding.
/// - [backgroundColor] (`Color?`, optional): Background color.
/// - [borderRadius] (`BorderRadiusGeometry?`, optional): Border radius.
///
/// Example:
/// ```dart
/// TooltipContainer(
///   surfaceOpacity: 0.9,
///   padding: EdgeInsets.all(8),
///   backgroundColor: Colors.black,
///   borderRadius: BorderRadius.circular(4),
///   child: Text('Tooltip text'),
/// )
/// ```
  const TooltipContainer({super.key, this.surfaceOpacity, this.surfaceBlur, this.padding, this.backgroundColor, this.borderRadius, required this.child});
/// Builds the tooltip container.
///
/// This allows using the widget as a builder function.
  Widget call(BuildContext context);
  Widget build(BuildContext context);
}
/// An interactive tooltip widget that displays contextual information on hover.
///
/// [Tooltip] provides contextual help and information by displaying a small overlay
/// when users hover over or interact with the child widget. It supports configurable
/// positioning, timing, and custom content through builder functions, making it
/// ideal for providing additional context without cluttering the interface.
///
/// Key features:
/// - Hover-activated tooltip display with configurable delays
/// - Flexible positioning with alignment and anchor point control
/// - Custom content through builder functions
/// - Duration controls for show/hide timing and minimum display time
/// - Smooth animations and transitions
/// - Integration with the overlay system for proper z-ordering
/// - Theme support for consistent styling
/// - Automatic positioning adjustment to stay within screen bounds
///
/// Timing behavior:
/// - Wait duration: Time to wait before showing tooltip on hover
/// - Show duration: Animation time for tooltip appearance
/// - Min duration: Minimum time tooltip stays visible once shown
/// - Auto-hide: Tooltip disappears when hover ends (after min duration)
///
/// The tooltip uses a popover-based implementation that ensures proper layering
/// and positioning relative to the trigger widget. The positioning system
/// automatically adjusts to keep tooltips within the viewport.
///
/// Example:
/// ```dart
/// Tooltip(
///   tooltip: (context) => TooltipContainer(
///     child: Text('This button performs a critical action'),
///   ),
///   waitDuration: Duration(milliseconds: 800),
///   showDuration: Duration(milliseconds: 150),
///   alignment: Alignment.topCenter,
///   anchorAlignment: Alignment.bottomCenter,
///   child: IconButton(
///     icon: Icon(Icons.warning),
///     onPressed: () => _handleCriticalAction(),
///   ),
/// );
/// ```
class Tooltip extends StatefulWidget {
/// The widget that triggers the tooltip on hover.
  Widget child;
/// Builder function for the tooltip content.
  WidgetBuilder tooltip;
/// Alignment of the tooltip relative to the anchor.
  AlignmentGeometry alignment;
/// Alignment point on the child widget where tooltip anchors.
  AlignmentGeometry anchorAlignment;
/// Time to wait before showing the tooltip on hover.
  Duration waitDuration;
/// Duration of the tooltip show animation.
  Duration showDuration;
/// Minimum time the tooltip stays visible once shown.
  Duration minDuration;
/// Creates a [Tooltip].
///
/// Parameters:
/// - [child] (`Widget`, required): Widget that triggers the tooltip.
/// - [tooltip] (`WidgetBuilder`, required): Builder for tooltip content.
/// - [alignment] (`AlignmentGeometry`, default: `Alignment.topCenter`): Tooltip position.
/// - [anchorAlignment] (`AlignmentGeometry`, default: `Alignment.bottomCenter`): Anchor point on child.
/// - [waitDuration] (`Duration`, default: 500ms): Delay before showing.
/// - [showDuration] (`Duration`, default: 200ms): Animation duration.
/// - [minDuration] (`Duration`, default: 0ms): Minimum visible time.
  const Tooltip({super.key, required this.child, required this.tooltip, this.alignment = Alignment.topCenter, this.anchorAlignment = Alignment.bottomCenter, this.waitDuration = const Duration(milliseconds: 500), this.showDuration = const Duration(milliseconds: 200), this.minDuration = const Duration(milliseconds: 0)});
  State<Tooltip> createState();
}
/// A tooltip that shows immediately on hover without delay.
///
/// Unlike [Tooltip], this widget displays the tooltip instantly when the
/// mouse enters the child widget area. It's useful for situations where
/// immediate feedback is desired, such as toolbar buttons or icon-only
/// controls where labels need to be visible right away.
///
/// The tooltip automatically closes when the mouse leaves the widget.
class InstantTooltip extends StatefulWidget {
/// The widget that triggers the tooltip on hover.
  Widget child;
/// How to behave during hit testing.
  HitTestBehavior behavior;
/// Builder function for the tooltip content.
  WidgetBuilder tooltipBuilder;
/// Alignment of the tooltip relative to the anchor.
  AlignmentGeometry tooltipAlignment;
/// Alignment point on the child widget where tooltip anchors.
  AlignmentGeometry? tooltipAnchorAlignment;
/// Creates an [InstantTooltip].
///
/// Parameters:
/// - [child] (`Widget`, required): Widget that triggers the tooltip.
/// - [tooltipBuilder] (`WidgetBuilder`, required): Builder for tooltip content.
/// - [behavior] (`HitTestBehavior`, default: `HitTestBehavior.translucent`): Hit test behavior.
/// - [tooltipAlignment] (`AlignmentGeometry`, default: `Alignment.bottomCenter`): Tooltip position.
/// - [tooltipAnchorAlignment] (`AlignmentGeometry?`, optional): Anchor point on child.
///
/// Example:
/// ```dart
/// InstantTooltip(
///   tooltipBuilder: (context) => Text('Help text'),
///   child: Icon(Icons.help),
/// )
/// ```
  const InstantTooltip({super.key, required this.child, required this.tooltipBuilder, this.behavior = HitTestBehavior.translucent, this.tooltipAlignment = Alignment.bottomCenter, this.tooltipAnchorAlignment});
  State<InstantTooltip> createState();
}
/// Overlay handler that delegates tooltip display to an [OverlayManager].
///
/// This handler integrates tooltips with the overlay management system,
/// allowing tooltips to be displayed through the overlay manager's
/// tooltip-specific display logic. This ensures proper layering and
/// lifecycle management within the overlay system.
class OverlayManagerAsTooltipOverlayHandler extends OverlayHandler {
/// The overlay manager instance to use for displaying tooltips.
  OverlayManager overlayManager;
/// Creates an [OverlayManagerAsTooltipOverlayHandler].
///
/// Parameters:
/// - [overlayManager] (`OverlayManager`, required): The overlay manager instance.
  const OverlayManagerAsTooltipOverlayHandler({required this.overlayManager});
  OverlayCompleter<T?> show<T>({required BuildContext context, required AlignmentGeometry alignment, required WidgetBuilder builder, Offset? position, AlignmentGeometry? anchorAlignment, PopoverConstraint widthConstraint = PopoverConstraint.flexible, PopoverConstraint heightConstraint = PopoverConstraint.flexible, Key? key, bool rootOverlay = true, bool barrierDismissable = true, bool modal = true, Clip clipBehavior = Clip.none, Object? regionGroupId, Offset? offset, AlignmentGeometry? transitionAlignment, EdgeInsetsGeometry? margin, bool follow = true, bool consumeOutsideTaps = true, ValueChanged<PopoverOverlayWidgetState>? onTickFollow, bool allowInvertHorizontal = true, bool allowInvertVertical = true, bool dismissBackdropFocus = true, Duration? showDuration, Duration? dismissDuration, OverlayBarrier? overlayBarrier, LayerLink? layerLink});
}
/// A fixed overlay handler for tooltips using direct overlay entries.
///
/// This handler creates tooltips using Flutter's built-in overlay system
/// without delegating to an overlay manager. Tooltips are positioned
/// directly in the overlay and use fixed positioning relative to their
/// anchor widget.
///
/// Use this handler when you need direct control over tooltip overlay
/// entries or when not using an overlay manager.
class FixedTooltipOverlayHandler extends OverlayHandler {
/// Creates a [FixedTooltipOverlayHandler].
  const FixedTooltipOverlayHandler();
  OverlayCompleter<T> show<T>({required BuildContext context, required AlignmentGeometry alignment, required WidgetBuilder builder, Offset? position, AlignmentGeometry? anchorAlignment, PopoverConstraint widthConstraint = PopoverConstraint.flexible, PopoverConstraint heightConstraint = PopoverConstraint.flexible, Key? key, bool rootOverlay = true, bool modal = true, bool barrierDismissable = true, Clip clipBehavior = Clip.none, Object? regionGroupId, Offset? offset, AlignmentGeometry? transitionAlignment, EdgeInsetsGeometry? margin, bool follow = true, bool consumeOutsideTaps = true, ValueChanged<PopoverOverlayWidgetState>? onTickFollow, bool allowInvertHorizontal = true, bool allowInvertVertical = true, bool dismissBackdropFocus = true, Duration? showDuration, Duration? dismissDuration, OverlayBarrier? overlayBarrier, LayerLink? layerLink});
}
/// Theme configuration for drawer and sheet overlays.
///
/// Defines visual properties for drawer and sheet components including
/// surface effects, drag handles, and barrier appearance.
///
/// Features:
/// - Surface opacity and blur effects
/// - Customizable barrier colors
/// - Drag handle appearance control
/// - Consistent theming across drawer types
///
/// Example:
/// ```dart
/// ComponentThemeData(
///   data: {
///     DrawerTheme: DrawerTheme(
///       surfaceOpacity: 0.9,
///       barrierColor: Colors.black54,
///       showDragHandle: true,
///     ),
///   },
///   child: MyApp(),
/// )
/// ```
class DrawerTheme extends ComponentThemeData {
/// Surface opacity for backdrop effects.
  double? surfaceOpacity;
/// Surface blur intensity for backdrop effects.
  double? surfaceBlur;
/// Color of the barrier behind the drawer.
  Color? barrierColor;
/// Whether to display the drag handle for draggable drawers.
  bool? showDragHandle;
/// Size of the drag handle when displayed.
  Size? dragHandleSize;
/// Creates a [DrawerTheme].
///
/// All parameters are optional and will use system defaults when null.
///
/// Parameters:
/// - [surfaceOpacity] (double?, optional): opacity for backdrop surface effects
/// - [surfaceBlur] (double?, optional): blur intensity for backdrop effects
/// - [barrierColor] (Color?, optional): color of the modal barrier
/// - [showDragHandle] (bool?, optional): whether to show drag handles
/// - [dragHandleSize] (Size?, optional): size of the drag handle
///
/// Example:
/// ```dart
/// const DrawerTheme(
///   surfaceOpacity: 0.95,
///   showDragHandle: true,
///   barrierColor: Color.fromRGBO(0, 0, 0, 0.7),
/// )
/// ```
  const DrawerTheme({this.surfaceOpacity, this.surfaceBlur, this.barrierColor, this.showDragHandle, this.dragHandleSize});
/// Creates a copy of this theme with the given fields replaced.
///
/// Parameters:
/// - [surfaceOpacity] (`ValueGetter<double?>?`, optional): New surface opacity.
/// - [surfaceBlur] (`ValueGetter<double?>?`, optional): New surface blur amount.
/// - [barrierColor] (`ValueGetter<Color?>?`, optional): New barrier color.
/// - [showDragHandle] (`ValueGetter<bool?>?`, optional): New show drag handle setting.
/// - [dragHandleSize] (`ValueGetter<Size?>?`, optional): New drag handle size.
///
/// Returns: A new [DrawerTheme] with updated properties.
  DrawerTheme copyWith({ValueGetter<double?>? surfaceOpacity, ValueGetter<double?>? surfaceBlur, ValueGetter<Color?>? barrierColor, ValueGetter<bool?>? showDragHandle, ValueGetter<Size?>? dragHandleSize});
  bool operator ==(Object other);
  int get hashCode;
  String toString();
}
/// Opens a drawer overlay with comprehensive customization options.
///
/// Creates a modal drawer that slides in from the specified position with
/// draggable interaction, backdrop transformation, and proper theme integration.
/// Returns a completer that can be used to control the drawer lifecycle.
///
/// Features:
/// - Configurable slide-in positions (left, right, top, bottom)
/// - Draggable interaction with gesture support
/// - Backdrop transformation and scaling effects
/// - Safe area handling and proper theming
/// - Dismissible barriers and custom backdrop builders
///
/// Parameters:
/// - [context] (BuildContext, required): build context for overlay creation
/// - [builder] (WidgetBuilder, required): function that builds drawer content
/// - [position] (OverlayPosition, required): side from which drawer slides in
/// - [expands] (bool, default: false): whether drawer should expand to fill available space
/// - [draggable] (bool, default: true): whether drawer can be dragged to dismiss
/// - [barrierDismissible] (bool, default: true): whether tapping barrier dismisses drawer
/// - [backdropBuilder] (WidgetBuilder?, optional): custom backdrop builder
/// - [useSafeArea] (bool, default: true): whether to respect device safe areas
/// - [showDragHandle] (bool?, optional): whether to show drag handle
/// - [borderRadius] (BorderRadiusGeometry?, optional): corner radius for drawer
/// - [dragHandleSize] (Size?, optional): size of the drag handle
/// - [transformBackdrop] (bool, default: true): whether to scale backdrop
/// - [surfaceOpacity] (double?, optional): opacity for surface effects
/// - [surfaceBlur] (double?, optional): blur intensity for surface effects
/// - [barrierColor] (Color?, optional): color of the modal barrier
/// - [animationController] (AnimationController?, optional): custom animation controller
/// - [autoOpen] (bool, default: true): whether to automatically open on creation
/// - [constraints] (BoxConstraints?, optional): size constraints for drawer
/// - [alignment] (AlignmentGeometry?, optional): alignment within constraints
///
/// Returns:
/// A [DrawerOverlayCompleter] that provides control over the drawer lifecycle.
///
/// Example:
/// ```dart
/// final completer = openDrawerOverlay<String>(
///   context: context,
///   position: OverlayPosition.left,
///   builder: (context) => DrawerContent(),
///   draggable: true,
///   barrierDismissible: true,
/// );
/// final result = await completer.future;
/// ```
DrawerOverlayCompleter<T?> openDrawerOverlay<T>({required BuildContext context, required WidgetBuilder builder, required OverlayPosition position, bool expands = false, bool draggable = true, bool barrierDismissible = true, WidgetBuilder? backdropBuilder, bool useSafeArea = true, bool? showDragHandle, BorderRadiusGeometry? borderRadius, Size? dragHandleSize, bool transformBackdrop = true, double? surfaceOpacity, double? surfaceBlur, Color? barrierColor, AnimationController? animationController, bool autoOpen = true, BoxConstraints? constraints, AlignmentGeometry? alignment});
/// Opens a sheet overlay with minimal styling and full-screen expansion.
///
/// Creates a sheet overlay that slides in from the specified position,
/// typically used for bottom sheets or side panels. Unlike drawers,
/// sheets don't transform the backdrop and have minimal decoration.
///
/// Features:
/// - Full-screen expansion with edge-to-edge content
/// - Minimal styling and decoration
/// - Optional drag interaction
/// - Safe area integration
/// - Barrier dismissal support
///
/// Parameters:
/// - [context] (BuildContext, required): build context for overlay creation
/// - [builder] (WidgetBuilder, required): function that builds sheet content
/// - [position] (OverlayPosition, required): side from which sheet slides in
/// - [barrierDismissible] (bool, default: true): whether tapping barrier dismisses sheet
/// - [transformBackdrop] (bool, default: false): whether to transform backdrop
/// - [backdropBuilder] (WidgetBuilder?, optional): custom backdrop builder
/// - [barrierColor] (Color?, optional): color of the modal barrier
/// - [draggable] (bool, default: false): whether sheet can be dragged to dismiss
/// - [animationController] (AnimationController?, optional): custom animation controller
/// - [autoOpen] (bool, default: true): whether to automatically open on creation
/// - [constraints] (BoxConstraints?, optional): size constraints for sheet
/// - [alignment] (AlignmentGeometry?, optional): alignment within constraints
///
/// Returns:
/// A [DrawerOverlayCompleter] that provides control over the sheet lifecycle.
///
/// Example:
/// ```dart
/// final completer = openSheetOverlay<bool>(
///   context: context,
///   position: OverlayPosition.bottom,
///   builder: (context) => BottomSheetContent(),
///   draggable: true,
/// );
/// ```
DrawerOverlayCompleter<T?> openSheetOverlay<T>({required BuildContext context, required WidgetBuilder builder, required OverlayPosition position, bool barrierDismissible = true, bool transformBackdrop = false, WidgetBuilder? backdropBuilder, Color? barrierColor, bool draggable = false, AnimationController? animationController, bool autoOpen = true, BoxConstraints? constraints, AlignmentGeometry? alignment});
/// Opens a drawer and returns a future that completes when dismissed.
///
/// Convenience function that opens a drawer overlay and returns the future
/// directly, suitable for use with async/await patterns.
///
/// Returns:
/// A [Future] that completes with the result when the drawer is dismissed.
///
/// Example:
/// ```dart
/// final result = await openDrawer<String>(
///   context: context,
///   position: OverlayPosition.left,
///   builder: (context) => MyDrawerContent(),
/// );
/// ```
Future<T?> openDrawer<T>({required BuildContext context, required WidgetBuilder builder, required OverlayPosition position, bool expands = false, bool draggable = true, bool barrierDismissible = true, WidgetBuilder? backdropBuilder, bool useSafeArea = true, bool? showDragHandle, BorderRadiusGeometry? borderRadius, Size? dragHandleSize, bool transformBackdrop = true, double? surfaceOpacity, double? surfaceBlur, Color? barrierColor, AnimationController? animationController, BoxConstraints? constraints, AlignmentGeometry? alignment});
/// Opens a sheet and returns a future that completes when dismissed.
///
/// Convenience function that opens a sheet overlay and returns the future
/// directly, suitable for use with async/await patterns.
///
/// Returns:
/// A [Future] that completes with the result when the sheet is dismissed.
///
/// Example:
/// ```dart
/// final accepted = await openSheet<bool>(
///   context: context,
///   position: OverlayPosition.bottom,
///   builder: (context) => ConfirmationSheet(),
/// );
/// ```
Future<T?> openSheet<T>({required BuildContext context, required WidgetBuilder builder, required OverlayPosition position, bool barrierDismissible = true, bool transformBackdrop = false, Color? barrierColor, bool draggable = false, AnimationController? animationController, WidgetBuilder? backdropBuilder, BoxConstraints? constraints, AlignmentGeometry? alignment});
/// Internal wrapper widget for drawer/sheet rendering.
///
/// Manages the visual presentation and interaction behavior of drawer overlays.
/// Handles sizing, positioning, drag interactions, and animations.
class DrawerWrapper extends StatefulWidget {
/// Position of the drawer on screen.
  OverlayPosition position;
/// Content widget displayed in the drawer.
  Widget child;
/// Whether the drawer expands to fill available space.
  bool expands;
/// Whether the drawer can be dragged to resize or dismiss.
  bool draggable;
/// Additional size beyond the content size.
  Size extraSize;
/// Size of the drawer.
  Size size;
/// Whether to show the drag handle.
  bool showDragHandle;
/// Border radius for the drawer.
  BorderRadiusGeometry? borderRadius;
/// Size of the drag handle.
  Size? dragHandleSize;
/// Internal padding of the drawer content.
  EdgeInsets padding;
/// Surface opacity for the drawer background.
  double? surfaceOpacity;
/// Surface blur amount for the drawer background.
  double? surfaceBlur;
/// Color of the barrier behind the drawer.
  Color? barrierColor;
/// Z-index for stacking multiple drawers.
  int stackIndex;
/// Gap before the drag handle.
  double? gapBeforeDragger;
/// Gap after the drag handle.
  double? gapAfterDragger;
/// Optional animation controller for custom animations.
  AnimationController? animationController;
/// Size constraints for the drawer.
  BoxConstraints? constraints;
/// Alignment of the drawer content.
  AlignmentGeometry? alignment;
/// Creates a [DrawerWrapper].
  const DrawerWrapper({super.key, required this.position, required this.child, this.expands = false, this.draggable = true, this.extraSize = Size.zero, required this.size, this.showDragHandle = true, this.borderRadius, this.dragHandleSize, this.padding = EdgeInsets.zero, this.surfaceOpacity, this.surfaceBlur, this.barrierColor, this.gapBeforeDragger, this.gapAfterDragger, required this.stackIndex, this.animationController, this.constraints, this.alignment});
  State<DrawerWrapper> createState();
}
/// Closes the currently open sheet overlay.
///
/// Dismisses the active sheet by closing the drawer. Sheets are drawers
/// without backdrop transformation.
///
/// Parameters:
/// - [context] (`BuildContext`, required): Build context.
///
/// Returns: `Future<void>` that completes when sheet is closed.
Future<void> closeSheet(BuildContext context);
/// Wrapper widget for sheet overlays.
///
/// Extends [DrawerWrapper] with sheet-specific defaults (no drag, no expansion).
/// Sheets are simplified drawers without backdrop transformation.
class SheetWrapper extends DrawerWrapper {
/// Creates a [SheetWrapper].
  const SheetWrapper({super.key, required super.position, required super.child, required super.size, required super.stackIndex, super.draggable = false, super.expands = false, super.extraSize = Size.zero, super.padding, super.surfaceBlur, super.surfaceOpacity, super.barrierColor, super.gapBeforeDragger, super.gapAfterDragger, super.constraints, super.alignment});
  State<DrawerWrapper> createState();
}
/// Position for overlay components like drawers and sheets.
enum OverlayPosition { left, right, top, bottom, start, end }
/// Scale factor for backdrop transform when drawer is open.
///
/// Constant value of 0.95 creates a subtle zoom-out effect on the
/// background content when overlays appear.
const kBackdropScaleDown = 0.95;
/// Data class containing backdrop transformation information.
///
/// Holds the size difference needed to scale and position backdrop
/// content when overlays are displayed.
class BackdropTransformData {
/// The difference in size between original and transformed backdrop.
  Size sizeDifference;
/// Creates backdrop transform data.
///
/// Parameters:
/// - [sizeDifference] (Size, required): Size difference for transform
  BackdropTransformData(this.sizeDifference);
}
/// Opens a raw drawer overlay with full customization.
///
/// Low-level function for creating custom drawer overlays. Provides complete
/// control over drawer positioning, appearance, and behavior.
///
/// Parameters:
/// - [key] (`Key?`, optional): Widget key.
/// - [context] (`BuildContext`, required): Build context.
/// - [builder] (`DrawerBuilder`, required): Drawer content builder.
/// - [position] (`OverlayPosition`, required): Drawer position on screen.
/// - [transformBackdrop] (`bool`, default: `true`): Whether to transform backdrop.
/// - [useRootDrawerOverlay] (`bool`, default: `true`): Use root overlay.
/// - [modal] (`bool`, default: `true`): Whether drawer is modal.
/// - [barrierColor] (`Color?`, optional): Barrier color.
/// - [barrierDismissible] (`bool`, default: `true`): Dismissible by tapping barrier.
/// - [backdropBuilder] (`WidgetBuilder?`, optional): Custom backdrop builder.
/// - [useSafeArea] (`bool`, default: `true`): Respect safe area.
/// - [animationController] (`AnimationController?`, optional): Custom animation.
/// - [autoOpen] (`bool`, default: `true`): Auto-open on creation.
/// - [constraints] (`BoxConstraints?`, optional): Size constraints.
/// - [alignment] (`AlignmentGeometry?`, optional): Content alignment.
///
/// Returns: `DrawerOverlayCompleter<T?>` for managing the drawer lifecycle.
DrawerOverlayCompleter<T?> openRawDrawer<T>({Key? key, required BuildContext context, required DrawerBuilder builder, required OverlayPosition position, bool transformBackdrop = true, bool useRootDrawerOverlay = true, bool modal = true, Color? barrierColor, bool barrierDismissible = true, WidgetBuilder? backdropBuilder, bool useSafeArea = true, AnimationController? animationController, bool autoOpen = true, BoxConstraints? constraints, AlignmentGeometry? alignment});
/// Closes the currently open drawer overlay.
///
/// Dismisses the active drawer from the overlay stack. Optionally returns
/// a result value to the code that opened the drawer.
///
/// Parameters:
/// - [context] (`BuildContext`, required): Build context from within the drawer.
/// - [result] (`T?`, optional): Optional result to return.
///
/// Returns: `Future<void>` that completes when drawer is closed.
Future<void> closeDrawer<T>(BuildContext context, [T? result]);
/// Data class representing a drawer overlay layer in the hierarchy.
///
/// Tracks the drawer overlay state and its parent layer, enabling nested
/// drawer management and size computation across the layer stack.
class DrawerLayerData {
/// The drawer overlay state for this layer.
  DrawerOverlayState overlay;
/// The parent drawer layer, null if this is the root layer.
  DrawerLayerData? parent;
/// Creates drawer layer data.
///
/// Parameters:
/// - [overlay] (DrawerOverlayState, required): Overlay state for this layer
/// - [parent] (DrawerLayerData?): Parent layer in the hierarchy
  const DrawerLayerData(this.overlay, this.parent);
/// Computes the size of this drawer layer.
///
/// Delegates to the overlay state to calculate the layer dimensions.
///
/// Returns the computed size or null if not available.
  Size? computeSize();
  bool operator ==(Object other);
  int get hashCode;
}
/// Widget that manages drawer overlay layers.
///
/// Provides a container for drawer overlays, managing their lifecycle and
/// hierarchical relationships. Supports nested drawers through layer data
/// propagation.
///
/// Example:
/// ```dart
/// DrawerOverlay(
///   child: MyAppContent(),
/// )
/// ```
class DrawerOverlay extends StatefulWidget {
/// Child widget displayed under the overlay layer.
  Widget child;
/// Creates a drawer overlay.
///
/// Parameters:
/// - [child] (Widget, required): Content widget
  const DrawerOverlay({super.key, required this.child});
  State<DrawerOverlay> createState();
/// Finds the drawer layer data from the widget tree.
///
/// Searches up the widget tree for the nearest [DrawerLayerData].
/// Optionally navigates to the root layer if [root] is true.
///
/// Parameters:
/// - [context] (BuildContext, required): Build context
/// - [root] (bool): Whether to find root layer, defaults to false
///
/// Returns [DrawerLayerData] or null if not found.
  static DrawerLayerData? maybeFind(BuildContext context, [bool root = false]);
/// Finds the drawer layer data using messenger lookup.
///
/// Similar to [maybeFind] but uses the messenger mechanism for lookup.
/// Optionally navigates to the root layer if [root] is true.
///
/// Parameters:
/// - [context] (BuildContext, required): Build context
/// - [root] (bool): Whether to find root layer, defaults to false
///
/// Returns [DrawerLayerData] or null if not found.
  static DrawerLayerData? maybeFindMessenger(BuildContext context, [bool root = false]);
}
/// State class for [DrawerOverlay] managing drawer entry lifecycle.
///
/// Manages the stack of active drawer overlays, handling their addition,
/// removal, and size computation. Maintains a backdrop key for managing
/// backdrop transformations.
class DrawerOverlayState extends State<DrawerOverlay> {
/// Key for the backdrop widget to enable transformations.
  GlobalKey backdropKey;
/// Adds a drawer overlay entry to the list of active entries.
///
/// Updates the widget state to include the new entry, triggering a rebuild
/// to display the drawer overlay.
///
/// Parameters:
/// - [entry] (`DrawerOverlayEntry`, required): The drawer entry to add.
///
/// Example:
/// ```dart
/// final entry = DrawerOverlayEntry(
///   builder: (context) => MyDrawerContent(),
/// );
/// drawerState.addEntry(entry);
/// ```
  void addEntry(DrawerOverlayEntry entry);
/// Computes the size of the drawer overlay area.
///
/// Returns the size of the overlay's render box. Used for positioning
/// and sizing drawer content.
///
/// Throws [AssertionError] if overlay is not ready (no size available).
///
/// Returns [Size] of the overlay area.
  Size computeSize();
/// Removes a drawer entry from the overlay stack.
///
/// Triggers a rebuild to update the overlay display after removing
/// the specified entry.
///
/// Parameters:
/// - [entry] (DrawerOverlayEntry, required): Entry to remove
  void removeEntry(DrawerOverlayEntry entry);
  Widget build(BuildContext context);
}
/// Widget representing a single drawer entry in the overlay stack.
///
/// Manages the lifecycle and rendering of an individual drawer overlay,
/// including its backdrop, barrier, and animated transitions.
class DrawerEntryWidget<T> extends StatefulWidget {
/// Builder function for the drawer content.
  DrawerBuilder builder;
/// Backdrop widget (content behind the drawer).
  Widget backdrop;
/// Builder for transforming the backdrop.
  BackdropBuilder backdropBuilder;
/// Builder for the modal barrier.
  BarrierBuilder barrierBuilder;
/// Whether the drawer is modal (blocks interaction with backdrop).
  bool modal;
/// Captured theme data to apply within the drawer.
  CapturedThemes? themes;
/// Captured inherited data to propagate.
  CapturedData? data;
/// Completer for the drawer's result value.
  Completer<T> completer;
/// Position of the drawer (left, right, top, bottom, start, end).
  OverlayPosition position;
/// Index of this drawer in the stack.
  int stackIndex;
/// Total number of drawers in the stack.
  int totalStack;
/// Whether to apply safe area insets.
  bool useSafeArea;
/// Optional external animation controller.
  AnimationController? animationController;
/// Whether to automatically open on mount.
  bool autoOpen;
/// Creates a drawer entry widget.
  const DrawerEntryWidget({super.key, required this.builder, required this.backdrop, required this.backdropBuilder, required this.barrierBuilder, required this.modal, required this.themes, required this.completer, required this.position, required this.stackIndex, required this.totalStack, required this.data, required this.useSafeArea, required this.animationController, required this.autoOpen});
  State<DrawerEntryWidget<T>> createState();
}
/// State class for [DrawerEntryWidget] managing drawer animations and lifecycle.
///
/// Handles animation control, focus management, and drawer dismissal.
/// Manages both internal and external animation controllers.
class DrawerEntryWidgetState<T> extends State<DrawerEntryWidget<T>> with SingleTickerProviderStateMixin {
/// Notifier for additional offset applied during drag gestures.
  ValueNotifier<double> additionalOffset;
  void initState();
  void dispose();
  void didUpdateWidget(covariant DrawerEntryWidget<T> oldWidget);
/// Closes the drawer with an optional result value.
///
/// Animates the drawer out using an ease-out cubic curve, then completes
/// the completer with the provided result.
///
/// Parameters:
/// - [result] (T?): Optional result to return when drawer closes
///
/// Returns a [Future] that completes when the close animation finishes.
  Future<void> close([T? result]);
  Widget build(BuildContext context);
}
/// Data class representing a drawer overlay entry in the stack.
///
/// Encapsulates all configuration and state needed to render a single
/// drawer overlay, including builders, animation, theming, and positioning.
class DrawerOverlayEntry<T> {
/// Key for accessing the drawer entry widget state.
  GlobalKey<DrawerEntryWidgetState<T>> key;
/// Builder for backdrop transformations.
  BackdropBuilder backdropBuilder;
/// Builder for drawer content.
  DrawerBuilder builder;
/// Whether the drawer is modal.
  bool modal;
/// Builder for the modal barrier.
  BarrierBuilder barrierBuilder;
/// Captured theme data.
  CapturedThemes? themes;
/// Captured inherited data.
  CapturedData? data;
/// Completer for the drawer result.
  Completer<T> completer;
/// Position of the drawer.
  OverlayPosition position;
/// Whether tapping the barrier dismisses the drawer.
  bool barrierDismissible;
/// Whether to apply safe area insets.
  bool useSafeArea;
/// Optional external animation controller.
  AnimationController? animationController;
/// Whether to automatically open on mount.
  bool autoOpen;
/// Size constraints for the drawer.
  BoxConstraints? constraints;
/// Alignment of the drawer content.
  AlignmentGeometry? alignment;
/// Creates a drawer overlay entry.
  DrawerOverlayEntry({required this.builder, required this.backdropBuilder, required this.modal, required this.barrierBuilder, required this.themes, required this.completer, required this.position, required this.data, required this.barrierDismissible, required this.useSafeArea, required this.animationController, required this.autoOpen, required this.constraints, required this.alignment});
}
/// Completer for drawer overlay operations.
///
/// Wraps a [DrawerOverlayEntry] to provide overlay lifecycle management,
/// including animation tracking and dismissal handling.
class DrawerOverlayCompleter<T> extends OverlayCompleter<T> {
/// Creates a drawer overlay completer.
///
/// Parameters:
/// - [_entry] (`DrawerOverlayEntry<T>`, required): The drawer entry to manage
  DrawerOverlayCompleter(this._entry);
  Future<void> get animationFuture;
  void dispose();
/// Gets the animation controller for the drawer.
///
/// Returns the external animation controller if provided, otherwise
/// returns the internal controller from the drawer entry widget state.
///
/// Returns [AnimationController] or null if not available.
  AnimationController? get animationController;
  Future<T> get future;
  bool get isAnimationCompleted;
  bool get isCompleted;
  void remove();
}
/// Overlay handler specialized for sheet-style overlays.
///
/// Provides a simplified API for showing sheet overlays (bottom sheets,
/// side sheets, etc.) with standard positioning and barrier behavior.
class SheetOverlayHandler extends OverlayHandler {
/// Checks if the current context is within a sheet overlay.
///
/// Parameters:
/// - [context] (BuildContext, required): Build context to check
///
/// Returns true if context is within a sheet overlay, false otherwise.
  static bool isSheetOverlay(BuildContext context);
/// Position where the sheet appears.
  OverlayPosition position;
/// Optional barrier color for the modal backdrop.
  Color? barrierColor;
/// Creates a sheet overlay handler.
///
/// Parameters:
/// - [position] (OverlayPosition): Sheet position, defaults to bottom
/// - [barrierColor] (Color?): Optional barrier color
  const SheetOverlayHandler({this.position = OverlayPosition.bottom, this.barrierColor});
  bool operator ==(Object other);
  int get hashCode;
  OverlayCompleter<T?> show<T>({required BuildContext context, required AlignmentGeometry alignment, required WidgetBuilder builder, Offset? position, AlignmentGeometry? anchorAlignment, PopoverConstraint widthConstraint = PopoverConstraint.flexible, PopoverConstraint heightConstraint = PopoverConstraint.flexible, Key? key, bool rootOverlay = true, bool modal = true, bool barrierDismissable = true, Clip clipBehavior = Clip.none, Object? regionGroupId, Offset? offset, AlignmentGeometry? transitionAlignment, EdgeInsetsGeometry? margin, bool follow = true, bool consumeOutsideTaps = true, ValueChanged<PopoverOverlayWidgetState>? onTickFollow, bool allowInvertHorizontal = true, bool allowInvertVertical = true, bool dismissBackdropFocus = true, Duration? showDuration, Duration? dismissDuration, OverlayBarrier? overlayBarrier, LayerLink? layerLink});
}
/// Theme configuration for [RefreshTrigger].
///
/// Example usage:
/// ```dart
/// ComponentTheme(
///   data: RefreshTriggerTheme(
///     minExtent: 100.0,
///     maxExtent: 200.0,
///     curve: Curves.easeInOut,
///     completeDuration: Duration(milliseconds: 800),
///   ),
///   child: RefreshTrigger(
///     onRefresh: () async {
///       // Refresh logic here
///     },
///     child: ListView(
///       children: [
///         // List items
///       ],
///     ),
///   ),
/// )
/// ```
class RefreshTriggerTheme extends ComponentThemeData {
/// Minimum pull extent required to trigger refresh.
  double? minExtent;
/// Maximum pull extent allowed.
  double? maxExtent;
/// Builder for the refresh indicator.
  RefreshIndicatorBuilder? indicatorBuilder;
/// Animation curve for the refresh trigger.
  Curve? curve;
/// Duration for the completion animation.
  Duration? completeDuration;
/// Creates a [RefreshTriggerTheme].
  const RefreshTriggerTheme({this.minExtent, this.maxExtent, this.indicatorBuilder, this.curve, this.completeDuration});
/// Creates a copy of this theme but with the given fields replaced.
  RefreshTriggerTheme copyWith({ValueGetter<double?>? minExtent, ValueGetter<double?>? maxExtent, ValueGetter<RefreshIndicatorBuilder?>? indicatorBuilder, ValueGetter<Curve?>? curve, ValueGetter<Duration?>? completeDuration});
  bool operator ==(Object other);
  int get hashCode;
  String toString();
}
/// A widget that provides pull-to-refresh functionality.
///
/// The [RefreshTrigger] wraps a scrollable widget and provides pull-to-refresh
/// functionality. When the user pulls the content beyond the [minExtent],
/// the [onRefresh] callback is triggered.
///
/// You can customize the appearance and behavior using [RefreshTriggerTheme]:
/// ```dart
/// ComponentTheme(
///   data: RefreshTriggerTheme(
///     minExtent: 100.0,
///     maxExtent: 200.0,
///     curve: Curves.bounceOut,
///   ),
///   child: RefreshTrigger(...),
/// )
/// ```
/// Pull-to-refresh gesture handler with customizable visual indicators.
///
/// Wraps scrollable content to provide pull-to-refresh functionality similar to
/// native mobile applications. Supports both vertical and horizontal refresh
/// gestures with fully customizable visual indicators and animation behavior.
///
/// Key Features:
/// - **Pull Gesture Detection**: Recognizes pull gestures beyond scroll boundaries
/// - **Visual Feedback**: Customizable refresh indicators with progress animation
/// - **Flexible Direction**: Supports vertical and horizontal refresh directions
/// - **Reverse Mode**: Can trigger from opposite direction (e.g., bottom-up)
/// - **Theme Integration**: Full theme support with customizable appearance
/// - **Async Support**: Handles async refresh operations with loading states
/// - **Physics Integration**: Works with any ScrollPhysics implementation
///
/// Operation Flow:
/// 1. User pulls scrollable content beyond normal bounds
/// 2. Visual indicator appears and updates based on pull distance
/// 3. When minimum threshold reached, indicator shows "ready to refresh" state
/// 4. On release, onRefresh callback is triggered
/// 5. Loading indicator shows during async refresh operation
/// 6. Completion animation plays when refresh finishes
/// 7. Content returns to normal scroll position
///
/// The component integrates seamlessly with ListView, GridView, CustomScrollView,
/// and other scrollable widgets without requiring changes to existing scroll behavior.
///
/// Example:
/// ```dart
/// RefreshTrigger(
///   minExtent: 80.0,
///   maxExtent: 150.0,
///   onRefresh: () async {
///     await Future.delayed(Duration(seconds: 2));
///     // Refresh data here
///   },
///   child: ListView.builder(
///     itemCount: items.length,
///     itemBuilder: (context, index) => ListTile(
///       title: Text(items[index]),
///     ),
///   ),
/// )
/// ```
class RefreshTrigger extends StatefulWidget {
/// Default indicator builder that creates a spinning progress indicator.
///
/// Displays a platform-appropriate circular progress indicator that rotates
/// based on pull extent and animates during refresh.
  static Widget defaultIndicatorBuilder(BuildContext context, RefreshTriggerStage stage);
/// Minimum pull extent required to trigger refresh.
///
/// Pull distance must exceed this value to activate the refresh callback.
/// If null, uses theme or default value.
  double? minExtent;
/// Maximum pull extent allowed.
///
/// Limits how far the user can pull to prevent excessive stretching.
/// If null, uses theme or default value.
  double? maxExtent;
/// Callback invoked when refresh is triggered.
///
/// Should return a Future that completes when the refresh operation finishes.
/// While the Future is pending, the refresh indicator shows loading state.
  FutureVoidCallback? onRefresh;
/// The scrollable child widget being refreshed.
  Widget child;
/// Direction of the pull gesture.
///
/// Defaults to [Axis.vertical] for standard top-down pull-to-refresh.
  Axis direction;
/// Whether to reverse the pull direction.
///
/// If true, pull gesture is inverted (e.g., pull down instead of up).
  bool reverse;
/// Custom builder for the refresh indicator.
///
/// If null, uses [defaultIndicatorBuilder].
  RefreshIndicatorBuilder? indicatorBuilder;
/// Animation curve for extent changes.
///
/// Controls how the pull extent animates during interactions.
  Curve? curve;
/// Duration for the completion animation.
///
/// Time to display the completion state before hiding the indicator.
  Duration? completeDuration;
/// Creates a [RefreshTrigger] with pull-to-refresh functionality.
///
/// Wraps the provided child widget with refresh gesture detection and
/// visual indicator management.
///
/// Parameters:
/// - [child] (Widget, required): Scrollable content to wrap with refresh capability
/// - [onRefresh] (FutureVoidCallback?, optional): Async callback triggered on refresh
/// - [direction] (Axis, default: Axis.vertical): Pull gesture direction
/// - [reverse] (bool, default: false): Whether to trigger from opposite direction
/// - [minExtent] (double?, optional): Minimum pull distance to trigger refresh
/// - [maxExtent] (double?, optional): Maximum allowed pull distance
/// - [indicatorBuilder] (RefreshIndicatorBuilder?, optional): Custom indicator widget builder
/// - [curve] (Curve?, optional): Animation curve for refresh transitions
/// - [completeDuration] (Duration?, optional): Duration of completion animation
///
/// The [onRefresh] callback should return a Future that completes when the
/// refresh operation is finished. During this time, a loading indicator will be shown.
///
/// Example:
/// ```dart
/// RefreshTrigger(
///   onRefresh: () async {
///     final newData = await fetchDataFromAPI();
///     setState(() => items = newData);
///   },
///   minExtent: 60,
///   direction: Axis.vertical,
///   child: ListView(children: widgets),
/// )
/// ```
  const RefreshTrigger({super.key, this.minExtent, this.maxExtent, this.onRefresh, this.direction = Axis.vertical, this.reverse = false, this.indicatorBuilder, this.curve, this.completeDuration, required this.child});
  State<RefreshTrigger> createState();
}
/// Default refresh indicator widget with platform-appropriate styling.
///
/// Displays a circular progress indicator that responds to pull gestures
/// and animates during the refresh lifecycle stages.
class DefaultRefreshIndicator extends StatefulWidget {
/// Current refresh trigger stage.
  RefreshTriggerStage stage;
/// Creates a default refresh indicator.
  const DefaultRefreshIndicator({super.key, required this.stage});
  State<DefaultRefreshIndicator> createState();
}
/// State for the refresh trigger widget.
///
/// Manages the refresh lifecycle, gesture detection, and animation coordination
/// for pull-to-refresh functionality.
class RefreshTriggerState extends State<RefreshTrigger> with SingleTickerProviderStateMixin {
  void didChangeDependencies();
  void didUpdateWidget(RefreshTrigger oldWidget);
/// Triggers a refresh programmatically.
///
/// Initiates the refresh animation and invokes the provided callback or
/// widget's [onRefresh] callback. Can be called from parent widgets to
/// trigger refresh without user gesture.
///
/// Parameters:
/// - [refreshCallback]: Optional callback to use instead of widget's onRefresh
///
/// Returns a Future that completes when refresh finishes.
  Future<void> refresh([FutureVoidCallback? refreshCallback]);
  Widget build(BuildContext context);
}
/// Lifecycle stages of a refresh trigger.
///
/// Represents the different states a refresh indicator can be in:
/// - [idle]: No refresh in progress, waiting for user interaction
/// - [pulling]: User is pulling but hasn't reached min extent
/// - [refreshing]: Refresh callback is executing
/// - [completed]: Refresh completed, showing completion state
enum TriggerStage { idle, pulling, refreshing, completed }
/// Immutable snapshot of refresh trigger state.
///
/// Provides information about the current refresh stage and pull extent
/// to indicator builders for rendering appropriate UI.
class RefreshTriggerStage {
/// Current stage of the refresh lifecycle.
  TriggerStage stage;
/// Animated pull extent value.
///
/// Range depends on min/max extent configuration. Use [extentValue] for
/// current numeric value.
  Animation<double> extent;
/// Direction of the pull gesture.
  Axis direction;
/// Whether the pull direction is reversed.
  bool reverse;
/// Creates a refresh trigger stage snapshot.
  const RefreshTriggerStage(this.stage, this.extent, this.direction, this.reverse);
/// Current numeric value of the pull extent.
///
/// Convenience getter for [extent.value].
  double get extentValue;
}
/// Custom scroll physics for refresh trigger behavior.
///
/// Enables over-scroll to allow pulling beyond content bounds for refresh.
/// Applied automatically by [RefreshTrigger] to its child scrollable.
class RefreshTriggerPhysics extends ScrollPhysics {
}
/// Theme configuration for toast notification system.
///
/// Provides comprehensive styling properties for toast notifications including
/// layout, positioning, animation behavior, and visual effects. These properties
/// integrate with the design system and can be overridden at the widget level.
///
/// The theme supports advanced features like stacking behavior, expansion modes,
/// and sophisticated animation timing for professional toast experiences.
class ToastTheme extends ComponentThemeData {
/// Maximum number of toast notifications to stack visually.
///
/// Type: `int?`. If null, defaults to 3 stacked entries. Controls how many
/// toasts are visible simultaneously, with older toasts being collapsed or hidden.
  int? maxStackedEntries;
/// Padding around the toast notification area.
///
/// Type: `EdgeInsetsGeometry?`. If null, defaults to EdgeInsets.all(24) scaled
/// by theme scaling factor. Applied to the toast positioning within safe area.
  EdgeInsetsGeometry? padding;
/// Behavior mode for toast stack expansion.
///
/// Type: `ExpandMode?`. If null, defaults to [ExpandMode.expandOnHover].
/// Controls when stacked toasts expand to show multiple entries simultaneously.
  ExpandMode? expandMode;
/// Offset for collapsed toast positioning.
///
/// Type: `Offset?`. If null, defaults to Offset(0, 12) scaled by theme.
/// Controls the vertical/horizontal spacing between stacked toast entries.
  Offset? collapsedOffset;
/// Scale factor for collapsed toast entries.
///
/// Type: `double?`. If null, defaults to 0.9. Controls the size reduction
/// of toast notifications that are stacked behind the active toast.
  double? collapsedScale;
/// Animation curve for toast expansion transitions.
///
/// Type: `Curve?`. If null, defaults to Curves.easeOutCubic.
/// Applied when transitioning between collapsed and expanded stack states.
  Curve? expandingCurve;
/// Duration for toast expansion animations.
///
/// Type: `Duration?`. If null, defaults to 500 milliseconds.
/// Controls the timing of stack expansion and collapse transitions.
  Duration? expandingDuration;
/// Opacity level for collapsed toast entries.
///
/// Type: `double?`. If null, defaults to 1.0 (fully opaque).
/// Controls the visibility of toast notifications in the stack behind the active toast.
  double? collapsedOpacity;
/// Initial opacity for toast entry animations.
///
/// Type: `double?`. If null, defaults to 0.0 (fully transparent).
/// Starting opacity value for toast notifications when they first appear.
  double? entryOpacity;
/// Spacing between expanded toast entries.
///
/// Type: `double?`. If null, defaults to 8.0. Controls the gap between
/// toast notifications when the stack is in expanded state.
  double? spacing;
/// Size constraints for individual toast notifications.
///
/// Type: `BoxConstraints?`. If null, defaults to fixed width of 320 scaled
/// by theme. Defines the maximum/minimum dimensions for toast content.
  BoxConstraints? toastConstraints;
/// Creates a [ToastTheme].
///
/// All parameters are optional and can be null to use intelligent defaults
/// that integrate with the current theme's design system and provide
/// professional toast notification behavior.
///
/// Example:
/// ```dart
/// const ToastTheme(
///   maxStackedEntries: 5,
///   expandMode: ExpandMode.expandOnHover,
///   spacing: 12.0,
///   collapsedScale: 0.95,
/// );
/// ```
  const ToastTheme({this.maxStackedEntries, this.padding, this.expandMode, this.collapsedOffset, this.collapsedScale, this.expandingCurve, this.expandingDuration, this.collapsedOpacity, this.entryOpacity, this.spacing, this.toastConstraints});
/// Type definition for toast content builder functions.
///
/// Takes a [BuildContext] and [ToastOverlay] instance, returning the widget
/// that represents the toast's visual content. The overlay parameter provides
/// control methods for dismissing or manipulating the toast notification.
///
/// Example:
/// ```dart
/// ToastBuilder builder = (context, overlay) => Card(
///   child: ListTile(
///     title: Text('Notification'),
///     trailing: IconButton(
///       icon: Icon(Icons.close),
///       onPressed: overlay.close,
///     ),
///   ),
/// );
/// ```
  ToastTheme copyWith({ValueGetter<int?>? maxStackedEntries, ValueGetter<EdgeInsetsGeometry?>? padding, ValueGetter<ExpandMode?>? expandMode, ValueGetter<Offset?>? collapsedOffset, ValueGetter<double?>? collapsedScale, ValueGetter<Curve?>? expandingCurve, ValueGetter<Duration?>? expandingDuration, ValueGetter<double?>? collapsedOpacity, ValueGetter<double?>? entryOpacity, ValueGetter<double?>? spacing, ValueGetter<BoxConstraints?>? toastConstraints});
  int get hashCode;
  bool operator ==(Object other);
  String toString();
}
/// Displays a toast notification with sophisticated positioning and animation.
///
/// Creates and shows a toast notification using the provided builder function
/// within the nearest [ToastLayer] in the widget tree. The toast appears at
/// the specified location with configurable animation, dismissal behavior,
/// and automatic timeout.
///
/// The function handles theme capture and data inheritance to ensure the toast
/// maintains consistent styling and access to inherited data from the calling
/// context. Toast notifications are managed through a layered system that
/// supports stacking, expansion, and smooth animations.
///
/// Parameters:
/// - [context] (BuildContext, required): The build context for theme and data capture
/// - [builder] (ToastBuilder, required): Function that builds the toast content widget
/// - [location] (ToastLocation, default: bottomRight): Screen position for the toast
/// - [dismissible] (bool, default: true): Whether users can dismiss via gesture
/// - [curve] (Curve, default: easeOutCubic): Animation curve for entry/exit transitions
/// - [entryDuration] (Duration, default: 500ms): Duration for toast entry animation
/// - [onClosed] (VoidCallback?, optional): Callback invoked when toast is dismissed
/// - [showDuration] (Duration, default: 5s): Auto-dismiss timeout duration
///
/// Returns:
/// A [ToastOverlay] instance that provides control methods for the displayed toast.
///
/// Throws:
/// - [AssertionError] if no [ToastLayer] is found in the widget tree.
///
/// Example:
/// ```dart
/// final toast = showToast(
///   context: context,
///   builder: (context, overlay) => AlertCard(
///     title: 'Success',
///     message: 'Operation completed successfully',
///     onDismiss: overlay.close,
///   ),
///   location: ToastLocation.topRight,
///   showDuration: Duration(seconds: 3),
/// );
/// ```
ToastOverlay showToast({required BuildContext context, required ToastBuilder builder, ToastLocation location = ToastLocation.bottomRight, bool dismissible = true, Curve curve = Curves.easeOutCubic, Duration entryDuration = const Duration(milliseconds: 500), VoidCallback? onClosed, Duration showDuration = const Duration(seconds: 5)});
/// Screen position enumeration for toast notification placement.
///
/// ToastLocation defines six standard positions around the screen edges where
/// toast notifications can appear. Each location includes alignment information
/// for both the toast container and the stacking direction of multiple toasts.
///
/// The enum ensures consistent positioning behavior across different screen
/// sizes and orientations while providing intuitive placement options for
/// various UI patterns and user experience requirements.
enum ToastLocation { topLeft, topCenter, topRight, bottomLeft, bottomCenter, bottomRight }
/// Expansion behavior modes for toast notification stacks.
///
/// ExpandMode controls when and how stacked toast notifications expand to
/// show multiple entries simultaneously. Different modes provide various
/// user interaction patterns for managing multiple notifications.
enum ExpandMode { alwaysExpanded, expandOnHover, expandOnTap, disabled }
/// A sophisticated layer widget that provides toast notification infrastructure.
///
/// ToastLayer serves as the foundation for the toast notification system,
/// managing the display, positioning, animation, and lifecycle of multiple
/// toast notifications. It wraps application content and provides the necessary
/// context for [showToast] functions to work properly.
///
/// The layer handles complex features including toast stacking, expansion modes,
/// hover/tap interactions, automatic dismissal timing, gesture-based dismissal,
/// and smooth animations between states. It ensures proper theme integration
/// and responsive behavior across different screen sizes.
///
/// Key features:
/// - Multi-location toast support with six standard positions
/// - Intelligent toast stacking with configurable maximum entries
/// - Interactive expansion modes (hover, tap, always, disabled)
/// - Gesture-based dismissal with swipe recognition
/// - Automatic timeout handling with pause on hover
/// - Smooth animations for entry, exit, and state transitions
/// - Safe area and padding handling for various screen layouts
/// - Theme integration with comprehensive customization options
///
/// This is typically placed high in the widget tree, often wrapping the main
/// application content or individual screens that need toast functionality.
///
/// Example:
/// ```dart
/// ToastLayer(
///   maxStackedEntries: 4,
///   expandMode: ExpandMode.expandOnHover,
///   child: MyAppContent(),
/// );
/// ```
class ToastLayer extends StatefulWidget {
/// The child widget to wrap with toast functionality.
///
/// Type: `Widget`, required. The main application content that will have
/// toast notification capabilities available through the widget tree.
  Widget child;
/// Maximum number of toast notifications to display simultaneously.
///
/// Type: `int`, default: `3`. Controls how many toasts are visible at once,
/// with older toasts being hidden or collapsed when limit is exceeded.
  int maxStackedEntries;
/// Padding around toast notification areas.
///
/// Type: `EdgeInsetsGeometry?`. If null, uses default padding that respects
/// safe area constraints. Applied to toast positioning within screen boundaries.
  EdgeInsetsGeometry? padding;
/// Behavior for toast stack expansion interactions.
///
/// Type: `ExpandMode`, default: [ExpandMode.expandOnHover]. Controls when
/// stacked toasts expand to show multiple entries simultaneously.
  ExpandMode expandMode;
/// Position offset for collapsed toast entries.
///
/// Type: `Offset?`. If null, uses default offset that creates subtle
/// stacking effect. Applied to toasts behind the active notification.
  Offset? collapsedOffset;
/// Scale factor for collapsed toast entries.
///
/// Type: `double`, default: `0.9`. Controls size reduction of background
/// toasts to create depth perception in the stack visualization.
  double collapsedScale;
/// Animation curve for expansion state transitions.
///
/// Type: `Curve`, default: [Curves.easeOutCubic]. Applied when transitioning
/// between collapsed and expanded stack states.
  Curve expandingCurve;
/// Duration for expansion animation transitions.
///
/// Type: `Duration`, default: `500ms`. Controls timing of stack expansion
/// and collapse animations for smooth user experience.
  Duration expandingDuration;
/// Opacity level for collapsed toast entries.
///
/// Type: `double`, default: `1.0`. Controls visibility of background toasts
/// in the stack, with 1.0 being fully opaque and 0.0 being transparent.
  double collapsedOpacity;
/// Initial opacity for toast entry animations.
///
/// Type: `double`, default: `0.0`. Starting opacity value for toast
/// notifications during their entrance animation sequence.
  double entryOpacity;
/// Spacing between toast entries in expanded mode.
///
/// Type: `double`, default: `8.0`. Gap between individual toast notifications
/// when the stack is expanded to show multiple entries.
  double spacing;
/// Size constraints for individual toast notifications.
///
/// Type: `BoxConstraints?`. If null, uses responsive width based on screen
/// size and theme scaling. Defines maximum and minimum toast dimensions.
  BoxConstraints? toastConstraints;
/// Creates a [ToastLayer].
///
/// The [child] parameter is required as the content to wrap with toast
/// functionality. All other parameters have sensible defaults but can be
/// customized to match specific design requirements.
///
/// Parameters:
/// - [child] (Widget, required): Content to wrap with toast capabilities
/// - [maxStackedEntries] (int, default: 3): Maximum visible toast count
/// - [padding] (EdgeInsetsGeometry?, optional): Toast area padding override
/// - [expandMode] (ExpandMode, default: expandOnHover): Stack expansion behavior
/// - [collapsedOffset] (Offset?, optional): Background toast positioning offset
/// - [collapsedScale] (double, default: 0.9): Background toast size reduction
/// - [expandingCurve] (Curve, default: easeOutCubic): Expansion animation curve
/// - [expandingDuration] (Duration, default: 500ms): Expansion animation timing
/// - [collapsedOpacity] (double, default: 1.0): Background toast visibility
/// - [entryOpacity] (double, default: 0.0): Toast entrance starting opacity
/// - [spacing] (double, default: 8.0): Gap between expanded toast entries
/// - [toastConstraints] (BoxConstraints?, optional): Individual toast size limits
///
/// Example:
/// ```dart
/// ToastLayer(
///   maxStackedEntries: 5,
///   expandMode: ExpandMode.expandOnTap,
///   spacing: 12.0,
///   child: MaterialApp(home: HomePage()),
/// );
/// ```
  const ToastLayer({super.key, required this.child, this.maxStackedEntries = 3, this.padding, this.expandMode = ExpandMode.expandOnHover, this.collapsedOffset, this.collapsedScale = 0.9, this.expandingCurve = Curves.easeOutCubic, this.expandingDuration = const Duration(milliseconds: 500), this.collapsedOpacity = 1, this.entryOpacity = 0.0, this.spacing = 8, this.toastConstraints});
  State<ToastLayer> createState();
}
/// Abstract interface for controlling individual toast notification instances.
///
/// ToastOverlay provides methods for managing the lifecycle and state of
/// individual toast notifications after they have been displayed. Instances
/// are returned by [showToast] and passed to [ToastBuilder] functions.
///
/// The interface allows checking the current display state and programmatically
/// dismissing toast notifications, enabling responsive user interactions and
/// proper cleanup when needed.
abstract class ToastOverlay {
/// Whether the toast notification is currently being displayed.
///
/// Type: `bool`. Returns true if the toast is visible or in the process
/// of animating in/out, false if it has been dismissed or closed.
  bool get isShowing;
/// Programmatically dismisses the toast notification.
///
/// Triggers the dismissal animation and removes the toast from the display
/// stack. This method can be called multiple times safely - subsequent
/// calls after dismissal will have no effect.
///
/// Example:
/// ```dart
/// final toast = showToast(context: context, builder: (context, overlay) {
///   return AlertCard(
///     title: 'Auto-close',
///     trailing: IconButton(
///       icon: Icon(Icons.close),
///       onPressed: overlay.close,
///     ),
///   );
/// });
///
/// // Close programmatically after delay
/// Timer(Duration(seconds: 2), toast.close);
/// ```
  void close();
}
/// Configuration for a single toast notification.
///
/// Encapsulates all properties needed to display and manage a toast,
/// including builder, location, timing, and dismissal behavior.
class ToastEntry {
/// Builder function to create the toast widget.
  ToastBuilder builder;
/// Position where the toast should appear.
  ToastLocation location;
/// Whether the toast can be dismissed by user interaction.
///
/// Defaults to true. When false, toast only closes after duration expires.
  bool dismissible;
/// Animation curve for entry/exit transitions.
  Curve curve;
/// Duration for entry/exit animations.
  Duration duration;
/// Captured theme data to apply to the toast.
  CapturedThemes? themes;
/// Captured inherited widget data to apply to the toast.
  CapturedData? data;
/// Callback invoked when toast is closed.
  VoidCallback? onClosed;
/// How long the toast remains visible before auto-dismissing.
///
/// Defaults to 5 seconds. If null, toast remains indefinitely.
  Duration? showDuration;
/// Creates a toast entry configuration.
  ToastEntry({required this.builder, required this.location, this.dismissible = true, this.curve = Curves.easeInOut, this.duration = kDefaultDuration, required this.themes, required this.data, this.onClosed, this.showDuration = const Duration(seconds: 5)});
}
/// Internal widget for managing toast entry layout and animations.
///
/// Handles the positioning, transitions, and lifecycle of individual toast
/// notifications. Manages expansion/collapse animations, entry/exit transitions,
/// and stacking behavior for multiple toasts.
///
/// This is an internal implementation class used by the toast system and
/// should not be used directly in application code.
class ToastEntryLayout extends StatefulWidget {
/// The toast entry data containing the notification content.
  ToastEntry entry;
/// Whether the toast is in expanded state.
  bool expanded;
/// Whether the toast is currently visible.
  bool visible;
/// Whether the toast can be dismissed by user interaction.
  bool dismissible;
/// Alignment used before the current animation.
  AlignmentGeometry previousAlignment;
/// Animation curve for transitions.
  Curve curve;
/// Duration of transition animations.
  Duration duration;
/// Captured theme data to apply to the toast content.
  CapturedThemes? themes;
/// Captured inherited data to apply to the toast content.
  CapturedData? data;
/// Notifies when the toast is closing.
  ValueListenable<bool> closing;
/// Callback invoked when the toast has completely closed.
  VoidCallback onClosed;
/// Offset applied when toast is in collapsed state.
  Offset collapsedOffset;
/// Scale factor applied when toast is in collapsed state.
  double collapsedScale;
/// Curve used for expansion animations.
  Curve expandingCurve;
/// Duration of expansion animations.
  Duration expandingDuration;
/// Opacity when toast is collapsed.
  double collapsedOpacity;
/// Initial opacity when toast enters.
  double entryOpacity;
/// The toast content widget.
  Widget child;
/// Initial offset when toast enters.
  Offset entryOffset;
/// Alignment of the toast entry.
  AlignmentGeometry entryAlignment;
/// Spacing between stacked toasts.
  double spacing;
/// Visual index in the toast stack.
  int index;
/// Actual index in the internal list.
  int actualIndex;
/// Callback invoked when toast starts closing.
  VoidCallback? onClosing;
/// Creates a [ToastEntryLayout].
///
/// Most parameters control animation and positioning behavior. This is
/// an internal widget used by the toast system.
  const ToastEntryLayout({super.key, required this.entry, required this.expanded, this.visible = true, this.dismissible = true, this.previousAlignment = Alignment.center, this.curve = Curves.easeInOut, this.duration = kDefaultDuration, required this.themes, required this.data, required this.closing, required this.onClosed, required this.collapsedOffset, required this.collapsedScale, this.expandingCurve = Curves.easeInOut, this.expandingDuration = kDefaultDuration, this.collapsedOpacity = 0.8, this.entryOpacity = 0.0, required this.entryOffset, required this.child, required this.entryAlignment, required this.spacing, required this.index, required this.actualIndex, required this.onClosing});
  State<ToastEntryLayout> createState();
}
/// Theme configuration for hover card behavior and appearance.
///
/// Defines timing, positioning, and interaction behavior for hover cards,
/// providing consistent styling across the application.
///
/// Example:
/// ```dart
/// ComponentThemeData(
///   data: {
///     HoverCardTheme: HoverCardTheme(
///       debounce: Duration(milliseconds: 300),
///       wait: Duration(milliseconds: 700),
///       popoverAlignment: Alignment.topCenter,
///     ),
///   },
///   child: MyApp(),
/// )
/// ```
class HoverCardTheme extends ComponentThemeData {
/// Duration to wait before hiding the hover card after mouse exit.
  Duration? debounce;
/// Duration to wait before showing the hover card after mouse enter.
  Duration? wait;
/// Alignment of the popover relative to its anchor.
  AlignmentGeometry? popoverAlignment;
/// Alignment point on the anchor widget.
  AlignmentGeometry? anchorAlignment;
/// Offset of the popover from its calculated position.
  Offset? popoverOffset;
/// Hit test behavior for mouse interactions.
  HitTestBehavior? behavior;
/// Creates a [HoverCardTheme].
///
/// All parameters are optional and will use system defaults when null.
///
/// Parameters:
/// - [debounce] (Duration?, optional): delay before hiding after mouse exit
/// - [wait] (Duration?, optional): delay before showing after mouse enter
/// - [popoverAlignment] (AlignmentGeometry?, optional): popover alignment
/// - [anchorAlignment] (AlignmentGeometry?, optional): anchor point alignment
/// - [popoverOffset] (Offset?, optional): offset from calculated position
/// - [behavior] (HitTestBehavior?, optional): mouse interaction behavior
///
/// Example:
/// ```dart
/// const HoverCardTheme(
///   debounce: Duration(milliseconds: 200),
///   wait: Duration(milliseconds: 600),
///   popoverAlignment: Alignment.bottomCenter,
/// )
/// ```
  const HoverCardTheme({this.debounce, this.wait, this.popoverAlignment, this.anchorAlignment, this.popoverOffset, this.behavior});
/// Creates a copy with specified fields replaced.
///
/// Parameters:
/// - [debounce] (`ValueGetter<Duration?>?`, optional): New debounce duration getter.
/// - [wait] (`ValueGetter<Duration?>?`, optional): New wait duration getter.
/// - [popoverAlignment] (`ValueGetter<AlignmentGeometry?>?`, optional): New popover alignment getter.
/// - [anchorAlignment] (`ValueGetter<AlignmentGeometry?>?`, optional): New anchor alignment getter.
/// - [popoverOffset] (`ValueGetter<Offset?>?`, optional): New offset getter.
/// - [behavior] (`ValueGetter<HitTestBehavior?>?`, optional): New behavior getter.
///
/// Returns: `HoverCardTheme` ‚Äî new theme with updated values.
  HoverCardTheme copyWith({ValueGetter<Duration?>? debounce, ValueGetter<Duration?>? wait, ValueGetter<AlignmentGeometry?>? popoverAlignment, ValueGetter<AlignmentGeometry?>? anchorAlignment, ValueGetter<Offset?>? popoverOffset, ValueGetter<HitTestBehavior?>? behavior});
  bool operator ==(Object other);
  int get hashCode;
}
/// A widget that displays a popover when hovered or long-pressed.
///
/// Shows contextual information or actions when the user hovers over the
/// child widget or performs a long press. Includes intelligent timing
/// controls to prevent flickering and provides smooth user interactions.
///
/// Features:
/// - Hover-based popover display with timing controls
/// - Long-press support for touch devices
/// - Configurable positioning and alignment
/// - Debounce timing to prevent flicker
/// - Custom overlay handlers support
/// - Theme integration
///
/// The hover card automatically manages show/hide timing based on mouse
/// enter/exit events, with configurable delays to provide a smooth UX.
///
/// Example:
/// ```dart
/// HoverCard(
///   hoverBuilder: (context) => Card(
///     child: Padding(
///       padding: EdgeInsets.all(12),
///       child: Text('Additional info appears on hover'),
///     ),
///   ),
///   child: Icon(Icons.help_outline),
/// )
/// ```
class HoverCard extends StatefulWidget {
/// The child widget that triggers the hover card.
  Widget child;
/// Duration to wait before hiding after mouse exit.
  Duration? debounce;
/// Duration to wait before showing after mouse enter.
  Duration? wait;
/// Builder function that creates the hover card content.
  WidgetBuilder hoverBuilder;
/// Alignment of the popover relative to its anchor.
  AlignmentGeometry? popoverAlignment;
/// Alignment point on the anchor widget.
  AlignmentGeometry? anchorAlignment;
/// Offset of the popover from its calculated position.
  Offset? popoverOffset;
/// Hit test behavior for mouse interactions.
  HitTestBehavior? behavior;
/// Controller to programmatically manage the popover.
  PopoverController? controller;
/// Custom overlay handler for popover display.
  OverlayHandler? handler;
/// Creates a [HoverCard].
///
/// The [child] and [hoverBuilder] parameters are required.
///
/// Parameters:
/// - [child] (Widget, required): widget that triggers the hover card
/// - [hoverBuilder] (WidgetBuilder, required): builds the hover card content
/// - [debounce] (Duration?, optional): delay before hiding, defaults to 500ms
/// - [wait] (Duration?, optional): delay before showing, defaults to 500ms
/// - [popoverAlignment] (AlignmentGeometry?, optional): popover alignment, defaults to topCenter
/// - [anchorAlignment] (AlignmentGeometry?, optional): anchor alignment, defaults to bottomCenter
/// - [popoverOffset] (Offset?, optional): offset from position, defaults to (0, 8)
/// - [behavior] (HitTestBehavior?, optional): hit test behavior, defaults to deferToChild
/// - [controller] (PopoverController?, optional): controller for programmatic control
/// - [handler] (OverlayHandler?, optional): custom overlay handler
///
/// Example:
/// ```dart
/// HoverCard(
///   debounce: Duration(milliseconds: 300),
///   hoverBuilder: (context) => Tooltip(message: 'Help text'),
///   child: Icon(Icons.info),
/// )
/// ```
  const HoverCard({super.key, required this.child, required this.hoverBuilder, this.debounce, this.wait, this.popoverAlignment, this.anchorAlignment, this.popoverOffset, this.behavior, this.controller, this.handler});
  State<HoverCard> createState();
}
/// Closes the currently active overlay with an optional result value.
///
/// Searches up the widget tree for an [OverlayHandlerStateMixin] and
/// requests it to close with the provided result. If no overlay handler
/// is found, returns a completed future.
///
/// Parameters:
/// - [context] (BuildContext, required): Build context from within the overlay
/// - [value] (T?): Optional result value to return when closing
///
/// Returns a [Future] that completes when the overlay is closed.
///
/// Example:
/// ```dart
/// closeOverlay(context, 'user_confirmed');
/// ```
Future<void> closeOverlay<T>(BuildContext context, [T? value]);
/// Mixin providing overlay state management methods.
///
/// Defines the interface for overlay state classes, including methods for
/// closing overlays and updating overlay configuration dynamically.
///
/// Used by overlay implementations to provide consistent lifecycle management
/// and configuration update capabilities.
mixin OverlayHandlerStateMixin<T extends StatefulWidget> on State<T> {
/// Closes the overlay.
///
/// Parameters:
/// - [immediate] (bool): If true, closes immediately without animation
///
/// Returns a [Future] that completes when closed.
  Future<void> close([bool immediate = false]);
/// Schedules overlay closure for the next frame.
///
/// Useful for closing overlays from callbacks where immediate closure
/// might cause issues with the widget tree.
  void closeLater();
/// Closes the overlay with a result value.
///
/// Parameters:
/// - [value] (X?): Optional result to return
///
/// Returns a [Future] that completes when closed.
  Future<void> closeWithResult<X>([X? value]);
/// Updates the anchor context for positioning.
  set anchorContext(BuildContext value);
/// Updates the overlay alignment.
  set alignment(AlignmentGeometry value);
/// Updates the anchor alignment.
  set anchorAlignment(AlignmentGeometry value);
/// Updates the width constraint.
  set widthConstraint(PopoverConstraint value);
/// Updates the height constraint.
  set heightConstraint(PopoverConstraint value);
/// Updates the margin.
  set margin(EdgeInsets value);
/// Updates whether the overlay follows the anchor.
  set follow(bool value);
/// Updates the position offset.
  set offset(Offset? value);
/// Updates horizontal inversion permission.
  set allowInvertHorizontal(bool value);
/// Updates vertical inversion permission.
  set allowInvertVertical(bool value);
}
/// Abstract interface for overlay operation completion tracking.
///
/// Provides lifecycle management and status tracking for overlay operations,
/// including completion state, animation state, and dismissal.
abstract class OverlayCompleter<T> {
/// Removes the overlay from the screen.
  void remove();
/// Disposes resources associated with the overlay.
  void dispose();
/// Whether the overlay operation has completed.
  bool get isCompleted;
/// Whether the overlay's animation has completed.
  bool get isAnimationCompleted;
/// Future that completes with the overlay's result value.
  Future<T?> get future;
/// Future that completes when the overlay animation finishes.
  Future<void> get animationFuture;
}
/// Abstract handler for managing overlay presentation and lifecycle.
///
/// Provides common interface for different overlay types (popover, sheet, dialog)
/// with customizable display, positioning, and interaction behavior.
abstract class OverlayHandler {
/// Default popover overlay handler.
  static const OverlayHandler popover = PopoverOverlayHandler();
/// Default sheet overlay handler.
  static const OverlayHandler sheet = SheetOverlayHandler();
/// Default dialog overlay handler.
  static const OverlayHandler dialog = DialogOverlayHandler();
/// Creates an [OverlayHandler].
  const OverlayHandler();
/// Shows an overlay with the specified configuration.
///
/// Displays an overlay (popover, sheet, or dialog) with extensive customization
/// options for positioning, sizing, behavior, and appearance.
///
/// Parameters:
/// - [context] (BuildContext, required): Build context
/// - [alignment] (AlignmentGeometry, required): Overlay alignment
/// - [builder] (WidgetBuilder, required): Overlay content builder
/// - [position] (Offset?): Explicit position (overrides alignment)
/// - [anchorAlignment] (AlignmentGeometry?): Anchor alignment
/// - [widthConstraint] (PopoverConstraint): Width constraint, defaults to flexible
/// - [heightConstraint] (PopoverConstraint): Height constraint, defaults to flexible
/// - [key] (Key?): Widget key
/// - [rootOverlay] (bool): Use root overlay, defaults to true
/// - [modal] (bool): Modal behavior, defaults to true
/// - [barrierDismissable] (bool): Dismissible by tapping barrier, defaults to true
/// - [clipBehavior] (Clip): Clipping behavior, defaults to none
/// - [regionGroupId] (Object?): Region group ID
/// - [offset] (Offset?): Position offset
/// - [transitionAlignment] (AlignmentGeometry?): Transition alignment
/// - [margin] (EdgeInsetsGeometry?): Overlay margin
/// - [follow] (bool): Follow anchor on move, defaults to true
/// - [consumeOutsideTaps] (bool): Consume outside taps, defaults to true
/// - [onTickFollow] (`ValueChanged<PopoverOverlayWidgetState>?`): Follow tick callback
/// - [allowInvertHorizontal] (bool): Allow horizontal inversion, defaults to true
/// - [allowInvertVertical] (bool): Allow vertical inversion, defaults to true
/// - [dismissBackdropFocus] (bool): Dismiss on backdrop focus, defaults to true
/// - [showDuration] (Duration?): Show animation duration
/// - [dismissDuration] (Duration?): Dismiss animation duration
/// - [overlayBarrier] (OverlayBarrier?): Custom barrier configuration
/// - [layerLink] (LayerLink?): Layer link for positioning
///
/// Returns an [OverlayCompleter] for managing the overlay lifecycle.
  OverlayCompleter<T?> show<T>({required BuildContext context, required AlignmentGeometry alignment, required WidgetBuilder builder, Offset? position, AlignmentGeometry? anchorAlignment, PopoverConstraint widthConstraint = PopoverConstraint.flexible, PopoverConstraint heightConstraint = PopoverConstraint.flexible, Key? key, bool rootOverlay = true, bool modal = true, bool barrierDismissable = true, Clip clipBehavior = Clip.none, Object? regionGroupId, Offset? offset, AlignmentGeometry? transitionAlignment, EdgeInsetsGeometry? margin, bool follow = true, bool consumeOutsideTaps = true, ValueChanged<PopoverOverlayWidgetState>? onTickFollow, bool allowInvertHorizontal = true, bool allowInvertVertical = true, bool dismissBackdropFocus = true, Duration? showDuration, Duration? dismissDuration, OverlayBarrier? overlayBarrier, LayerLink? layerLink});
}
/// Configuration for overlay modal barriers.
///
/// Defines the visual appearance and spacing of the barrier displayed
/// behind modal overlays.
class OverlayBarrier {
/// Padding around the barrier.
  EdgeInsetsGeometry padding;
/// Border radius for the barrier shape.
  BorderRadiusGeometry borderRadius;
/// Color of the barrier (typically semi-transparent).
  Color? barrierColor;
/// Creates an overlay barrier configuration.
///
/// Parameters:
/// - [padding] (EdgeInsetsGeometry): Barrier padding, defaults to zero
/// - [borderRadius] (BorderRadiusGeometry): Border radius, defaults to zero
/// - [barrierColor] (Color?): Barrier color
  const OverlayBarrier({this.padding = EdgeInsets.zero, this.borderRadius = BorderRadius.zero, this.barrierColor});
}
/// Abstract manager for overlay operations.
///
/// Extends [OverlayHandler] with additional methods for showing specialized
/// overlay types like tooltips and menus. Provides centralized overlay
/// management for an application.
abstract class OverlayManager implements OverlayHandler {
/// Gets the overlay manager from the widget tree.
///
/// Searches for an [OverlayManager] in the build context and throws
/// an assertion error if not found.
///
/// Parameters:
/// - [context] (BuildContext, required): Build context
///
/// Returns the [OverlayManager] instance.
  static OverlayManager of(BuildContext context);
  OverlayCompleter<T?> show<T>({required BuildContext context, required WidgetBuilder builder, AlignmentGeometry alignment = Alignment.center, Offset? position, AlignmentGeometry? anchorAlignment, PopoverConstraint widthConstraint = PopoverConstraint.flexible, PopoverConstraint heightConstraint = PopoverConstraint.flexible, Key? key, bool rootOverlay = true, bool modal = true, bool barrierDismissable = true, Clip clipBehavior = Clip.none, Object? regionGroupId, Offset? offset, AlignmentGeometry? transitionAlignment, EdgeInsetsGeometry? margin, bool follow = true, bool consumeOutsideTaps = true, ValueChanged<PopoverOverlayWidgetState>? onTickFollow, bool allowInvertHorizontal = true, bool allowInvertVertical = true, bool dismissBackdropFocus = true, Duration? showDuration, Duration? dismissDuration, OverlayBarrier? overlayBarrier, LayerLink? layerLink});
/// Shows a tooltip overlay.
///
/// Specialized method for displaying tooltips with appropriate defaults
/// for tooltip behavior (non-modal, brief display, etc.).
///
/// Parameters similar to [show] method. See [show] for full parameter documentation.
///
/// Returns an [OverlayCompleter] for managing the tooltip lifecycle.
  OverlayCompleter<T?> showTooltip<T>({required BuildContext context, required WidgetBuilder builder, AlignmentGeometry alignment = Alignment.center, Offset? position, AlignmentGeometry? anchorAlignment, PopoverConstraint widthConstraint = PopoverConstraint.flexible, PopoverConstraint heightConstraint = PopoverConstraint.flexible, Key? key, bool rootOverlay = true, bool modal = true, bool barrierDismissable = true, Clip clipBehavior = Clip.none, Object? regionGroupId, Offset? offset, AlignmentGeometry? transitionAlignment, EdgeInsetsGeometry? margin, bool follow = true, bool consumeOutsideTaps = true, ValueChanged<PopoverOverlayWidgetState>? onTickFollow, bool allowInvertHorizontal = true, bool allowInvertVertical = true, bool dismissBackdropFocus = true, Duration? showDuration, Duration? dismissDuration, OverlayBarrier? overlayBarrier, LayerLink? layerLink});
/// Shows a menu overlay.
///
/// Specialized method for displaying menus with appropriate defaults
/// for menu behavior (dismissible, follows anchor, etc.).
///
/// Parameters similar to [show] method. See [show] for full parameter documentation.
///
/// Returns an [OverlayCompleter] for managing the menu lifecycle.
  OverlayCompleter<T?> showMenu<T>({required BuildContext context, required WidgetBuilder builder, AlignmentGeometry alignment = Alignment.center, Offset? position, AlignmentGeometry? anchorAlignment, PopoverConstraint widthConstraint = PopoverConstraint.flexible, PopoverConstraint heightConstraint = PopoverConstraint.flexible, Key? key, bool rootOverlay = true, bool modal = true, bool barrierDismissable = true, Clip clipBehavior = Clip.none, Object? regionGroupId, Offset? offset, AlignmentGeometry? transitionAlignment, EdgeInsetsGeometry? margin, bool follow = true, bool consumeOutsideTaps = true, ValueChanged<PopoverOverlayWidgetState>? onTickFollow, bool allowInvertHorizontal = true, bool allowInvertVertical = true, bool dismissBackdropFocus = true, Duration? showDuration, Duration? dismissDuration, OverlayBarrier? overlayBarrier, LayerLink? layerLink});
}
/// Layer widget managing different overlay handlers for the application.
///
/// Provides centralized overlay management for popovers, tooltips, and menus
/// with customizable handlers for each type.
class OverlayManagerLayer extends StatefulWidget {
/// Handler for popover overlays.
  OverlayHandler popoverHandler;
/// Handler for tooltip overlays.
  OverlayHandler tooltipHandler;
/// Handler for menu overlays.
  OverlayHandler menuHandler;
/// Child widget wrapped by overlay management.
  Widget child;
/// Creates an overlay manager layer.
///
/// Parameters:
/// - [popoverHandler] (OverlayHandler, required): Handler for popover overlays
/// - [tooltipHandler] (OverlayHandler, required): Handler for tooltip overlays
/// - [menuHandler] (OverlayHandler, required): Handler for menu overlays
/// - [child] (Widget, required): Child widget
  const OverlayManagerLayer({super.key, required this.popoverHandler, required this.tooltipHandler, required this.menuHandler, required this.child});
  State<OverlayManagerLayer> createState();
}
/// Theme configuration for swiper overlay behavior and appearance.
///
/// Defines default properties for swiper components including overlay
/// behavior, drag interaction, surface effects, and visual styling.
///
/// Features:
/// - Configurable drag and expansion behavior
/// - Surface effects and backdrop styling
/// - Barrier and interaction customization
/// - Consistent theming across swiper variants
///
/// Example:
/// ```dart
/// ComponentThemeData(
///   data: {
///     SwiperTheme: SwiperTheme(
///       expands: true,
///       draggable: true,
///       barrierDismissible: true,
///       transformBackdrop: true,
///     ),
///   },
///   child: MyApp(),
/// )
/// ```
class SwiperTheme extends ComponentThemeData {
/// Whether the swiper should expand to fill available space.
  bool? expands;
/// Whether the swiper can be dragged to dismiss.
  bool? draggable;
/// Whether tapping the barrier dismisses the swiper.
  bool? barrierDismissible;
/// Builder for custom backdrop content.
  WidgetBuilder? backdropBuilder;
/// Whether to respect device safe areas.
  bool? useSafeArea;
/// Whether to show the drag handle.
  bool? showDragHandle;
/// Border radius for the swiper container.
  BorderRadiusGeometry? borderRadius;
/// Size of the drag handle when displayed.
  Size? dragHandleSize;
/// Whether to transform the backdrop when shown.
  bool? transformBackdrop;
/// Opacity for surface effects.
  double? surfaceOpacity;
/// Blur intensity for surface effects.
  double? surfaceBlur;
/// Color of the modal barrier.
  Color? barrierColor;
/// Hit test behavior for gesture detection.
  HitTestBehavior? behavior;
/// Creates a [SwiperTheme].
///
/// All parameters are optional and will use system defaults when null.
///
/// Example:
/// ```dart
/// const SwiperTheme(
///   expands: true,
///   draggable: true,
///   transformBackdrop: true,
/// )
/// ```
  const SwiperTheme({this.expands, this.draggable, this.barrierDismissible, this.backdropBuilder, this.useSafeArea, this.showDragHandle, this.borderRadius, this.dragHandleSize, this.transformBackdrop, this.surfaceOpacity, this.surfaceBlur, this.barrierColor, this.behavior});
/// Creates a copy of this theme with optionally replaced values.
///
/// All parameters are wrapped in [ValueGetter] to allow lazy evaluation
/// and dynamic theme changes.
  SwiperTheme copyWith({ValueGetter<bool?>? expands, ValueGetter<bool?>? draggable, ValueGetter<bool?>? barrierDismissible, ValueGetter<WidgetBuilder?>? backdropBuilder, ValueGetter<bool?>? useSafeArea, ValueGetter<bool?>? showDragHandle, ValueGetter<BorderRadiusGeometry?>? borderRadius, ValueGetter<Size?>? dragHandleSize, ValueGetter<bool?>? transformBackdrop, ValueGetter<double?>? surfaceOpacity, ValueGetter<double?>? surfaceBlur, ValueGetter<Color?>? barrierColor, ValueGetter<HitTestBehavior?>? behavior});
  int get hashCode;
  bool operator ==(Object other);
  String toString();
}
/// Abstract handler interface for swiper overlay implementations.
///
/// Defines the contract for creating different types of swiper overlays,
/// with built-in implementations for drawer-style and sheet-style swipers.
///
/// Features:
/// - Pluggable swiper behavior patterns
/// - Built-in drawer and sheet implementations
/// - Consistent API across swiper types
/// - Configurable overlay properties
///
/// Example:
/// ```dart
/// // Use built-in handlers
/// const SwiperHandler.drawer
/// const SwiperHandler.sheet
/// ```
abstract class SwiperHandler {
/// Handler for drawer-style swipers with backdrop transformation.
  static const SwiperHandler drawer = DrawerSwiperHandler();
/// Handler for sheet-style swipers with minimal styling.
  static const SwiperHandler sheet = SheetSwiperHandler();
/// Creates a swiper handler.
  const SwiperHandler();
/// Creates a swiper overlay with the specified configuration.
///
/// Parameters vary by implementation but commonly include position,
/// builder, and visual/behavioral properties.
///
/// Returns:
/// A [DrawerOverlayCompleter] for managing the swiper lifecycle.
  DrawerOverlayCompleter openSwiper({required BuildContext context, required WidgetBuilder builder, required OverlayPosition position, bool? expands, bool? draggable, bool? barrierDismissible, WidgetBuilder? backdropBuilder, bool? useSafeArea, bool? showDragHandle, BorderRadiusGeometry? borderRadius, Size? dragHandleSize, bool? transformBackdrop, double? surfaceOpacity, double? surfaceBlur, Color? barrierColor});
}
/// Drawer-style swiper handler with backdrop transformation.
///
/// Creates swipers that behave like drawers with backdrop scaling,
/// drag handles, and full interaction support.
///
/// Example:
/// ```dart
/// Swiper(
///   handler: SwiperHandler.drawer,
///   position: OverlayPosition.left,
///   builder: (context) => DrawerContent(),
///   child: MenuButton(),
/// )
/// ```
class DrawerSwiperHandler extends SwiperHandler {
/// Creates a drawer-style swiper handler.
  const DrawerSwiperHandler();
  DrawerOverlayCompleter openSwiper({required BuildContext context, required WidgetBuilder builder, required OverlayPosition position, bool? expands, bool? draggable, bool? barrierDismissible, WidgetBuilder? backdropBuilder, bool? useSafeArea, bool? showDragHandle, BorderRadiusGeometry? borderRadius, Size? dragHandleSize, bool? transformBackdrop, double? surfaceOpacity, double? surfaceBlur, Color? barrierColor});
}
/// Sheet-style swiper handler with minimal styling.
///
/// Creates swipers that behave like sheets with edge-to-edge content,
/// minimal decoration, and optional drag interaction.
///
/// Example:
/// ```dart
/// Swiper(
///   handler: SwiperHandler.sheet,
///   position: OverlayPosition.bottom,
///   builder: (context) => BottomSheetContent(),
///   child: ActionButton(),
/// )
/// ```
class SheetSwiperHandler extends SwiperHandler {
/// Creates a sheet-style swiper handler.
  const SheetSwiperHandler();
  DrawerOverlayCompleter openSwiper({required BuildContext context, required WidgetBuilder builder, required OverlayPosition position, bool? expands, bool? draggable, bool? barrierDismissible, WidgetBuilder? backdropBuilder, bool? useSafeArea, bool? showDragHandle, BorderRadiusGeometry? borderRadius, Size? dragHandleSize, bool? transformBackdrop, double? surfaceOpacity, double? surfaceBlur, Color? barrierColor});
}
/// A gesture-responsive widget that triggers overlay content through swiping.
///
/// Detects swipe gestures on the child widget and displays overlay content
/// using the configured handler (drawer or sheet style). Supports both
/// programmatic and gesture-based triggering with comprehensive customization.
///
/// Features:
/// - Gesture-based overlay triggering
/// - Multiple handler implementations (drawer/sheet)
/// - Configurable swipe sensitivity and behavior
/// - Theme integration and visual customization
/// - Programmatic control and dismissal
/// - Position-aware gesture detection
///
/// The swiper responds to swipe gestures in the direction that would reveal
/// the overlay (e.g., swiping right reveals a left-positioned overlay).
///
/// Example:
/// ```dart
/// Swiper(
///   handler: SwiperHandler.drawer,
///   position: OverlayPosition.left,
///   builder: (context) => NavigationDrawer(),
///   child: AppBar(
///     leading: Icon(Icons.menu),
///     title: Text('My App'),
///   ),
/// )
/// ```
class Swiper extends StatefulWidget {
/// Whether swipe gestures are enabled.
  bool enabled;
/// Position from which the overlay should appear.
  OverlayPosition position;
/// Builder function that creates the overlay content.
  WidgetBuilder builder;
/// Handler that defines the overlay behavior (drawer or sheet).
  SwiperHandler handler;
/// Whether the overlay should expand to fill available space.
  bool? expands;
/// Whether the overlay can be dragged to dismiss.
  bool? draggable;
/// Whether tapping the barrier dismisses the overlay.
  bool? barrierDismissible;
/// Builder for custom backdrop content.
  WidgetBuilder? backdropBuilder;
/// Whether to respect device safe areas.
  bool? useSafeArea;
/// Whether to show the drag handle.
  bool? showDragHandle;
/// Border radius for the overlay container.
  BorderRadiusGeometry? borderRadius;
/// Size of the drag handle when displayed.
  Size? dragHandleSize;
/// Whether to transform the backdrop when shown.
  bool? transformBackdrop;
/// Opacity for surface effects.
  double? surfaceOpacity;
/// Blur intensity for surface effects.
  double? surfaceBlur;
/// Color of the modal barrier.
  Color? barrierColor;
/// The child widget that responds to swipe gestures.
  Widget child;
/// Hit test behavior for gesture detection.
  HitTestBehavior? behavior;
/// Creates a [Swiper].
///
/// The [position], [builder], [handler], and [child] parameters are required.
/// Other parameters customize the overlay behavior and appearance.
///
/// Parameters:
/// - [enabled] (bool, default: true): whether swipe gestures are enabled
/// - [position] (OverlayPosition, required): side from which overlay appears
/// - [builder] (WidgetBuilder, required): builds the overlay content
/// - [handler] (SwiperHandler, required): defines overlay behavior (drawer/sheet)
/// - [child] (Widget, required): widget that responds to swipe gestures
/// - [expands] (bool?, optional): whether overlay expands to fill space
/// - [draggable] (bool?, optional): whether overlay can be dragged to dismiss
/// - [barrierDismissible] (bool?, optional): whether barrier tap dismisses overlay
/// - [backdropBuilder] (WidgetBuilder?, optional): custom backdrop builder
/// - [useSafeArea] (bool?, optional): whether to respect safe areas
/// - [showDragHandle] (bool?, optional): whether to show drag handle
/// - [borderRadius] (BorderRadiusGeometry?, optional): overlay corner radius
/// - [dragHandleSize] (Size?, optional): size of drag handle
/// - [transformBackdrop] (bool?, optional): whether to transform backdrop
/// - [surfaceOpacity] (double?, optional): surface opacity level
/// - [surfaceBlur] (double?, optional): surface blur intensity
/// - [barrierColor] (Color?, optional): modal barrier color
/// - [behavior] (HitTestBehavior?, optional): gesture detection behavior
///
/// Example:
/// ```dart
/// Swiper(
///   position: OverlayPosition.bottom,
///   handler: SwiperHandler.sheet,
///   builder: (context) => ActionSheet(),
///   child: FloatingActionButton(
///     onPressed: null,
///     child: Icon(Icons.more_horiz),
///   ),
/// )
/// ```
  const Swiper({super.key, this.enabled = true, required this.position, required this.builder, required this.handler, this.expands, this.draggable, this.barrierDismissible, this.backdropBuilder, this.useSafeArea, this.showDragHandle, this.borderRadius, this.dragHandleSize, this.transformBackdrop, this.surfaceOpacity, this.surfaceBlur, this.barrierColor, this.behavior, required this.child});
  State<Swiper> createState();
}
/// Theme configuration for modal backdrop appearance and behavior.
///
/// Defines the visual and behavioral properties of the backdrop that appears
/// behind modal dialogs, including border radius, padding, barrier color,
/// and modal interaction settings.
///
/// Example:
/// ```dart
/// ComponentThemeData(
///   data: {
///     ModalBackdropTheme: ModalBackdropTheme(
///       barrierColor: Colors.black54,
///       borderRadius: BorderRadius.circular(12),
///       modal: true,
///     ),
///   },
///   child: MyApp(),
/// )
/// ```
class ModalBackdropTheme extends ComponentThemeData {
/// Border radius applied to the modal surface.
  BorderRadiusGeometry? borderRadius;
/// Padding around the modal content area.
  EdgeInsetsGeometry? padding;
/// Color of the barrier that appears behind the modal.
  Color? barrierColor;
/// Whether the backdrop behaves as a modal (blocking interaction).
  bool? modal;
/// Whether to clip the surface for visual effects.
  bool? surfaceClip;
/// Creates a [ModalBackdropTheme].
///
/// All parameters are optional and will use system defaults when null.
///
/// Parameters:
/// - [borderRadius] (BorderRadiusGeometry?, optional): corner radius for the modal surface
/// - [padding] (EdgeInsetsGeometry?, optional): padding around modal content
/// - [barrierColor] (Color?, optional): backdrop color, typically semi-transparent
/// - [modal] (bool?, optional): whether backdrop blocks user interaction
/// - [surfaceClip] (bool?, optional): whether to clip surface for visual effects
///
/// Example:
/// ```dart
/// const ModalBackdropTheme(
///   borderRadius: BorderRadius.circular(8),
///   barrierColor: Color.fromRGBO(0, 0, 0, 0.5),
///   modal: true,
/// )
/// ```
  const ModalBackdropTheme({this.borderRadius, this.padding, this.barrierColor, this.modal, this.surfaceClip});
/// Creates a copy of this theme with the given fields replaced.
///
/// Uses [ValueGetter] functions to allow null value assignments.
/// Any parameter set to null will use the current value.
///
/// Returns:
/// A new [ModalBackdropTheme] with updated values.
///
/// Example:
/// ```dart
/// final newTheme = theme.copyWith(
///   barrierColor: () => Colors.red.withOpacity(0.3),
///   modal: () => false,
/// );
/// ```
  ModalBackdropTheme copyWith({ValueGetter<BorderRadiusGeometry?>? borderRadius, ValueGetter<EdgeInsetsGeometry?>? padding, ValueGetter<Color?>? barrierColor, ValueGetter<bool?>? modal, ValueGetter<bool?>? surfaceClip});
  bool operator ==(Object other);
  int get hashCode;
}
/// A visual backdrop widget that creates modal-style overlays.
///
/// Creates a semi-transparent barrier behind modal content with support for
/// custom colors, clipping, and animation. The backdrop can be configured
/// to prevent interaction with content below when modal behavior is enabled.
///
/// Features:
/// - Customizable barrier color and opacity
/// - Surface clipping for visual effects
/// - Animation support with fade transitions
/// - Configurable modal behavior
/// - Theme integration
///
/// Example:
/// ```dart
/// ModalBackdrop(
///   barrierColor: Colors.black54,
///   borderRadius: BorderRadius.circular(12),
///   modal: true,
///   child: MyDialogContent(),
/// )
/// ```
class ModalBackdrop extends StatelessWidget {
/// Determines if surface clipping should be enabled based on opacity.
///
/// Returns `true` if [surfaceOpacity] is null or less than 1.0,
/// indicating that clipping is needed for proper visual effects.
  static bool shouldClipSurface(double? surfaceOpacity);
/// The child widget to display above the backdrop.
  Widget child;
/// Border radius for the backdrop cutout around the child.
  BorderRadiusGeometry? borderRadius;
/// Padding around the child widget.
  EdgeInsetsGeometry? padding;
/// Color of the backdrop barrier.
  Color? barrierColor;
/// Animation for fade in/out transitions.
  Animation<double>? fadeAnimation;
/// Whether the backdrop should behave as a modal.
  bool? modal;
/// Whether to apply surface clipping effects.
  bool? surfaceClip;
/// Creates a [ModalBackdrop].
///
/// The [child] parameter is required and represents the content to display
/// above the backdrop.
///
/// Parameters:
/// - [child] (Widget, required): content widget displayed above backdrop
/// - [modal] (bool?, optional): enables modal behavior, defaults to true
/// - [surfaceClip] (bool?, optional): enables surface clipping, defaults to true
/// - [borderRadius] (BorderRadiusGeometry?, optional): corner radius for cutout
/// - [barrierColor] (Color?, optional): backdrop color, defaults to black with 80% opacity
/// - [padding] (EdgeInsetsGeometry?, optional): padding around child
/// - [fadeAnimation] (`Animation<double>?`, optional): fade transition animation
///
/// Example:
/// ```dart
/// ModalBackdrop(
///   barrierColor: Colors.black54,
///   fadeAnimation: slideController,
///   child: AlertDialog(title: Text('Alert')),
/// )
/// ```
  const ModalBackdrop({super.key, this.modal, this.surfaceClip, this.borderRadius, this.barrierColor, this.padding, this.fadeAnimation, required this.child});
  Widget build(BuildContext context);
}
/// A container widget that provides consistent styling for modal content.
///
/// Wraps modal content in a [SurfaceCard] with appropriate styling that
/// adapts to full-screen mode. Handles surface effects, borders, shadows,
/// and clipping behavior automatically based on the modal context.
///
/// Features:
/// - Automatic full-screen mode detection
/// - Surface styling with blur and opacity effects
/// - Configurable borders and shadows
/// - Clip behavior control
/// - Theme integration
///
/// Example:
/// ```dart
/// ModalContainer(
///   padding: EdgeInsets.all(16),
///   borderRadius: BorderRadius.circular(12),
///   filled: true,
///   child: Column(
///     children: [
///       Text('Dialog Title'),
///       Text('Dialog content here'),
///     ],
///   ),
/// )
/// ```
class ModalContainer extends StatelessWidget {
/// Model key used to identify full-screen modal mode.
  static const kFullScreenMode = #modal_surface_card_fullscreen;
/// Checks if the current context is in full-screen modal mode.
///
/// Returns `true` if the modal should display in full-screen mode,
/// which affects styling such as border radius and shadows.
  static bool isFullScreenMode(BuildContext context);
/// The child widget to display inside the modal container.
  Widget child;
/// Padding applied inside the container around the child.
  EdgeInsetsGeometry? padding;
/// Whether the container should have a filled background.
  bool filled;
/// Background fill color when [filled] is true.
  Color? fillColor;
/// Border radius for the container corners.
  BorderRadiusGeometry? borderRadius;
/// Color of the container border.
  Color? borderColor;
/// Width of the container border in logical pixels.
  double? borderWidth;
/// Clipping behavior for the container content.
  Clip clipBehavior;
/// Drop shadow effects applied to the container.
  List<BoxShadow>? boxShadow;
/// Surface opacity for backdrop effects.
  double? surfaceOpacity;
/// Surface blur intensity for backdrop effects.
  double? surfaceBlur;
/// Animation duration for surface transitions.
  Duration? duration;
/// Creates a [ModalContainer].
///
/// The [child] parameter is required. Other parameters customize the
/// container's appearance and behavior.
///
/// Parameters:
/// - [child] (Widget, required): content to display in the container
/// - [padding] (EdgeInsetsGeometry?, optional): inner padding around child
/// - [filled] (bool, default: false): whether to show background fill
/// - [fillColor] (Color?, optional): background fill color when filled is true
/// - [borderRadius] (BorderRadiusGeometry?, optional): corner radius
/// - [clipBehavior] (Clip, default: Clip.none): clipping behavior for content
/// - [borderColor] (Color?, optional): border color
/// - [borderWidth] (double?, optional): border width in logical pixels
/// - [boxShadow] (`List<BoxShadow>?`, optional): drop shadow effects
/// - [surfaceOpacity] (double?, optional): backdrop opacity level
/// - [surfaceBlur] (double?, optional): backdrop blur intensity
/// - [duration] (Duration?, optional): animation duration for transitions
///
/// Example:
/// ```dart
/// ModalContainer(
///   filled: true,
///   padding: EdgeInsets.all(24),
///   borderRadius: BorderRadius.circular(8),
///   child: Text('Modal Content'),
/// )
/// ```
  const ModalContainer({super.key, required this.child, this.padding, this.filled = false, this.fillColor, this.borderRadius, this.clipBehavior = Clip.none, this.borderColor, this.borderWidth, this.boxShadow, this.surfaceOpacity, this.surfaceBlur, this.duration});
  Widget build(BuildContext context);
}
/// Custom painter that creates a barrier effect with an optional cutout.
///
/// Paints a large colored rectangle that covers the entire screen, with
/// an optional rounded rectangle cutout to create a "spotlight" effect
/// around modal content. Uses path clipping to create the cutout area.
///
/// Features:
/// - Full-screen barrier painting
/// - Rounded rectangle cutouts
/// - Configurable colors and padding
/// - Efficient repainting optimization
///
/// Example:
/// ```dart
/// CustomPaint(
///   painter: SurfaceBarrierPainter(
///     clip: true,
///     borderRadius: BorderRadius.circular(8),
///     barrierColor: Colors.black54,
///     padding: EdgeInsets.all(16),
///   ),
/// )
/// ```
class SurfaceBarrierPainter extends CustomPainter {
/// Large size constant for creating screen-filling effects.
  static const double bigSize = 1000000;
/// Large screen size for painting operations.
  static const bigScreen = Size(bigSize, bigSize);
/// Large offset to center the big screen.
  static const bigOffset = Offset(-bigSize / 2, -bigSize / 2);
/// Whether to clip a cutout area in the barrier.
  bool clip;
/// Border radius for the cutout area.
  BorderRadius borderRadius;
/// Color of the barrier.
  Color barrierColor;
/// Padding around the cutout area.
  EdgeInsets padding;
/// Creates a [SurfaceBarrierPainter].
///
/// Parameters:
/// - [clip] (bool, required): whether to create a cutout in the barrier
/// - [borderRadius] (BorderRadius, required): radius for the cutout corners
/// - [barrierColor] (Color, required): color of the barrier
/// - [padding] (EdgeInsets, default: EdgeInsets.zero): padding around cutout
///
/// Example:
/// ```dart
/// SurfaceBarrierPainter(
///   clip: true,
///   borderRadius: BorderRadius.circular(12),
///   barrierColor: Colors.black54,
/// )
/// ```
  SurfaceBarrierPainter({required this.clip, required this.borderRadius, required this.barrierColor, this.padding = EdgeInsets.zero});
  void paint(Canvas canvas, Size size);
  bool shouldRepaint(covariant SurfaceBarrierPainter oldDelegate);
}
/// Custom route implementation for shadcn_flutter dialogs.
///
/// Extends [RawDialogRoute] to provide consistent dialog behavior with
/// proper theme inheritance, data capture, and transition animations.
/// Handles both standard and full-screen dialog presentations.
///
/// Features:
/// - Theme and data inheritance across navigation boundaries
/// - Configurable alignment and positioning
/// - Full-screen mode support
/// - Custom transition animations
/// - Safe area integration
///
/// This class is typically not used directly - use [showDialog] instead.
class DialogRoute<T> extends RawDialogRoute<T> {
/// Captured data from the launching context.
  CapturedData? data;
/// Alignment for positioning the dialog.
  AlignmentGeometry alignment;
/// Whether the dialog should display in full-screen mode.
  bool fullScreen;
/// Creates a [DialogRoute].
///
/// Parameters:
/// - [context] (`BuildContext`, required): Build context.
/// - [builder] (`WidgetBuilder`, required): Dialog content builder.
/// - [themes] (`CapturedThemes?`, optional): Captured theme data.
/// - [barrierColor] (`Color`, default: transparent): Barrier color.
/// - [barrierDismissible] (`bool?`, optional): Whether tapping barrier dismisses dialog.
/// - [barrierLabel] (`String?`, optional): Semantic label for barrier.
/// - [useSafeArea] (`bool`, default: `true`): Whether to respect safe area.
/// - [settings] (`RouteSettings?`, optional): Route settings.
/// - [anchorPoint] (`Offset?`, optional): Anchor point for route.
/// - [traversalEdgeBehavior] (`TraversalEdgeBehavior?`, optional): Traversal behavior.
/// - [alignment] (`AlignmentGeometry`, required): Dialog alignment.
/// - [transitionBuilder] (`RouteTransitionsBuilder`, required): Transition builder.
/// - [fullScreen] (`bool`, default: `false`): Full-screen mode.
/// - [data] (`CapturedData?`, optional): Captured data.
  DialogRoute({required BuildContext context, required WidgetBuilder builder, CapturedThemes? themes, super.barrierColor = const Color.fromRGBO(0, 0, 0, 0), super.barrierDismissible, String? barrierLabel, bool useSafeArea = true, super.settings, super.anchorPoint, super.traversalEdgeBehavior, required this.alignment, required super.transitionBuilder, this.fullScreen = false, this.data});
}
/// Displays a dialog using the shadcn_flutter design system.
///
/// Shows a modal dialog with consistent styling and animation behavior.
/// The dialog is displayed over the current route and blocks interaction
/// with the content below. Supports both centered and full-screen modes.
///
/// Features:
/// - Consistent design system integration
/// - Smooth scale and fade animations
/// - Configurable alignment and barriers
/// - Theme and data inheritance
/// - Safe area handling
/// - Custom transition animations
///
/// Parameters:
/// - [context] (BuildContext, required): build context for navigation
/// - [builder] (WidgetBuilder, required): function that builds dialog content
/// - [useRootNavigator] (bool, default: true): whether to use root navigator
/// - [barrierDismissible] (bool, default: true): tap outside to dismiss
/// - [barrierColor] (Color?, optional): color of the backdrop barrier
/// - [barrierLabel] (String?, optional): semantic label for the barrier
/// - [useSafeArea] (bool, default: true): respect device safe areas
/// - [routeSettings] (RouteSettings?, optional): settings for the route
/// - [anchorPoint] (Offset?, optional): anchor point for transitions
/// - [traversalEdgeBehavior] (TraversalEdgeBehavior?, optional): focus traversal
/// - [alignment] (AlignmentGeometry?, optional): dialog alignment, defaults to center
/// - [fullScreen] (bool, default: false): whether to display in full-screen mode
///
/// Returns:
/// A [Future] that resolves to the result passed to [Navigator.pop].
///
/// Example:
/// ```dart
/// final result = await showDialog<String>(
///   context: context,
///   builder: (context) => AlertDialog(
///     title: Text('Confirm'),
///     content: Text('Are you sure?'),
///     actions: [
///       TextButton(
///         onPressed: () => Navigator.pop(context, 'cancel'),
///         child: Text('Cancel'),
///       ),
///       TextButton(
///         onPressed: () => Navigator.pop(context, 'ok'),
///         child: Text('OK'),
///       ),
///     ],
///   ),
/// );
/// ```
Future<T?> showDialog<T>({required BuildContext context, required WidgetBuilder builder, bool useRootNavigator = true, bool barrierDismissible = true, Color? barrierColor, String? barrierLabel, bool useSafeArea = true, RouteSettings? routeSettings, Offset? anchorPoint, TraversalEdgeBehavior? traversalEdgeBehavior, AlignmentGeometry? alignment, bool fullScreen = false});
/// Overlay handler that manages dialog display using the navigation stack.
///
/// Provides a standardized way to show dialogs through the overlay system
/// with proper theme inheritance, animation handling, and modal behavior.
/// Integrates with the shadcn_flutter overlay architecture for consistent
/// dialog management across the application.
///
/// Features:
/// - Navigation-based dialog management
/// - Theme and data inheritance
/// - Configurable modal barriers
/// - Animation integration
/// - Proper focus management
///
/// Example:
/// ```dart
/// const DialogOverlayHandler().show<String>(
///   context: context,
///   alignment: Alignment.center,
///   builder: (context) => MyCustomDialog(),
/// );
/// ```
class DialogOverlayHandler extends OverlayHandler {
/// Checks if the current context is within a dialog overlay.
///
/// Returns `true` if the context is inside a dialog managed by
/// this overlay handler.
  static bool isDialogOverlay(BuildContext context);
/// Creates a [DialogOverlayHandler].
///
/// Example:
/// ```dart
/// const DialogOverlayHandler()
/// ```
  const DialogOverlayHandler();
  OverlayCompleter<T> show<T>({required BuildContext context, required AlignmentGeometry alignment, required WidgetBuilder builder, Offset? position, AlignmentGeometry? anchorAlignment, PopoverConstraint widthConstraint = PopoverConstraint.flexible, PopoverConstraint heightConstraint = PopoverConstraint.flexible, Key? key, bool rootOverlay = true, bool modal = true, bool barrierDismissable = true, Clip clipBehavior = Clip.none, Object? regionGroupId, Offset? offset, AlignmentGeometry? transitionAlignment, EdgeInsetsGeometry? margin, bool follow = true, bool consumeOutsideTaps = true, ValueChanged<PopoverOverlayWidgetState>? onTickFollow, bool allowInvertHorizontal = true, bool allowInvertVertical = true, bool dismissBackdropFocus = true, Duration? showDuration, Duration? dismissDuration, OverlayBarrier? overlayBarrier, LayerLink? layerLink});
}
/// Full-screen variant of the dialog overlay handler.
///
/// Similar to [DialogOverlayHandler] but specifically designed for full-screen
/// modal presentations. Removes padding and adjusts styling to fill the entire
/// screen while maintaining proper overlay management and animation behavior.
///
/// Features:
/// - Full-screen modal presentation
/// - Edge-to-edge content display
/// - Maintained overlay architecture
/// - Proper animation handling
/// - Theme inheritance
///
/// Example:
/// ```dart
/// const FullScreenDialogOverlayHandler().show<bool>(
///   context: context,
///   alignment: Alignment.center,
///   builder: (context) => FullScreenForm(),
/// );
/// ```
class FullScreenDialogOverlayHandler extends OverlayHandler {
/// Checks if the current context is within a dialog overlay.
///
/// Returns `true` if the context is inside a dialog managed by
/// this overlay handler.
  static bool isDialogOverlay(BuildContext context);
/// Creates a [FullScreenDialogOverlayHandler].
///
/// Example:
/// ```dart
/// const FullScreenDialogOverlayHandler()
/// ```
  const FullScreenDialogOverlayHandler();
  OverlayCompleter<T> show<T>({required BuildContext context, required AlignmentGeometry alignment, required WidgetBuilder builder, Offset? position, AlignmentGeometry? anchorAlignment, PopoverConstraint widthConstraint = PopoverConstraint.flexible, PopoverConstraint heightConstraint = PopoverConstraint.flexible, Key? key, bool rootOverlay = true, bool modal = true, bool barrierDismissable = true, Clip clipBehavior = Clip.none, Object? regionGroupId, Offset? offset, AlignmentGeometry? transitionAlignment, EdgeInsetsGeometry? margin, bool follow = true, bool consumeOutsideTaps = true, ValueChanged<PopoverOverlayWidgetState>? onTickFollow, bool allowInvertHorizontal = true, bool allowInvertVertical = true, bool dismissBackdropFocus = true, Duration? showDuration, Duration? dismissDuration, OverlayBarrier? overlayBarrier, LayerLink? layerLink});
}
/// Completer that manages the lifecycle of a dialog overlay.
///
/// Provides control over dialog animations, completion status, and disposal.
/// Wraps a [DialogRoute] to offer a consistent interface for managing
/// dialog lifecycles through the overlay system.
///
/// Features:
/// - Animation state monitoring
/// - Future-based completion handling
/// - Proper resource disposal
/// - Route management integration
///
/// Example:
/// ```dart
/// final completer = DialogOverlayCompleter(dialogRoute);
/// await completer.future; // Wait for dialog completion
/// completer.remove(); // Programmatically close dialog
/// ```
class DialogOverlayCompleter<T> extends OverlayCompleter<T> {
/// The dialog route managed by this completer.
  DialogRoute<T> route;
/// Creates a [DialogOverlayCompleter].
///
/// Parameters:
/// - [route] (`DialogRoute<T>`, required): the dialog route to manage
///
/// Example:
/// ```dart
/// DialogOverlayCompleter(myDialogRoute)
/// ```
  DialogOverlayCompleter(this.route);
  Future<void> get animationFuture;
  void dispose();
  Future<T> get future;
  bool get isAnimationCompleted;
  bool get isCompleted;
  void remove();
}
/// A widget that conditionally wraps its child with a builder function.
///
/// [Wrapper] provides flexible control over whether and how to wrap a child widget.
/// It can optionally apply a custom builder function and maintain the widget
/// structure across rebuilds using a keyed subtree.
///
/// Key features:
/// - Conditional wrapping with [wrap] flag
/// - Optional structure preservation with [maintainStructure]
/// - Custom builder function support via [WrapperBuilder]
///
/// Example:
/// ```dart
/// Wrapper(
///   wrap: true,
///   builder: (context, child) => Container(
///     padding: EdgeInsets.all(8),
///     child: child,
///   ),
///   child: Text('Hello'),
/// )
/// ```
class Wrapper extends StatefulWidget {
/// The child widget to be wrapped.
  Widget child;
/// Optional builder function to wrap the child.
///
/// If [wrap] is true and this is provided, the child will be wrapped
/// using this builder function. If null, the child is returned as-is.
  WrapperBuilder? builder;
/// Whether to apply the [builder] wrapper.
///
/// When false, the [child] is returned directly regardless of [builder].
/// Defaults to true.
  bool wrap;
/// Whether to maintain the widget structure across rebuilds.
///
/// When true, wraps the child in a [KeyedSubtree] to preserve the widget
/// subtree identity across rebuilds. This can be useful for maintaining
/// widget state when the wrapper's parent rebuilds.
/// Defaults to false.
  bool maintainStructure;
/// Creates a [Wrapper] widget.
///
/// The [child] parameter is required. The [wrap] parameter defaults to true,
/// and [maintainStructure] defaults to false.
  const Wrapper({super.key, required this.child, this.builder, this.wrap = true, this.maintainStructure = false});
  State<Wrapper> createState();
}
/// Details about a click event, including the click count.
///
/// Provides information about click interactions, particularly useful
/// for detecting single, double, or multiple clicks on a widget.
///
/// The [clickCount] indicates how many consecutive clicks have occurred
/// within the threshold duration (e.g., 1 for single click, 2 for double click).
class ClickDetails {
/// The number of consecutive clicks within the threshold period.
///
/// Increments for each click that occurs within [ClickDetector.threshold]
/// duration of the previous click. Resets to 1 when threshold is exceeded.
  int clickCount;
/// Creates click details with the specified click count.
///
/// Parameters:
/// - [clickCount]: Number of consecutive clicks (required)
  const ClickDetails({required this.clickCount});
}
/// A widget that detects and reports click events with multi-click support.
///
/// Wraps a child widget and detects tap gestures, tracking consecutive clicks
/// within a configurable threshold duration. Useful for implementing double-click,
/// triple-click, or other multi-click interactions.
///
/// Features:
/// - **Click Count Tracking**: Automatically counts consecutive clicks
/// - **Configurable Threshold**: Set maximum time between clicks
/// - **Flexible Behavior**: Customize hit test behavior
/// - **Simple Integration**: Wraps any widget with tap detection
///
/// The widget calls [onClick] with [ClickDetails] containing the click count
/// each time a tap is detected. The count resets to 1 if taps are spaced
/// beyond the [threshold] duration.
///
/// Example - Double Click Detection:
/// ```dart
/// ClickDetector(
///   onClick: (details) {
///     if (details.clickCount == 2) {
///       print('Double clicked!');
///     }
///   },
///   child: Text('Double click me'),
/// )
/// ```
///
/// Example - Custom Threshold:
/// ```dart
/// ClickDetector(
///   onClick: (details) {
///     print('Clicked ${details.clickCount} times');
///   },
///   threshold: Duration(milliseconds: 500),
///   child: Container(
///     padding: EdgeInsets.all(16),
///     child: Text('Click rapidly'),
///   ),
/// )
/// ```
class ClickDetector extends StatefulWidget {
/// Callback invoked when the child widget is clicked.
///
/// Called with [ClickDetails] containing the current click count.
/// If `null`, the detector is effectively disabled (no taps detected).
  ClickCallback<ClickDetails>? onClick;
/// The widget that receives click detection.
///
/// This widget will be wrapped with gesture detection capabilities.
  Widget child;
/// How to behave during hit testing.
///
/// Determines whether this detector should participate in hit testing
/// and how it should behave. Defaults to [HitTestBehavior.deferToChild].
  HitTestBehavior behavior;
/// Maximum time between clicks to count as consecutive.
///
/// When clicks occur within this duration, they increment the click count.
/// When clicks are spaced beyond this duration, the count resets to 1.
///
/// Defaults to 300 milliseconds, which is a common double-click threshold.
  Duration threshold;
/// Creates a click detector widget.
///
/// Parameters:
/// - [child]: The widget to wrap with click detection (required)
/// - [onClick]: Callback for click events (optional)
/// - [behavior]: Hit test behavior (defaults to [HitTestBehavior.deferToChild])
/// - [threshold]: Max time between consecutive clicks (defaults to 300ms)
  const ClickDetector({super.key, this.onClick, required this.child, this.behavior = HitTestBehavior.deferToChild, this.threshold = const Duration(milliseconds: 300)});
  State<ClickDetector> createState();
}
/// A widget that builds itself based on a [FutureOr] value.
///
/// This widget handles both immediate values and futures uniformly, building
/// the appropriate widget based on whether the value is synchronous or asynchronous.
///
/// ## Type Parameters
///
/// * [T] - The type of value being awaited.
///
/// ## Overview
///
/// Use [FutureOrBuilder] when you have a value that might be either synchronous
/// (already available) or asynchronous (requires waiting). If the value is
/// synchronous, the widget is built immediately. If it's a [Future], the widget
/// uses [FutureBuilder] internally.
///
/// ## Example
///
/// ```dart
/// FutureOrBuilder<String>(
///   future: getData(), // Returns FutureOr<String>
///   builder: (context, snapshot) {
///     if (snapshot.hasError) {
///       return Text('Error: ${snapshot.error}');
///     }
///     if (!snapshot.hasData) {
///       return CircularProgressIndicator();
///     }
///     return Text(snapshot.data!);
///   },
/// )
/// ```
///
/// See also:
///
/// * [FutureBuilder] for handling only futures.
class FutureOrBuilder<T> extends StatelessWidget {
/// The [FutureOr] value to track - can be either immediate or async.
  FutureOr<T> future;
/// The builder function called to construct the widget.
  FutureOrWidgetBuilder<T> builder;
/// An optional initial value to use before async completion.
  T? initialValue;
/// Creates a [FutureOrBuilder].
///
/// ## Parameters
///
/// * [future] - The [FutureOr] value to track.
/// * [builder] - Function to build the widget based on the async state.
/// * [initialValue] - Optional initial data to use before the future completes.
///
/// ## Example
///
/// ```dart
/// FutureOrBuilder<int>(
///   future: fetchCount(),
///   initialValue: 0,
///   builder: (context, snapshot) => Text('Count: ${snapshot.data}'),
/// )
/// ```
  const FutureOrBuilder({super.key, required this.future, required this.builder, this.initialValue});
  Widget build(BuildContext context);
}
/// Web platform-specific implementations for shadcn_flutter.
///
/// This class provides web-specific functionality, including integration
/// with the JavaScript preloader and theme synchronization.
class ShadcnFlutterPlatformImplementations {
/// Called when the app is initialized.
///
/// Notifies the JavaScript preloader that the Flutter app is ready
/// by dispatching a "shadcn_flutter_app_ready" event.
  void onAppInitialized();
/// Called when the theme changes.
///
/// Synchronizes the Flutter theme with the JavaScript preloader by
/// dispatching a theme change event with the new color values.
  void onThemeChanged(ThemeData theme);
}
/// Mutates a list to contain source elements with separators between them.
///
/// This function efficiently updates [separatedList] in place to match the pattern
/// of [source] elements interleaved with [separator] values. It minimizes memory
/// allocations by reusing existing list elements where possible.
///
/// ## Parameters
///
/// * [source] - The source list of elements to separate.
/// * [separatedList] - The list to mutate. Will be modified in place.
/// * [separator] - The separator value to insert between source elements.
///
/// ## Side Effects
///
/// Modifies [separatedList] to contain elements from [source] with [separator]
/// inserted between each pair of adjacent elements. If [separatedList] is too
/// long, extra elements are removed. If too short, new elements are added.
///
/// ## Example
///
/// ```dart
/// final source = [1, 2, 3];
/// final separated = <int>[];
/// mutateSeparated(source, separated, 0);
/// // separated is now [1, 0, 2, 0, 3]
///
/// // Update with new source
/// mutateSeparated([4, 5], separated, 0);
/// // separated is now [4, 0, 5]
/// ```
void mutateSeparated<T>(List<T> source, List<T> separatedList, T separator);
/// An iterable that inserts a separator between elements of another iterable.
///
/// This class wraps an existing iterable and lazily produces elements with
/// a separator value inserted between each pair of adjacent elements.
///
/// ## Type Parameters
///
/// * [T] - The type of elements in the iterable.
///
/// ## Overview
///
/// Use [SeparatedIterable] when you need to iterate over a collection with
/// separators but don't want to allocate a new list. The separation happens
/// lazily during iteration.
///
/// ## Example
///
/// ```dart
/// final numbers = [1, 2, 3, 4];
/// final separated = SeparatedIterable(numbers, 0);
///
/// print(separated.toList()); // [1, 0, 2, 0, 3, 0, 4]
/// ```
///
/// See also:
///
/// * [mutateSeparated] for in-place list mutation with separators.
class SeparatedIterable<T> extends Iterable<T> {
/// Creates a separated iterable.
///
/// ## Parameters
///
/// * [_iterable] - The source iterable to separate.
/// * [_separator] - The separator value to insert between elements.
  SeparatedIterable(this._iterable, this._separator);
  Iterator<T> get iterator;
}
/// An iterator that yields elements with separators between them.
///
/// This iterator wraps an existing iterator and produces elements from the
/// source with a separator value inserted between each pair of adjacent
/// elements.
///
/// ## Type Parameters
///
/// * [T] - The type of elements being iterated.
///
/// ## Overview
///
/// [SeparatedIterator] is used internally by [SeparatedIterable]. It maintains
/// state to alternate between source elements and separator values.
///
/// ## Example
///
/// ```dart
/// final iterator = SeparatedIterator([1, 2, 3].iterator, 0);
///
/// while (iterator.moveNext()) {
///   print(iterator.current); // Prints: 1, 0, 2, 0, 3
/// }
/// ```
class SeparatedIterator<T> implements Iterator<T> {
/// Creates a separated iterator.
///
/// ## Parameters
///
/// * [_iterator] - The source iterator to separate.
/// * [_separator] - The separator value to insert between elements.
  SeparatedIterator(this._iterator, this._separator);
  T get current;
  bool moveNext();
}
/// A [Preview] that wraps the previewed widget in a [ShadcnLayer].
///
/// This is useful for testing shadcn widgets in a preview.
class ShadcnPreview extends Preview {
/// The color scheme to use for the preview.
  ColorScheme? colorScheme;
/// Creates a [ShadcnPreview].
///
/// Parameters:
/// - [colorScheme] (`ColorScheme?`, optional): The color scheme to use for the preview.
  const ShadcnPreview({super.name, super.group, super.size, super.textScaleFactor, super.wrapper, super.brightness, super.localizations, this.colorScheme});
/// The theme builder for the [ShadcnPreview].
///
/// Returns:
/// A [PreviewThemeData] instance.
  static PreviewThemeData themeBuilder();
  Preview transform();
}
/// A [MultiPreview] that generates multiple [ShadcnPreview]s with different configurations.
///
/// This is useful for testing shadcn widgets in different themes and brightness modes.
///
/// Example:
/// ```dart
/// @ShadcnMultiPreview()
/// class MyWidgetPreview extends StatelessWidget {
///   @override
///   Widget build(BuildContext context) {
///     return MyWidget();
///   }
/// }
/// ```
class ShadcnMultiPreview extends MultiPreview {
/// The name of the preview.
  String? name;
/// The group of the preview.
  String? group;
/// The size of the preview.
  Size? size;
/// The text scale factor of the preview.
  double? textScaleFactor;
/// The widget wrapper for the preview.
  WidgetWrapper? wrapper;
/// The brightness of the preview.
  Brightness? brightness;
/// The localizations for the preview.
  PreviewLocalizationsData Function()? localizations;
/// The dark color scheme for the preview.
  ColorScheme? darkColorScheme;
/// The light color scheme for the preview.
  ColorScheme? lightColorScheme;
/// Creates a [ShadcnMultiPreview].
///
/// Parameters:
/// - [name] (`String?`, optional): The name of the preview.
/// - [group] (`String?`, optional): The group of the preview.
/// - [size] (`Size?`, optional): The size of the preview.
/// - [textScaleFactor] (`double?`, optional): The text scale factor of the preview.
/// - [wrapper] (`WidgetWrapper?`, optional): The widget wrapper for the preview.
/// - [brightness] (`Brightness?`, optional): The brightness of the preview.
/// - [localizations] (`PreviewLocalizationsData Function()?`, optional): The localizations for the preview.
/// - [darkColorScheme] (`ColorScheme?`, optional): The dark color scheme for the preview.
/// - [lightColorScheme] (`ColorScheme?`, optional): The light color scheme for the preview.
  const ShadcnMultiPreview({this.name, this.group, this.size, this.textScaleFactor, this.wrapper, this.brightness, this.localizations, this.darkColorScheme, this.lightColorScheme});
  List<Preview> get previews;
}
/// A controlled animation that wraps an [AnimationController] and provides
/// smooth transitions between values using curves.
///
/// This class extends [Animation]`<double>` and allows programmatic control
/// of animations with custom start and end values, as well as curve adjustments.
///
/// ## Overview
///
/// Use [ControlledAnimation] when you need fine-grained control over animation
/// values and want to smoothly transition from any current value to a target
/// value with a specified curve.
///
/// ## Example
///
/// ```dart
/// final controller = AnimationController(
///   vsync: this,
///   duration: const Duration(milliseconds: 300),
/// );
/// final animation = ControlledAnimation(controller);
///
/// // Animate to 0.8 with ease-in curve
/// animation.forward(0.8, Curves.easeIn);
/// ```
class ControlledAnimation extends Animation<double> {
/// Creates a [ControlledAnimation] that wraps the given [AnimationController].
///
/// ## Parameters
///
/// * [_controller] - The underlying animation controller to use for timing.
///
/// ## Example
///
/// ```dart
/// final controller = AnimationController(
///   vsync: this,
///   duration: const Duration(milliseconds: 200),
/// );
/// final animation = ControlledAnimation(controller);
/// ```
  ControlledAnimation(this._controller);
/// Animates from the current value to the specified target value.
///
/// This method starts a forward animation from the current [value] to the
/// specified [to] value, applying the given [curve] for easing.
///
/// ## Parameters
///
/// * [to] - The target value to animate to (typically between 0.0 and 1.0).
/// * [curve] - Optional easing curve. Defaults to `Curves.linear` if not specified.
///
/// ## Returns
///
/// A [TickerFuture] that completes when the animation finishes.
///
/// ## Example
///
/// ```dart
/// // Animate to 1.0 with ease-out curve
/// await animation.forward(1.0, Curves.easeOut);
/// ```
  TickerFuture forward(double to, [Curve? curve]);
  set value(double value);
  void addListener(VoidCallback listener);
  void addStatusListener(AnimationStatusListener listener);
  void removeListener(VoidCallback listener);
  void removeStatusListener(AnimationStatusListener listener);
  AnimationStatus get status;
  double get value;
}
/// A mixin that provides animated property management for stateful widgets.
///
/// This mixin extends [TickerProviderStateMixin] and manages a collection of
/// animated properties, automatically disposing of their controllers.
///
/// ## Overview
///
/// Use [AnimatedMixin] when building stateful widgets that need multiple
/// animated properties. The mixin handles lifecycle management and provides
/// convenient factory methods for common types.
///
/// ## Example
///
/// ```dart
/// class MyWidget extends StatefulWidget {
///   @override
///   State<MyWidget> createState() => _MyWidgetState();
/// }
///
/// class _MyWidgetState extends State<MyWidget>
///     with TickerProviderStateMixin, AnimatedMixin {
///   late final AnimatedProperty<double> opacity;
///
///   @override
///   void initState() {
///     super.initState();
///     opacity = createAnimatedDouble(1.0);
///   }
///
///   @override
///   Widget build(BuildContext context) {
///     return Opacity(
///       opacity: opacity.value,
///       child: Container(),
///     );
///   }
/// }
/// ```
mixin AnimatedMixin on TickerProviderStateMixin {
/// Creates a new animated property with a custom interpolation function.
///
/// ## Type Parameters
///
/// * [T] - The type of value to animate.
///
/// ## Parameters
///
/// * [value] - The initial value of the property.
/// * [lerp] - The interpolation function to use for animating between values.
///
/// ## Returns
///
/// A new [AnimatedProperty]`<T>` that will be automatically disposed.
///
/// ## Example
///
/// ```dart
/// final customProp = createAnimatedProperty<MyType>(
///   initialValue,
///   (a, b, t) => MyType.lerp(a, b, t),
/// );
/// ```
  AnimatedProperty<T> createAnimatedProperty<T>(T value, PropertyLerp<T> lerp);
  void dispose();
/// Creates an animated property for integer values.
///
/// This is a convenience method that uses [Transformers.typeInt] for interpolation.
///
/// ## Parameters
///
/// * [value] - The initial integer value.
///
/// ## Returns
///
/// A new [AnimatedProperty]`<int>` configured for integer interpolation.
///
/// ## Example
///
/// ```dart
/// final count = createAnimatedInt(0);
/// count.value = 100; // Will animate from 0 to 100
/// ```
  AnimatedProperty<int> createAnimatedInt(int value);
/// Creates an animated property for double values.
///
/// This is a convenience method that uses [Transformers.typeDouble] for interpolation.
///
/// ## Parameters
///
/// * [value] - The initial double value.
///
/// ## Returns
///
/// A new [AnimatedProperty]`<double>` configured for double interpolation.
///
/// ## Example
///
/// ```dart
/// final opacity = createAnimatedDouble(1.0);
/// opacity.value = 0.0; // Will animate from 1.0 to 0.0
/// ```
  AnimatedProperty<double> createAnimatedDouble(double value);
/// Creates an animated property for [Color] values.
///
/// This is a convenience method that uses [Transformers.typeColor] for interpolation.
///
/// ## Parameters
///
/// * [value] - The initial color value.
///
/// ## Returns
///
/// A new [AnimatedProperty]`<Color>` configured for color interpolation.
///
/// ## Example
///
/// ```dart
/// final bgColor = createAnimatedColor(Colors.red);
/// bgColor.value = Colors.blue; // Will smoothly transition from red to blue
/// ```
  AnimatedProperty<Color> createAnimatedColor(Color value);
}
/// A property that can be animated between values of type [T].
///
/// This class manages an animation controller and interpolates between values
/// using a custom lerp function. It automatically triggers widget rebuilds when
/// the animation progresses.
///
/// ## Type Parameters
///
/// * [T] - The type of value being animated.
///
/// ## Overview
///
/// [AnimatedProperty] is typically created via [AnimatedMixin] factory methods
/// like [createAnimatedDouble] or [createAnimatedColor]. When you set a new
/// [value], it smoothly animates from the current value to the target.
///
/// ## Example
///
/// ```dart
/// // Created via AnimatedMixin
/// final opacity = createAnimatedDouble(1.0);
///
/// // Setting value triggers animation
/// opacity.value = 0.0;
///
/// // Access current value during animation
/// final current = opacity.value;
/// ```
class AnimatedProperty<T> {
/// Gets the current value of the animated property.
///
/// If an animation is in progress (has a target), this returns the interpolated
/// value between the start and target based on the controller's progress.
/// Otherwise, it returns the static value.
///
/// ## Returns
///
/// The current value of type [T], interpolated if animating.
///
/// ## Example
///
/// ```dart
/// final opacity = createAnimatedDouble(1.0);
/// print(opacity.value); // 1.0
///
/// opacity.value = 0.0; // Start animating
/// print(opacity.value); // Something between 0.0 and 1.0 during animation
/// ```
  T get value;
/// Sets a new target value and starts animating towards it.
///
/// When set, this property will smoothly animate from its current value to
/// the new target value. If already animating, the animation is reset and
/// restarted from the current interpolated position.
///
/// ## Parameters
///
/// * [value] - The new target value of type [T].
///
/// ## Side Effects
///
/// Triggers the animation controller to start/restart, which will cause
/// widget rebuilds via the update callback.
///
/// ## Example
///
/// ```dart
/// final size = createAnimatedDouble(100.0);
///
/// // Start animation to 200.0
/// size.value = 200.0;
///
/// // Change target mid-animation
/// size.value = 150.0; // Will animate from current position to 150.0
/// ```
  set value(T value);
}
/// Represents a request to animate to a specific target value.
///
/// This class encapsulates the parameters needed for a single animation step,
/// including the target value, duration, and easing curve.
///
/// ## Overview
///
/// Use [AnimationRequest] with [AnimationQueueController] to queue multiple
/// animation steps that will be executed sequentially or as replacements.
///
/// ## Example
///
/// ```dart
/// final request = AnimationRequest(
///   1.0,
///   Duration(milliseconds: 300),
///   Curves.easeOut,
/// );
/// controller.push(request);
/// ```
class AnimationRequest {
/// The target value to animate to (typically 0.0 to 1.0).
  double target;
/// The duration of the animation.
  Duration duration;
/// The easing curve to apply during the animation.
  Curve curve;
/// Creates an animation request with the specified parameters.
///
/// ## Parameters
///
/// * [target] - The destination value for the animation.
/// * [duration] - How long the animation should take.
/// * [curve] - The easing curve to use.
  AnimationRequest(this.target, this.duration, this.curve);
}
/// Manages the execution of a single animation step.
///
/// This class tracks the progress of an animation from a start value to an
/// end value over a specified duration using a curve.
///
/// ## Overview
///
/// [AnimationRunner] is used internally by [AnimationQueueController] to
/// execute individual animation steps. It tracks progress and computes
/// intermediate values.
///
/// ## Example
///
/// ```dart
/// final runner = AnimationRunner(
///   0.0, // from
///   1.0, // to
///   Duration(milliseconds: 200),
///   Curves.easeIn,
/// );
/// ```
class AnimationRunner {
/// The starting value of the animation.
  double from;
/// The ending value of the animation.
  double to;
/// The total duration of the animation.
  Duration duration;
/// The easing curve applied to the animation.
  Curve curve;
/// Creates an animation runner with the specified parameters.
///
/// ## Parameters
///
/// * [from] - The starting value.
/// * [to] - The target value.
/// * [duration] - The animation duration.
/// * [curve] - The easing curve.
  AnimationRunner(this.from, this.to, this.duration, this.curve);
}
/// A controller that manages a queue of animation requests.
///
/// This class extends [ChangeNotifier] and provides a way to queue multiple
/// animations that execute sequentially or replace the current queue. It
/// handles timing via [tick] calls and notifies listeners of value changes.
///
/// ## Overview
///
/// Use [AnimationQueueController] when you need to chain multiple animations
/// or dynamically add/remove animation steps. Call [tick] regularly (e.g., in
/// a ticker or animation frame callback) to progress the animations.
///
/// ## Example
///
/// ```dart
/// final controller = AnimationQueueController(0.0);
///
/// // Queue animations
/// controller.push(AnimationRequest(0.5, Duration(milliseconds: 200), Curves.easeIn));
/// controller.push(AnimationRequest(1.0, Duration(milliseconds: 300), Curves.easeOut));
///
/// // In ticker
/// controller.tick(deltaTime);
/// ```
class AnimationQueueController extends ChangeNotifier {
/// Creates an animation queue controller with an optional initial value.
///
/// ## Parameters
///
/// * [_value] - The initial value. Defaults to `0.0`.
///
/// ## Example
///
/// ```dart
/// final controller = AnimationQueueController(0.5);
/// ```
  AnimationQueueController([this._value = 0.0]);
/// Adds an animation request to the queue or replaces the current queue.
///
/// ## Parameters
///
/// * [request] - The animation request to add.
/// * [queue] - If `true` (default), adds to the queue. If `false`, clears
///   the queue and current runner, making this the only animation.
///
/// ## Side Effects
///
/// Notifies listeners after modifying the queue.
///
/// ## Example
///
/// ```dart
/// // Add to queue
/// controller.push(request);
///
/// // Replace queue
/// controller.push(request, false);
/// ```
  void push(AnimationRequest request, [bool queue = true]);
/// Sets the current value immediately, clearing all queued animations.
///
/// ## Parameters
///
/// * [value] - The new value to set.
///
/// ## Side Effects
///
/// Clears the animation queue and runner, then notifies listeners.
///
/// ## Example
///
/// ```dart
/// controller.value = 0.5; // Jumps to 0.5, cancels animations
/// ```
  set value(double value);
/// Gets the current animation value.
///
/// ## Returns
///
/// The current value, which may be actively animating.
  double get value;
/// Checks if there are pending animations or an active runner.
///
/// ## Returns
///
/// `true` if animations should continue to be ticked, `false` otherwise.
///
/// ## Example
///
/// ```dart
/// if (controller.shouldTick) {
///   controller.tick(deltaTime);
/// }
/// ```
  bool get shouldTick;
/// Advances the animation by the given time delta.
///
/// Call this method regularly (e.g., from a ticker) to progress animations.
/// If the current animation completes, the next queued animation starts.
///
/// ## Parameters
///
/// * [delta] - The time elapsed since the last tick.
///
/// ## Side Effects
///
/// Updates [value] and notifies listeners as the animation progresses.
///
/// ## Example
///
/// ```dart
/// // In a ticker callback
/// void _tick(Duration elapsed) {
///   final delta = elapsed - _lastElapsed;
///   controller.tick(delta);
///   _lastElapsed = elapsed;
/// }
/// ```
  void tick(Duration delta);
}
/// An abstract interface for keyframes in timeline animations.
///
/// A keyframe defines how to compute a value at a specific point in a
/// timeline animation. Different implementations provide different interpolation
/// strategies (absolute, relative, or static).
///
/// ## Type Parameters
///
/// * [T] - The type of value this keyframe produces.
///
/// ## Overview
///
/// Use [Keyframe] implementations like [AbsoluteKeyframe], [RelativeKeyframe],
/// or [StillKeyframe] to build complex timeline animations with
/// [TimelineAnimation].
///
/// See also:
///
/// * [AbsoluteKeyframe] - Animates between explicit start and end values.
/// * [RelativeKeyframe] - Animates from the previous keyframe's end value.
/// * [StillKeyframe] - Holds a value without animating.
abstract class Keyframe<T> {
/// The duration of this keyframe.
///
/// ## Returns
///
/// The time this keyframe takes to complete.
  Duration get duration;
/// Computes the value for this keyframe at the given progress.
///
/// ## Parameters
///
/// * [timeline] - The parent timeline animation.
/// * [index] - The index of this keyframe in the timeline.
/// * [t] - The local progress through this keyframe (0.0 to 1.0).
///
/// ## Returns
///
/// The computed value of type [T] at the given progress.
  T compute(TimelineAnimation<T> timeline, int index, double t);
}
/// A keyframe that animates between explicit start and end values.
///
/// This keyframe interpolates from a specified [from] value to a [to] value
/// over its [duration], independent of previous keyframes.
///
/// ## Type Parameters
///
/// * [T] - The type of value to animate.
///
/// ## Overview
///
/// Use [AbsoluteKeyframe] when you want complete control over both the start
/// and end values of a keyframe, regardless of previous animation state.
///
/// ## Example
///
/// ```dart
/// // Animate from 0.0 to 1.0 over 200ms
/// final keyframe = AbsoluteKeyframe<double>(
///   Duration(milliseconds: 200),
///   0.0,
///   1.0,
/// );
/// ```
class AbsoluteKeyframe<T> implements Keyframe<T> {
/// The starting value of the animation.
  T from;
/// The ending value of the animation.
  T to;
  Duration duration;
/// Creates an absolute keyframe with explicit start and end values.
///
/// ## Parameters
///
/// * [duration] - How long to animate from [from] to [to].
/// * [from] - The starting value.
/// * [to] - The ending value.
  const AbsoluteKeyframe(this.duration, this.from, this.to);
  T compute(TimelineAnimation<T> timeline, int index, double t);
}
/// A keyframe that animates from the previous keyframe's end value to a target.
///
/// This keyframe automatically uses the ending value of the previous keyframe
/// as its starting point, animating to the specified [target] value.
///
/// ## Type Parameters
///
/// * [T] - The type of value to animate.
///
/// ## Overview
///
/// Use [RelativeKeyframe] for smooth transitions between keyframes without
/// explicitly specifying start values. If used as the first keyframe, it acts
/// as a still keyframe.
///
/// ## Example
///
/// ```dart
/// final timeline = TimelineAnimation<double>(
///   keyframes: [
///     AbsoluteKeyframe(Duration(milliseconds: 100), 0.0, 0.5),
///     RelativeKeyframe(Duration(milliseconds: 100), 1.0), // from 0.5 to 1.0
///   ],
/// );
/// ```
class RelativeKeyframe<T> implements Keyframe<T> {
/// The target value to animate to from the previous keyframe's end.
  T target;
  Duration duration;
/// Creates a relative keyframe that animates to the target value.
///
/// ## Parameters
///
/// * [duration] - How long to animate to [target].
/// * [target] - The ending value for this keyframe.
  const RelativeKeyframe(this.duration, this.target);
  T compute(TimelineAnimation<T> timeline, int index, double t);
}
/// A keyframe that holds a constant value without animating.
///
/// This keyframe maintains a static value for its duration. If [value] is `null`,
/// it uses the ending value from the previous keyframe.
///
/// ## Type Parameters
///
/// * [T] - The type of value to hold.
///
/// ## Overview
///
/// Use [StillKeyframe] to create pauses or delays in timeline animations where
/// the value remains constant for a period of time.
///
/// ## Example
///
/// ```dart
/// final timeline = TimelineAnimation<double>(
///   keyframes: [
///     AbsoluteKeyframe(Duration(milliseconds: 100), 0.0, 1.0),
///     StillKeyframe(Duration(milliseconds: 200)), // Hold at 1.0 for 200ms
///     RelativeKeyframe(Duration(milliseconds: 100), 0.0), // Back to 0.0
///   ],
/// );
/// ```
class StillKeyframe<T> implements Keyframe<T> {
/// The value to hold, or `null` to use the previous keyframe's end value.
  T? value;
  Duration duration;
/// Creates a still keyframe that holds a value.
///
/// ## Parameters
///
/// * [duration] - How long to hold the value.
/// * [value] - The value to hold, or `null` to use the previous keyframe's end value.
///
/// ## Notes
///
/// If [value] is `null`, this keyframe must not be the first in the timeline.
  const StillKeyframe(this.duration, [this.value]);
  T compute(TimelineAnimation<T> timeline, int index, double t);
}
/// An [Animatable] wrapper for [TimelineAnimation] with explicit duration.
///
/// This class adapts a [TimelineAnimation] to work with a specific total duration,
/// scaling the animation to fit within that time frame.
///
/// ## Type Parameters
///
/// * [T] - The type of value being animated.
///
/// ## Overview
///
/// [TimelineAnimatable] is typically created via [TimelineAnimation.drive] or
/// [TimelineAnimation.withTotalDuration] to bind a timeline to a controller.
///
/// ## Example
///
/// ```dart
/// final controller = AnimationController(
///   vsync: this,
///   duration: Duration(seconds: 2),
/// );
/// final animatable = timeline.drive(controller);
/// ```
class TimelineAnimatable<T> extends Animatable<T> {
/// The total duration for this animatable.
  Duration duration;
/// The underlying timeline animation.
  TimelineAnimation<T> animation;
/// Creates a timeline animatable with the specified duration.
///
/// ## Parameters
///
/// * [duration] - The total duration for the animation.
/// * [animation] - The timeline animation to wrap.
  TimelineAnimatable(this.duration, this.animation);
  T transform(double t);
}
/// A timeline-based animation built from multiple keyframes.
///
/// This class extends [Animatable]`<T>` and orchestrates complex animations by
/// sequencing multiple [Keyframe]s. Each keyframe defines a segment of the
/// animation with its own duration and interpolation strategy.
///
/// ## Type Parameters
///
/// * [T] - The type of value being animated.
///
/// ## Overview
///
/// Use [TimelineAnimation] to create sophisticated multi-stage animations.
/// Keyframes can be absolute, relative, or still, allowing for diverse
/// animation patterns. The timeline automatically calculates total duration
/// from all keyframes.
///
/// ## Example
///
/// ```dart
/// final timeline = TimelineAnimation<double>(
///   lerp: Transformers.typeDouble,
///   keyframes: [
///     AbsoluteKeyframe(Duration(milliseconds: 100), 0.0, 1.0),
///     StillKeyframe(Duration(milliseconds: 50)),
///     RelativeKeyframe(Duration(milliseconds: 100), 0.5),
///   ],
/// );
/// ```
class TimelineAnimation<T> extends Animatable<T> {
/// Default lerp function that works with numeric types.
///
/// This function performs basic arithmetic interpolation. It assumes the
/// type supports addition, subtraction, and multiplication operators.
///
/// ## Type Parameters
///
/// * [T] - The type to interpolate (must support arithmetic operations).
///
/// ## Parameters
///
/// * [a] - The starting value.
/// * [b] - The ending value.
/// * [t] - The interpolation factor (0.0 to 1.0).
///
/// ## Returns
///
/// The interpolated value.
  static T defaultLerp<T>(T a, T b, double t);
/// The interpolation function used for this timeline.
  PropertyLerp<T> lerp;
/// The total duration of all keyframes combined.
  Duration totalDuration;
/// The list of keyframes that make up this timeline.
  List<Keyframe<T>> keyframes;
/// Creates a timeline animation from a list of keyframes.
///
/// ## Parameters
///
/// * [lerp] - Optional interpolation function. Uses [defaultLerp] if not provided.
/// * [keyframes] - The list of keyframes defining the animation. Must not be empty.
///
/// ## Returns
///
/// A new [TimelineAnimation] with calculated total duration.
///
/// ## Example
///
/// ```dart
/// final timeline = TimelineAnimation<Color>(
///   lerp: Transformers.typeColor,
///   keyframes: [
///     AbsoluteKeyframe(Duration(milliseconds: 300), Colors.red, Colors.blue),
///     RelativeKeyframe(Duration(milliseconds: 200), Colors.green),
///   ],
/// );
/// ```
  factory TimelineAnimation({PropertyLerp<T>? lerp, required List<Keyframe<T>> keyframes});
/// Binds this timeline to an [AnimationController].
///
/// ## Parameters
///
/// * [controller] - The animation controller to drive this timeline.
///   Must have a non-null duration.
///
/// ## Returns
///
/// A [TimelineAnimatable] that can be used with the controller.
///
/// ## Example
///
/// ```dart
/// final controller = AnimationController(
///   vsync: this,
///   duration: Duration(seconds: 1),
/// );
/// final animatable = timeline.drive(controller);
/// ```
  TimelineAnimatable<T> drive(AnimationController controller);
/// Transforms the timeline using the controller's current value.
///
/// This is a convenience method that combines [drive] and [Animatable.transform].
///
/// ## Parameters
///
/// * [controller] - The animation controller to read the value from.
///
/// ## Returns
///
/// The current value of type [T] based on the controller's progress.
///
/// ## Example
///
/// ```dart
/// final value = timeline.transformWithController(controller);
/// ```
  T transformWithController(AnimationController controller);
/// Creates a [TimelineAnimatable] with the specified total duration.
///
/// ## Parameters
///
/// * [duration] - The desired total duration for this timeline.
///
/// ## Returns
///
/// A [TimelineAnimatable] that scales this timeline to the given duration.
///
/// ## Example
///
/// ```dart
/// // Timeline with natural duration of 500ms
/// final timeline = TimelineAnimation<double>(...);
///
/// // Scale to 2 seconds
/// final animatable = timeline.withTotalDuration(Duration(seconds: 2));
/// ```
  TimelineAnimatable<T> withTotalDuration(Duration duration);
  T transform(double t);
}
/// Returns the maximum of two [Duration] values.
///
/// ## Parameters
///
/// * [a] - The first duration.
/// * [b] - The second duration.
///
/// ## Returns
///
/// The longer of the two durations.
///
/// ## Example
///
/// ```dart
/// final longer = maxDuration(
///   Duration(milliseconds: 100),
///   Duration(milliseconds: 200),
/// ); // Duration(milliseconds: 200)
/// ```
Duration maxDuration(Duration a, Duration b);
/// Returns the minimum of two [Duration] values.
///
/// ## Parameters
///
/// * [a] - The first duration.
/// * [b] - The second duration.
///
/// ## Returns
///
/// The shorter of the two durations.
///
/// ## Example
///
/// ```dart
/// final shorter = minDuration(
///   Duration(milliseconds: 100),
///   Duration(milliseconds: 200),
/// ); // Duration(milliseconds: 100)
/// ```
Duration minDuration(Duration a, Duration b);
/// Finds the maximum total duration among multiple timeline animations.
///
/// ## Parameters
///
/// * [timelines] - An iterable collection of [TimelineAnimation] instances.
///
/// ## Returns
///
/// The longest [totalDuration] found among all timelines, or [Duration.zero]
/// if the collection is empty.
///
/// ## Example
///
/// ```dart
/// final timelines = [
///   TimelineAnimation<double>(keyframes: [...]), // 300ms
///   TimelineAnimation<Color>(keyframes: [...]),   // 500ms
///   TimelineAnimation<Offset>(keyframes: [...]),  // 200ms
/// ];
///
/// final maxDur = timelineMaxDuration(timelines); // Duration(milliseconds: 500)
/// ```
Duration timelineMaxDuration(Iterable<TimelineAnimation> timelines);
/// Platform-specific implementations for shadcn_flutter.
///
/// This class provides a base interface for platform-specific functionality.
/// Platform-specific implementations should override these methods.
class ShadcnFlutterPlatformImplementations {
/// Called when the app is initialized.
///
/// Platform implementations can override this to perform initialization tasks.
  void onAppInitialized();
/// Called when the theme changes.
///
/// Platform implementations can override this to respond to theme changes.
/// The [theme] parameter contains the new theme data.
  void onThemeChanged(ThemeData theme);
}
/// The main application widget for shadcn_flutter.
///
/// ShadcnApp provides a Material-style app structure with shadcn theming.
/// It wraps the Flutter [WidgetsApp] and provides theme management,
/// navigation, and other app-level configurations.
class ShadcnApp extends StatefulWidget {
/// Creates a ShadcnApp with navigator-based routing.
///
/// This constructor is used for apps that use named routes and
/// a Navigator for navigation.
  const ShadcnApp({super.key, this.navigatorKey, this.home, this.routes = const {}, this.initialRoute, this.onGenerateRoute, this.onGenerateInitialRoutes, this.onUnknownRoute, this.onNavigationNotification, this.navigatorObservers = const [], this.builder, this.title = '', this.onGenerateTitle, this.color, this.background, this.theme = const ThemeData(), this.locale, this.localizationsDelegates, this.localeListResolutionCallback, this.localeResolutionCallback, this.supportedLocales = const [Locale('en', 'US')], this.debugShowMaterialGrid = false, this.showPerformanceOverlay = false, this.showSemanticsDebugger = false, this.debugShowCheckedModeBanner = true, this.shortcuts, this.actions, this.restorationScopeId, this.scrollBehavior, this.materialTheme, this.cupertinoTheme, this.scaling, this.disableBrowserContextMenu = true, this.initialRecentColors = const [], this.maxRecentColors = 10, this.onRecentColorsChanged, this.pixelSnap = true, this.enableScrollInterception = true, this.darkTheme, this.themeMode = ThemeMode.system, this.popoverHandler, this.tooltipHandler, this.menuHandler, this.enableThemeAnimation = true});
/// Creates a ShadcnApp with router-based routing.
///
/// This constructor is used for apps that use the Router API
/// for declarative navigation.
  const ShadcnApp.router({super.key, this.routeInformationProvider, this.routeInformationParser, this.routerDelegate, this.routerConfig, this.backButtonDispatcher, this.builder, this.title = '', this.onGenerateTitle, this.onNavigationNotification, this.color, this.background, this.theme = const ThemeData(), this.locale, this.localizationsDelegates, this.localeListResolutionCallback, this.localeResolutionCallback, this.supportedLocales = const [Locale('en', 'US')], this.debugShowMaterialGrid = false, this.showPerformanceOverlay = false, this.showSemanticsDebugger = false, this.debugShowCheckedModeBanner = true, this.shortcuts, this.actions, this.restorationScopeId, this.scrollBehavior, this.materialTheme, this.cupertinoTheme, this.scaling, this.disableBrowserContextMenu = true, this.initialRecentColors = const [], this.maxRecentColors = 50, this.onRecentColorsChanged, this.pixelSnap = true, this.enableScrollInterception = false, this.darkTheme, this.themeMode = ThemeMode.system, this.popoverHandler, this.tooltipHandler, this.menuHandler, this.enableThemeAnimation = true});
/// A key to use when building the [Navigator].
  GlobalKey<NavigatorState>? navigatorKey;
/// The scaling strategy for the app.
  AdaptiveScaling? scaling;
/// The widget for the default route of the app.
  Widget? home;
/// The application's top-level routing table.
  Map<String, WidgetBuilder>? routes;
/// The name of the first route to show.
  String? initialRoute;
/// The route generator callback used when the app is navigated to a named route.
  RouteFactory? onGenerateRoute;
/// The route generator callback used to generate initial routes.
  InitialRouteListFactory? onGenerateInitialRoutes;
/// Called when [onGenerateRoute] fails to generate a route.
  RouteFactory? onUnknownRoute;
/// Called when a navigation notification is dispatched.
  NotificationListenerCallback<NavigationNotification>? onNavigationNotification;
/// The list of observers for the [Navigator] created for this app.
  List<NavigatorObserver>? navigatorObservers;
/// The route information provider for router-based navigation.
  RouteInformationProvider? routeInformationProvider;
/// The route information parser for router-based navigation.
  RouteInformationParser<Object>? routeInformationParser;
/// The router delegate for router-based navigation.
  RouterDelegate<Object>? routerDelegate;
/// The back button dispatcher for router-based navigation.
  BackButtonDispatcher? backButtonDispatcher;
/// The router configuration for router-based navigation.
  RouterConfig<Object>? routerConfig;
/// A builder that wraps the app's content.
  TransitionBuilder? builder;
/// A one-line description used by the device to identify the app.
  String title;
/// A callback that produces the app title based on the context.
  GenerateAppTitle? onGenerateTitle;
/// The theme data for the app.
  ThemeData theme;
/// The dark theme data for the app.
  ThemeData? darkTheme;
/// Determines which theme will be used by the app.
  ThemeMode themeMode;
/// The primary color to use for the app's widgets.
  Color? color;
/// The background color for the app.
  Color? background;
/// The initial locale for this app's [Localizations] widget.
  Locale? locale;
/// The delegates for this app's [Localizations] widget.
  Iterable<LocalizationsDelegate<dynamic>>? localizationsDelegates;
/// Callback that receives the list of locales and returns the best match.
  LocaleListResolutionCallback? localeListResolutionCallback;
/// Callback that receives locale and supported locales and returns the best match.
  LocaleResolutionCallback? localeResolutionCallback;
/// The list of locales that this app has been localized for.
  Iterable<Locale> supportedLocales;
/// Whether to show the performance overlay.
  bool showPerformanceOverlay;
/// Whether to show the semantics debugger.
  bool showSemanticsDebugger;
/// Whether to show the debug banner.
  bool debugShowCheckedModeBanner;
/// The default map of shortcuts to intents for the application.
  Map<ShortcutActivator, Intent>? shortcuts;
/// The default map of intent types to actions for the application.
  Map<Type, Action<Intent>>? actions;
/// The identifier to use for state restoration of the app.
  String? restorationScopeId;
/// The scroll behavior for the app.
  ScrollBehavior? scrollBehavior;
/// Whether to show the Material grid in debug mode.
  bool debugShowMaterialGrid;
/// The Material theme to use for Material widgets.
  m.ThemeData? materialTheme;
/// The Cupertino theme to use for Cupertino widgets.
  c.CupertinoThemeData? cupertinoTheme;
/// Whether to disable the browser context menu.
  bool disableBrowserContextMenu;
/// The initial list of recent colors.
  List<Color> initialRecentColors;
/// The maximum number of recent colors to track.
  int maxRecentColors;
/// Called when the list of recent colors changes.
  ValueChanged<List<Color>>? onRecentColorsChanged;
/// Whether to snap widgets to physical pixels.
  bool pixelSnap;
/// Whether to enable scroll interception.
  bool enableScrollInterception;
/// The overlay handler for popovers.
  OverlayHandler? popoverHandler;
/// The overlay handler for tooltips.
  OverlayHandler? tooltipHandler;
/// The overlay handler for menus.
  OverlayHandler? menuHandler;
/// Whether to animate theme changes.
  bool enableThemeAnimation;
  State<ShadcnApp> createState();
}
/// Default scroll behavior for shadcn_flutter applications.
///
/// Provides bouncing physics and platform-appropriate scrollbars.
class ShadcnScrollBehavior extends ScrollBehavior {
/// Creates a shadcn scroll behavior.
  const ShadcnScrollBehavior();
  ScrollPhysics getScrollPhysics(BuildContext context);
  Widget buildScrollbar(BuildContext context, Widget child, ScrollableDetails details);
  Widget buildOverscrollIndicator(BuildContext context, Widget child, ScrollableDetails details);
}
/// A layer widget that provides shadcn theme and infrastructure.
///
/// This widget sets up the theming, overlay handlers, scroll behavior,
/// and other infrastructure needed for shadcn_flutter widgets to work correctly.
class ShadcnLayer extends StatelessWidget {
/// The child widget to wrap with shadcn infrastructure.
  Widget? child;
/// The light theme data.
  ThemeData theme;
/// The dark theme data.
  ThemeData? darkTheme;
/// Determines which theme to use.
  ThemeMode themeMode;
/// The scaling strategy for adaptive layouts.
  AdaptiveScaling? scaling;
/// The initial list of recent colors.
  List<Color> initialRecentColors;
/// The maximum number of recent colors to track.
  int maxRecentColors;
/// Called when the list of recent colors changes.
  ValueChanged<List<Color>>? onRecentColorsChanged;
/// A builder to wrap the child widget.
  Widget Function(BuildContext context, Widget? child)? builder;
/// Whether to enable scroll interception.
  bool enableScrollInterception;
/// The overlay handler for popovers.
  OverlayHandler? popoverHandler;
/// The overlay handler for tooltips.
  OverlayHandler? tooltipHandler;
/// The overlay handler for menus.
  OverlayHandler? menuHandler;
/// Whether to animate theme changes.
  bool enableThemeAnimation;
/// Creates a shadcn layer.
  const ShadcnLayer({super.key, required this.theme, this.scaling, this.child, this.initialRecentColors = const [], this.maxRecentColors = 50, this.onRecentColorsChanged, this.builder, this.enableScrollInterception = false, this.darkTheme, this.themeMode = ThemeMode.system, this.popoverHandler, this.tooltipHandler, this.menuHandler, this.enableThemeAnimation = true});
  Widget build(BuildContext context);
}
/// An animated theme widget for shadcn_flutter.
///
/// Animates theme changes over time with smooth transitions.
class ShadcnAnimatedTheme extends StatelessWidget {
/// The child widget to apply the theme to.
  Widget child;
/// The theme data to animate to.
  ThemeData data;
/// The duration of the animation.
  Duration duration;
/// The curve for the animation.
  Curve curve;
/// Called when the animation completes.
  VoidCallback? onEnd;
/// Creates an animated theme widget.
  const ShadcnAnimatedTheme({super.key, required this.data, required this.duration, this.curve = Curves.linear, this.onEnd, required this.child});
  Widget build(BuildContext context);
}
/// A custom tween for animating rectangles along an arc.
///
/// This tween creates more natural-looking animations for rectangles
/// by moving them along an arc path rather than a straight line.
class ShadcnRectArcTween extends RectTween {
/// Creates a rectangle arc tween.
  ShadcnRectArcTween({super.begin, super.end});
/// Gets the arc tween for the beginning point of the rectangle.
  ShadcnPointArcTween? get beginArc;
/// Gets the arc tween for the ending point of the rectangle.
  ShadcnPointArcTween? get endArc;
  set begin(Rect? value);
  set end(Rect? value);
  Rect lerp(double t);
}
/// A custom tween for animating points along an arc.
///
/// This tween creates curved motion between two points, useful for
/// creating natural-looking animations.
class ShadcnPointArcTween extends Tween<Offset> {
/// Creates a point arc tween.
  ShadcnPointArcTween({super.begin, super.end});
/// Gets the center point of the arc between [begin] and [end].
///
/// Returns `null` if either [begin] or [end] is null.
///
/// The center is computed lazily and cached for performance.
  Offset? get center;
/// Gets the radius of the arc between [begin] and [end].
///
/// Returns `null` if either [begin] or [end] is null.
///
/// The radius is the distance from the center to either endpoint.
  double? get radius;
/// Gets the starting angle of the arc in radians.
///
/// Returns `null` if either [begin] or [end] is null.
///
/// Angle is measured clockwise from the positive x-axis.
  double? get beginAngle;
/// Gets the ending angle of the arc in radians.
///
/// Returns `null` if either [begin] or [end] is null.
///
/// Angle is measured clockwise from the positive x-axis.
  double? get endAngle;
  set begin(Offset? value);
  set end(Offset? value);
  Offset lerp(double t);
}
/// A widget that provides text and icon styling for shadcn UI components.
///
/// Applies consistent text styles and icon themes to its descendants.
class ShadcnUI extends StatelessWidget {
/// Optional text style override.
  TextStyle? textStyle;
/// The child widget.
  Widget child;
/// Creates a ShadcnUI widget.
  const ShadcnUI({super.key, this.textStyle, required this.child});
  Widget build(BuildContext context);
}
/// Data about the current pointer position.
///
/// Used to track mouse/pointer location in the app.
class PointerData {
/// The current position of the pointer.
  Offset position;
/// Creates pointer data with the given position.
  PointerData({required this.position});
  bool operator ==(Object other);
  int get hashCode;
  String toString();
}
/// A collection of Radix Icons for Flutter applications.
///
/// This class provides access to all icons from the Radix Icons library.
/// All icons are defined as static constants of type [IconData].
class RadixIcons {
/// Zoom out icon from Radix Icons.
  static IconData zoomOut;
/// Zoom in icon from Radix Icons.
  static IconData zoomIn;
/// Width icon from Radix Icons.
  static IconData width;
/// View vertical icon from Radix Icons.
  static IconData viewVertical;
/// View none icon from Radix Icons.
  static IconData viewNone;
/// View horizontal icon from Radix Icons.
  static IconData viewHorizontal;
/// View grid icon from Radix Icons.
  static IconData viewGrid;
/// Video icon from Radix Icons.
  static IconData video;
/// Vercel logo icon from Radix Icons.
  static IconData vercelLogo;
/// Value icon from Radix Icons.
  static IconData value;
/// Value none icon from Radix Icons.
  static IconData valueNone;
/// Upload icon from Radix Icons.
  static IconData upload;
/// Update icon from Radix Icons.
  static IconData update;
/// Underline icon from Radix Icons.
  static IconData underline;
/// Twitter logo icon from Radix Icons.
  static IconData twitterLogo;
/// Triangle up icon from Radix Icons.
  static IconData triangleUp;
/// Triangle right icon from Radix Icons.
  static IconData triangleRight;
/// Triangle left icon from Radix Icons.
  static IconData triangleLeft;
/// Triangle down icon from Radix Icons.
  static IconData triangleDown;
/// Trash icon from Radix Icons.
  static IconData trash;
/// Transparency grid icon from Radix Icons.
  static IconData transparencyGrid;
/// Transform icon from Radix Icons.
  static IconData transform;
/// Track previous icon from Radix Icons.
  static IconData trackPrevious;
/// Track next icon from Radix Icons.
  static IconData trackNext;
/// Tokens icon from Radix Icons.
  static IconData tokens;
/// Timer icon from Radix Icons.
  static IconData timer;
/// Thick arrow up icon from Radix Icons.
  static IconData thickArrowUp;
/// Thick arrow right icon from Radix Icons.
  static IconData thickArrowRight;
/// Thick arrow left icon from Radix Icons.
  static IconData thickArrowLeft;
/// Thick arrow down icon from Radix Icons.
  static IconData thickArrowDown;
/// Text icon from Radix Icons.
  static IconData text;
/// Text none icon from Radix Icons.
  static IconData textNone;
/// Text align top icon from Radix Icons.
  static IconData textAlignTop;
/// Text align right icon from Radix Icons.
  static IconData textAlignRight;
/// Text align middle icon from Radix Icons.
  static IconData textAlignMiddle;
/// Text align left icon from Radix Icons.
  static IconData textAlignLeft;
/// Text align justify icon from Radix Icons.
  static IconData textAlignJustify;
/// Text align center icon from Radix Icons.
  static IconData textAlignCenter;
/// Text align bottom icon from Radix Icons.
  static IconData textAlignBottom;
/// Target icon from Radix Icons.
  static IconData target;
/// Table icon from Radix Icons.
  static IconData table;
/// Symbol icon from Radix Icons.
  static IconData symbol;
/// Switch icon from Radix Icons.
  static IconData iconSwitch;
/// Sun icon from Radix Icons.
  static IconData sun;
/// Strikethrough icon from Radix Icons.
  static IconData strikethrough;
/// Stretch vertically icon from Radix Icons.
  static IconData stretchVertically;
/// Stretch horizontally icon from Radix Icons.
  static IconData stretchHorizontally;
/// Stopwatch icon from Radix Icons.
  static IconData stopwatch;
/// Stop icon from Radix Icons.
  static IconData stop;
/// Stitches logo icon from Radix Icons.
  static IconData stitchesLogo;
/// Star icon from Radix Icons.
  static IconData star;
/// Star filled icon from Radix Icons.
  static IconData starFilled;
/// Stack icon from Radix Icons.
  static IconData stack;
/// Square icon from Radix Icons.
  static IconData square;
/// Speaker quiet icon from Radix Icons.
  static IconData speakerQuiet;
/// Speaker off icon from Radix Icons.
  static IconData speakerOff;
/// Speaker moderate icon from Radix Icons.
  static IconData speakerModerate;
/// Speaker loud icon from Radix Icons.
  static IconData speakerLoud;
/// Space evenly vertically icon from Radix Icons.
  static IconData spaceEvenlyVertically;
/// Space evenly horizontally icon from Radix Icons.
  static IconData spaceEvenlyHorizontally;
/// Space between vertically icon from Radix Icons.
  static IconData spaceBetweenVertically;
/// Space between horizontally icon from Radix Icons.
  static IconData spaceBetweenHorizontally;
/// Slider icon from Radix Icons.
  static IconData slider;
/// Slash icon from Radix Icons.
  static IconData slash;
/// Sketch logo icon from Radix Icons.
  static IconData sketchLogo;
/// Size icon from Radix Icons.
  static IconData size;
/// Shuffle icon from Radix Icons.
  static IconData shuffle;
/// Share2 icon from Radix Icons.
  static IconData share2;
/// Share1 icon from Radix Icons.
  static IconData share1;
/// Shadow icon from Radix Icons.
  static IconData shadow;
/// Shadow outer icon from Radix Icons.
  static IconData shadowOuter;
/// Shadow none icon from Radix Icons.
  static IconData shadowNone;
/// Shadow inner icon from Radix Icons.
  static IconData shadowInner;
/// Sewing pin icon from Radix Icons.
  static IconData sewingPin;
/// Sewing pin solid icon from Radix Icons.
  static IconData sewingPinSolid;
/// Sewing pin filled icon from Radix Icons.
  static IconData sewingPinFilled;
/// Section icon from Radix Icons.
  static IconData section;
/// Scissors icon from Radix Icons.
  static IconData scissors;
/// Ruler square icon from Radix Icons.
  static IconData rulerSquare;
/// Ruler horizontal icon from Radix Icons.
  static IconData rulerHorizontal;
/// Rows icon from Radix Icons.
  static IconData rows;
/// Row spacing icon from Radix Icons.
  static IconData rowSpacing;
/// Rotate counter clockwise icon from Radix Icons.
  static IconData rotateCounterClockwise;
/// Rocket icon from Radix Icons.
  static IconData rocket;
/// Resume icon from Radix Icons.
  static IconData resume;
/// Reset icon from Radix Icons.
  static IconData reset;
/// Reload icon from Radix Icons.
  static IconData reload;
/// Reader icon from Radix Icons.
  static IconData reader;
/// Radiobutton icon from Radix Icons.
  static IconData radiobutton;
/// Quote icon from Radix Icons.
  static IconData quote;
/// Question mark icon from Radix Icons.
  static IconData questionMark;
/// Question mark circled icon from Radix Icons.
  static IconData questionMarkCircled;
/// Plus icon from Radix Icons.
  static IconData plus;
/// Plus circled icon from Radix Icons.
  static IconData plusCircled;
/// Play icon from Radix Icons.
  static IconData play;
/// Pin top icon from Radix Icons.
  static IconData pinTop;
/// Pin right icon from Radix Icons.
  static IconData pinRight;
/// Pin left icon from Radix Icons.
  static IconData pinLeft;
/// Pin bottom icon from Radix Icons.
  static IconData pinBottom;
/// Pilcrow icon from Radix Icons.
  static IconData pilcrow;
/// Pie chart icon from Radix Icons.
  static IconData pieChart;
/// Person icon from Radix Icons.
  static IconData person;
/// Pencil2 icon from Radix Icons.
  static IconData pencil2;
/// Pencil1 icon from Radix Icons.
  static IconData pencil1;
/// Pause icon from Radix Icons.
  static IconData pause;
/// Paper plane icon from Radix Icons.
  static IconData paperPlane;
/// Padding icon from Radix Icons.
  static IconData padding;
/// Overline icon from Radix Icons.
  static IconData overline;
/// Outer shadow icon from Radix Icons.
  static IconData outerShadow;
/// Open in new window icon from Radix Icons.
  static IconData openInNewWindow;
/// Opacity icon from Radix Icons.
  static IconData opacity;
/// Notion logo icon from Radix Icons.
  static IconData notionLogo;
/// Move icon from Radix Icons.
  static IconData move;
/// Moon icon from Radix Icons.
  static IconData moon;
/// Modulz logo icon from Radix Icons.
  static IconData modulzLogo;
/// Mobile icon from Radix Icons.
  static IconData mobile;
/// Mixer vertical icon from Radix Icons.
  static IconData mixerVertical;
/// Mixer horizontal icon from Radix Icons.
  static IconData mixerHorizontal;
/// Mix icon from Radix Icons.
  static IconData mix;
/// Minus icon from Radix Icons.
  static IconData minus;
/// Minus circled icon from Radix Icons.
  static IconData minusCircled;
/// Mask on icon from Radix Icons.
  static IconData maskOn;
/// Mask off icon from Radix Icons.
  static IconData maskOff;
/// Margin icon from Radix Icons.
  static IconData margin;
/// Magnifying glass icon from Radix Icons.
  static IconData magnifyingGlass;
/// Magic wand icon from Radix Icons.
  static IconData magicWand;
/// Loop icon from Radix Icons.
  static IconData loop;
/// Lock open2 icon from Radix Icons.
  static IconData lockOpen2;
/// Lock open1 icon from Radix Icons.
  static IconData lockOpen1;
/// Lock closed icon from Radix Icons.
  static IconData lockClosed;
/// List bullet icon from Radix Icons.
  static IconData listBullet;
/// Linkedin logo icon from Radix Icons.
  static IconData linkedinLogo;
/// Link none2 icon from Radix Icons.
  static IconData linkNone2;
/// Link none1 icon from Radix Icons.
  static IconData linkNone1;
/// Link break2 icon from Radix Icons.
  static IconData linkBreak2;
/// Link break1 icon from Radix Icons.
  static IconData linkBreak1;
/// Link2 icon from Radix Icons.
  static IconData link2;
/// Link1 icon from Radix Icons.
  static IconData link1;
/// Line height icon from Radix Icons.
  static IconData lineHeight;
/// Lightning bolt icon from Radix Icons.
  static IconData lightningBolt;
/// Letter spacing icon from Radix Icons.
  static IconData letterSpacing;
/// Letter case uppercase icon from Radix Icons.
  static IconData letterCaseUppercase;
/// Letter case toggle icon from Radix Icons.
  static IconData letterCaseToggle;
/// Letter case lowercase icon from Radix Icons.
  static IconData letterCaseLowercase;
/// Letter case capitalize icon from Radix Icons.
  static IconData letterCaseCapitalize;
/// Layout icon from Radix Icons.
  static IconData layout;
/// Layers icon from Radix Icons.
  static IconData layers;
/// Laptop icon from Radix Icons.
  static IconData laptop;
/// Lap timer icon from Radix Icons.
  static IconData lapTimer;
/// Keyboard icon from Radix Icons.
  static IconData keyboard;
/// Justify stretch icon from Radix Icons.
  static IconData justifyStretch;
/// Justify start icon from Radix Icons.
  static IconData justifyStart;
/// Justify end icon from Radix Icons.
  static IconData justifyEnd;
/// Justify center icon from Radix Icons.
  static IconData justifyCenter;
/// Instagram logo icon from Radix Icons.
  static IconData instagramLogo;
/// Input icon from Radix Icons.
  static IconData input;
/// Inner shadow icon from Radix Icons.
  static IconData innerShadow;
/// Info circled icon from Radix Icons.
  static IconData infoCircled;
/// Image icon from Radix Icons.
  static IconData image;
/// Id card icon from Radix Icons.
  static IconData idCard;
/// Iconjar logo icon from Radix Icons.
  static IconData iconjarLogo;
/// Home icon from Radix Icons.
  static IconData home;
/// Hobby knife icon from Radix Icons.
  static IconData hobbyKnife;
/// Height icon from Radix Icons.
  static IconData height;
/// Heart icon from Radix Icons.
  static IconData heart;
/// Heart filled icon from Radix Icons.
  static IconData heartFilled;
/// Heading icon from Radix Icons.
  static IconData heading;
/// Hand icon from Radix Icons.
  static IconData hand;
/// Hamburger menu icon from Radix Icons.
  static IconData hamburgerMenu;
/// Half2 icon from Radix Icons.
  static IconData half2;
/// Half1 icon from Radix Icons.
  static IconData half1;
/// Group icon from Radix Icons.
  static IconData group;
/// Grid icon from Radix Icons.
  static IconData grid;
/// Globe icon from Radix Icons.
  static IconData globe;
/// Github logo icon from Radix Icons.
  static IconData githubLogo;
/// Gear icon from Radix Icons.
  static IconData gear;
/// Framer logo icon from Radix Icons.
  static IconData framerLogo;
/// Frame icon from Radix Icons.
  static IconData frame;
/// Font style icon from Radix Icons.
  static IconData fontStyle;
/// Font size icon from Radix Icons.
  static IconData fontSize;
/// Font roman icon from Radix Icons.
  static IconData fontRoman;
/// Font italic icon from Radix Icons.
  static IconData fontItalic;
/// Font family icon from Radix Icons.
  static IconData fontFamily;
/// Font bold icon from Radix Icons.
  static IconData fontBold;
/// File icon from Radix Icons.
  static IconData file;
/// File text icon from Radix Icons.
  static IconData fileText;
/// File plus icon from Radix Icons.
  static IconData filePlus;
/// File minus icon from Radix Icons.
  static IconData fileMinus;
/// Figma logo icon from Radix Icons.
  static IconData figmaLogo;
/// Face icon from Radix Icons.
  static IconData face;
/// Eye open icon from Radix Icons.
  static IconData eyeOpen;
/// Eye none icon from Radix Icons.
  static IconData eyeNone;
/// Eye closed icon from Radix Icons.
  static IconData eyeClosed;
/// External link icon from Radix Icons.
  static IconData externalLink;
/// Exit icon from Radix Icons.
  static IconData exit;
/// Exit full screen icon from Radix Icons.
  static IconData exitFullScreen;
/// Exclamation triangle icon from Radix Icons.
  static IconData exclamationTriangle;
/// Eraser icon from Radix Icons.
  static IconData eraser;
/// Envelope open icon from Radix Icons.
  static IconData envelopeOpen;
/// Envelope closed icon from Radix Icons.
  static IconData envelopeClosed;
/// Enter icon from Radix Icons.
  static IconData enter;
/// Enter full screen icon from Radix Icons.
  static IconData enterFullScreen;
/// Dropdown menu icon from Radix Icons.
  static IconData dropdownMenu;
/// Drawing pin icon from Radix Icons.
  static IconData drawingPin;
/// Drawing pin solid icon from Radix Icons.
  static IconData drawingPinSolid;
/// Drawing pin filled icon from Radix Icons.
  static IconData drawingPinFilled;
/// Drag handle vertical icon from Radix Icons.
  static IconData dragHandleVertical;
/// Drag handle horizontal icon from Radix Icons.
  static IconData dragHandleHorizontal;
/// Drag handle dots2 icon from Radix Icons.
  static IconData dragHandleDots2;
/// Drag handle dots1 icon from Radix Icons.
  static IconData dragHandleDots1;
/// Download icon from Radix Icons.
  static IconData download;
/// Double arrow up icon from Radix Icons.
  static IconData doubleArrowUp;
/// Double arrow right icon from Radix Icons.
  static IconData doubleArrowRight;
/// Double arrow left icon from Radix Icons.
  static IconData doubleArrowLeft;
/// Double arrow down icon from Radix Icons.
  static IconData doubleArrowDown;
/// Dots vertical icon from Radix Icons.
  static IconData dotsVertical;
/// Dots horizontal icon from Radix Icons.
  static IconData dotsHorizontal;
/// Dot icon from Radix Icons.
  static IconData dot;
/// Dot solid icon from Radix Icons.
  static IconData dotSolid;
/// Dot filled icon from Radix Icons.
  static IconData dotFilled;
/// Divider vertical icon from Radix Icons.
  static IconData dividerVertical;
/// Divider horizontal icon from Radix Icons.
  static IconData dividerHorizontal;
/// Discord logo icon from Radix Icons.
  static IconData discordLogo;
/// Disc icon from Radix Icons.
  static IconData disc;
/// Dimensions icon from Radix Icons.
  static IconData dimensions;
/// Desktop icon from Radix Icons.
  static IconData desktop;
/// Dashboard icon from Radix Icons.
  static IconData dashboard;
/// Dash icon from Radix Icons.
  static IconData dash;
/// Cursor text icon from Radix Icons.
  static IconData cursorText;
/// Cursor arrow icon from Radix Icons.
  static IconData cursorArrow;
/// Cube icon from Radix Icons.
  static IconData cube;
/// Crumpled paper icon from Radix Icons.
  static IconData crumpledPaper;
/// Crosshair2 icon from Radix Icons.
  static IconData crosshair2;
/// Crosshair1 icon from Radix Icons.
  static IconData crosshair1;
/// Cross circled icon from Radix Icons.
  static IconData crossCircled;
/// Cross2 icon from Radix Icons.
  static IconData cross2;
/// Cross1 icon from Radix Icons.
  static IconData cross1;
/// Crop icon from Radix Icons.
  static IconData crop;
/// Counter clockwise clock icon from Radix Icons.
  static IconData counterClockwiseClock;
/// Countdown timer icon from Radix Icons.
  static IconData countdownTimer;
/// Corners icon from Radix Icons.
  static IconData corners;
/// Corner top right icon from Radix Icons.
  static IconData cornerTopRight;
/// Corner top left icon from Radix Icons.
  static IconData cornerTopLeft;
/// Corner bottom right icon from Radix Icons.
  static IconData cornerBottomRight;
/// Corner bottom left icon from Radix Icons.
  static IconData cornerBottomLeft;
/// Copy icon from Radix Icons.
  static IconData copy;
/// Cookie icon from Radix Icons.
  static IconData cookie;
/// Container icon from Radix Icons.
  static IconData container;
/// Component placeholder icon from Radix Icons.
  static IconData componentPlaceholder;
/// Component none icon from Radix Icons.
  static IconData componentNone;
/// Component instance icon from Radix Icons.
  static IconData componentInstance;
/// Component boolean icon from Radix Icons.
  static IconData componentBoolean;
/// Component2 icon from Radix Icons.
  static IconData component2;
/// Component1 icon from Radix Icons.
  static IconData component1;
/// Commit icon from Radix Icons.
  static IconData commit;
/// Columns icon from Radix Icons.
  static IconData columns;
/// Column spacing icon from Radix Icons.
  static IconData columnSpacing;
/// Color wheel icon from Radix Icons.
  static IconData colorWheel;
/// Codesandbox logo icon from Radix Icons.
  static IconData codesandboxLogo;
/// Code icon from Radix Icons.
  static IconData code;
/// Clock icon from Radix Icons.
  static IconData clock;
/// Clipboard icon from Radix Icons.
  static IconData clipboard;
/// Clipboard copy icon from Radix Icons.
  static IconData clipboardCopy;
/// Circle icon from Radix Icons.
  static IconData circle;
/// Circle backslash icon from Radix Icons.
  static IconData circleBackslash;
/// Chevron up icon from Radix Icons.
  static IconData chevronUp;
/// Chevron right icon from Radix Icons.
  static IconData chevronRight;
/// Chevron left icon from Radix Icons.
  static IconData chevronLeft;
/// Chevron down icon from Radix Icons.
  static IconData chevronDown;
/// Checkbox icon from Radix Icons.
  static IconData checkbox;
/// Check icon from Radix Icons.
  static IconData check;
/// Check circled icon from Radix Icons.
  static IconData checkCircled;
/// Chat bubble icon from Radix Icons.
  static IconData chatBubble;
/// Caret up icon from Radix Icons.
  static IconData caretUp;
/// Caret sort icon from Radix Icons.
  static IconData caretSort;
/// Caret right icon from Radix Icons.
  static IconData caretRight;
/// Caret left icon from Radix Icons.
  static IconData caretLeft;
/// Caret down icon from Radix Icons.
  static IconData caretDown;
/// Card stack icon from Radix Icons.
  static IconData cardStack;
/// Card stack plus icon from Radix Icons.
  static IconData cardStackPlus;
/// Card stack minus icon from Radix Icons.
  static IconData cardStackMinus;
/// Camera icon from Radix Icons.
  static IconData camera;
/// Calendar icon from Radix Icons.
  static IconData calendar;
/// Button icon from Radix Icons.
  static IconData button;
/// Box icon from Radix Icons.
  static IconData box;
/// Box model icon from Radix Icons.
  static IconData boxModel;
/// Border width icon from Radix Icons.
  static IconData borderWidth;
/// Border top icon from Radix Icons.
  static IconData borderTop;
/// Border style icon from Radix Icons.
  static IconData borderStyle;
/// Border split icon from Radix Icons.
  static IconData borderSplit;
/// Border solid icon from Radix Icons.
  static IconData borderSolid;
/// Border right icon from Radix Icons.
  static IconData borderRight;
/// Border none icon from Radix Icons.
  static IconData borderNone;
/// Border left icon from Radix Icons.
  static IconData borderLeft;
/// Border dotted icon from Radix Icons.
  static IconData borderDotted;
/// Border dashed icon from Radix Icons.
  static IconData borderDashed;
/// Border bottom icon from Radix Icons.
  static IconData borderBottom;
/// Border all icon from Radix Icons.
  static IconData borderAll;
/// Bookmark icon from Radix Icons.
  static IconData bookmark;
/// Bookmark filled icon from Radix Icons.
  static IconData bookmarkFilled;
/// Blending mode icon from Radix Icons.
  static IconData blendingMode;
/// Bell icon from Radix Icons.
  static IconData bell;
/// Bar chart icon from Radix Icons.
  static IconData barChart;
/// Badge icon from Radix Icons.
  static IconData badge;
/// Backpack icon from Radix Icons.
  static IconData backpack;
/// Avatar icon from Radix Icons.
  static IconData avatar;
/// Aspect ratio icon from Radix Icons.
  static IconData aspectRatio;
/// Arrow up icon from Radix Icons.
  static IconData arrowUp;
/// Arrow top right icon from Radix Icons.
  static IconData arrowTopRight;
/// Arrow top left icon from Radix Icons.
  static IconData arrowTopLeft;
/// Arrow right icon from Radix Icons.
  static IconData arrowRight;
/// Arrow left icon from Radix Icons.
  static IconData arrowLeft;
/// Arrow down icon from Radix Icons.
  static IconData arrowDown;
/// Arrow bottom right icon from Radix Icons.
  static IconData arrowBottomRight;
/// Arrow bottom left icon from Radix Icons.
  static IconData arrowBottomLeft;
/// Archive icon from Radix Icons.
  static IconData archive;
/// Angle icon from Radix Icons.
  static IconData angle;
/// All sides icon from Radix Icons.
  static IconData allSides;
/// Align vertical centers icon from Radix Icons.
  static IconData alignVerticalCenters;
/// Align top icon from Radix Icons.
  static IconData alignTop;
/// Align stretch icon from Radix Icons.
  static IconData alignStretch;
/// Align start icon from Radix Icons.
  static IconData alignStart;
/// Align right icon from Radix Icons.
  static IconData alignRight;
/// Align left icon from Radix Icons.
  static IconData alignLeft;
/// Align horizontal centers icon from Radix Icons.
  static IconData alignHorizontalCenters;
/// Align end icon from Radix Icons.
  static IconData alignEnd;
/// Align center icon from Radix Icons.
  static IconData alignCenter;
/// Align center vertically icon from Radix Icons.
  static IconData alignCenterVertically;
/// Align center horizontally icon from Radix Icons.
  static IconData alignCenterHorizontally;
/// Align bottom icon from Radix Icons.
  static IconData alignBottom;
/// Align baseline icon from Radix Icons.
  static IconData alignBaseline;
/// Activity log icon from Radix Icons.
  static IconData activityLog;
/// Accessibility icon from Radix Icons.
  static IconData accessibility;
}
/// A collection of Lucide icons as Flutter IconData constants.
///
/// Lucide is an open-source icon library that provides a wide range of
/// carefully crafted icons for use in Flutter applications.
///
/// Each icon is available as a static constant `IconData` that can be used
/// directly with Flutter's `Icon` widget.
///
/// Example:
/// ```dart
/// Icon(
///   LucideIcons.heart,
///   size: 24,
///   color: Colors.red,
/// )
/// ```
class LucideIcons {
/// Lucide icon for 'A arrow down'.
  static IconData aArrowDown;
/// Lucide icon for 'A arrow up'.
  static IconData aArrowUp;
/// Lucide icon for 'A large small'.
  static IconData aLargeSmall;
/// Lucide icon for 'accessibility'.
  static IconData accessibility;
/// Lucide icon for 'activity'.
  static IconData activity;
/// Lucide icon for 'air vent'.
  static IconData airVent;
/// Lucide icon for 'airplay'.
  static IconData airplay;
/// Lucide icon for 'alarm clock check'.
  static IconData alarmClockCheck;
/// Lucide icon for 'alarm clock minus'.
  static IconData alarmClockMinus;
/// Lucide icon for 'alarm clock off'.
  static IconData alarmClockOff;
/// Lucide icon for 'alarm clock plus'.
  static IconData alarmClockPlus;
/// Lucide icon for 'alarm clock'.
  static IconData alarmClock;
/// Lucide icon for 'alarm smoke'.
  static IconData alarmSmoke;
/// Lucide icon for 'album'.
  static IconData album;
/// Lucide icon for 'align center horizontal'.
  static IconData alignCenterHorizontal;
/// Lucide icon for 'align center vertical'.
  static IconData alignCenterVertical;
/// Lucide icon for 'align center'.
  static IconData alignCenter;
/// Lucide icon for 'align end horizontal'.
  static IconData alignEndHorizontal;
/// Lucide icon for 'align end vertical'.
  static IconData alignEndVertical;
/// Lucide icon for 'align horizontal distribute center'.
  static IconData alignHorizontalDistributeCenter;
/// Lucide icon for 'align horizontal distribute end'.
  static IconData alignHorizontalDistributeEnd;
/// Lucide icon for 'align horizontal distribute start'.
  static IconData alignHorizontalDistributeStart;
/// Lucide icon for 'align horizontal justify center'.
  static IconData alignHorizontalJustifyCenter;
/// Lucide icon for 'align horizontal justify end'.
  static IconData alignHorizontalJustifyEnd;
/// Lucide icon for 'align horizontal justify start'.
  static IconData alignHorizontalJustifyStart;
/// Lucide icon for 'align horizontal space around'.
  static IconData alignHorizontalSpaceAround;
/// Lucide icon for 'align horizontal space between'.
  static IconData alignHorizontalSpaceBetween;
/// Lucide icon for 'align justify'.
  static IconData alignJustify;
/// Lucide icon for 'align left'.
  static IconData alignLeft;
/// Lucide icon for 'align right'.
  static IconData alignRight;
/// Lucide icon for 'align start horizontal'.
  static IconData alignStartHorizontal;
/// Lucide icon for 'align start vertical'.
  static IconData alignStartVertical;
/// Lucide icon for 'align vertical distribute center'.
  static IconData alignVerticalDistributeCenter;
/// Lucide icon for 'align vertical distribute end'.
  static IconData alignVerticalDistributeEnd;
/// Lucide icon for 'align vertical distribute start'.
  static IconData alignVerticalDistributeStart;
/// Lucide icon for 'align vertical justify center'.
  static IconData alignVerticalJustifyCenter;
/// Lucide icon for 'align vertical justify end'.
  static IconData alignVerticalJustifyEnd;
/// Lucide icon for 'align vertical justify start'.
  static IconData alignVerticalJustifyStart;
/// Lucide icon for 'align vertical space around'.
  static IconData alignVerticalSpaceAround;
/// Lucide icon for 'align vertical space between'.
  static IconData alignVerticalSpaceBetween;
/// Lucide icon for 'ambulance'.
  static IconData ambulance;
/// Lucide icon for 'ampersand'.
  static IconData ampersand;
/// Lucide icon for 'ampersands'.
  static IconData ampersands;
/// Lucide icon for 'amphora'.
  static IconData amphora;
/// Lucide icon for 'anchor'.
  static IconData anchor;
/// Lucide icon for 'angry'.
  static IconData angry;
/// Lucide icon for 'annoyed'.
  static IconData annoyed;
/// Lucide icon for 'antenna'.
  static IconData antenna;
/// Lucide icon for 'anvil'.
  static IconData anvil;
/// Lucide icon for 'aperture'.
  static IconData aperture;
/// Lucide icon for 'app window mac'.
  static IconData appWindowMac;
/// Lucide icon for 'app window'.
  static IconData appWindow;
/// Lucide icon for 'apple'.
  static IconData apple;
/// Lucide icon for 'archive restore'.
  static IconData archiveRestore;
/// Lucide icon for 'archive X'.
  static IconData archiveX;
/// Lucide icon for 'archive'.
  static IconData archive;
/// Lucide icon for 'armchair'.
  static IconData armchair;
/// Lucide icon for 'arrow big down dash'.
  static IconData arrowBigDownDash;
/// Lucide icon for 'arrow big down'.
  static IconData arrowBigDown;
/// Lucide icon for 'arrow big left dash'.
  static IconData arrowBigLeftDash;
/// Lucide icon for 'arrow big left'.
  static IconData arrowBigLeft;
/// Lucide icon for 'arrow big right dash'.
  static IconData arrowBigRightDash;
/// Lucide icon for 'arrow big right'.
  static IconData arrowBigRight;
/// Lucide icon for 'arrow big up dash'.
  static IconData arrowBigUpDash;
/// Lucide icon for 'arrow big up'.
  static IconData arrowBigUp;
/// Lucide icon for 'arrow down 01'.
  static IconData arrowDown01;
/// Lucide icon for 'arrow down 10'.
  static IconData arrowDown10;
/// Lucide icon for 'arrow down A Z'.
  static IconData arrowDownAZ;
/// Lucide icon for 'arrow down from line'.
  static IconData arrowDownFromLine;
/// Lucide icon for 'arrow down left'.
  static IconData arrowDownLeft;
/// Lucide icon for 'arrow down narrow wide'.
  static IconData arrowDownNarrowWide;
/// Lucide icon for 'arrow down right'.
  static IconData arrowDownRight;
/// Lucide icon for 'arrow down to dot'.
  static IconData arrowDownToDot;
/// Lucide icon for 'arrow down to line'.
  static IconData arrowDownToLine;
/// Lucide icon for 'arrow down up'.
  static IconData arrowDownUp;
/// Lucide icon for 'arrow down wide narrow'.
  static IconData arrowDownWideNarrow;
/// Lucide icon for 'arrow down Z A'.
  static IconData arrowDownZA;
/// Lucide icon for 'arrow down'.
  static IconData arrowDown;
/// Lucide icon for 'arrow left from line'.
  static IconData arrowLeftFromLine;
/// Lucide icon for 'arrow left right'.
  static IconData arrowLeftRight;
/// Lucide icon for 'arrow left to line'.
  static IconData arrowLeftToLine;
/// Lucide icon for 'arrow left'.
  static IconData arrowLeft;
/// Lucide icon for 'arrow right from line'.
  static IconData arrowRightFromLine;
/// Lucide icon for 'arrow right left'.
  static IconData arrowRightLeft;
/// Lucide icon for 'arrow right to line'.
  static IconData arrowRightToLine;
/// Lucide icon for 'arrow right'.
  static IconData arrowRight;
/// Lucide icon for 'arrow up 01'.
  static IconData arrowUp01;
/// Lucide icon for 'arrow up 10'.
  static IconData arrowUp10;
/// Lucide icon for 'arrow up A Z'.
  static IconData arrowUpAZ;
/// Lucide icon for 'arrow up down'.
  static IconData arrowUpDown;
/// Lucide icon for 'arrow up from dot'.
  static IconData arrowUpFromDot;
/// Lucide icon for 'arrow up from line'.
  static IconData arrowUpFromLine;
/// Lucide icon for 'arrow up left'.
  static IconData arrowUpLeft;
/// Lucide icon for 'arrow up narrow wide'.
  static IconData arrowUpNarrowWide;
/// Lucide icon for 'arrow up right'.
  static IconData arrowUpRight;
/// Lucide icon for 'arrow up to line'.
  static IconData arrowUpToLine;
/// Lucide icon for 'arrow up wide narrow'.
  static IconData arrowUpWideNarrow;
/// Lucide icon for 'arrow up Z A'.
  static IconData arrowUpZA;
/// Lucide icon for 'arrow up'.
  static IconData arrowUp;
/// Lucide icon for 'arrows up from line'.
  static IconData arrowsUpFromLine;
/// Lucide icon for 'asterisk'.
  static IconData asterisk;
/// Lucide icon for 'at sign'.
  static IconData atSign;
/// Lucide icon for 'atom'.
  static IconData atom;
/// Lucide icon for 'audio lines'.
  static IconData audioLines;
/// Lucide icon for 'audio waveform'.
  static IconData audioWaveform;
/// Lucide icon for 'award'.
  static IconData award;
/// Lucide icon for 'axe'.
  static IconData axe;
/// Lucide icon for 'axis 3d'.
  static IconData axis3d;
/// Lucide icon for 'baby'.
  static IconData baby;
/// Lucide icon for 'backpack'.
  static IconData backpack;
/// Lucide icon for 'badge alert'.
  static IconData badgeAlert;
/// Lucide icon for 'badge cent'.
  static IconData badgeCent;
/// Lucide icon for 'badge check'.
  static IconData badgeCheck;
/// Lucide icon for 'badge dollar sign'.
  static IconData badgeDollarSign;
/// Lucide icon for 'badge euro'.
  static IconData badgeEuro;
/// Lucide icon for 'badge help'.
  static IconData badgeHelp;
/// Lucide icon for 'badge indian rupee'.
  static IconData badgeIndianRupee;
/// Lucide icon for 'badge info'.
  static IconData badgeInfo;
/// Lucide icon for 'badge japanese yen'.
  static IconData badgeJapaneseYen;
/// Lucide icon for 'badge minus'.
  static IconData badgeMinus;
/// Lucide icon for 'badge percent'.
  static IconData badgePercent;
/// Lucide icon for 'badge plus'.
  static IconData badgePlus;
/// Lucide icon for 'badge pound sterling'.
  static IconData badgePoundSterling;
/// Lucide icon for 'badge russian ruble'.
  static IconData badgeRussianRuble;
/// Lucide icon for 'badge swiss franc'.
  static IconData badgeSwissFranc;
/// Lucide icon for 'badge X'.
  static IconData badgeX;
/// Lucide icon for 'badge'.
  static IconData badge;
/// Lucide icon for 'baggage claim'.
  static IconData baggageClaim;
/// Lucide icon for 'ban'.
  static IconData ban;
/// Lucide icon for 'banana'.
  static IconData banana;
/// Lucide icon for 'bandage'.
  static IconData bandage;
/// Lucide icon for 'banknote'.
  static IconData banknote;
/// Lucide icon for 'barcode'.
  static IconData barcode;
/// Lucide icon for 'baseline'.
  static IconData baseline;
/// Lucide icon for 'bath'.
  static IconData bath;
/// Lucide icon for 'battery charging'.
  static IconData batteryCharging;
/// Lucide icon for 'battery full'.
  static IconData batteryFull;
/// Lucide icon for 'battery low'.
  static IconData batteryLow;
/// Lucide icon for 'battery medium'.
  static IconData batteryMedium;
/// Lucide icon for 'battery plus'.
  static IconData batteryPlus;
/// Lucide icon for 'battery warning'.
  static IconData batteryWarning;
/// Lucide icon for 'battery'.
  static IconData battery;
/// Lucide icon for 'beaker'.
  static IconData beaker;
/// Lucide icon for 'bean off'.
  static IconData beanOff;
/// Lucide icon for 'bean'.
  static IconData bean;
/// Lucide icon for 'bed double'.
  static IconData bedDouble;
/// Lucide icon for 'bed single'.
  static IconData bedSingle;
/// Lucide icon for 'bed'.
  static IconData bed;
/// Lucide icon for 'beef'.
  static IconData beef;
/// Lucide icon for 'beer off'.
  static IconData beerOff;
/// Lucide icon for 'beer'.
  static IconData beer;
/// Lucide icon for 'bell dot'.
  static IconData bellDot;
/// Lucide icon for 'bell electric'.
  static IconData bellElectric;
/// Lucide icon for 'bell minus'.
  static IconData bellMinus;
/// Lucide icon for 'bell off'.
  static IconData bellOff;
/// Lucide icon for 'bell plus'.
  static IconData bellPlus;
/// Lucide icon for 'bell ring'.
  static IconData bellRing;
/// Lucide icon for 'bell'.
  static IconData bell;
/// Lucide icon for 'between horizontal end'.
  static IconData betweenHorizontalEnd;
/// Lucide icon for 'between horizontal start'.
  static IconData betweenHorizontalStart;
/// Lucide icon for 'between vertical end'.
  static IconData betweenVerticalEnd;
/// Lucide icon for 'between vertical start'.
  static IconData betweenVerticalStart;
/// Lucide icon for 'biceps flexed'.
  static IconData bicepsFlexed;
/// Lucide icon for 'bike'.
  static IconData bike;
/// Lucide icon for 'binary'.
  static IconData binary;
/// Lucide icon for 'binoculars'.
  static IconData binoculars;
/// Lucide icon for 'biohazard'.
  static IconData biohazard;
/// Lucide icon for 'bird'.
  static IconData bird;
/// Lucide icon for 'bitcoin'.
  static IconData bitcoin;
/// Lucide icon for 'blend'.
  static IconData blend;
/// Lucide icon for 'blinds'.
  static IconData blinds;
/// Lucide icon for 'blocks'.
  static IconData blocks;
/// Lucide icon for 'bluetooth connected'.
  static IconData bluetoothConnected;
/// Lucide icon for 'bluetooth off'.
  static IconData bluetoothOff;
/// Lucide icon for 'bluetooth searching'.
  static IconData bluetoothSearching;
/// Lucide icon for 'bluetooth'.
  static IconData bluetooth;
/// Lucide icon for 'bold'.
  static IconData bold;
/// Lucide icon for 'bolt'.
  static IconData bolt;
/// Lucide icon for 'bomb'.
  static IconData bomb;
/// Lucide icon for 'bone'.
  static IconData bone;
/// Lucide icon for 'book A'.
  static IconData bookA;
/// Lucide icon for 'book audio'.
  static IconData bookAudio;
/// Lucide icon for 'book check'.
  static IconData bookCheck;
/// Lucide icon for 'book copy'.
  static IconData bookCopy;
/// Lucide icon for 'book dashed'.
  static IconData bookDashed;
/// Lucide icon for 'book down'.
  static IconData bookDown;
/// Lucide icon for 'book headphones'.
  static IconData bookHeadphones;
/// Lucide icon for 'book heart'.
  static IconData bookHeart;
/// Lucide icon for 'book image'.
  static IconData bookImage;
/// Lucide icon for 'book key'.
  static IconData bookKey;
/// Lucide icon for 'book lock'.
  static IconData bookLock;
/// Lucide icon for 'book marked'.
  static IconData bookMarked;
/// Lucide icon for 'book minus'.
  static IconData bookMinus;
/// Lucide icon for 'book open check'.
  static IconData bookOpenCheck;
/// Lucide icon for 'book open text'.
  static IconData bookOpenText;
/// Lucide icon for 'book open'.
  static IconData bookOpen;
/// Lucide icon for 'book plus'.
  static IconData bookPlus;
/// Lucide icon for 'book text'.
  static IconData bookText;
/// Lucide icon for 'book type'.
  static IconData bookType;
/// Lucide icon for 'book up 2'.
  static IconData bookUp2;
/// Lucide icon for 'book up'.
  static IconData bookUp;
/// Lucide icon for 'book user'.
  static IconData bookUser;
/// Lucide icon for 'book X'.
  static IconData bookX;
/// Lucide icon for 'book'.
  static IconData book;
/// Lucide icon for 'bookmark check'.
  static IconData bookmarkCheck;
/// Lucide icon for 'bookmark minus'.
  static IconData bookmarkMinus;
/// Lucide icon for 'bookmark plus'.
  static IconData bookmarkPlus;
/// Lucide icon for 'bookmark X'.
  static IconData bookmarkX;
/// Lucide icon for 'bookmark'.
  static IconData bookmark;
/// Lucide icon for 'boom box'.
  static IconData boomBox;
/// Lucide icon for 'bot message square'.
  static IconData botMessageSquare;
/// Lucide icon for 'bot off'.
  static IconData botOff;
/// Lucide icon for 'bot'.
  static IconData bot;
/// Lucide icon for 'box'.
  static IconData box;
/// Lucide icon for 'boxes'.
  static IconData boxes;
/// Lucide icon for 'braces'.
  static IconData braces;
/// Lucide icon for 'brackets'.
  static IconData brackets;
/// Lucide icon for 'brain circuit'.
  static IconData brainCircuit;
/// Lucide icon for 'brain cog'.
  static IconData brainCog;
/// Lucide icon for 'brain'.
  static IconData brain;
/// Lucide icon for 'brick wall'.
  static IconData brickWall;
/// Lucide icon for 'briefcase business'.
  static IconData briefcaseBusiness;
/// Lucide icon for 'briefcase conveyor belt'.
  static IconData briefcaseConveyorBelt;
/// Lucide icon for 'briefcase medical'.
  static IconData briefcaseMedical;
/// Lucide icon for 'briefcase'.
  static IconData briefcase;
/// Lucide icon for 'bring to front'.
  static IconData bringToFront;
/// Lucide icon for 'brush'.
  static IconData brush;
/// Lucide icon for 'bug off'.
  static IconData bugOff;
/// Lucide icon for 'bug play'.
  static IconData bugPlay;
/// Lucide icon for 'bug'.
  static IconData bug;
/// Lucide icon for 'building 2'.
  static IconData building2;
/// Lucide icon for 'building'.
  static IconData building;
/// Lucide icon for 'bus front'.
  static IconData busFront;
/// Lucide icon for 'bus'.
  static IconData bus;
/// Lucide icon for 'cable car'.
  static IconData cableCar;
/// Lucide icon for 'cable'.
  static IconData cable;
/// Lucide icon for 'cake slice'.
  static IconData cakeSlice;
/// Lucide icon for 'cake'.
  static IconData cake;
/// Lucide icon for 'calculator'.
  static IconData calculator;
/// Lucide icon for 'calendar 1'.
  static IconData calendar1;
/// Lucide icon for 'calendar arrow down'.
  static IconData calendarArrowDown;
/// Lucide icon for 'calendar arrow up'.
  static IconData calendarArrowUp;
/// Lucide icon for 'calendar check 2'.
  static IconData calendarCheck2;
/// Lucide icon for 'calendar check'.
  static IconData calendarCheck;
/// Lucide icon for 'calendar clock'.
  static IconData calendarClock;
/// Lucide icon for 'calendar cog'.
  static IconData calendarCog;
/// Lucide icon for 'calendar days'.
  static IconData calendarDays;
/// Lucide icon for 'calendar fold'.
  static IconData calendarFold;
/// Lucide icon for 'calendar heart'.
  static IconData calendarHeart;
/// Lucide icon for 'calendar minus 2'.
  static IconData calendarMinus2;
/// Lucide icon for 'calendar minus'.
  static IconData calendarMinus;
/// Lucide icon for 'calendar off'.
  static IconData calendarOff;
/// Lucide icon for 'calendar plus 2'.
  static IconData calendarPlus2;
/// Lucide icon for 'calendar plus'.
  static IconData calendarPlus;
/// Lucide icon for 'calendar range'.
  static IconData calendarRange;
/// Lucide icon for 'calendar search'.
  static IconData calendarSearch;
/// Lucide icon for 'calendar sync'.
  static IconData calendarSync;
/// Lucide icon for 'calendar X 2'.
  static IconData calendarX2;
/// Lucide icon for 'calendar X'.
  static IconData calendarX;
/// Lucide icon for 'calendar'.
  static IconData calendar;
/// Lucide icon for 'camera off'.
  static IconData cameraOff;
/// Lucide icon for 'camera'.
  static IconData camera;
/// Lucide icon for 'candy cane'.
  static IconData candyCane;
/// Lucide icon for 'candy off'.
  static IconData candyOff;
/// Lucide icon for 'candy'.
  static IconData candy;
/// Lucide icon for 'cannabis'.
  static IconData cannabis;
/// Lucide icon for 'captions off'.
  static IconData captionsOff;
/// Lucide icon for 'captions'.
  static IconData captions;
/// Lucide icon for 'car front'.
  static IconData carFront;
/// Lucide icon for 'car taxi front'.
  static IconData carTaxiFront;
/// Lucide icon for 'car'.
  static IconData car;
/// Lucide icon for 'caravan'.
  static IconData caravan;
/// Lucide icon for 'carrot'.
  static IconData carrot;
/// Lucide icon for 'case lower'.
  static IconData caseLower;
/// Lucide icon for 'case sensitive'.
  static IconData caseSensitive;
/// Lucide icon for 'case upper'.
  static IconData caseUpper;
/// Lucide icon for 'cassette tape'.
  static IconData cassetteTape;
/// Lucide icon for 'cast'.
  static IconData cast;
/// Lucide icon for 'castle'.
  static IconData castle;
/// Lucide icon for 'cat'.
  static IconData cat;
/// Lucide icon for 'cctv'.
  static IconData cctv;
/// Lucide icon for 'chart area'.
  static IconData chartArea;
/// Lucide icon for 'chart bar big'.
  static IconData chartBarBig;
/// Lucide icon for 'chart bar decreasing'.
  static IconData chartBarDecreasing;
/// Lucide icon for 'chart bar increasing'.
  static IconData chartBarIncreasing;
/// Lucide icon for 'chart bar stacked'.
  static IconData chartBarStacked;
/// Lucide icon for 'chart bar'.
  static IconData chartBar;
/// Lucide icon for 'chart candlestick'.
  static IconData chartCandlestick;
/// Lucide icon for 'chart column big'.
  static IconData chartColumnBig;
/// Lucide icon for 'chart column decreasing'.
  static IconData chartColumnDecreasing;
/// Lucide icon for 'chart column increasing'.
  static IconData chartColumnIncreasing;
/// Lucide icon for 'chart column stacked'.
  static IconData chartColumnStacked;
/// Lucide icon for 'chart column'.
  static IconData chartColumn;
/// Lucide icon for 'chart gantt'.
  static IconData chartGantt;
/// Lucide icon for 'chart line'.
  static IconData chartLine;
/// Lucide icon for 'chart network'.
  static IconData chartNetwork;
/// Lucide icon for 'chart no axes column decreasing'.
  static IconData chartNoAxesColumnDecreasing;
/// Lucide icon for 'chart no axes column increasing'.
  static IconData chartNoAxesColumnIncreasing;
/// Lucide icon for 'chart no axes column'.
  static IconData chartNoAxesColumn;
/// Lucide icon for 'chart no axes combined'.
  static IconData chartNoAxesCombined;
/// Lucide icon for 'chart no axes gantt'.
  static IconData chartNoAxesGantt;
/// Lucide icon for 'chart pie'.
  static IconData chartPie;
/// Lucide icon for 'chart scatter'.
  static IconData chartScatter;
/// Lucide icon for 'chart spline'.
  static IconData chartSpline;
/// Lucide icon for 'check check'.
  static IconData checkCheck;
/// Lucide icon for 'check'.
  static IconData check;
/// Lucide icon for 'chef hat'.
  static IconData chefHat;
/// Lucide icon for 'cherry'.
  static IconData cherry;
/// Lucide icon for 'chevron down'.
  static IconData chevronDown;
/// Lucide icon for 'chevron first'.
  static IconData chevronFirst;
/// Lucide icon for 'chevron last'.
  static IconData chevronLast;
/// Lucide icon for 'chevron left'.
  static IconData chevronLeft;
/// Lucide icon for 'chevron right'.
  static IconData chevronRight;
/// Lucide icon for 'chevron up'.
  static IconData chevronUp;
/// Lucide icon for 'chevrons down up'.
  static IconData chevronsDownUp;
/// Lucide icon for 'chevrons down'.
  static IconData chevronsDown;
/// Lucide icon for 'chevrons left right ellipsis'.
  static IconData chevronsLeftRightEllipsis;
/// Lucide icon for 'chevrons left right'.
  static IconData chevronsLeftRight;
/// Lucide icon for 'chevrons left'.
  static IconData chevronsLeft;
/// Lucide icon for 'chevrons right left'.
  static IconData chevronsRightLeft;
/// Lucide icon for 'chevrons right'.
  static IconData chevronsRight;
/// Lucide icon for 'chevrons up down'.
  static IconData chevronsUpDown;
/// Lucide icon for 'chevrons up'.
  static IconData chevronsUp;
/// Lucide icon for 'chrome'.
  static IconData chrome;
/// Lucide icon for 'church'.
  static IconData church;
/// Lucide icon for 'cigarette off'.
  static IconData cigaretteOff;
/// Lucide icon for 'cigarette'.
  static IconData cigarette;
/// Lucide icon for 'circle alert'.
  static IconData circleAlert;
/// Lucide icon for 'circle arrow down'.
  static IconData circleArrowDown;
/// Lucide icon for 'circle arrow left'.
  static IconData circleArrowLeft;
/// Lucide icon for 'circle arrow out down left'.
  static IconData circleArrowOutDownLeft;
/// Lucide icon for 'circle arrow out down right'.
  static IconData circleArrowOutDownRight;
/// Lucide icon for 'circle arrow out up left'.
  static IconData circleArrowOutUpLeft;
/// Lucide icon for 'circle arrow out up right'.
  static IconData circleArrowOutUpRight;
/// Lucide icon for 'circle arrow right'.
  static IconData circleArrowRight;
/// Lucide icon for 'circle arrow up'.
  static IconData circleArrowUp;
/// Lucide icon for 'circle check big'.
  static IconData circleCheckBig;
/// Lucide icon for 'circle check'.
  static IconData circleCheck;
/// Lucide icon for 'circle chevron down'.
  static IconData circleChevronDown;
/// Lucide icon for 'circle chevron left'.
  static IconData circleChevronLeft;
/// Lucide icon for 'circle chevron right'.
  static IconData circleChevronRight;
/// Lucide icon for 'circle chevron up'.
  static IconData circleChevronUp;
/// Lucide icon for 'circle dashed'.
  static IconData circleDashed;
/// Lucide icon for 'circle divide'.
  static IconData circleDivide;
/// Lucide icon for 'circle dollar sign'.
  static IconData circleDollarSign;
/// Lucide icon for 'circle dot dashed'.
  static IconData circleDotDashed;
/// Lucide icon for 'circle dot'.
  static IconData circleDot;
/// Lucide icon for 'circle ellipsis'.
  static IconData circleEllipsis;
/// Lucide icon for 'circle equal'.
  static IconData circleEqual;
/// Lucide icon for 'circle fading arrow up'.
  static IconData circleFadingArrowUp;
/// Lucide icon for 'circle fading plus'.
  static IconData circleFadingPlus;
/// Lucide icon for 'circle gauge'.
  static IconData circleGauge;
/// Lucide icon for 'circle help'.
  static IconData circleHelp;
/// Lucide icon for 'circle minus'.
  static IconData circleMinus;
/// Lucide icon for 'circle off'.
  static IconData circleOff;
/// Lucide icon for 'circle parking off'.
  static IconData circleParkingOff;
/// Lucide icon for 'circle parking'.
  static IconData circleParking;
/// Lucide icon for 'circle pause'.
  static IconData circlePause;
/// Lucide icon for 'circle percent'.
  static IconData circlePercent;
/// Lucide icon for 'circle play'.
  static IconData circlePlay;
/// Lucide icon for 'circle plus'.
  static IconData circlePlus;
/// Lucide icon for 'circle power'.
  static IconData circlePower;
/// Lucide icon for 'circle slash 2'.
  static IconData circleSlash2;
/// Lucide icon for 'circle slash'.
  static IconData circleSlash;
/// Lucide icon for 'circle small'.
  static IconData circleSmall;
/// Lucide icon for 'circle stop'.
  static IconData circleStop;
/// Lucide icon for 'circle user round'.
  static IconData circleUserRound;
/// Lucide icon for 'circle user'.
  static IconData circleUser;
/// Lucide icon for 'circle X'.
  static IconData circleX;
/// Lucide icon for 'circle'.
  static IconData circle;
/// Lucide icon for 'circuit board'.
  static IconData circuitBoard;
/// Lucide icon for 'citrus'.
  static IconData citrus;
/// Lucide icon for 'clapperboard'.
  static IconData clapperboard;
/// Lucide icon for 'clipboard check'.
  static IconData clipboardCheck;
/// Lucide icon for 'clipboard copy'.
  static IconData clipboardCopy;
/// Lucide icon for 'clipboard list'.
  static IconData clipboardList;
/// Lucide icon for 'clipboard minus'.
  static IconData clipboardMinus;
/// Lucide icon for 'clipboard paste'.
  static IconData clipboardPaste;
/// Lucide icon for 'clipboard pen line'.
  static IconData clipboardPenLine;
/// Lucide icon for 'clipboard pen'.
  static IconData clipboardPen;
/// Lucide icon for 'clipboard plus'.
  static IconData clipboardPlus;
/// Lucide icon for 'clipboard type'.
  static IconData clipboardType;
/// Lucide icon for 'clipboard X'.
  static IconData clipboardX;
/// Lucide icon for 'clipboard'.
  static IconData clipboard;
/// Lucide icon for 'clock 1'.
  static IconData clock1;
/// Lucide icon for 'clock 10'.
  static IconData clock10;
/// Lucide icon for 'clock 11'.
  static IconData clock11;
/// Lucide icon for 'clock 12'.
  static IconData clock12;
/// Lucide icon for 'clock 2'.
  static IconData clock2;
/// Lucide icon for 'clock 3'.
  static IconData clock3;
/// Lucide icon for 'clock 4'.
  static IconData clock4;
/// Lucide icon for 'clock 5'.
  static IconData clock5;
/// Lucide icon for 'clock 6'.
  static IconData clock6;
/// Lucide icon for 'clock 7'.
  static IconData clock7;
/// Lucide icon for 'clock 8'.
  static IconData clock8;
/// Lucide icon for 'clock 9'.
  static IconData clock9;
/// Lucide icon for 'clock alert'.
  static IconData clockAlert;
/// Lucide icon for 'clock arrow down'.
  static IconData clockArrowDown;
/// Lucide icon for 'clock arrow up'.
  static IconData clockArrowUp;
/// Lucide icon for 'clock'.
  static IconData clock;
/// Lucide icon for 'cloud alert'.
  static IconData cloudAlert;
/// Lucide icon for 'cloud cog'.
  static IconData cloudCog;
/// Lucide icon for 'cloud download'.
  static IconData cloudDownload;
/// Lucide icon for 'cloud drizzle'.
  static IconData cloudDrizzle;
/// Lucide icon for 'cloud fog'.
  static IconData cloudFog;
/// Lucide icon for 'cloud hail'.
  static IconData cloudHail;
/// Lucide icon for 'cloud lightning'.
  static IconData cloudLightning;
/// Lucide icon for 'cloud moon rain'.
  static IconData cloudMoonRain;
/// Lucide icon for 'cloud moon'.
  static IconData cloudMoon;
/// Lucide icon for 'cloud off'.
  static IconData cloudOff;
/// Lucide icon for 'cloud rain wind'.
  static IconData cloudRainWind;
/// Lucide icon for 'cloud rain'.
  static IconData cloudRain;
/// Lucide icon for 'cloud snow'.
  static IconData cloudSnow;
/// Lucide icon for 'cloud sun rain'.
  static IconData cloudSunRain;
/// Lucide icon for 'cloud sun'.
  static IconData cloudSun;
/// Lucide icon for 'cloud upload'.
  static IconData cloudUpload;
/// Lucide icon for 'cloud'.
  static IconData cloud;
/// Lucide icon for 'cloudy'.
  static IconData cloudy;
/// Lucide icon for 'clover'.
  static IconData clover;
/// Lucide icon for 'club'.
  static IconData club;
/// Lucide icon for 'code xml'.
  static IconData codeXml;
/// Lucide icon for 'code'.
  static IconData code;
/// Lucide icon for 'codepen'.
  static IconData codepen;
/// Lucide icon for 'codesandbox'.
  static IconData codesandbox;
/// Lucide icon for 'coffee'.
  static IconData coffee;
/// Lucide icon for 'cog'.
  static IconData cog;
/// Lucide icon for 'coins'.
  static IconData coins;
/// Lucide icon for 'columns 2'.
  static IconData columns2;
/// Lucide icon for 'columns 3'.
  static IconData columns3;
/// Lucide icon for 'columns 4'.
  static IconData columns4;
/// Lucide icon for 'combine'.
  static IconData combine;
/// Lucide icon for 'command'.
  static IconData command;
/// Lucide icon for 'compass'.
  static IconData compass;
/// Lucide icon for 'component'.
  static IconData component;
/// Lucide icon for 'computer'.
  static IconData computer;
/// Lucide icon for 'concierge bell'.
  static IconData conciergeBell;
/// Lucide icon for 'cone'.
  static IconData cone;
/// Lucide icon for 'construction'.
  static IconData construction;
/// Lucide icon for 'contact round'.
  static IconData contactRound;
/// Lucide icon for 'contact'.
  static IconData contact;
/// Lucide icon for 'container'.
  static IconData container;
/// Lucide icon for 'contrast'.
  static IconData contrast;
/// Lucide icon for 'cookie'.
  static IconData cookie;
/// Lucide icon for 'cooking pot'.
  static IconData cookingPot;
/// Lucide icon for 'copy check'.
  static IconData copyCheck;
/// Lucide icon for 'copy minus'.
  static IconData copyMinus;
/// Lucide icon for 'copy plus'.
  static IconData copyPlus;
/// Lucide icon for 'copy slash'.
  static IconData copySlash;
/// Lucide icon for 'copy X'.
  static IconData copyX;
/// Lucide icon for 'copy'.
  static IconData copy;
/// Lucide icon for 'copyleft'.
  static IconData copyleft;
/// Lucide icon for 'copyright'.
  static IconData copyright;
/// Lucide icon for 'corner down left'.
  static IconData cornerDownLeft;
/// Lucide icon for 'corner down right'.
  static IconData cornerDownRight;
/// Lucide icon for 'corner left down'.
  static IconData cornerLeftDown;
/// Lucide icon for 'corner left up'.
  static IconData cornerLeftUp;
/// Lucide icon for 'corner right down'.
  static IconData cornerRightDown;
/// Lucide icon for 'corner right up'.
  static IconData cornerRightUp;
/// Lucide icon for 'corner up left'.
  static IconData cornerUpLeft;
/// Lucide icon for 'corner up right'.
  static IconData cornerUpRight;
/// Lucide icon for 'cpu'.
  static IconData cpu;
/// Lucide icon for 'creative commons'.
  static IconData creativeCommons;
/// Lucide icon for 'credit card'.
  static IconData creditCard;
/// Lucide icon for 'croissant'.
  static IconData croissant;
/// Lucide icon for 'crop'.
  static IconData crop;
/// Lucide icon for 'cross'.
  static IconData cross;
/// Lucide icon for 'crosshair'.
  static IconData crosshair;
/// Lucide icon for 'crown'.
  static IconData crown;
/// Lucide icon for 'cuboid'.
  static IconData cuboid;
/// Lucide icon for 'cup soda'.
  static IconData cupSoda;
/// Lucide icon for 'currency'.
  static IconData currency;
/// Lucide icon for 'cylinder'.
  static IconData cylinder;
/// Lucide icon for 'dam'.
  static IconData dam;
/// Lucide icon for 'database backup'.
  static IconData databaseBackup;
/// Lucide icon for 'database zap'.
  static IconData databaseZap;
/// Lucide icon for 'database'.
  static IconData database;
/// Lucide icon for 'delete'.
  static IconData delete;
/// Lucide icon for 'dessert'.
  static IconData dessert;
/// Lucide icon for 'diameter'.
  static IconData diameter;
/// Lucide icon for 'diamond minus'.
  static IconData diamondMinus;
/// Lucide icon for 'diamond percent'.
  static IconData diamondPercent;
/// Lucide icon for 'diamond plus'.
  static IconData diamondPlus;
/// Lucide icon for 'diamond'.
  static IconData diamond;
/// Lucide icon for 'dice 1'.
  static IconData dice1;
/// Lucide icon for 'dice 2'.
  static IconData dice2;
/// Lucide icon for 'dice 3'.
  static IconData dice3;
/// Lucide icon for 'dice 4'.
  static IconData dice4;
/// Lucide icon for 'dice 5'.
  static IconData dice5;
/// Lucide icon for 'dice 6'.
  static IconData dice6;
/// Lucide icon for 'dices'.
  static IconData dices;
/// Lucide icon for 'diff'.
  static IconData diff;
/// Lucide icon for 'disc 2'.
  static IconData disc2;
/// Lucide icon for 'disc 3'.
  static IconData disc3;
/// Lucide icon for 'disc album'.
  static IconData discAlbum;
/// Lucide icon for 'disc'.
  static IconData disc;
/// Lucide icon for 'divide'.
  static IconData divide;
/// Lucide icon for 'dna off'.
  static IconData dnaOff;
/// Lucide icon for 'dna'.
  static IconData dna;
/// Lucide icon for 'dock'.
  static IconData dock;
/// Lucide icon for 'dog'.
  static IconData dog;
/// Lucide icon for 'dollar sign'.
  static IconData dollarSign;
/// Lucide icon for 'donut'.
  static IconData donut;
/// Lucide icon for 'door closed'.
  static IconData doorClosed;
/// Lucide icon for 'door open'.
  static IconData doorOpen;
/// Lucide icon for 'dot'.
  static IconData dot;
/// Lucide icon for 'download'.
  static IconData download;
/// Lucide icon for 'drafting compass'.
  static IconData draftingCompass;
/// Lucide icon for 'drama'.
  static IconData drama;
/// Lucide icon for 'dribbble'.
  static IconData dribbble;
/// Lucide icon for 'drill'.
  static IconData drill;
/// Lucide icon for 'droplet off'.
  static IconData dropletOff;
/// Lucide icon for 'droplet'.
  static IconData droplet;
/// Lucide icon for 'droplets'.
  static IconData droplets;
/// Lucide icon for 'drum'.
  static IconData drum;
/// Lucide icon for 'drumstick'.
  static IconData drumstick;
/// Lucide icon for 'dumbbell'.
  static IconData dumbbell;
/// Lucide icon for 'ear off'.
  static IconData earOff;
/// Lucide icon for 'ear'.
  static IconData ear;
/// Lucide icon for 'earth lock'.
  static IconData earthLock;
/// Lucide icon for 'earth'.
  static IconData earth;
/// Lucide icon for 'eclipse'.
  static IconData eclipse;
/// Lucide icon for 'egg fried'.
  static IconData eggFried;
/// Lucide icon for 'egg off'.
  static IconData eggOff;
/// Lucide icon for 'egg'.
  static IconData egg;
/// Lucide icon for 'ellipsis vertical'.
  static IconData ellipsisVertical;
/// Lucide icon for 'ellipsis'.
  static IconData ellipsis;
/// Lucide icon for 'equal approximately'.
  static IconData equalApproximately;
/// Lucide icon for 'equal not'.
  static IconData equalNot;
/// Lucide icon for 'equal'.
  static IconData equal;
/// Lucide icon for 'eraser'.
  static IconData eraser;
/// Lucide icon for 'ethernet port'.
  static IconData ethernetPort;
/// Lucide icon for 'euro'.
  static IconData euro;
/// Lucide icon for 'expand'.
  static IconData expand;
/// Lucide icon for 'external link'.
  static IconData externalLink;
/// Lucide icon for 'eye closed'.
  static IconData eyeClosed;
/// Lucide icon for 'eye off'.
  static IconData eyeOff;
/// Lucide icon for 'eye'.
  static IconData eye;
/// Lucide icon for 'facebook'.
  static IconData facebook;
/// Lucide icon for 'factory'.
  static IconData factory;
/// Lucide icon for 'fan'.
  static IconData fan;
/// Lucide icon for 'fast forward'.
  static IconData fastForward;
/// Lucide icon for 'feather'.
  static IconData feather;
/// Lucide icon for 'fence'.
  static IconData fence;
/// Lucide icon for 'ferris wheel'.
  static IconData ferrisWheel;
/// Lucide icon for 'figma'.
  static IconData figma;
/// Lucide icon for 'file archive'.
  static IconData fileArchive;
/// Lucide icon for 'file audio 2'.
  static IconData fileAudio2;
/// Lucide icon for 'file audio'.
  static IconData fileAudio;
/// Lucide icon for 'file axis 3d'.
  static IconData fileAxis3d;
/// Lucide icon for 'file badge 2'.
  static IconData fileBadge2;
/// Lucide icon for 'file badge'.
  static IconData fileBadge;
/// Lucide icon for 'file box'.
  static IconData fileBox;
/// Lucide icon for 'file chart column increasing'.
  static IconData fileChartColumnIncreasing;
/// Lucide icon for 'file chart column'.
  static IconData fileChartColumn;
/// Lucide icon for 'file chart line'.
  static IconData fileChartLine;
/// Lucide icon for 'file chart pie'.
  static IconData fileChartPie;
/// Lucide icon for 'file check 2'.
  static IconData fileCheck2;
/// Lucide icon for 'file check'.
  static IconData fileCheck;
/// Lucide icon for 'file clock'.
  static IconData fileClock;
/// Lucide icon for 'file code 2'.
  static IconData fileCode2;
/// Lucide icon for 'file code'.
  static IconData fileCode;
/// Lucide icon for 'file cog'.
  static IconData fileCog;
/// Lucide icon for 'file diff'.
  static IconData fileDiff;
/// Lucide icon for 'file digit'.
  static IconData fileDigit;
/// Lucide icon for 'file down'.
  static IconData fileDown;
/// Lucide icon for 'file heart'.
  static IconData fileHeart;
/// Lucide icon for 'file image'.
  static IconData fileImage;
/// Lucide icon for 'file input'.
  static IconData fileInput;
/// Lucide icon for 'file json 2'.
  static IconData fileJson2;
/// Lucide icon for 'file json'.
  static IconData fileJson;
/// Lucide icon for 'file key 2'.
  static IconData fileKey2;
/// Lucide icon for 'file key'.
  static IconData fileKey;
/// Lucide icon for 'file lock 2'.
  static IconData fileLock2;
/// Lucide icon for 'file lock'.
  static IconData fileLock;
/// Lucide icon for 'file minus 2'.
  static IconData fileMinus2;
/// Lucide icon for 'file minus'.
  static IconData fileMinus;
/// Lucide icon for 'file music'.
  static IconData fileMusic;
/// Lucide icon for 'file output'.
  static IconData fileOutput;
/// Lucide icon for 'file pen line'.
  static IconData filePenLine;
/// Lucide icon for 'file pen'.
  static IconData filePen;
/// Lucide icon for 'file plus 2'.
  static IconData filePlus2;
/// Lucide icon for 'file plus'.
  static IconData filePlus;
/// Lucide icon for 'file question'.
  static IconData fileQuestion;
/// Lucide icon for 'file scan'.
  static IconData fileScan;
/// Lucide icon for 'file search 2'.
  static IconData fileSearch2;
/// Lucide icon for 'file search'.
  static IconData fileSearch;
/// Lucide icon for 'file sliders'.
  static IconData fileSliders;
/// Lucide icon for 'file spreadsheet'.
  static IconData fileSpreadsheet;
/// Lucide icon for 'file stack'.
  static IconData fileStack;
/// Lucide icon for 'file symlink'.
  static IconData fileSymlink;
/// Lucide icon for 'file terminal'.
  static IconData fileTerminal;
/// Lucide icon for 'file text'.
  static IconData fileText;
/// Lucide icon for 'file type 2'.
  static IconData fileType2;
/// Lucide icon for 'file type'.
  static IconData fileType;
/// Lucide icon for 'file up'.
  static IconData fileUp;
/// Lucide icon for 'file user'.
  static IconData fileUser;
/// Lucide icon for 'file video 2'.
  static IconData fileVideo2;
/// Lucide icon for 'file video'.
  static IconData fileVideo;
/// Lucide icon for 'file volume 2'.
  static IconData fileVolume2;
/// Lucide icon for 'file volume'.
  static IconData fileVolume;
/// Lucide icon for 'file warning'.
  static IconData fileWarning;
/// Lucide icon for 'file X 2'.
  static IconData fileX2;
/// Lucide icon for 'file X'.
  static IconData fileX;
/// Lucide icon for 'file'.
  static IconData file;
/// Lucide icon for 'files'.
  static IconData files;
/// Lucide icon for 'film'.
  static IconData film;
/// Lucide icon for 'filter X'.
  static IconData filterX;
/// Lucide icon for 'filter'.
  static IconData filter;
/// Lucide icon for 'fingerprint'.
  static IconData fingerprint;
/// Lucide icon for 'fire extinguisher'.
  static IconData fireExtinguisher;
/// Lucide icon for 'fish off'.
  static IconData fishOff;
/// Lucide icon for 'fish symbol'.
  static IconData fishSymbol;
/// Lucide icon for 'fish'.
  static IconData fish;
/// Lucide icon for 'flag off'.
  static IconData flagOff;
/// Lucide icon for 'flag triangle left'.
  static IconData flagTriangleLeft;
/// Lucide icon for 'flag triangle right'.
  static IconData flagTriangleRight;
/// Lucide icon for 'flag'.
  static IconData flag;
/// Lucide icon for 'flame kindling'.
  static IconData flameKindling;
/// Lucide icon for 'flame'.
  static IconData flame;
/// Lucide icon for 'flashlight off'.
  static IconData flashlightOff;
/// Lucide icon for 'flashlight'.
  static IconData flashlight;
/// Lucide icon for 'flask conical off'.
  static IconData flaskConicalOff;
/// Lucide icon for 'flask conical'.
  static IconData flaskConical;
/// Lucide icon for 'flask round'.
  static IconData flaskRound;
/// Lucide icon for 'flip horizontal 2'.
  static IconData flipHorizontal2;
/// Lucide icon for 'flip horizontal'.
  static IconData flipHorizontal;
/// Lucide icon for 'flip vertical 2'.
  static IconData flipVertical2;
/// Lucide icon for 'flip vertical'.
  static IconData flipVertical;
/// Lucide icon for 'flower 2'.
  static IconData flower2;
/// Lucide icon for 'flower'.
  static IconData flower;
/// Lucide icon for 'focus'.
  static IconData focus;
/// Lucide icon for 'fold horizontal'.
  static IconData foldHorizontal;
/// Lucide icon for 'fold vertical'.
  static IconData foldVertical;
/// Lucide icon for 'folder archive'.
  static IconData folderArchive;
/// Lucide icon for 'folder check'.
  static IconData folderCheck;
/// Lucide icon for 'folder clock'.
  static IconData folderClock;
/// Lucide icon for 'folder closed'.
  static IconData folderClosed;
/// Lucide icon for 'folder code'.
  static IconData folderCode;
/// Lucide icon for 'folder cog'.
  static IconData folderCog;
/// Lucide icon for 'folder dot'.
  static IconData folderDot;
/// Lucide icon for 'folder down'.
  static IconData folderDown;
/// Lucide icon for 'folder git 2'.
  static IconData folderGit2;
/// Lucide icon for 'folder git'.
  static IconData folderGit;
/// Lucide icon for 'folder heart'.
  static IconData folderHeart;
/// Lucide icon for 'folder input'.
  static IconData folderInput;
/// Lucide icon for 'folder kanban'.
  static IconData folderKanban;
/// Lucide icon for 'folder key'.
  static IconData folderKey;
/// Lucide icon for 'folder lock'.
  static IconData folderLock;
/// Lucide icon for 'folder minus'.
  static IconData folderMinus;
/// Lucide icon for 'folder open dot'.
  static IconData folderOpenDot;
/// Lucide icon for 'folder open'.
  static IconData folderOpen;
/// Lucide icon for 'folder output'.
  static IconData folderOutput;
/// Lucide icon for 'folder pen'.
  static IconData folderPen;
/// Lucide icon for 'folder plus'.
  static IconData folderPlus;
/// Lucide icon for 'folder root'.
  static IconData folderRoot;
/// Lucide icon for 'folder search 2'.
  static IconData folderSearch2;
/// Lucide icon for 'folder search'.
  static IconData folderSearch;
/// Lucide icon for 'folder symlink'.
  static IconData folderSymlink;
/// Lucide icon for 'folder sync'.
  static IconData folderSync;
/// Lucide icon for 'folder tree'.
  static IconData folderTree;
/// Lucide icon for 'folder up'.
  static IconData folderUp;
/// Lucide icon for 'folder X'.
  static IconData folderX;
/// Lucide icon for 'folder'.
  static IconData folder;
/// Lucide icon for 'folders'.
  static IconData folders;
/// Lucide icon for 'footprints'.
  static IconData footprints;
/// Lucide icon for 'forklift'.
  static IconData forklift;
/// Lucide icon for 'forward'.
  static IconData forward;
/// Lucide icon for 'frame'.
  static IconData frame;
/// Lucide icon for 'framer'.
  static IconData framer;
/// Lucide icon for 'frown'.
  static IconData frown;
/// Lucide icon for 'fuel'.
  static IconData fuel;
/// Lucide icon for 'fullscreen'.
  static IconData fullscreen;
/// Lucide icon for 'gallery horizontal end'.
  static IconData galleryHorizontalEnd;
/// Lucide icon for 'gallery horizontal'.
  static IconData galleryHorizontal;
/// Lucide icon for 'gallery thumbnails'.
  static IconData galleryThumbnails;
/// Lucide icon for 'gallery vertical end'.
  static IconData galleryVerticalEnd;
/// Lucide icon for 'gallery vertical'.
  static IconData galleryVertical;
/// Lucide icon for 'gamepad 2'.
  static IconData gamepad2;
/// Lucide icon for 'gamepad'.
  static IconData gamepad;
/// Lucide icon for 'gauge'.
  static IconData gauge;
/// Lucide icon for 'gavel'.
  static IconData gavel;
/// Lucide icon for 'gem'.
  static IconData gem;
/// Lucide icon for 'ghost'.
  static IconData ghost;
/// Lucide icon for 'gift'.
  static IconData gift;
/// Lucide icon for 'git branch plus'.
  static IconData gitBranchPlus;
/// Lucide icon for 'git branch'.
  static IconData gitBranch;
/// Lucide icon for 'git commit horizontal'.
  static IconData gitCommitHorizontal;
/// Lucide icon for 'git commit vertical'.
  static IconData gitCommitVertical;
/// Lucide icon for 'git compare arrows'.
  static IconData gitCompareArrows;
/// Lucide icon for 'git compare'.
  static IconData gitCompare;
/// Lucide icon for 'git fork'.
  static IconData gitFork;
/// Lucide icon for 'git graph'.
  static IconData gitGraph;
/// Lucide icon for 'git merge'.
  static IconData gitMerge;
/// Lucide icon for 'git pull request arrow'.
  static IconData gitPullRequestArrow;
/// Lucide icon for 'git pull request closed'.
  static IconData gitPullRequestClosed;
/// Lucide icon for 'git pull request create arrow'.
  static IconData gitPullRequestCreateArrow;
/// Lucide icon for 'git pull request create'.
  static IconData gitPullRequestCreate;
/// Lucide icon for 'git pull request draft'.
  static IconData gitPullRequestDraft;
/// Lucide icon for 'git pull request'.
  static IconData gitPullRequest;
/// Lucide icon for 'github'.
  static IconData github;
/// Lucide icon for 'gitlab'.
  static IconData gitlab;
/// Lucide icon for 'glass water'.
  static IconData glassWater;
/// Lucide icon for 'glasses'.
  static IconData glasses;
/// Lucide icon for 'globe lock'.
  static IconData globeLock;
/// Lucide icon for 'globe'.
  static IconData globe;
/// Lucide icon for 'goal'.
  static IconData goal;
/// Lucide icon for 'grab'.
  static IconData grab;
/// Lucide icon for 'graduation cap'.
  static IconData graduationCap;
/// Lucide icon for 'grape'.
  static IconData grape;
/// Lucide icon for 'grid 2x 2 check'.
  static IconData grid2x2Check;
/// Lucide icon for 'grid 2x 2 plus'.
  static IconData grid2x2Plus;
/// Lucide icon for 'grid 2x 2 X'.
  static IconData grid2x2X;
/// Lucide icon for 'grid 2x 2'.
  static IconData grid2x2;
/// Lucide icon for 'grid 3x 3'.
  static IconData grid3x3;
/// Lucide icon for 'grip horizontal'.
  static IconData gripHorizontal;
/// Lucide icon for 'grip vertical'.
  static IconData gripVertical;
/// Lucide icon for 'grip'.
  static IconData grip;
/// Lucide icon for 'group'.
  static IconData group;
/// Lucide icon for 'guitar'.
  static IconData guitar;
/// Lucide icon for 'ham'.
  static IconData ham;
/// Lucide icon for 'hammer'.
  static IconData hammer;
/// Lucide icon for 'hand coins'.
  static IconData handCoins;
/// Lucide icon for 'hand heart'.
  static IconData handHeart;
/// Lucide icon for 'hand helping'.
  static IconData handHelping;
/// Lucide icon for 'hand metal'.
  static IconData handMetal;
/// Lucide icon for 'hand platter'.
  static IconData handPlatter;
/// Lucide icon for 'hand'.
  static IconData hand;
/// Lucide icon for 'handshake'.
  static IconData handshake;
/// Lucide icon for 'hard drive download'.
  static IconData hardDriveDownload;
/// Lucide icon for 'hard drive upload'.
  static IconData hardDriveUpload;
/// Lucide icon for 'hard drive'.
  static IconData hardDrive;
/// Lucide icon for 'hard hat'.
  static IconData hardHat;
/// Lucide icon for 'hash'.
  static IconData hash;
/// Lucide icon for 'haze'.
  static IconData haze;
/// Lucide icon for 'hdmi port'.
  static IconData hdmiPort;
/// Lucide icon for 'heading 1'.
  static IconData heading1;
/// Lucide icon for 'heading 2'.
  static IconData heading2;
/// Lucide icon for 'heading 3'.
  static IconData heading3;
/// Lucide icon for 'heading 4'.
  static IconData heading4;
/// Lucide icon for 'heading 5'.
  static IconData heading5;
/// Lucide icon for 'heading 6'.
  static IconData heading6;
/// Lucide icon for 'heading'.
  static IconData heading;
/// Lucide icon for 'headphone off'.
  static IconData headphoneOff;
/// Lucide icon for 'headphones'.
  static IconData headphones;
/// Lucide icon for 'headset'.
  static IconData headset;
/// Lucide icon for 'heart crack'.
  static IconData heartCrack;
/// Lucide icon for 'heart handshake'.
  static IconData heartHandshake;
/// Lucide icon for 'heart off'.
  static IconData heartOff;
/// Lucide icon for 'heart pulse'.
  static IconData heartPulse;
/// Lucide icon for 'heart'.
  static IconData heart;
/// Lucide icon for 'heater'.
  static IconData heater;
/// Lucide icon for 'hexagon'.
  static IconData hexagon;
/// Lucide icon for 'highlighter'.
  static IconData highlighter;
/// Lucide icon for 'history'.
  static IconData history;
/// Lucide icon for 'hop off'.
  static IconData hopOff;
/// Lucide icon for 'hop'.
  static IconData hop;
/// Lucide icon for 'hospital'.
  static IconData hospital;
/// Lucide icon for 'hotel'.
  static IconData hotel;
/// Lucide icon for 'hourglass'.
  static IconData hourglass;
/// Lucide icon for 'house plug'.
  static IconData housePlug;
/// Lucide icon for 'house plus'.
  static IconData housePlus;
/// Lucide icon for 'house wifi'.
  static IconData houseWifi;
/// Lucide icon for 'house'.
  static IconData house;
/// Lucide icon for 'ice cream bowl'.
  static IconData iceCreamBowl;
/// Lucide icon for 'ice cream cone'.
  static IconData iceCreamCone;
/// Lucide icon for 'id card'.
  static IconData idCard;
/// Lucide icon for 'image down'.
  static IconData imageDown;
/// Lucide icon for 'image minus'.
  static IconData imageMinus;
/// Lucide icon for 'image off'.
  static IconData imageOff;
/// Lucide icon for 'image play'.
  static IconData imagePlay;
/// Lucide icon for 'image plus'.
  static IconData imagePlus;
/// Lucide icon for 'image up'.
  static IconData imageUp;
/// Lucide icon for 'image upscale'.
  static IconData imageUpscale;
/// Lucide icon for 'image'.
  static IconData image;
/// Lucide icon for 'images'.
  static IconData images;
/// Lucide icon for 'import'.
  static IconData import;
/// Lucide icon for 'inbox'.
  static IconData inbox;
/// Lucide icon for 'indent decrease'.
  static IconData indentDecrease;
/// Lucide icon for 'indent increase'.
  static IconData indentIncrease;
/// Lucide icon for 'indian rupee'.
  static IconData indianRupee;
/// Lucide icon for 'infinity'.
  static IconData infinity;
/// Lucide icon for 'info'.
  static IconData info;
/// Lucide icon for 'inspection panel'.
  static IconData inspectionPanel;
/// Lucide icon for 'instagram'.
  static IconData instagram;
/// Lucide icon for 'italic'.
  static IconData italic;
/// Lucide icon for 'iteration ccw'.
  static IconData iterationCcw;
/// Lucide icon for 'iteration cw'.
  static IconData iterationCw;
/// Lucide icon for 'japanese yen'.
  static IconData japaneseYen;
/// Lucide icon for 'joystick'.
  static IconData joystick;
/// Lucide icon for 'kanban'.
  static IconData kanban;
/// Lucide icon for 'key round'.
  static IconData keyRound;
/// Lucide icon for 'key square'.
  static IconData keySquare;
/// Lucide icon for 'key'.
  static IconData key;
/// Lucide icon for 'keyboard music'.
  static IconData keyboardMusic;
/// Lucide icon for 'keyboard off'.
  static IconData keyboardOff;
/// Lucide icon for 'keyboard'.
  static IconData keyboard;
/// Lucide icon for 'lamp ceiling'.
  static IconData lampCeiling;
/// Lucide icon for 'lamp desk'.
  static IconData lampDesk;
/// Lucide icon for 'lamp floor'.
  static IconData lampFloor;
/// Lucide icon for 'lamp wall down'.
  static IconData lampWallDown;
/// Lucide icon for 'lamp wall up'.
  static IconData lampWallUp;
/// Lucide icon for 'lamp'.
  static IconData lamp;
/// Lucide icon for 'land plot'.
  static IconData landPlot;
/// Lucide icon for 'landmark'.
  static IconData landmark;
/// Lucide icon for 'languages'.
  static IconData languages;
/// Lucide icon for 'laptop minimal check'.
  static IconData laptopMinimalCheck;
/// Lucide icon for 'laptop minimal'.
  static IconData laptopMinimal;
/// Lucide icon for 'laptop'.
  static IconData laptop;
/// Lucide icon for 'lasso select'.
  static IconData lassoSelect;
/// Lucide icon for 'lasso'.
  static IconData lasso;
/// Lucide icon for 'laugh'.
  static IconData laugh;
/// Lucide icon for 'layers 2'.
  static IconData layers2;
/// Lucide icon for 'layers'.
  static IconData layers;
/// Lucide icon for 'layout dashboard'.
  static IconData layoutDashboard;
/// Lucide icon for 'layout grid'.
  static IconData layoutGrid;
/// Lucide icon for 'layout list'.
  static IconData layoutList;
/// Lucide icon for 'layout panel left'.
  static IconData layoutPanelLeft;
/// Lucide icon for 'layout panel top'.
  static IconData layoutPanelTop;
/// Lucide icon for 'layout template'.
  static IconData layoutTemplate;
/// Lucide icon for 'leaf'.
  static IconData leaf;
/// Lucide icon for 'leafy green'.
  static IconData leafyGreen;
/// Lucide icon for 'lectern'.
  static IconData lectern;
/// Lucide icon for 'letter text'.
  static IconData letterText;
/// Lucide icon for 'library big'.
  static IconData libraryBig;
/// Lucide icon for 'library'.
  static IconData library;
/// Lucide icon for 'life buoy'.
  static IconData lifeBuoy;
/// Lucide icon for 'ligature'.
  static IconData ligature;
/// Lucide icon for 'lightbulb off'.
  static IconData lightbulbOff;
/// Lucide icon for 'lightbulb'.
  static IconData lightbulb;
/// Lucide icon for 'link 2 off'.
  static IconData link2Off;
/// Lucide icon for 'link 2'.
  static IconData link2;
/// Lucide icon for 'link'.
  static IconData link;
/// Lucide icon for 'linkedin'.
  static IconData linkedin;
/// Lucide icon for 'list check'.
  static IconData listCheck;
/// Lucide icon for 'list checks'.
  static IconData listChecks;
/// Lucide icon for 'list collapse'.
  static IconData listCollapse;
/// Lucide icon for 'list end'.
  static IconData listEnd;
/// Lucide icon for 'list filter plus'.
  static IconData listFilterPlus;
/// Lucide icon for 'list filter'.
  static IconData listFilter;
/// Lucide icon for 'list minus'.
  static IconData listMinus;
/// Lucide icon for 'list music'.
  static IconData listMusic;
/// Lucide icon for 'list ordered'.
  static IconData listOrdered;
/// Lucide icon for 'list plus'.
  static IconData listPlus;
/// Lucide icon for 'list restart'.
  static IconData listRestart;
/// Lucide icon for 'list start'.
  static IconData listStart;
/// Lucide icon for 'list todo'.
  static IconData listTodo;
/// Lucide icon for 'list tree'.
  static IconData listTree;
/// Lucide icon for 'list video'.
  static IconData listVideo;
/// Lucide icon for 'list X'.
  static IconData listX;
/// Lucide icon for 'list'.
  static IconData list;
/// Lucide icon for 'loader circle'.
  static IconData loaderCircle;
/// Lucide icon for 'loader pinwheel'.
  static IconData loaderPinwheel;
/// Lucide icon for 'loader'.
  static IconData loader;
/// Lucide icon for 'locate fixed'.
  static IconData locateFixed;
/// Lucide icon for 'locate off'.
  static IconData locateOff;
/// Lucide icon for 'locate'.
  static IconData locate;
/// Lucide icon for 'lock keyhole open'.
  static IconData lockKeyholeOpen;
/// Lucide icon for 'lock keyhole'.
  static IconData lockKeyhole;
/// Lucide icon for 'lock open'.
  static IconData lockOpen;
/// Lucide icon for 'lock'.
  static IconData lock;
/// Lucide icon for 'log in'.
  static IconData logIn;
/// Lucide icon for 'log out'.
  static IconData logOut;
/// Lucide icon for 'logs'.
  static IconData logs;
/// Lucide icon for 'lollipop'.
  static IconData lollipop;
/// Lucide icon for 'luggage'.
  static IconData luggage;
/// Lucide icon for 'magnet'.
  static IconData magnet;
/// Lucide icon for 'mail check'.
  static IconData mailCheck;
/// Lucide icon for 'mail minus'.
  static IconData mailMinus;
/// Lucide icon for 'mail open'.
  static IconData mailOpen;
/// Lucide icon for 'mail plus'.
  static IconData mailPlus;
/// Lucide icon for 'mail question'.
  static IconData mailQuestion;
/// Lucide icon for 'mail search'.
  static IconData mailSearch;
/// Lucide icon for 'mail warning'.
  static IconData mailWarning;
/// Lucide icon for 'mail X'.
  static IconData mailX;
/// Lucide icon for 'mail'.
  static IconData mail;
/// Lucide icon for 'mailbox'.
  static IconData mailbox;
/// Lucide icon for 'mails'.
  static IconData mails;
/// Lucide icon for 'map pin check inside'.
  static IconData mapPinCheckInside;
/// Lucide icon for 'map pin check'.
  static IconData mapPinCheck;
/// Lucide icon for 'map pin house'.
  static IconData mapPinHouse;
/// Lucide icon for 'map pin minus inside'.
  static IconData mapPinMinusInside;
/// Lucide icon for 'map pin minus'.
  static IconData mapPinMinus;
/// Lucide icon for 'map pin off'.
  static IconData mapPinOff;
/// Lucide icon for 'map pin plus inside'.
  static IconData mapPinPlusInside;
/// Lucide icon for 'map pin plus'.
  static IconData mapPinPlus;
/// Lucide icon for 'map pin X inside'.
  static IconData mapPinXInside;
/// Lucide icon for 'map pin X'.
  static IconData mapPinX;
/// Lucide icon for 'map pin'.
  static IconData mapPin;
/// Lucide icon for 'map pinned'.
  static IconData mapPinned;
/// Lucide icon for 'map plus'.
  static IconData mapPlus;
/// Lucide icon for 'map'.
  static IconData map;
/// Lucide icon for 'mars stroke'.
  static IconData marsStroke;
/// Lucide icon for 'mars'.
  static IconData mars;
/// Lucide icon for 'martini'.
  static IconData martini;
/// Lucide icon for 'maximize 2'.
  static IconData maximize2;
/// Lucide icon for 'maximize'.
  static IconData maximize;
/// Lucide icon for 'medal'.
  static IconData medal;
/// Lucide icon for 'megaphone off'.
  static IconData megaphoneOff;
/// Lucide icon for 'megaphone'.
  static IconData megaphone;
/// Lucide icon for 'meh'.
  static IconData meh;
/// Lucide icon for 'memory stick'.
  static IconData memoryStick;
/// Lucide icon for 'menu'.
  static IconData menu;
/// Lucide icon for 'merge'.
  static IconData merge;
/// Lucide icon for 'message circle code'.
  static IconData messageCircleCode;
/// Lucide icon for 'message circle dashed'.
  static IconData messageCircleDashed;
/// Lucide icon for 'message circle heart'.
  static IconData messageCircleHeart;
/// Lucide icon for 'message circle more'.
  static IconData messageCircleMore;
/// Lucide icon for 'message circle off'.
  static IconData messageCircleOff;
/// Lucide icon for 'message circle plus'.
  static IconData messageCirclePlus;
/// Lucide icon for 'message circle question'.
  static IconData messageCircleQuestion;
/// Lucide icon for 'message circle reply'.
  static IconData messageCircleReply;
/// Lucide icon for 'message circle warning'.
  static IconData messageCircleWarning;
/// Lucide icon for 'message circle X'.
  static IconData messageCircleX;
/// Lucide icon for 'message circle'.
  static IconData messageCircle;
/// Lucide icon for 'message square code'.
  static IconData messageSquareCode;
/// Lucide icon for 'message square dashed'.
  static IconData messageSquareDashed;
/// Lucide icon for 'message square diff'.
  static IconData messageSquareDiff;
/// Lucide icon for 'message square dot'.
  static IconData messageSquareDot;
/// Lucide icon for 'message square heart'.
  static IconData messageSquareHeart;
/// Lucide icon for 'message square lock'.
  static IconData messageSquareLock;
/// Lucide icon for 'message square more'.
  static IconData messageSquareMore;
/// Lucide icon for 'message square off'.
  static IconData messageSquareOff;
/// Lucide icon for 'message square plus'.
  static IconData messageSquarePlus;
/// Lucide icon for 'message square quote'.
  static IconData messageSquareQuote;
/// Lucide icon for 'message square reply'.
  static IconData messageSquareReply;
/// Lucide icon for 'message square share'.
  static IconData messageSquareShare;
/// Lucide icon for 'message square text'.
  static IconData messageSquareText;
/// Lucide icon for 'message square warning'.
  static IconData messageSquareWarning;
/// Lucide icon for 'message square X'.
  static IconData messageSquareX;
/// Lucide icon for 'message square'.
  static IconData messageSquare;
/// Lucide icon for 'messages square'.
  static IconData messagesSquare;
/// Lucide icon for 'mic off'.
  static IconData micOff;
/// Lucide icon for 'mic vocal'.
  static IconData micVocal;
/// Lucide icon for 'mic'.
  static IconData mic;
/// Lucide icon for 'microchip'.
  static IconData microchip;
/// Lucide icon for 'microscope'.
  static IconData microscope;
/// Lucide icon for 'microwave'.
  static IconData microwave;
/// Lucide icon for 'milestone'.
  static IconData milestone;
/// Lucide icon for 'milk off'.
  static IconData milkOff;
/// Lucide icon for 'milk'.
  static IconData milk;
/// Lucide icon for 'minimize 2'.
  static IconData minimize2;
/// Lucide icon for 'minimize'.
  static IconData minimize;
/// Lucide icon for 'minus'.
  static IconData minus;
/// Lucide icon for 'monitor check'.
  static IconData monitorCheck;
/// Lucide icon for 'monitor cog'.
  static IconData monitorCog;
/// Lucide icon for 'monitor dot'.
  static IconData monitorDot;
/// Lucide icon for 'monitor down'.
  static IconData monitorDown;
/// Lucide icon for 'monitor off'.
  static IconData monitorOff;
/// Lucide icon for 'monitor pause'.
  static IconData monitorPause;
/// Lucide icon for 'monitor play'.
  static IconData monitorPlay;
/// Lucide icon for 'monitor smartphone'.
  static IconData monitorSmartphone;
/// Lucide icon for 'monitor speaker'.
  static IconData monitorSpeaker;
/// Lucide icon for 'monitor stop'.
  static IconData monitorStop;
/// Lucide icon for 'monitor up'.
  static IconData monitorUp;
/// Lucide icon for 'monitor X'.
  static IconData monitorX;
/// Lucide icon for 'monitor'.
  static IconData monitor;
/// Lucide icon for 'moon star'.
  static IconData moonStar;
/// Lucide icon for 'moon'.
  static IconData moon;
/// Lucide icon for 'mountain snow'.
  static IconData mountainSnow;
/// Lucide icon for 'mountain'.
  static IconData mountain;
/// Lucide icon for 'mouse off'.
  static IconData mouseOff;
/// Lucide icon for 'mouse pointer 2'.
  static IconData mousePointer2;
/// Lucide icon for 'mouse pointer ban'.
  static IconData mousePointerBan;
/// Lucide icon for 'mouse pointer click'.
  static IconData mousePointerClick;
/// Lucide icon for 'mouse pointer'.
  static IconData mousePointer;
/// Lucide icon for 'mouse'.
  static IconData mouse;
/// Lucide icon for 'move 3d'.
  static IconData move3d;
/// Lucide icon for 'move diagonal 2'.
  static IconData moveDiagonal2;
/// Lucide icon for 'move diagonal'.
  static IconData moveDiagonal;
/// Lucide icon for 'move down left'.
  static IconData moveDownLeft;
/// Lucide icon for 'move down right'.
  static IconData moveDownRight;
/// Lucide icon for 'move down'.
  static IconData moveDown;
/// Lucide icon for 'move horizontal'.
  static IconData moveHorizontal;
/// Lucide icon for 'move left'.
  static IconData moveLeft;
/// Lucide icon for 'move right'.
  static IconData moveRight;
/// Lucide icon for 'move up left'.
  static IconData moveUpLeft;
/// Lucide icon for 'move up right'.
  static IconData moveUpRight;
/// Lucide icon for 'move up'.
  static IconData moveUp;
/// Lucide icon for 'move vertical'.
  static IconData moveVertical;
/// Lucide icon for 'move'.
  static IconData move;
/// Lucide icon for 'music 2'.
  static IconData music2;
/// Lucide icon for 'music 3'.
  static IconData music3;
/// Lucide icon for 'music 4'.
  static IconData music4;
/// Lucide icon for 'music'.
  static IconData music;
/// Lucide icon for 'navigation 2 off'.
  static IconData navigation2Off;
/// Lucide icon for 'navigation 2'.
  static IconData navigation2;
/// Lucide icon for 'navigation off'.
  static IconData navigationOff;
/// Lucide icon for 'navigation'.
  static IconData navigation;
/// Lucide icon for 'network'.
  static IconData network;
/// Lucide icon for 'newspaper'.
  static IconData newspaper;
/// Lucide icon for 'nfc'.
  static IconData nfc;
/// Lucide icon for 'non binary'.
  static IconData nonBinary;
/// Lucide icon for 'notebook pen'.
  static IconData notebookPen;
/// Lucide icon for 'notebook tabs'.
  static IconData notebookTabs;
/// Lucide icon for 'notebook text'.
  static IconData notebookText;
/// Lucide icon for 'notebook'.
  static IconData notebook;
/// Lucide icon for 'notepad text dashed'.
  static IconData notepadTextDashed;
/// Lucide icon for 'notepad text'.
  static IconData notepadText;
/// Lucide icon for 'nut off'.
  static IconData nutOff;
/// Lucide icon for 'nut'.
  static IconData nut;
/// Lucide icon for 'octagon alert'.
  static IconData octagonAlert;
/// Lucide icon for 'octagon minus'.
  static IconData octagonMinus;
/// Lucide icon for 'octagon pause'.
  static IconData octagonPause;
/// Lucide icon for 'octagon X'.
  static IconData octagonX;
/// Lucide icon for 'octagon'.
  static IconData octagon;
/// Lucide icon for 'omega'.
  static IconData omega;
/// Lucide icon for 'option'.
  static IconData option;
/// Lucide icon for 'orbit'.
  static IconData orbit;
/// Lucide icon for 'origami'.
  static IconData origami;
/// Lucide icon for 'package 2'.
  static IconData package2;
/// Lucide icon for 'package check'.
  static IconData packageCheck;
/// Lucide icon for 'package minus'.
  static IconData packageMinus;
/// Lucide icon for 'package open'.
  static IconData packageOpen;
/// Lucide icon for 'package plus'.
  static IconData packagePlus;
/// Lucide icon for 'package search'.
  static IconData packageSearch;
/// Lucide icon for 'package X'.
  static IconData packageX;
/// Lucide icon for 'package'.
  static IconData package;
/// Lucide icon for 'paint bucket'.
  static IconData paintBucket;
/// Lucide icon for 'paint roller'.
  static IconData paintRoller;
/// Lucide icon for 'paintbrush vertical'.
  static IconData paintbrushVertical;
/// Lucide icon for 'paintbrush'.
  static IconData paintbrush;
/// Lucide icon for 'palette'.
  static IconData palette;
/// Lucide icon for 'panel bottom close'.
  static IconData panelBottomClose;
/// Lucide icon for 'panel bottom dashed'.
  static IconData panelBottomDashed;
/// Lucide icon for 'panel bottom open'.
  static IconData panelBottomOpen;
/// Lucide icon for 'panel bottom'.
  static IconData panelBottom;
/// Lucide icon for 'panel left close'.
  static IconData panelLeftClose;
/// Lucide icon for 'panel left dashed'.
  static IconData panelLeftDashed;
/// Lucide icon for 'panel left open'.
  static IconData panelLeftOpen;
/// Lucide icon for 'panel left'.
  static IconData panelLeft;
/// Lucide icon for 'panel right close'.
  static IconData panelRightClose;
/// Lucide icon for 'panel right dashed'.
  static IconData panelRightDashed;
/// Lucide icon for 'panel right open'.
  static IconData panelRightOpen;
/// Lucide icon for 'panel right'.
  static IconData panelRight;
/// Lucide icon for 'panel top close'.
  static IconData panelTopClose;
/// Lucide icon for 'panel top dashed'.
  static IconData panelTopDashed;
/// Lucide icon for 'panel top open'.
  static IconData panelTopOpen;
/// Lucide icon for 'panel top'.
  static IconData panelTop;
/// Lucide icon for 'panels left bottom'.
  static IconData panelsLeftBottom;
/// Lucide icon for 'panels right bottom'.
  static IconData panelsRightBottom;
/// Lucide icon for 'panels top left'.
  static IconData panelsTopLeft;
/// Lucide icon for 'paperclip'.
  static IconData paperclip;
/// Lucide icon for 'parentheses'.
  static IconData parentheses;
/// Lucide icon for 'parking meter'.
  static IconData parkingMeter;
/// Lucide icon for 'party popper'.
  static IconData partyPopper;
/// Lucide icon for 'pause'.
  static IconData pause;
/// Lucide icon for 'paw print'.
  static IconData pawPrint;
/// Lucide icon for 'pc case'.
  static IconData pcCase;
/// Lucide icon for 'pen line'.
  static IconData penLine;
/// Lucide icon for 'pen off'.
  static IconData penOff;
/// Lucide icon for 'pen tool'.
  static IconData penTool;
/// Lucide icon for 'pen'.
  static IconData pen;
/// Lucide icon for 'pencil line'.
  static IconData pencilLine;
/// Lucide icon for 'pencil off'.
  static IconData pencilOff;
/// Lucide icon for 'pencil ruler'.
  static IconData pencilRuler;
/// Lucide icon for 'pencil'.
  static IconData pencil;
/// Lucide icon for 'pentagon'.
  static IconData pentagon;
/// Lucide icon for 'percent'.
  static IconData percent;
/// Lucide icon for 'person standing'.
  static IconData personStanding;
/// Lucide icon for 'philippine peso'.
  static IconData philippinePeso;
/// Lucide icon for 'phone call'.
  static IconData phoneCall;
/// Lucide icon for 'phone forwarded'.
  static IconData phoneForwarded;
/// Lucide icon for 'phone incoming'.
  static IconData phoneIncoming;
/// Lucide icon for 'phone missed'.
  static IconData phoneMissed;
/// Lucide icon for 'phone off'.
  static IconData phoneOff;
/// Lucide icon for 'phone outgoing'.
  static IconData phoneOutgoing;
/// Lucide icon for 'phone'.
  static IconData phone;
/// Lucide icon for 'pi'.
  static IconData pi;
/// Lucide icon for 'piano'.
  static IconData piano;
/// Lucide icon for 'pickaxe'.
  static IconData pickaxe;
/// Lucide icon for 'picture in picture 2'.
  static IconData pictureInPicture2;
/// Lucide icon for 'picture in picture'.
  static IconData pictureInPicture;
/// Lucide icon for 'piggy bank'.
  static IconData piggyBank;
/// Lucide icon for 'pilcrow left'.
  static IconData pilcrowLeft;
/// Lucide icon for 'pilcrow right'.
  static IconData pilcrowRight;
/// Lucide icon for 'pilcrow'.
  static IconData pilcrow;
/// Lucide icon for 'pill bottle'.
  static IconData pillBottle;
/// Lucide icon for 'pill'.
  static IconData pill;
/// Lucide icon for 'pin off'.
  static IconData pinOff;
/// Lucide icon for 'pin'.
  static IconData pin;
/// Lucide icon for 'pipette'.
  static IconData pipette;
/// Lucide icon for 'pizza'.
  static IconData pizza;
/// Lucide icon for 'plane landing'.
  static IconData planeLanding;
/// Lucide icon for 'plane takeoff'.
  static IconData planeTakeoff;
/// Lucide icon for 'plane'.
  static IconData plane;
/// Lucide icon for 'play'.
  static IconData play;
/// Lucide icon for 'plug 2'.
  static IconData plug2;
/// Lucide icon for 'plug zap'.
  static IconData plugZap;
/// Lucide icon for 'plug'.
  static IconData plug;
/// Lucide icon for 'plus'.
  static IconData plus;
/// Lucide icon for 'pocket knife'.
  static IconData pocketKnife;
/// Lucide icon for 'pocket'.
  static IconData pocket;
/// Lucide icon for 'podcast'.
  static IconData podcast;
/// Lucide icon for 'pointer off'.
  static IconData pointerOff;
/// Lucide icon for 'pointer'.
  static IconData pointer;
/// Lucide icon for 'popcorn'.
  static IconData popcorn;
/// Lucide icon for 'popsicle'.
  static IconData popsicle;
/// Lucide icon for 'pound sterling'.
  static IconData poundSterling;
/// Lucide icon for 'power off'.
  static IconData powerOff;
/// Lucide icon for 'power'.
  static IconData power;
/// Lucide icon for 'presentation'.
  static IconData presentation;
/// Lucide icon for 'printer check'.
  static IconData printerCheck;
/// Lucide icon for 'printer'.
  static IconData printer;
/// Lucide icon for 'projector'.
  static IconData projector;
/// Lucide icon for 'proportions'.
  static IconData proportions;
/// Lucide icon for 'puzzle'.
  static IconData puzzle;
/// Lucide icon for 'pyramid'.
  static IconData pyramid;
/// Lucide icon for 'qr code'.
  static IconData qrCode;
/// Lucide icon for 'quote'.
  static IconData quote;
/// Lucide icon for 'rabbit'.
  static IconData rabbit;
/// Lucide icon for 'radar'.
  static IconData radar;
/// Lucide icon for 'radiation'.
  static IconData radiation;
/// Lucide icon for 'radical'.
  static IconData radical;
/// Lucide icon for 'radio receiver'.
  static IconData radioReceiver;
/// Lucide icon for 'radio tower'.
  static IconData radioTower;
/// Lucide icon for 'radio'.
  static IconData radio;
/// Lucide icon for 'radius'.
  static IconData radius;
/// Lucide icon for 'rail symbol'.
  static IconData railSymbol;
/// Lucide icon for 'rainbow'.
  static IconData rainbow;
/// Lucide icon for 'rat'.
  static IconData rat;
/// Lucide icon for 'ratio'.
  static IconData ratio;
/// Lucide icon for 'receipt cent'.
  static IconData receiptCent;
/// Lucide icon for 'receipt euro'.
  static IconData receiptEuro;
/// Lucide icon for 'receipt indian rupee'.
  static IconData receiptIndianRupee;
/// Lucide icon for 'receipt japanese yen'.
  static IconData receiptJapaneseYen;
/// Lucide icon for 'receipt pound sterling'.
  static IconData receiptPoundSterling;
/// Lucide icon for 'receipt russian ruble'.
  static IconData receiptRussianRuble;
/// Lucide icon for 'receipt swiss franc'.
  static IconData receiptSwissFranc;
/// Lucide icon for 'receipt text'.
  static IconData receiptText;
/// Lucide icon for 'receipt'.
  static IconData receipt;
/// Lucide icon for 'rectangle ellipsis'.
  static IconData rectangleEllipsis;
/// Lucide icon for 'rectangle horizontal'.
  static IconData rectangleHorizontal;
/// Lucide icon for 'rectangle vertical'.
  static IconData rectangleVertical;
/// Lucide icon for 'recycle'.
  static IconData recycle;
/// Lucide icon for 'redo 2'.
  static IconData redo2;
/// Lucide icon for 'redo dot'.
  static IconData redoDot;
/// Lucide icon for 'redo'.
  static IconData redo;
/// Lucide icon for 'refresh ccw dot'.
  static IconData refreshCcwDot;
/// Lucide icon for 'refresh ccw'.
  static IconData refreshCcw;
/// Lucide icon for 'refresh cw off'.
  static IconData refreshCwOff;
/// Lucide icon for 'refresh cw'.
  static IconData refreshCw;
/// Lucide icon for 'refrigerator'.
  static IconData refrigerator;
/// Lucide icon for 'regex'.
  static IconData regex;
/// Lucide icon for 'remove formatting'.
  static IconData removeFormatting;
/// Lucide icon for 'repeat 1'.
  static IconData repeat1;
/// Lucide icon for 'repeat 2'.
  static IconData repeat2;
/// Lucide icon for 'repeat'.
  static IconData repeat;
/// Lucide icon for 'replace all'.
  static IconData replaceAll;
/// Lucide icon for 'replace'.
  static IconData replace;
/// Lucide icon for 'reply all'.
  static IconData replyAll;
/// Lucide icon for 'reply'.
  static IconData reply;
/// Lucide icon for 'rewind'.
  static IconData rewind;
/// Lucide icon for 'ribbon'.
  static IconData ribbon;
/// Lucide icon for 'rocket'.
  static IconData rocket;
/// Lucide icon for 'rocking chair'.
  static IconData rockingChair;
/// Lucide icon for 'roller coaster'.
  static IconData rollerCoaster;
/// Lucide icon for 'rotate 3d'.
  static IconData rotate3d;
/// Lucide icon for 'rotate ccw square'.
  static IconData rotateCcwSquare;
/// Lucide icon for 'rotate ccw'.
  static IconData rotateCcw;
/// Lucide icon for 'rotate cw square'.
  static IconData rotateCwSquare;
/// Lucide icon for 'rotate cw'.
  static IconData rotateCw;
/// Lucide icon for 'route off'.
  static IconData routeOff;
/// Lucide icon for 'route'.
  static IconData route;
/// Lucide icon for 'router'.
  static IconData router;
/// Lucide icon for 'rows 2'.
  static IconData rows2;
/// Lucide icon for 'rows 3'.
  static IconData rows3;
/// Lucide icon for 'rows 4'.
  static IconData rows4;
/// Lucide icon for 'rss'.
  static IconData rss;
/// Lucide icon for 'ruler'.
  static IconData ruler;
/// Lucide icon for 'russian ruble'.
  static IconData russianRuble;
/// Lucide icon for 'sailboat'.
  static IconData sailboat;
/// Lucide icon for 'salad'.
  static IconData salad;
/// Lucide icon for 'sandwich'.
  static IconData sandwich;
/// Lucide icon for 'satellite dish'.
  static IconData satelliteDish;
/// Lucide icon for 'satellite'.
  static IconData satellite;
/// Lucide icon for 'save all'.
  static IconData saveAll;
/// Lucide icon for 'save off'.
  static IconData saveOff;
/// Lucide icon for 'save'.
  static IconData save;
/// Lucide icon for 'scale 3d'.
  static IconData scale3d;
/// Lucide icon for 'scale'.
  static IconData scale;
/// Lucide icon for 'scaling'.
  static IconData scaling;
/// Lucide icon for 'scan barcode'.
  static IconData scanBarcode;
/// Lucide icon for 'scan eye'.
  static IconData scanEye;
/// Lucide icon for 'scan face'.
  static IconData scanFace;
/// Lucide icon for 'scan heart'.
  static IconData scanHeart;
/// Lucide icon for 'scan line'.
  static IconData scanLine;
/// Lucide icon for 'scan qr code'.
  static IconData scanQrCode;
/// Lucide icon for 'scan search'.
  static IconData scanSearch;
/// Lucide icon for 'scan text'.
  static IconData scanText;
/// Lucide icon for 'scan'.
  static IconData scan;
/// Lucide icon for 'school'.
  static IconData school;
/// Lucide icon for 'scissors line dashed'.
  static IconData scissorsLineDashed;
/// Lucide icon for 'scissors'.
  static IconData scissors;
/// Lucide icon for 'screen share off'.
  static IconData screenShareOff;
/// Lucide icon for 'screen share'.
  static IconData screenShare;
/// Lucide icon for 'scroll text'.
  static IconData scrollText;
/// Lucide icon for 'scroll'.
  static IconData scroll;
/// Lucide icon for 'search check'.
  static IconData searchCheck;
/// Lucide icon for 'search code'.
  static IconData searchCode;
/// Lucide icon for 'search slash'.
  static IconData searchSlash;
/// Lucide icon for 'search X'.
  static IconData searchX;
/// Lucide icon for 'search'.
  static IconData search;
/// Lucide icon for 'section'.
  static IconData section;
/// Lucide icon for 'send horizontal'.
  static IconData sendHorizontal;
/// Lucide icon for 'send to back'.
  static IconData sendToBack;
/// Lucide icon for 'send'.
  static IconData send;
/// Lucide icon for 'separator horizontal'.
  static IconData separatorHorizontal;
/// Lucide icon for 'separator vertical'.
  static IconData separatorVertical;
/// Lucide icon for 'server cog'.
  static IconData serverCog;
/// Lucide icon for 'server crash'.
  static IconData serverCrash;
/// Lucide icon for 'server off'.
  static IconData serverOff;
/// Lucide icon for 'server'.
  static IconData server;
/// Lucide icon for 'settings 2'.
  static IconData settings2;
/// Lucide icon for 'settings'.
  static IconData settings;
/// Lucide icon for 'shapes'.
  static IconData shapes;
/// Lucide icon for 'share 2'.
  static IconData share2;
/// Lucide icon for 'share'.
  static IconData share;
/// Lucide icon for 'sheet'.
  static IconData sheet;
/// Lucide icon for 'shell'.
  static IconData shell;
/// Lucide icon for 'shield alert'.
  static IconData shieldAlert;
/// Lucide icon for 'shield ban'.
  static IconData shieldBan;
/// Lucide icon for 'shield check'.
  static IconData shieldCheck;
/// Lucide icon for 'shield ellipsis'.
  static IconData shieldEllipsis;
/// Lucide icon for 'shield half'.
  static IconData shieldHalf;
/// Lucide icon for 'shield minus'.
  static IconData shieldMinus;
/// Lucide icon for 'shield off'.
  static IconData shieldOff;
/// Lucide icon for 'shield plus'.
  static IconData shieldPlus;
/// Lucide icon for 'shield question'.
  static IconData shieldQuestion;
/// Lucide icon for 'shield user'.
  static IconData shieldUser;
/// Lucide icon for 'shield X'.
  static IconData shieldX;
/// Lucide icon for 'shield'.
  static IconData shield;
/// Lucide icon for 'ship wheel'.
  static IconData shipWheel;
/// Lucide icon for 'ship'.
  static IconData ship;
/// Lucide icon for 'shirt'.
  static IconData shirt;
/// Lucide icon for 'shopping bag'.
  static IconData shoppingBag;
/// Lucide icon for 'shopping basket'.
  static IconData shoppingBasket;
/// Lucide icon for 'shopping cart'.
  static IconData shoppingCart;
/// Lucide icon for 'shovel'.
  static IconData shovel;
/// Lucide icon for 'shower head'.
  static IconData showerHead;
/// Lucide icon for 'shrink'.
  static IconData shrink;
/// Lucide icon for 'shrub'.
  static IconData shrub;
/// Lucide icon for 'shuffle'.
  static IconData shuffle;
/// Lucide icon for 'sigma'.
  static IconData sigma;
/// Lucide icon for 'signal high'.
  static IconData signalHigh;
/// Lucide icon for 'signal low'.
  static IconData signalLow;
/// Lucide icon for 'signal medium'.
  static IconData signalMedium;
/// Lucide icon for 'signal zero'.
  static IconData signalZero;
/// Lucide icon for 'signal'.
  static IconData signal;
/// Lucide icon for 'signature'.
  static IconData signature;
/// Lucide icon for 'signpost big'.
  static IconData signpostBig;
/// Lucide icon for 'signpost'.
  static IconData signpost;
/// Lucide icon for 'siren'.
  static IconData siren;
/// Lucide icon for 'skip back'.
  static IconData skipBack;
/// Lucide icon for 'skip forward'.
  static IconData skipForward;
/// Lucide icon for 'skull'.
  static IconData skull;
/// Lucide icon for 'slack'.
  static IconData slack;
/// Lucide icon for 'slash'.
  static IconData slash;
/// Lucide icon for 'slice'.
  static IconData slice;
/// Lucide icon for 'sliders horizontal'.
  static IconData slidersHorizontal;
/// Lucide icon for 'sliders vertical'.
  static IconData slidersVertical;
/// Lucide icon for 'smartphone charging'.
  static IconData smartphoneCharging;
/// Lucide icon for 'smartphone nfc'.
  static IconData smartphoneNfc;
/// Lucide icon for 'smartphone'.
  static IconData smartphone;
/// Lucide icon for 'smile plus'.
  static IconData smilePlus;
/// Lucide icon for 'smile'.
  static IconData smile;
/// Lucide icon for 'snail'.
  static IconData snail;
/// Lucide icon for 'snowflake'.
  static IconData snowflake;
/// Lucide icon for 'sofa'.
  static IconData sofa;
/// Lucide icon for 'soup'.
  static IconData soup;
/// Lucide icon for 'space'.
  static IconData space;
/// Lucide icon for 'spade'.
  static IconData spade;
/// Lucide icon for 'sparkle'.
  static IconData sparkle;
/// Lucide icon for 'sparkles'.
  static IconData sparkles;
/// Lucide icon for 'speaker'.
  static IconData speaker;
/// Lucide icon for 'speech'.
  static IconData speech;
/// Lucide icon for 'spell check 2'.
  static IconData spellCheck2;
/// Lucide icon for 'spell check'.
  static IconData spellCheck;
/// Lucide icon for 'spline'.
  static IconData spline;
/// Lucide icon for 'split'.
  static IconData split;
/// Lucide icon for 'spray can'.
  static IconData sprayCan;
/// Lucide icon for 'sprout'.
  static IconData sprout;
/// Lucide icon for 'square activity'.
  static IconData squareActivity;
/// Lucide icon for 'square arrow down left'.
  static IconData squareArrowDownLeft;
/// Lucide icon for 'square arrow down right'.
  static IconData squareArrowDownRight;
/// Lucide icon for 'square arrow down'.
  static IconData squareArrowDown;
/// Lucide icon for 'square arrow left'.
  static IconData squareArrowLeft;
/// Lucide icon for 'square arrow out down left'.
  static IconData squareArrowOutDownLeft;
/// Lucide icon for 'square arrow out down right'.
  static IconData squareArrowOutDownRight;
/// Lucide icon for 'square arrow out up left'.
  static IconData squareArrowOutUpLeft;
/// Lucide icon for 'square arrow out up right'.
  static IconData squareArrowOutUpRight;
/// Lucide icon for 'square arrow right'.
  static IconData squareArrowRight;
/// Lucide icon for 'square arrow up left'.
  static IconData squareArrowUpLeft;
/// Lucide icon for 'square arrow up right'.
  static IconData squareArrowUpRight;
/// Lucide icon for 'square arrow up'.
  static IconData squareArrowUp;
/// Lucide icon for 'square asterisk'.
  static IconData squareAsterisk;
/// Lucide icon for 'square bottom dashed scissors'.
  static IconData squareBottomDashedScissors;
/// Lucide icon for 'square chart gantt'.
  static IconData squareChartGantt;
/// Lucide icon for 'square check big'.
  static IconData squareCheckBig;
/// Lucide icon for 'square check'.
  static IconData squareCheck;
/// Lucide icon for 'square chevron down'.
  static IconData squareChevronDown;
/// Lucide icon for 'square chevron left'.
  static IconData squareChevronLeft;
/// Lucide icon for 'square chevron right'.
  static IconData squareChevronRight;
/// Lucide icon for 'square chevron up'.
  static IconData squareChevronUp;
/// Lucide icon for 'square code'.
  static IconData squareCode;
/// Lucide icon for 'square dashed bottom code'.
  static IconData squareDashedBottomCode;
/// Lucide icon for 'square dashed bottom'.
  static IconData squareDashedBottom;
/// Lucide icon for 'square dashed kanban'.
  static IconData squareDashedKanban;
/// Lucide icon for 'square dashed mouse pointer'.
  static IconData squareDashedMousePointer;
/// Lucide icon for 'square dashed'.
  static IconData squareDashed;
/// Lucide icon for 'square divide'.
  static IconData squareDivide;
/// Lucide icon for 'square dot'.
  static IconData squareDot;
/// Lucide icon for 'square equal'.
  static IconData squareEqual;
/// Lucide icon for 'square function'.
  static IconData squareFunction;
/// Lucide icon for 'square kanban'.
  static IconData squareKanban;
/// Lucide icon for 'square library'.
  static IconData squareLibrary;
/// Lucide icon for 'square M'.
  static IconData squareM;
/// Lucide icon for 'square menu'.
  static IconData squareMenu;
/// Lucide icon for 'square minus'.
  static IconData squareMinus;
/// Lucide icon for 'square mouse pointer'.
  static IconData squareMousePointer;
/// Lucide icon for 'square parking off'.
  static IconData squareParkingOff;
/// Lucide icon for 'square parking'.
  static IconData squareParking;
/// Lucide icon for 'square pen'.
  static IconData squarePen;
/// Lucide icon for 'square percent'.
  static IconData squarePercent;
/// Lucide icon for 'square pi'.
  static IconData squarePi;
/// Lucide icon for 'square pilcrow'.
  static IconData squarePilcrow;
/// Lucide icon for 'square play'.
  static IconData squarePlay;
/// Lucide icon for 'square plus'.
  static IconData squarePlus;
/// Lucide icon for 'square power'.
  static IconData squarePower;
/// Lucide icon for 'square radical'.
  static IconData squareRadical;
/// Lucide icon for 'square round corner'.
  static IconData squareRoundCorner;
/// Lucide icon for 'square scissors'.
  static IconData squareScissors;
/// Lucide icon for 'square sigma'.
  static IconData squareSigma;
/// Lucide icon for 'square slash'.
  static IconData squareSlash;
/// Lucide icon for 'square split horizontal'.
  static IconData squareSplitHorizontal;
/// Lucide icon for 'square split vertical'.
  static IconData squareSplitVertical;
/// Lucide icon for 'square square'.
  static IconData squareSquare;
/// Lucide icon for 'square stack'.
  static IconData squareStack;
/// Lucide icon for 'square terminal'.
  static IconData squareTerminal;
/// Lucide icon for 'square user round'.
  static IconData squareUserRound;
/// Lucide icon for 'square user'.
  static IconData squareUser;
/// Lucide icon for 'square X'.
  static IconData squareX;
/// Lucide icon for 'square'.
  static IconData square;
/// Lucide icon for 'squircle'.
  static IconData squircle;
/// Lucide icon for 'squirrel'.
  static IconData squirrel;
/// Lucide icon for 'stamp'.
  static IconData stamp;
/// Lucide icon for 'star half'.
  static IconData starHalf;
/// Lucide icon for 'star off'.
  static IconData starOff;
/// Lucide icon for 'star'.
  static IconData star;
/// Lucide icon for 'step back'.
  static IconData stepBack;
/// Lucide icon for 'step forward'.
  static IconData stepForward;
/// Lucide icon for 'stethoscope'.
  static IconData stethoscope;
/// Lucide icon for 'sticker'.
  static IconData sticker;
/// Lucide icon for 'sticky note'.
  static IconData stickyNote;
/// Lucide icon for 'store'.
  static IconData store;
/// Lucide icon for 'stretch horizontal'.
  static IconData stretchHorizontal;
/// Lucide icon for 'stretch vertical'.
  static IconData stretchVertical;
/// Lucide icon for 'strikethrough'.
  static IconData strikethrough;
/// Lucide icon for 'subscript'.
  static IconData subscript;
/// Lucide icon for 'sun dim'.
  static IconData sunDim;
/// Lucide icon for 'sun medium'.
  static IconData sunMedium;
/// Lucide icon for 'sun moon'.
  static IconData sunMoon;
/// Lucide icon for 'sun snow'.
  static IconData sunSnow;
/// Lucide icon for 'sun'.
  static IconData sun;
/// Lucide icon for 'sunrise'.
  static IconData sunrise;
/// Lucide icon for 'sunset'.
  static IconData sunset;
/// Lucide icon for 'superscript'.
  static IconData superscript;
/// Lucide icon for 'swatch book'.
  static IconData swatchBook;
/// Lucide icon for 'swiss franc'.
  static IconData swissFranc;
/// Lucide icon for 'switch camera'.
  static IconData switchCamera;
/// Lucide icon for 'sword'.
  static IconData sword;
/// Lucide icon for 'swords'.
  static IconData swords;
/// Lucide icon for 'syringe'.
  static IconData syringe;
/// Lucide icon for 'table 2'.
  static IconData table2;
/// Lucide icon for 'table cells merge'.
  static IconData tableCellsMerge;
/// Lucide icon for 'table cells split'.
  static IconData tableCellsSplit;
/// Lucide icon for 'table columns split'.
  static IconData tableColumnsSplit;
/// Lucide icon for 'table of contents'.
  static IconData tableOfContents;
/// Lucide icon for 'table properties'.
  static IconData tableProperties;
/// Lucide icon for 'table rows split'.
  static IconData tableRowsSplit;
/// Lucide icon for 'table'.
  static IconData table;
/// Lucide icon for 'tablet smartphone'.
  static IconData tabletSmartphone;
/// Lucide icon for 'tablet'.
  static IconData tablet;
/// Lucide icon for 'tablets'.
  static IconData tablets;
/// Lucide icon for 'tag'.
  static IconData tag;
/// Lucide icon for 'tags'.
  static IconData tags;
/// Lucide icon for 'tally 1'.
  static IconData tally1;
/// Lucide icon for 'tally 2'.
  static IconData tally2;
/// Lucide icon for 'tally 3'.
  static IconData tally3;
/// Lucide icon for 'tally 4'.
  static IconData tally4;
/// Lucide icon for 'tally 5'.
  static IconData tally5;
/// Lucide icon for 'tangent'.
  static IconData tangent;
/// Lucide icon for 'target'.
  static IconData target;
/// Lucide icon for 'telescope'.
  static IconData telescope;
/// Lucide icon for 'tent tree'.
  static IconData tentTree;
/// Lucide icon for 'tent'.
  static IconData tent;
/// Lucide icon for 'terminal'.
  static IconData terminal;
/// Lucide icon for 'test tube diagonal'.
  static IconData testTubeDiagonal;
/// Lucide icon for 'test tube'.
  static IconData testTube;
/// Lucide icon for 'test tubes'.
  static IconData testTubes;
/// Lucide icon for 'text cursor input'.
  static IconData textCursorInput;
/// Lucide icon for 'text cursor'.
  static IconData textCursor;
/// Lucide icon for 'text quote'.
  static IconData textQuote;
/// Lucide icon for 'text search'.
  static IconData textSearch;
/// Lucide icon for 'text select'.
  static IconData textSelect;
/// Lucide icon for 'text'.
  static IconData text;
/// Lucide icon for 'theater'.
  static IconData theater;
/// Lucide icon for 'thermometer snowflake'.
  static IconData thermometerSnowflake;
/// Lucide icon for 'thermometer sun'.
  static IconData thermometerSun;
/// Lucide icon for 'thermometer'.
  static IconData thermometer;
/// Lucide icon for 'thumbs down'.
  static IconData thumbsDown;
/// Lucide icon for 'thumbs up'.
  static IconData thumbsUp;
/// Lucide icon for 'ticket check'.
  static IconData ticketCheck;
/// Lucide icon for 'ticket minus'.
  static IconData ticketMinus;
/// Lucide icon for 'ticket percent'.
  static IconData ticketPercent;
/// Lucide icon for 'ticket plus'.
  static IconData ticketPlus;
/// Lucide icon for 'ticket slash'.
  static IconData ticketSlash;
/// Lucide icon for 'ticket X'.
  static IconData ticketX;
/// Lucide icon for 'ticket'.
  static IconData ticket;
/// Lucide icon for 'tickets plane'.
  static IconData ticketsPlane;
/// Lucide icon for 'tickets'.
  static IconData tickets;
/// Lucide icon for 'timer off'.
  static IconData timerOff;
/// Lucide icon for 'timer reset'.
  static IconData timerReset;
/// Lucide icon for 'timer'.
  static IconData timer;
/// Lucide icon for 'toggle left'.
  static IconData toggleLeft;
/// Lucide icon for 'toggle right'.
  static IconData toggleRight;
/// Lucide icon for 'toilet'.
  static IconData toilet;
/// Lucide icon for 'tornado'.
  static IconData tornado;
/// Lucide icon for 'torus'.
  static IconData torus;
/// Lucide icon for 'touchpad off'.
  static IconData touchpadOff;
/// Lucide icon for 'touchpad'.
  static IconData touchpad;
/// Lucide icon for 'tower control'.
  static IconData towerControl;
/// Lucide icon for 'toy brick'.
  static IconData toyBrick;
/// Lucide icon for 'tractor'.
  static IconData tractor;
/// Lucide icon for 'traffic cone'.
  static IconData trafficCone;
/// Lucide icon for 'train front tunnel'.
  static IconData trainFrontTunnel;
/// Lucide icon for 'train front'.
  static IconData trainFront;
/// Lucide icon for 'train track'.
  static IconData trainTrack;
/// Lucide icon for 'tram front'.
  static IconData tramFront;
/// Lucide icon for 'transgender'.
  static IconData transgender;
/// Lucide icon for 'trash 2'.
  static IconData trash2;
/// Lucide icon for 'trash'.
  static IconData trash;
/// Lucide icon for 'tree deciduous'.
  static IconData treeDeciduous;
/// Lucide icon for 'tree palm'.
  static IconData treePalm;
/// Lucide icon for 'tree pine'.
  static IconData treePine;
/// Lucide icon for 'trees'.
  static IconData trees;
/// Lucide icon for 'trello'.
  static IconData trello;
/// Lucide icon for 'trending down'.
  static IconData trendingDown;
/// Lucide icon for 'trending up down'.
  static IconData trendingUpDown;
/// Lucide icon for 'trending up'.
  static IconData trendingUp;
/// Lucide icon for 'triangle alert'.
  static IconData triangleAlert;
/// Lucide icon for 'triangle dashed'.
  static IconData triangleDashed;
/// Lucide icon for 'triangle right'.
  static IconData triangleRight;
/// Lucide icon for 'triangle'.
  static IconData triangle;
/// Lucide icon for 'trophy'.
  static IconData trophy;
/// Lucide icon for 'truck'.
  static IconData truck;
/// Lucide icon for 'turtle'.
  static IconData turtle;
/// Lucide icon for 'tv minimal play'.
  static IconData tvMinimalPlay;
/// Lucide icon for 'tv minimal'.
  static IconData tvMinimal;
/// Lucide icon for 'tv'.
  static IconData tv;
/// Lucide icon for 'twitch'.
  static IconData twitch;
/// Lucide icon for 'twitter'.
  static IconData twitter;
/// Lucide icon for 'type outline'.
  static IconData typeOutline;
/// Lucide icon for 'type'.
  static IconData type;
/// Lucide icon for 'umbrella off'.
  static IconData umbrellaOff;
/// Lucide icon for 'umbrella'.
  static IconData umbrella;
/// Lucide icon for 'underline'.
  static IconData underline;
/// Lucide icon for 'undo 2'.
  static IconData undo2;
/// Lucide icon for 'undo dot'.
  static IconData undoDot;
/// Lucide icon for 'undo'.
  static IconData undo;
/// Lucide icon for 'unfold horizontal'.
  static IconData unfoldHorizontal;
/// Lucide icon for 'unfold vertical'.
  static IconData unfoldVertical;
/// Lucide icon for 'ungroup'.
  static IconData ungroup;
/// Lucide icon for 'university'.
  static IconData university;
/// Lucide icon for 'unlink 2'.
  static IconData unlink2;
/// Lucide icon for 'unlink'.
  static IconData unlink;
/// Lucide icon for 'unplug'.
  static IconData unplug;
/// Lucide icon for 'upload'.
  static IconData upload;
/// Lucide icon for 'usb'.
  static IconData usb;
/// Lucide icon for 'user check'.
  static IconData userCheck;
/// Lucide icon for 'user cog'.
  static IconData userCog;
/// Lucide icon for 'user minus'.
  static IconData userMinus;
/// Lucide icon for 'user pen'.
  static IconData userPen;
/// Lucide icon for 'user plus'.
  static IconData userPlus;
/// Lucide icon for 'user round check'.
  static IconData userRoundCheck;
/// Lucide icon for 'user round cog'.
  static IconData userRoundCog;
/// Lucide icon for 'user round minus'.
  static IconData userRoundMinus;
/// Lucide icon for 'user round pen'.
  static IconData userRoundPen;
/// Lucide icon for 'user round plus'.
  static IconData userRoundPlus;
/// Lucide icon for 'user round search'.
  static IconData userRoundSearch;
/// Lucide icon for 'user round X'.
  static IconData userRoundX;
/// Lucide icon for 'user round'.
  static IconData userRound;
/// Lucide icon for 'user search'.
  static IconData userSearch;
/// Lucide icon for 'user X'.
  static IconData userX;
/// Lucide icon for 'user'.
  static IconData user;
/// Lucide icon for 'users round'.
  static IconData usersRound;
/// Lucide icon for 'users'.
  static IconData users;
/// Lucide icon for 'utensils crossed'.
  static IconData utensilsCrossed;
/// Lucide icon for 'utensils'.
  static IconData utensils;
/// Lucide icon for 'utility pole'.
  static IconData utilityPole;
/// Lucide icon for 'variable'.
  static IconData variable;
/// Lucide icon for 'vault'.
  static IconData vault;
/// Lucide icon for 'vegan'.
  static IconData vegan;
/// Lucide icon for 'venetian mask'.
  static IconData venetianMask;
/// Lucide icon for 'venus and mars'.
  static IconData venusAndMars;
/// Lucide icon for 'venus'.
  static IconData venus;
/// Lucide icon for 'vibrate off'.
  static IconData vibrateOff;
/// Lucide icon for 'vibrate'.
  static IconData vibrate;
/// Lucide icon for 'video off'.
  static IconData videoOff;
/// Lucide icon for 'video'.
  static IconData video;
/// Lucide icon for 'videotape'.
  static IconData videotape;
/// Lucide icon for 'view'.
  static IconData view;
/// Lucide icon for 'voicemail'.
  static IconData voicemail;
/// Lucide icon for 'volleyball'.
  static IconData volleyball;
/// Lucide icon for 'volume 1'.
  static IconData volume1;
/// Lucide icon for 'volume 2'.
  static IconData volume2;
/// Lucide icon for 'volume off'.
  static IconData volumeOff;
/// Lucide icon for 'volume X'.
  static IconData volumeX;
/// Lucide icon for 'volume'.
  static IconData volume;
/// Lucide icon for 'vote'.
  static IconData vote;
/// Lucide icon for 'wallet cards'.
  static IconData walletCards;
/// Lucide icon for 'wallet minimal'.
  static IconData walletMinimal;
/// Lucide icon for 'wallet'.
  static IconData wallet;
/// Lucide icon for 'wallpaper'.
  static IconData wallpaper;
/// Lucide icon for 'wand sparkles'.
  static IconData wandSparkles;
/// Lucide icon for 'wand'.
  static IconData wand;
/// Lucide icon for 'warehouse'.
  static IconData warehouse;
/// Lucide icon for 'washing machine'.
  static IconData washingMachine;
/// Lucide icon for 'watch'.
  static IconData watch;
/// Lucide icon for 'waves ladder'.
  static IconData wavesLadder;
/// Lucide icon for 'waves'.
  static IconData waves;
/// Lucide icon for 'waypoints'.
  static IconData waypoints;
/// Lucide icon for 'webcam'.
  static IconData webcam;
/// Lucide icon for 'webhook off'.
  static IconData webhookOff;
/// Lucide icon for 'webhook'.
  static IconData webhook;
/// Lucide icon for 'weight'.
  static IconData weight;
/// Lucide icon for 'wheat off'.
  static IconData wheatOff;
/// Lucide icon for 'wheat'.
  static IconData wheat;
/// Lucide icon for 'whole word'.
  static IconData wholeWord;
/// Lucide icon for 'wifi high'.
  static IconData wifiHigh;
/// Lucide icon for 'wifi low'.
  static IconData wifiLow;
/// Lucide icon for 'wifi off'.
  static IconData wifiOff;
/// Lucide icon for 'wifi zero'.
  static IconData wifiZero;
/// Lucide icon for 'wifi'.
  static IconData wifi;
/// Lucide icon for 'wind arrow down'.
  static IconData windArrowDown;
/// Lucide icon for 'wind'.
  static IconData wind;
/// Lucide icon for 'wine off'.
  static IconData wineOff;
/// Lucide icon for 'wine'.
  static IconData wine;
/// Lucide icon for 'workflow'.
  static IconData workflow;
/// Lucide icon for 'worm'.
  static IconData worm;
/// Lucide icon for 'wrap text'.
  static IconData wrapText;
/// Lucide icon for 'wrench'.
  static IconData wrench;
/// Lucide icon for 'X'.
  static IconData x;
/// Lucide icon for 'youtube'.
  static IconData youtube;
/// Lucide icon for 'zap off'.
  static IconData zapOff;
/// Lucide icon for 'zap'.
  static IconData zap;
/// Lucide icon for 'zoom in'.
  static IconData zoomIn;
/// Lucide icon for 'zoom out'.
  static IconData zoomOut;
}
/// A collection of Bootstrap Icons as Flutter IconData.
///
/// Provides access to the complete Bootstrap Icons font family.
/// Each icon is defined as a static constant [IconData] that can be
/// used directly with Flutter's [Icon] widget.
///
/// Example:
/// ```dart
/// Icon(BootstrapIcons.alarm)
/// ```
class BootstrapIcons {
/// Bootstrap icon for icon123.
  static IconData icon123;
/// Bootstrap icon for alarm fill.
  static IconData alarmFill;
/// Bootstrap icon for alarm.
  static IconData alarm;
/// Bootstrap icon for align bottom.
  static IconData alignBottom;
/// Bootstrap icon for align center.
  static IconData alignCenter;
/// Bootstrap icon for align end.
  static IconData alignEnd;
/// Bootstrap icon for align middle.
  static IconData alignMiddle;
/// Bootstrap icon for align start.
  static IconData alignStart;
/// Bootstrap icon for align top.
  static IconData alignTop;
/// Bootstrap icon for alt.
  static IconData alt;
/// Bootstrap icon for app indicator.
  static IconData appIndicator;
/// Bootstrap icon for app.
  static IconData app;
/// Bootstrap icon for archive fill.
  static IconData archiveFill;
/// Bootstrap icon for archive.
  static IconData archive;
/// Bootstrap icon for arrow90deg down.
  static IconData arrow90degDown;
/// Bootstrap icon for arrow90deg left.
  static IconData arrow90degLeft;
/// Bootstrap icon for arrow90deg right.
  static IconData arrow90degRight;
/// Bootstrap icon for arrow90deg up.
  static IconData arrow90degUp;
/// Bootstrap icon for arrow bar down.
  static IconData arrowBarDown;
/// Bootstrap icon for arrow bar left.
  static IconData arrowBarLeft;
/// Bootstrap icon for arrow bar right.
  static IconData arrowBarRight;
/// Bootstrap icon for arrow bar up.
  static IconData arrowBarUp;
/// Bootstrap icon for arrow clockwise.
  static IconData arrowClockwise;
/// Bootstrap icon for arrow counterclockwise.
  static IconData arrowCounterclockwise;
/// Bootstrap icon for arrow down circle fill.
  static IconData arrowDownCircleFill;
/// Bootstrap icon for arrow down circle.
  static IconData arrowDownCircle;
/// Bootstrap icon for arrow down left circle fill.
  static IconData arrowDownLeftCircleFill;
/// Bootstrap icon for arrow down left circle.
  static IconData arrowDownLeftCircle;
/// Bootstrap icon for arrow down left square fill.
  static IconData arrowDownLeftSquareFill;
/// Bootstrap icon for arrow down left square.
  static IconData arrowDownLeftSquare;
/// Bootstrap icon for arrow down left.
  static IconData arrowDownLeft;
/// Bootstrap icon for arrow down right circle fill.
  static IconData arrowDownRightCircleFill;
/// Bootstrap icon for arrow down right circle.
  static IconData arrowDownRightCircle;
/// Bootstrap icon for arrow down right square fill.
  static IconData arrowDownRightSquareFill;
/// Bootstrap icon for arrow down right square.
  static IconData arrowDownRightSquare;
/// Bootstrap icon for arrow down right.
  static IconData arrowDownRight;
/// Bootstrap icon for arrow down short.
  static IconData arrowDownShort;
/// Bootstrap icon for arrow down square fill.
  static IconData arrowDownSquareFill;
/// Bootstrap icon for arrow down square.
  static IconData arrowDownSquare;
/// Bootstrap icon for arrow down up.
  static IconData arrowDownUp;
/// Bootstrap icon for arrow down.
  static IconData arrowDown;
/// Bootstrap icon for arrow left circle fill.
  static IconData arrowLeftCircleFill;
/// Bootstrap icon for arrow left circle.
  static IconData arrowLeftCircle;
/// Bootstrap icon for arrow left right.
  static IconData arrowLeftRight;
/// Bootstrap icon for arrow left short.
  static IconData arrowLeftShort;
/// Bootstrap icon for arrow left square fill.
  static IconData arrowLeftSquareFill;
/// Bootstrap icon for arrow left square.
  static IconData arrowLeftSquare;
/// Bootstrap icon for arrow left.
  static IconData arrowLeft;
/// Bootstrap icon for arrow repeat.
  static IconData arrowRepeat;
/// Bootstrap icon for arrow return left.
  static IconData arrowReturnLeft;
/// Bootstrap icon for arrow return right.
  static IconData arrowReturnRight;
/// Bootstrap icon for arrow right circle fill.
  static IconData arrowRightCircleFill;
/// Bootstrap icon for arrow right circle.
  static IconData arrowRightCircle;
/// Bootstrap icon for arrow right short.
  static IconData arrowRightShort;
/// Bootstrap icon for arrow right square fill.
  static IconData arrowRightSquareFill;
/// Bootstrap icon for arrow right square.
  static IconData arrowRightSquare;
/// Bootstrap icon for arrow right.
  static IconData arrowRight;
/// Bootstrap icon for arrow up circle fill.
  static IconData arrowUpCircleFill;
/// Bootstrap icon for arrow up circle.
  static IconData arrowUpCircle;
/// Bootstrap icon for arrow up left circle fill.
  static IconData arrowUpLeftCircleFill;
/// Bootstrap icon for arrow up left circle.
  static IconData arrowUpLeftCircle;
/// Bootstrap icon for arrow up left square fill.
  static IconData arrowUpLeftSquareFill;
/// Bootstrap icon for arrow up left square.
  static IconData arrowUpLeftSquare;
/// Bootstrap icon for arrow up left.
  static IconData arrowUpLeft;
/// Bootstrap icon for arrow up right circle fill.
  static IconData arrowUpRightCircleFill;
/// Bootstrap icon for arrow up right circle.
  static IconData arrowUpRightCircle;
/// Bootstrap icon for arrow up right square fill.
  static IconData arrowUpRightSquareFill;
/// Bootstrap icon for arrow up right square.
  static IconData arrowUpRightSquare;
/// Bootstrap icon for arrow up right.
  static IconData arrowUpRight;
/// Bootstrap icon for arrow up short.
  static IconData arrowUpShort;
/// Bootstrap icon for arrow up square fill.
  static IconData arrowUpSquareFill;
/// Bootstrap icon for arrow up square.
  static IconData arrowUpSquare;
/// Bootstrap icon for arrow up.
  static IconData arrowUp;
/// Bootstrap icon for arrows angle contract.
  static IconData arrowsAngleContract;
/// Bootstrap icon for arrows angle expand.
  static IconData arrowsAngleExpand;
/// Bootstrap icon for arrows collapse.
  static IconData arrowsCollapse;
/// Bootstrap icon for arrows expand.
  static IconData arrowsExpand;
/// Bootstrap icon for arrows fullscreen.
  static IconData arrowsFullscreen;
/// Bootstrap icon for arrows move.
  static IconData arrowsMove;
/// Bootstrap icon for aspect ratio fill.
  static IconData aspectRatioFill;
/// Bootstrap icon for aspect ratio.
  static IconData aspectRatio;
/// Bootstrap icon for asterisk.
  static IconData asterisk;
/// Bootstrap icon for at.
  static IconData at;
/// Bootstrap icon for award fill.
  static IconData awardFill;
/// Bootstrap icon for award.
  static IconData award;
/// Bootstrap icon for back.
  static IconData back;
/// Bootstrap icon for backspace fill.
  static IconData backspaceFill;
/// Bootstrap icon for backspace reverse fill.
  static IconData backspaceReverseFill;
/// Bootstrap icon for backspace reverse.
  static IconData backspaceReverse;
/// Bootstrap icon for backspace.
  static IconData backspace;
/// Bootstrap icon for badge3d fill.
  static IconData badge3dFill;
/// Bootstrap icon for badge3d.
  static IconData badge3d;
/// Bootstrap icon for badge4k fill.
  static IconData badge4kFill;
/// Bootstrap icon for badge4k.
  static IconData badge4k;
/// Bootstrap icon for badge8k fill.
  static IconData badge8kFill;
/// Bootstrap icon for badge8k.
  static IconData badge8k;
/// Bootstrap icon for badge ad fill.
  static IconData badgeAdFill;
/// Bootstrap icon for badge ad.
  static IconData badgeAd;
/// Bootstrap icon for badge ar fill.
  static IconData badgeArFill;
/// Bootstrap icon for badge ar.
  static IconData badgeAr;
/// Bootstrap icon for badge cc fill.
  static IconData badgeCcFill;
/// Bootstrap icon for badge cc.
  static IconData badgeCc;
/// Bootstrap icon for badge hd fill.
  static IconData badgeHdFill;
/// Bootstrap icon for badge hd.
  static IconData badgeHd;
/// Bootstrap icon for badge tm fill.
  static IconData badgeTmFill;
/// Bootstrap icon for badge tm.
  static IconData badgeTm;
/// Bootstrap icon for badge vo fill.
  static IconData badgeVoFill;
/// Bootstrap icon for badge vo.
  static IconData badgeVo;
/// Bootstrap icon for badge vr fill.
  static IconData badgeVrFill;
/// Bootstrap icon for badge vr.
  static IconData badgeVr;
/// Bootstrap icon for badge wc fill.
  static IconData badgeWcFill;
/// Bootstrap icon for badge wc.
  static IconData badgeWc;
/// Bootstrap icon for bag check fill.
  static IconData bagCheckFill;
/// Bootstrap icon for bag check.
  static IconData bagCheck;
/// Bootstrap icon for bag dash fill.
  static IconData bagDashFill;
/// Bootstrap icon for bag dash.
  static IconData bagDash;
/// Bootstrap icon for bag fill.
  static IconData bagFill;
/// Bootstrap icon for bag plus fill.
  static IconData bagPlusFill;
/// Bootstrap icon for bag plus.
  static IconData bagPlus;
/// Bootstrap icon for bag x fill.
  static IconData bagXFill;
/// Bootstrap icon for bag x.
  static IconData bagX;
/// Bootstrap icon for bag.
  static IconData bag;
/// Bootstrap icon for bar chart fill.
  static IconData barChartFill;
/// Bootstrap icon for bar chart line fill.
  static IconData barChartLineFill;
/// Bootstrap icon for bar chart line.
  static IconData barChartLine;
/// Bootstrap icon for bar chart steps.
  static IconData barChartSteps;
/// Bootstrap icon for bar chart.
  static IconData barChart;
/// Bootstrap icon for basket fill.
  static IconData basketFill;
/// Bootstrap icon for basket.
  static IconData basket;
/// Bootstrap icon for basket2 fill.
  static IconData basket2Fill;
/// Bootstrap icon for basket2.
  static IconData basket2;
/// Bootstrap icon for basket3 fill.
  static IconData basket3Fill;
/// Bootstrap icon for basket3.
  static IconData basket3;
/// Bootstrap icon for battery charging.
  static IconData batteryCharging;
/// Bootstrap icon for battery full.
  static IconData batteryFull;
/// Bootstrap icon for battery half.
  static IconData batteryHalf;
/// Bootstrap icon for battery.
  static IconData battery;
/// Bootstrap icon for bell fill.
  static IconData bellFill;
/// Bootstrap icon for bell.
  static IconData bell;
/// Bootstrap icon for bezier.
  static IconData bezier;
/// Bootstrap icon for bezier2.
  static IconData bezier2;
/// Bootstrap icon for bicycle.
  static IconData bicycle;
/// Bootstrap icon for binoculars fill.
  static IconData binocularsFill;
/// Bootstrap icon for binoculars.
  static IconData binoculars;
/// Bootstrap icon for blockquote left.
  static IconData blockquoteLeft;
/// Bootstrap icon for blockquote right.
  static IconData blockquoteRight;
/// Bootstrap icon for book fill.
  static IconData bookFill;
/// Bootstrap icon for book half.
  static IconData bookHalf;
/// Bootstrap icon for book.
  static IconData book;
/// Bootstrap icon for bookmark check fill.
  static IconData bookmarkCheckFill;
/// Bootstrap icon for bookmark check.
  static IconData bookmarkCheck;
/// Bootstrap icon for bookmark dash fill.
  static IconData bookmarkDashFill;
/// Bootstrap icon for bookmark dash.
  static IconData bookmarkDash;
/// Bootstrap icon for bookmark fill.
  static IconData bookmarkFill;
/// Bootstrap icon for bookmark heart fill.
  static IconData bookmarkHeartFill;
/// Bootstrap icon for bookmark heart.
  static IconData bookmarkHeart;
/// Bootstrap icon for bookmark plus fill.
  static IconData bookmarkPlusFill;
/// Bootstrap icon for bookmark plus.
  static IconData bookmarkPlus;
/// Bootstrap icon for bookmark star fill.
  static IconData bookmarkStarFill;
/// Bootstrap icon for bookmark star.
  static IconData bookmarkStar;
/// Bootstrap icon for bookmark x fill.
  static IconData bookmarkXFill;
/// Bootstrap icon for bookmark x.
  static IconData bookmarkX;
/// Bootstrap icon for bookmark.
  static IconData bookmark;
/// Bootstrap icon for bookmarks fill.
  static IconData bookmarksFill;
/// Bootstrap icon for bookmarks.
  static IconData bookmarks;
/// Bootstrap icon for bookshelf.
  static IconData bookshelf;
/// Bootstrap icon for bootstrap fill.
  static IconData bootstrapFill;
/// Bootstrap icon for bootstrap reboot.
  static IconData bootstrapReboot;
/// Bootstrap icon for bootstrap.
  static IconData bootstrap;
/// Bootstrap icon for border all.
  static IconData borderAll;
/// Bootstrap icon for border bottom.
  static IconData borderBottom;
/// Bootstrap icon for border center.
  static IconData borderCenter;
/// Bootstrap icon for border inner.
  static IconData borderInner;
/// Bootstrap icon for border left.
  static IconData borderLeft;
/// Bootstrap icon for border middle.
  static IconData borderMiddle;
/// Bootstrap icon for border outer.
  static IconData borderOuter;
/// Bootstrap icon for border right.
  static IconData borderRight;
/// Bootstrap icon for border style.
  static IconData borderStyle;
/// Bootstrap icon for border top.
  static IconData borderTop;
/// Bootstrap icon for border width.
  static IconData borderWidth;
/// Bootstrap icon for border.
  static IconData border;
/// Bootstrap icon for bounding box circles.
  static IconData boundingBoxCircles;
/// Bootstrap icon for bounding box.
  static IconData boundingBox;
/// Bootstrap icon for box arrow down left.
  static IconData boxArrowDownLeft;
/// Bootstrap icon for box arrow down right.
  static IconData boxArrowDownRight;
/// Bootstrap icon for box arrow down.
  static IconData boxArrowDown;
/// Bootstrap icon for box arrow in down left.
  static IconData boxArrowInDownLeft;
/// Bootstrap icon for box arrow in down right.
  static IconData boxArrowInDownRight;
/// Bootstrap icon for box arrow in down.
  static IconData boxArrowInDown;
/// Bootstrap icon for box arrow in left.
  static IconData boxArrowInLeft;
/// Bootstrap icon for box arrow in right.
  static IconData boxArrowInRight;
/// Bootstrap icon for box arrow in up left.
  static IconData boxArrowInUpLeft;
/// Bootstrap icon for box arrow in up right.
  static IconData boxArrowInUpRight;
/// Bootstrap icon for box arrow in up.
  static IconData boxArrowInUp;
/// Bootstrap icon for box arrow left.
  static IconData boxArrowLeft;
/// Bootstrap icon for box arrow right.
  static IconData boxArrowRight;
/// Bootstrap icon for box arrow up left.
  static IconData boxArrowUpLeft;
/// Bootstrap icon for box arrow up right.
  static IconData boxArrowUpRight;
/// Bootstrap icon for box arrow up.
  static IconData boxArrowUp;
/// Bootstrap icon for box seam.
  static IconData boxSeam;
/// Bootstrap icon for box.
  static IconData box;
/// Bootstrap icon for braces.
  static IconData braces;
/// Bootstrap icon for bricks.
  static IconData bricks;
/// Bootstrap icon for briefcase fill.
  static IconData briefcaseFill;
/// Bootstrap icon for briefcase.
  static IconData briefcase;
/// Bootstrap icon for brightness alt high fill.
  static IconData brightnessAltHighFill;
/// Bootstrap icon for brightness alt high.
  static IconData brightnessAltHigh;
/// Bootstrap icon for brightness alt low fill.
  static IconData brightnessAltLowFill;
/// Bootstrap icon for brightness alt low.
  static IconData brightnessAltLow;
/// Bootstrap icon for brightness high fill.
  static IconData brightnessHighFill;
/// Bootstrap icon for brightness high.
  static IconData brightnessHigh;
/// Bootstrap icon for brightness low fill.
  static IconData brightnessLowFill;
/// Bootstrap icon for brightness low.
  static IconData brightnessLow;
/// Bootstrap icon for broadcast pin.
  static IconData broadcastPin;
/// Bootstrap icon for broadcast.
  static IconData broadcast;
/// Bootstrap icon for brush fill.
  static IconData brushFill;
/// Bootstrap icon for brush.
  static IconData brush;
/// Bootstrap icon for bucket fill.
  static IconData bucketFill;
/// Bootstrap icon for bucket.
  static IconData bucket;
/// Bootstrap icon for bug fill.
  static IconData bugFill;
/// Bootstrap icon for bug.
  static IconData bug;
/// Bootstrap icon for building.
  static IconData building;
/// Bootstrap icon for bullseye.
  static IconData bullseye;
/// Bootstrap icon for calculator fill.
  static IconData calculatorFill;
/// Bootstrap icon for calculator.
  static IconData calculator;
/// Bootstrap icon for calendar check fill.
  static IconData calendarCheckFill;
/// Bootstrap icon for calendar check.
  static IconData calendarCheck;
/// Bootstrap icon for calendar date fill.
  static IconData calendarDateFill;
/// Bootstrap icon for calendar date.
  static IconData calendarDate;
/// Bootstrap icon for calendar day fill.
  static IconData calendarDayFill;
/// Bootstrap icon for calendar day.
  static IconData calendarDay;
/// Bootstrap icon for calendar event fill.
  static IconData calendarEventFill;
/// Bootstrap icon for calendar event.
  static IconData calendarEvent;
/// Bootstrap icon for calendar fill.
  static IconData calendarFill;
/// Bootstrap icon for calendar minus fill.
  static IconData calendarMinusFill;
/// Bootstrap icon for calendar minus.
  static IconData calendarMinus;
/// Bootstrap icon for calendar month fill.
  static IconData calendarMonthFill;
/// Bootstrap icon for calendar month.
  static IconData calendarMonth;
/// Bootstrap icon for calendar plus fill.
  static IconData calendarPlusFill;
/// Bootstrap icon for calendar plus.
  static IconData calendarPlus;
/// Bootstrap icon for calendar range fill.
  static IconData calendarRangeFill;
/// Bootstrap icon for calendar range.
  static IconData calendarRange;
/// Bootstrap icon for calendar week fill.
  static IconData calendarWeekFill;
/// Bootstrap icon for calendar week.
  static IconData calendarWeek;
/// Bootstrap icon for calendar x fill.
  static IconData calendarXFill;
/// Bootstrap icon for calendar x.
  static IconData calendarX;
/// Bootstrap icon for calendar.
  static IconData calendar;
/// Bootstrap icon for calendar2 check fill.
  static IconData calendar2CheckFill;
/// Bootstrap icon for calendar2 check.
  static IconData calendar2Check;
/// Bootstrap icon for calendar2 date fill.
  static IconData calendar2DateFill;
/// Bootstrap icon for calendar2 date.
  static IconData calendar2Date;
/// Bootstrap icon for calendar2 day fill.
  static IconData calendar2DayFill;
/// Bootstrap icon for calendar2 day.
  static IconData calendar2Day;
/// Bootstrap icon for calendar2 event fill.
  static IconData calendar2EventFill;
/// Bootstrap icon for calendar2 event.
  static IconData calendar2Event;
/// Bootstrap icon for calendar2 fill.
  static IconData calendar2Fill;
/// Bootstrap icon for calendar2 minus fill.
  static IconData calendar2MinusFill;
/// Bootstrap icon for calendar2 minus.
  static IconData calendar2Minus;
/// Bootstrap icon for calendar2 month fill.
  static IconData calendar2MonthFill;
/// Bootstrap icon for calendar2 month.
  static IconData calendar2Month;
/// Bootstrap icon for calendar2 plus fill.
  static IconData calendar2PlusFill;
/// Bootstrap icon for calendar2 plus.
  static IconData calendar2Plus;
/// Bootstrap icon for calendar2 range fill.
  static IconData calendar2RangeFill;
/// Bootstrap icon for calendar2 range.
  static IconData calendar2Range;
/// Bootstrap icon for calendar2 week fill.
  static IconData calendar2WeekFill;
/// Bootstrap icon for calendar2 week.
  static IconData calendar2Week;
/// Bootstrap icon for calendar2 x fill.
  static IconData calendar2XFill;
/// Bootstrap icon for calendar2 x.
  static IconData calendar2X;
/// Bootstrap icon for calendar2.
  static IconData calendar2;
/// Bootstrap icon for calendar3 event fill.
  static IconData calendar3EventFill;
/// Bootstrap icon for calendar3 event.
  static IconData calendar3Event;
/// Bootstrap icon for calendar3 fill.
  static IconData calendar3Fill;
/// Bootstrap icon for calendar3 range fill.
  static IconData calendar3RangeFill;
/// Bootstrap icon for calendar3 range.
  static IconData calendar3Range;
/// Bootstrap icon for calendar3 week fill.
  static IconData calendar3WeekFill;
/// Bootstrap icon for calendar3 week.
  static IconData calendar3Week;
/// Bootstrap icon for calendar3.
  static IconData calendar3;
/// Bootstrap icon for calendar4 event.
  static IconData calendar4Event;
/// Bootstrap icon for calendar4 range.
  static IconData calendar4Range;
/// Bootstrap icon for calendar4 week.
  static IconData calendar4Week;
/// Bootstrap icon for calendar4.
  static IconData calendar4;
/// Bootstrap icon for camera fill.
  static IconData cameraFill;
/// Bootstrap icon for camera reels fill.
  static IconData cameraReelsFill;
/// Bootstrap icon for camera reels.
  static IconData cameraReels;
/// Bootstrap icon for camera video fill.
  static IconData cameraVideoFill;
/// Bootstrap icon for camera video off fill.
  static IconData cameraVideoOffFill;
/// Bootstrap icon for camera video off.
  static IconData cameraVideoOff;
/// Bootstrap icon for camera video.
  static IconData cameraVideo;
/// Bootstrap icon for camera.
  static IconData camera;
/// Bootstrap icon for camera2.
  static IconData camera2;
/// Bootstrap icon for capslock fill.
  static IconData capslockFill;
/// Bootstrap icon for capslock.
  static IconData capslock;
/// Bootstrap icon for card checklist.
  static IconData cardChecklist;
/// Bootstrap icon for card heading.
  static IconData cardHeading;
/// Bootstrap icon for card image.
  static IconData cardImage;
/// Bootstrap icon for card list.
  static IconData cardList;
/// Bootstrap icon for card text.
  static IconData cardText;
/// Bootstrap icon for caret down fill.
  static IconData caretDownFill;
/// Bootstrap icon for caret down square fill.
  static IconData caretDownSquareFill;
/// Bootstrap icon for caret down square.
  static IconData caretDownSquare;
/// Bootstrap icon for caret down.
  static IconData caretDown;
/// Bootstrap icon for caret left fill.
  static IconData caretLeftFill;
/// Bootstrap icon for caret left square fill.
  static IconData caretLeftSquareFill;
/// Bootstrap icon for caret left square.
  static IconData caretLeftSquare;
/// Bootstrap icon for caret left.
  static IconData caretLeft;
/// Bootstrap icon for caret right fill.
  static IconData caretRightFill;
/// Bootstrap icon for caret right square fill.
  static IconData caretRightSquareFill;
/// Bootstrap icon for caret right square.
  static IconData caretRightSquare;
/// Bootstrap icon for caret right.
  static IconData caretRight;
/// Bootstrap icon for caret up fill.
  static IconData caretUpFill;
/// Bootstrap icon for caret up square fill.
  static IconData caretUpSquareFill;
/// Bootstrap icon for caret up square.
  static IconData caretUpSquare;
/// Bootstrap icon for caret up.
  static IconData caretUp;
/// Bootstrap icon for cart check fill.
  static IconData cartCheckFill;
/// Bootstrap icon for cart check.
  static IconData cartCheck;
/// Bootstrap icon for cart dash fill.
  static IconData cartDashFill;
/// Bootstrap icon for cart dash.
  static IconData cartDash;
/// Bootstrap icon for cart fill.
  static IconData cartFill;
/// Bootstrap icon for cart plus fill.
  static IconData cartPlusFill;
/// Bootstrap icon for cart plus.
  static IconData cartPlus;
/// Bootstrap icon for cart x fill.
  static IconData cartXFill;
/// Bootstrap icon for cart x.
  static IconData cartX;
/// Bootstrap icon for cart.
  static IconData cart;
/// Bootstrap icon for cart2.
  static IconData cart2;
/// Bootstrap icon for cart3.
  static IconData cart3;
/// Bootstrap icon for cart4.
  static IconData cart4;
/// Bootstrap icon for cash stack.
  static IconData cashStack;
/// Bootstrap icon for cash.
  static IconData cash;
/// Bootstrap icon for cast.
  static IconData cast;
/// Bootstrap icon for chat dots fill.
  static IconData chatDotsFill;
/// Bootstrap icon for chat dots.
  static IconData chatDots;
/// Bootstrap icon for chat fill.
  static IconData chatFill;
/// Bootstrap icon for chat left dots fill.
  static IconData chatLeftDotsFill;
/// Bootstrap icon for chat left dots.
  static IconData chatLeftDots;
/// Bootstrap icon for chat left fill.
  static IconData chatLeftFill;
/// Bootstrap icon for chat left quote fill.
  static IconData chatLeftQuoteFill;
/// Bootstrap icon for chat left quote.
  static IconData chatLeftQuote;
/// Bootstrap icon for chat left text fill.
  static IconData chatLeftTextFill;
/// Bootstrap icon for chat left text.
  static IconData chatLeftText;
/// Bootstrap icon for chat left.
  static IconData chatLeft;
/// Bootstrap icon for chat quote fill.
  static IconData chatQuoteFill;
/// Bootstrap icon for chat quote.
  static IconData chatQuote;
/// Bootstrap icon for chat right dots fill.
  static IconData chatRightDotsFill;
/// Bootstrap icon for chat right dots.
  static IconData chatRightDots;
/// Bootstrap icon for chat right fill.
  static IconData chatRightFill;
/// Bootstrap icon for chat right quote fill.
  static IconData chatRightQuoteFill;
/// Bootstrap icon for chat right quote.
  static IconData chatRightQuote;
/// Bootstrap icon for chat right text fill.
  static IconData chatRightTextFill;
/// Bootstrap icon for chat right text.
  static IconData chatRightText;
/// Bootstrap icon for chat right.
  static IconData chatRight;
/// Bootstrap icon for chat square dots fill.
  static IconData chatSquareDotsFill;
/// Bootstrap icon for chat square dots.
  static IconData chatSquareDots;
/// Bootstrap icon for chat square fill.
  static IconData chatSquareFill;
/// Bootstrap icon for chat square quote fill.
  static IconData chatSquareQuoteFill;
/// Bootstrap icon for chat square quote.
  static IconData chatSquareQuote;
/// Bootstrap icon for chat square text fill.
  static IconData chatSquareTextFill;
/// Bootstrap icon for chat square text.
  static IconData chatSquareText;
/// Bootstrap icon for chat square.
  static IconData chatSquare;
/// Bootstrap icon for chat text fill.
  static IconData chatTextFill;
/// Bootstrap icon for chat text.
  static IconData chatText;
/// Bootstrap icon for chat.
  static IconData chat;
/// Bootstrap icon for check all.
  static IconData checkAll;
/// Bootstrap icon for check circle fill.
  static IconData checkCircleFill;
/// Bootstrap icon for check circle.
  static IconData checkCircle;
/// Bootstrap icon for check square fill.
  static IconData checkSquareFill;
/// Bootstrap icon for check square.
  static IconData checkSquare;
/// Bootstrap icon for check.
  static IconData check;
/// Bootstrap icon for check2 all.
  static IconData check2All;
/// Bootstrap icon for check2 circle.
  static IconData check2Circle;
/// Bootstrap icon for check2 square.
  static IconData check2Square;
/// Bootstrap icon for check2.
  static IconData check2;
/// Bootstrap icon for chevron bar contract.
  static IconData chevronBarContract;
/// Bootstrap icon for chevron bar down.
  static IconData chevronBarDown;
/// Bootstrap icon for chevron bar expand.
  static IconData chevronBarExpand;
/// Bootstrap icon for chevron bar left.
  static IconData chevronBarLeft;
/// Bootstrap icon for chevron bar right.
  static IconData chevronBarRight;
/// Bootstrap icon for chevron bar up.
  static IconData chevronBarUp;
/// Bootstrap icon for chevron compact down.
  static IconData chevronCompactDown;
/// Bootstrap icon for chevron compact left.
  static IconData chevronCompactLeft;
/// Bootstrap icon for chevron compact right.
  static IconData chevronCompactRight;
/// Bootstrap icon for chevron compact up.
  static IconData chevronCompactUp;
/// Bootstrap icon for chevron contract.
  static IconData chevronContract;
/// Bootstrap icon for chevron double down.
  static IconData chevronDoubleDown;
/// Bootstrap icon for chevron double left.
  static IconData chevronDoubleLeft;
/// Bootstrap icon for chevron double right.
  static IconData chevronDoubleRight;
/// Bootstrap icon for chevron double up.
  static IconData chevronDoubleUp;
/// Bootstrap icon for chevron down.
  static IconData chevronDown;
/// Bootstrap icon for chevron expand.
  static IconData chevronExpand;
/// Bootstrap icon for chevron left.
  static IconData chevronLeft;
/// Bootstrap icon for chevron right.
  static IconData chevronRight;
/// Bootstrap icon for chevron up.
  static IconData chevronUp;
/// Bootstrap icon for circle fill.
  static IconData circleFill;
/// Bootstrap icon for circle half.
  static IconData circleHalf;
/// Bootstrap icon for circle square.
  static IconData circleSquare;
/// Bootstrap icon for circle.
  static IconData circle;
/// Bootstrap icon for clipboard check.
  static IconData clipboardCheck;
/// Bootstrap icon for clipboard data.
  static IconData clipboardData;
/// Bootstrap icon for clipboard minus.
  static IconData clipboardMinus;
/// Bootstrap icon for clipboard plus.
  static IconData clipboardPlus;
/// Bootstrap icon for clipboard x.
  static IconData clipboardX;
/// Bootstrap icon for clipboard.
  static IconData clipboard;
/// Bootstrap icon for clock fill.
  static IconData clockFill;
/// Bootstrap icon for clock history.
  static IconData clockHistory;
/// Bootstrap icon for clock.
  static IconData clock;
/// Bootstrap icon for cloud arrow down fill.
  static IconData cloudArrowDownFill;
/// Bootstrap icon for cloud arrow down.
  static IconData cloudArrowDown;
/// Bootstrap icon for cloud arrow up fill.
  static IconData cloudArrowUpFill;
/// Bootstrap icon for cloud arrow up.
  static IconData cloudArrowUp;
/// Bootstrap icon for cloud check fill.
  static IconData cloudCheckFill;
/// Bootstrap icon for cloud check.
  static IconData cloudCheck;
/// Bootstrap icon for cloud download fill.
  static IconData cloudDownloadFill;
/// Bootstrap icon for cloud download.
  static IconData cloudDownload;
/// Bootstrap icon for cloud drizzle fill.
  static IconData cloudDrizzleFill;
/// Bootstrap icon for cloud drizzle.
  static IconData cloudDrizzle;
/// Bootstrap icon for cloud fill.
  static IconData cloudFill;
/// Bootstrap icon for cloud fog fill.
  static IconData cloudFogFill;
/// Bootstrap icon for cloud fog.
  static IconData cloudFog;
/// Bootstrap icon for cloud fog2 fill.
  static IconData cloudFog2Fill;
/// Bootstrap icon for cloud fog2.
  static IconData cloudFog2;
/// Bootstrap icon for cloud hail fill.
  static IconData cloudHailFill;
/// Bootstrap icon for cloud hail.
  static IconData cloudHail;
/// Bootstrap icon for cloud haze fill.
  static IconData cloudHazeFill;
/// Bootstrap icon for cloud haze.
  static IconData cloudHaze;
/// Bootstrap icon for cloud haze2 fill.
  static IconData cloudHaze2Fill;
/// Bootstrap icon for cloud lightning fill.
  static IconData cloudLightningFill;
/// Bootstrap icon for cloud lightning rain fill.
  static IconData cloudLightningRainFill;
/// Bootstrap icon for cloud lightning rain.
  static IconData cloudLightningRain;
/// Bootstrap icon for cloud lightning.
  static IconData cloudLightning;
/// Bootstrap icon for cloud minus fill.
  static IconData cloudMinusFill;
/// Bootstrap icon for cloud minus.
  static IconData cloudMinus;
/// Bootstrap icon for cloud moon fill.
  static IconData cloudMoonFill;
/// Bootstrap icon for cloud moon.
  static IconData cloudMoon;
/// Bootstrap icon for cloud plus fill.
  static IconData cloudPlusFill;
/// Bootstrap icon for cloud plus.
  static IconData cloudPlus;
/// Bootstrap icon for cloud rain fill.
  static IconData cloudRainFill;
/// Bootstrap icon for cloud rain heavy fill.
  static IconData cloudRainHeavyFill;
/// Bootstrap icon for cloud rain heavy.
  static IconData cloudRainHeavy;
/// Bootstrap icon for cloud rain.
  static IconData cloudRain;
/// Bootstrap icon for cloud slash fill.
  static IconData cloudSlashFill;
/// Bootstrap icon for cloud slash.
  static IconData cloudSlash;
/// Bootstrap icon for cloud sleet fill.
  static IconData cloudSleetFill;
/// Bootstrap icon for cloud sleet.
  static IconData cloudSleet;
/// Bootstrap icon for cloud snow fill.
  static IconData cloudSnowFill;
/// Bootstrap icon for cloud snow.
  static IconData cloudSnow;
/// Bootstrap icon for cloud sun fill.
  static IconData cloudSunFill;
/// Bootstrap icon for cloud sun.
  static IconData cloudSun;
/// Bootstrap icon for cloud upload fill.
  static IconData cloudUploadFill;
/// Bootstrap icon for cloud upload.
  static IconData cloudUpload;
/// Bootstrap icon for cloud.
  static IconData cloud;
/// Bootstrap icon for clouds fill.
  static IconData cloudsFill;
/// Bootstrap icon for clouds.
  static IconData clouds;
/// Bootstrap icon for cloudy fill.
  static IconData cloudyFill;
/// Bootstrap icon for cloudy.
  static IconData cloudy;
/// Bootstrap icon for code slash.
  static IconData codeSlash;
/// Bootstrap icon for code square.
  static IconData codeSquare;
/// Bootstrap icon for code.
  static IconData code;
/// Bootstrap icon for collection fill.
  static IconData collectionFill;
/// Bootstrap icon for collection play fill.
  static IconData collectionPlayFill;
/// Bootstrap icon for collection play.
  static IconData collectionPlay;
/// Bootstrap icon for collection.
  static IconData collection;
/// Bootstrap icon for columns gap.
  static IconData columnsGap;
/// Bootstrap icon for columns.
  static IconData columns;
/// Bootstrap icon for command.
  static IconData command;
/// Bootstrap icon for compass fill.
  static IconData compassFill;
/// Bootstrap icon for compass.
  static IconData compass;
/// Bootstrap icon for cone striped.
  static IconData coneStriped;
/// Bootstrap icon for cone.
  static IconData cone;
/// Bootstrap icon for controller.
  static IconData controller;
/// Bootstrap icon for cpu fill.
  static IconData cpuFill;
/// Bootstrap icon for cpu.
  static IconData cpu;
/// Bootstrap icon for credit card2 back fill.
  static IconData creditCard2BackFill;
/// Bootstrap icon for credit card2 back.
  static IconData creditCard2Back;
/// Bootstrap icon for credit card2 front fill.
  static IconData creditCard2FrontFill;
/// Bootstrap icon for credit card2 front.
  static IconData creditCard2Front;
/// Bootstrap icon for credit card fill.
  static IconData creditCardFill;
/// Bootstrap icon for credit card.
  static IconData creditCard;
/// Bootstrap icon for crop.
  static IconData crop;
/// Bootstrap icon for cup fill.
  static IconData cupFill;
/// Bootstrap icon for cup straw.
  static IconData cupStraw;
/// Bootstrap icon for cup.
  static IconData cup;
/// Bootstrap icon for cursor fill.
  static IconData cursorFill;
/// Bootstrap icon for cursor text.
  static IconData cursorText;
/// Bootstrap icon for cursor.
  static IconData cursor;
/// Bootstrap icon for dash circle dotted.
  static IconData dashCircleDotted;
/// Bootstrap icon for dash circle fill.
  static IconData dashCircleFill;
/// Bootstrap icon for dash circle.
  static IconData dashCircle;
/// Bootstrap icon for dash square dotted.
  static IconData dashSquareDotted;
/// Bootstrap icon for dash square fill.
  static IconData dashSquareFill;
/// Bootstrap icon for dash square.
  static IconData dashSquare;
/// Bootstrap icon for dash.
  static IconData dash;
/// Bootstrap icon for diagram2 fill.
  static IconData diagram2Fill;
/// Bootstrap icon for diagram2.
  static IconData diagram2;
/// Bootstrap icon for diagram3 fill.
  static IconData diagram3Fill;
/// Bootstrap icon for diagram3.
  static IconData diagram3;
/// Bootstrap icon for diamond fill.
  static IconData diamondFill;
/// Bootstrap icon for diamond half.
  static IconData diamondHalf;
/// Bootstrap icon for diamond.
  static IconData diamond;
/// Bootstrap icon for dice1 fill.
  static IconData dice1Fill;
/// Bootstrap icon for dice1.
  static IconData dice1;
/// Bootstrap icon for dice2 fill.
  static IconData dice2Fill;
/// Bootstrap icon for dice2.
  static IconData dice2;
/// Bootstrap icon for dice3 fill.
  static IconData dice3Fill;
/// Bootstrap icon for dice3.
  static IconData dice3;
/// Bootstrap icon for dice4 fill.
  static IconData dice4Fill;
/// Bootstrap icon for dice4.
  static IconData dice4;
/// Bootstrap icon for dice5 fill.
  static IconData dice5Fill;
/// Bootstrap icon for dice5.
  static IconData dice5;
/// Bootstrap icon for dice6 fill.
  static IconData dice6Fill;
/// Bootstrap icon for dice6.
  static IconData dice6;
/// Bootstrap icon for disc fill.
  static IconData discFill;
/// Bootstrap icon for disc.
  static IconData disc;
/// Bootstrap icon for discord.
  static IconData discord;
/// Bootstrap icon for display fill.
  static IconData displayFill;
/// Bootstrap icon for display.
  static IconData display;
/// Bootstrap icon for distribute horizontal.
  static IconData distributeHorizontal;
/// Bootstrap icon for distribute vertical.
  static IconData distributeVertical;
/// Bootstrap icon for door closed fill.
  static IconData doorClosedFill;
/// Bootstrap icon for door closed.
  static IconData doorClosed;
/// Bootstrap icon for door open fill.
  static IconData doorOpenFill;
/// Bootstrap icon for door open.
  static IconData doorOpen;
/// Bootstrap icon for dot.
  static IconData dot;
/// Bootstrap icon for download.
  static IconData download;
/// Bootstrap icon for droplet fill.
  static IconData dropletFill;
/// Bootstrap icon for droplet half.
  static IconData dropletHalf;
/// Bootstrap icon for droplet.
  static IconData droplet;
/// Bootstrap icon for earbuds.
  static IconData earbuds;
/// Bootstrap icon for easel fill.
  static IconData easelFill;
/// Bootstrap icon for easel.
  static IconData easel;
/// Bootstrap icon for egg fill.
  static IconData eggFill;
/// Bootstrap icon for egg fried.
  static IconData eggFried;
/// Bootstrap icon for egg.
  static IconData egg;
/// Bootstrap icon for eject fill.
  static IconData ejectFill;
/// Bootstrap icon for eject.
  static IconData eject;
/// Bootstrap icon for emoji angry fill.
  static IconData emojiAngryFill;
/// Bootstrap icon for emoji angry.
  static IconData emojiAngry;
/// Bootstrap icon for emoji dizzy fill.
  static IconData emojiDizzyFill;
/// Bootstrap icon for emoji dizzy.
  static IconData emojiDizzy;
/// Bootstrap icon for emoji expressionless fill.
  static IconData emojiExpressionlessFill;
/// Bootstrap icon for emoji expressionless.
  static IconData emojiExpressionless;
/// Bootstrap icon for emoji frown fill.
  static IconData emojiFrownFill;
/// Bootstrap icon for emoji frown.
  static IconData emojiFrown;
/// Bootstrap icon for emoji heart eyes fill.
  static IconData emojiHeartEyesFill;
/// Bootstrap icon for emoji heart eyes.
  static IconData emojiHeartEyes;
/// Bootstrap icon for emoji laughing fill.
  static IconData emojiLaughingFill;
/// Bootstrap icon for emoji laughing.
  static IconData emojiLaughing;
/// Bootstrap icon for emoji neutral fill.
  static IconData emojiNeutralFill;
/// Bootstrap icon for emoji neutral.
  static IconData emojiNeutral;
/// Bootstrap icon for emoji smile fill.
  static IconData emojiSmileFill;
/// Bootstrap icon for emoji smile upside down fill.
  static IconData emojiSmileUpsideDownFill;
/// Bootstrap icon for emoji smile upside down.
  static IconData emojiSmileUpsideDown;
/// Bootstrap icon for emoji smile.
  static IconData emojiSmile;
/// Bootstrap icon for emoji sunglasses fill.
  static IconData emojiSunglassesFill;
/// Bootstrap icon for emoji sunglasses.
  static IconData emojiSunglasses;
/// Bootstrap icon for emoji wink fill.
  static IconData emojiWinkFill;
/// Bootstrap icon for emoji wink.
  static IconData emojiWink;
/// Bootstrap icon for envelope fill.
  static IconData envelopeFill;
/// Bootstrap icon for envelope open fill.
  static IconData envelopeOpenFill;
/// Bootstrap icon for envelope open.
  static IconData envelopeOpen;
/// Bootstrap icon for envelope.
  static IconData envelope;
/// Bootstrap icon for eraser fill.
  static IconData eraserFill;
/// Bootstrap icon for eraser.
  static IconData eraser;
/// Bootstrap icon for exclamation circle fill.
  static IconData exclamationCircleFill;
/// Bootstrap icon for exclamation circle.
  static IconData exclamationCircle;
/// Bootstrap icon for exclamation diamond fill.
  static IconData exclamationDiamondFill;
/// Bootstrap icon for exclamation diamond.
  static IconData exclamationDiamond;
/// Bootstrap icon for exclamation octagon fill.
  static IconData exclamationOctagonFill;
/// Bootstrap icon for exclamation octagon.
  static IconData exclamationOctagon;
/// Bootstrap icon for exclamation square fill.
  static IconData exclamationSquareFill;
/// Bootstrap icon for exclamation square.
  static IconData exclamationSquare;
/// Bootstrap icon for exclamation triangle fill.
  static IconData exclamationTriangleFill;
/// Bootstrap icon for exclamation triangle.
  static IconData exclamationTriangle;
/// Bootstrap icon for exclamation.
  static IconData exclamation;
/// Bootstrap icon for exclude.
  static IconData exclude;
/// Bootstrap icon for eye fill.
  static IconData eyeFill;
/// Bootstrap icon for eye slash fill.
  static IconData eyeSlashFill;
/// Bootstrap icon for eye slash.
  static IconData eyeSlash;
/// Bootstrap icon for eye.
  static IconData eye;
/// Bootstrap icon for eyedropper.
  static IconData eyedropper;
/// Bootstrap icon for eyeglasses.
  static IconData eyeglasses;
/// Bootstrap icon for facebook.
  static IconData facebook;
/// Bootstrap icon for file arrow down fill.
  static IconData fileArrowDownFill;
/// Bootstrap icon for file arrow down.
  static IconData fileArrowDown;
/// Bootstrap icon for file arrow up fill.
  static IconData fileArrowUpFill;
/// Bootstrap icon for file arrow up.
  static IconData fileArrowUp;
/// Bootstrap icon for file bar graph fill.
  static IconData fileBarGraphFill;
/// Bootstrap icon for file bar graph.
  static IconData fileBarGraph;
/// Bootstrap icon for file binary fill.
  static IconData fileBinaryFill;
/// Bootstrap icon for file binary.
  static IconData fileBinary;
/// Bootstrap icon for file break fill.
  static IconData fileBreakFill;
/// Bootstrap icon for file break.
  static IconData fileBreak;
/// Bootstrap icon for file check fill.
  static IconData fileCheckFill;
/// Bootstrap icon for file check.
  static IconData fileCheck;
/// Bootstrap icon for file code fill.
  static IconData fileCodeFill;
/// Bootstrap icon for file code.
  static IconData fileCode;
/// Bootstrap icon for file diff fill.
  static IconData fileDiffFill;
/// Bootstrap icon for file diff.
  static IconData fileDiff;
/// Bootstrap icon for file earmark arrow down fill.
  static IconData fileEarmarkArrowDownFill;
/// Bootstrap icon for file earmark arrow down.
  static IconData fileEarmarkArrowDown;
/// Bootstrap icon for file earmark arrow up fill.
  static IconData fileEarmarkArrowUpFill;
/// Bootstrap icon for file earmark arrow up.
  static IconData fileEarmarkArrowUp;
/// Bootstrap icon for file earmark bar graph fill.
  static IconData fileEarmarkBarGraphFill;
/// Bootstrap icon for file earmark bar graph.
  static IconData fileEarmarkBarGraph;
/// Bootstrap icon for file earmark binary fill.
  static IconData fileEarmarkBinaryFill;
/// Bootstrap icon for file earmark binary.
  static IconData fileEarmarkBinary;
/// Bootstrap icon for file earmark break fill.
  static IconData fileEarmarkBreakFill;
/// Bootstrap icon for file earmark break.
  static IconData fileEarmarkBreak;
/// Bootstrap icon for file earmark check fill.
  static IconData fileEarmarkCheckFill;
/// Bootstrap icon for file earmark check.
  static IconData fileEarmarkCheck;
/// Bootstrap icon for file earmark code fill.
  static IconData fileEarmarkCodeFill;
/// Bootstrap icon for file earmark code.
  static IconData fileEarmarkCode;
/// Bootstrap icon for file earmark diff fill.
  static IconData fileEarmarkDiffFill;
/// Bootstrap icon for file earmark diff.
  static IconData fileEarmarkDiff;
/// Bootstrap icon for file earmark easel fill.
  static IconData fileEarmarkEaselFill;
/// Bootstrap icon for file earmark easel.
  static IconData fileEarmarkEasel;
/// Bootstrap icon for file earmark excel fill.
  static IconData fileEarmarkExcelFill;
/// Bootstrap icon for file earmark excel.
  static IconData fileEarmarkExcel;
/// Bootstrap icon for file earmark fill.
  static IconData fileEarmarkFill;
/// Bootstrap icon for file earmark font fill.
  static IconData fileEarmarkFontFill;
/// Bootstrap icon for file earmark font.
  static IconData fileEarmarkFont;
/// Bootstrap icon for file earmark image fill.
  static IconData fileEarmarkImageFill;
/// Bootstrap icon for file earmark image.
  static IconData fileEarmarkImage;
/// Bootstrap icon for file earmark lock fill.
  static IconData fileEarmarkLockFill;
/// Bootstrap icon for file earmark lock.
  static IconData fileEarmarkLock;
/// Bootstrap icon for file earmark lock2 fill.
  static IconData fileEarmarkLock2Fill;
/// Bootstrap icon for file earmark lock2.
  static IconData fileEarmarkLock2;
/// Bootstrap icon for file earmark medical fill.
  static IconData fileEarmarkMedicalFill;
/// Bootstrap icon for file earmark medical.
  static IconData fileEarmarkMedical;
/// Bootstrap icon for file earmark minus fill.
  static IconData fileEarmarkMinusFill;
/// Bootstrap icon for file earmark minus.
  static IconData fileEarmarkMinus;
/// Bootstrap icon for file earmark music fill.
  static IconData fileEarmarkMusicFill;
/// Bootstrap icon for file earmark music.
  static IconData fileEarmarkMusic;
/// Bootstrap icon for file earmark person fill.
  static IconData fileEarmarkPersonFill;
/// Bootstrap icon for file earmark person.
  static IconData fileEarmarkPerson;
/// Bootstrap icon for file earmark play fill.
  static IconData fileEarmarkPlayFill;
/// Bootstrap icon for file earmark play.
  static IconData fileEarmarkPlay;
/// Bootstrap icon for file earmark plus fill.
  static IconData fileEarmarkPlusFill;
/// Bootstrap icon for file earmark plus.
  static IconData fileEarmarkPlus;
/// Bootstrap icon for file earmark post fill.
  static IconData fileEarmarkPostFill;
/// Bootstrap icon for file earmark post.
  static IconData fileEarmarkPost;
/// Bootstrap icon for file earmark ppt fill.
  static IconData fileEarmarkPptFill;
/// Bootstrap icon for file earmark ppt.
  static IconData fileEarmarkPpt;
/// Bootstrap icon for file earmark richtext fill.
  static IconData fileEarmarkRichtextFill;
/// Bootstrap icon for file earmark richtext.
  static IconData fileEarmarkRichtext;
/// Bootstrap icon for file earmark ruled fill.
  static IconData fileEarmarkRuledFill;
/// Bootstrap icon for file earmark ruled.
  static IconData fileEarmarkRuled;
/// Bootstrap icon for file earmark slides fill.
  static IconData fileEarmarkSlidesFill;
/// Bootstrap icon for file earmark slides.
  static IconData fileEarmarkSlides;
/// Bootstrap icon for file earmark spreadsheet fill.
  static IconData fileEarmarkSpreadsheetFill;
/// Bootstrap icon for file earmark spreadsheet.
  static IconData fileEarmarkSpreadsheet;
/// Bootstrap icon for file earmark text fill.
  static IconData fileEarmarkTextFill;
/// Bootstrap icon for file earmark text.
  static IconData fileEarmarkText;
/// Bootstrap icon for file earmark word fill.
  static IconData fileEarmarkWordFill;
/// Bootstrap icon for file earmark word.
  static IconData fileEarmarkWord;
/// Bootstrap icon for file earmark x fill.
  static IconData fileEarmarkXFill;
/// Bootstrap icon for file earmark x.
  static IconData fileEarmarkX;
/// Bootstrap icon for file earmark zip fill.
  static IconData fileEarmarkZipFill;
/// Bootstrap icon for file earmark zip.
  static IconData fileEarmarkZip;
/// Bootstrap icon for file earmark.
  static IconData fileEarmark;
/// Bootstrap icon for file easel fill.
  static IconData fileEaselFill;
/// Bootstrap icon for file easel.
  static IconData fileEasel;
/// Bootstrap icon for file excel fill.
  static IconData fileExcelFill;
/// Bootstrap icon for file excel.
  static IconData fileExcel;
/// Bootstrap icon for file fill.
  static IconData fileFill;
/// Bootstrap icon for file font fill.
  static IconData fileFontFill;
/// Bootstrap icon for file font.
  static IconData fileFont;
/// Bootstrap icon for file image fill.
  static IconData fileImageFill;
/// Bootstrap icon for file image.
  static IconData fileImage;
/// Bootstrap icon for file lock fill.
  static IconData fileLockFill;
/// Bootstrap icon for file lock.
  static IconData fileLock;
/// Bootstrap icon for file lock2 fill.
  static IconData fileLock2Fill;
/// Bootstrap icon for file lock2.
  static IconData fileLock2;
/// Bootstrap icon for file medical fill.
  static IconData fileMedicalFill;
/// Bootstrap icon for file medical.
  static IconData fileMedical;
/// Bootstrap icon for file minus fill.
  static IconData fileMinusFill;
/// Bootstrap icon for file minus.
  static IconData fileMinus;
/// Bootstrap icon for file music fill.
  static IconData fileMusicFill;
/// Bootstrap icon for file music.
  static IconData fileMusic;
/// Bootstrap icon for file person fill.
  static IconData filePersonFill;
/// Bootstrap icon for file person.
  static IconData filePerson;
/// Bootstrap icon for file play fill.
  static IconData filePlayFill;
/// Bootstrap icon for file play.
  static IconData filePlay;
/// Bootstrap icon for file plus fill.
  static IconData filePlusFill;
/// Bootstrap icon for file plus.
  static IconData filePlus;
/// Bootstrap icon for file post fill.
  static IconData filePostFill;
/// Bootstrap icon for file post.
  static IconData filePost;
/// Bootstrap icon for file ppt fill.
  static IconData filePptFill;
/// Bootstrap icon for file ppt.
  static IconData filePpt;
/// Bootstrap icon for file richtext fill.
  static IconData fileRichtextFill;
/// Bootstrap icon for file richtext.
  static IconData fileRichtext;
/// Bootstrap icon for file ruled fill.
  static IconData fileRuledFill;
/// Bootstrap icon for file ruled.
  static IconData fileRuled;
/// Bootstrap icon for file slides fill.
  static IconData fileSlidesFill;
/// Bootstrap icon for file slides.
  static IconData fileSlides;
/// Bootstrap icon for file spreadsheet fill.
  static IconData fileSpreadsheetFill;
/// Bootstrap icon for file spreadsheet.
  static IconData fileSpreadsheet;
/// Bootstrap icon for file text fill.
  static IconData fileTextFill;
/// Bootstrap icon for file text.
  static IconData fileText;
/// Bootstrap icon for file word fill.
  static IconData fileWordFill;
/// Bootstrap icon for file word.
  static IconData fileWord;
/// Bootstrap icon for file x fill.
  static IconData fileXFill;
/// Bootstrap icon for file x.
  static IconData fileX;
/// Bootstrap icon for file zip fill.
  static IconData fileZipFill;
/// Bootstrap icon for file zip.
  static IconData fileZip;
/// Bootstrap icon for file.
  static IconData file;
/// Bootstrap icon for files alt.
  static IconData filesAlt;
/// Bootstrap icon for files.
  static IconData files;
/// Bootstrap icon for film.
  static IconData film;
/// Bootstrap icon for filter circle fill.
  static IconData filterCircleFill;
/// Bootstrap icon for filter circle.
  static IconData filterCircle;
/// Bootstrap icon for filter left.
  static IconData filterLeft;
/// Bootstrap icon for filter right.
  static IconData filterRight;
/// Bootstrap icon for filter square fill.
  static IconData filterSquareFill;
/// Bootstrap icon for filter square.
  static IconData filterSquare;
/// Bootstrap icon for filter.
  static IconData filter;
/// Bootstrap icon for flag fill.
  static IconData flagFill;
/// Bootstrap icon for flag.
  static IconData flag;
/// Bootstrap icon for flower1.
  static IconData flower1;
/// Bootstrap icon for flower2.
  static IconData flower2;
/// Bootstrap icon for flower3.
  static IconData flower3;
/// Bootstrap icon for folder check.
  static IconData folderCheck;
/// Bootstrap icon for folder fill.
  static IconData folderFill;
/// Bootstrap icon for folder minus.
  static IconData folderMinus;
/// Bootstrap icon for folder plus.
  static IconData folderPlus;
/// Bootstrap icon for folder symlink fill.
  static IconData folderSymlinkFill;
/// Bootstrap icon for folder symlink.
  static IconData folderSymlink;
/// Bootstrap icon for folder x.
  static IconData folderX;
/// Bootstrap icon for folder.
  static IconData folder;
/// Bootstrap icon for folder2 open.
  static IconData folder2Open;
/// Bootstrap icon for folder2.
  static IconData folder2;
/// Bootstrap icon for fonts.
  static IconData fonts;
/// Bootstrap icon for forward fill.
  static IconData forwardFill;
/// Bootstrap icon for forward.
  static IconData forward;
/// Bootstrap icon for front.
  static IconData front;
/// Bootstrap icon for fullscreen exit.
  static IconData fullscreenExit;
/// Bootstrap icon for fullscreen.
  static IconData fullscreen;
/// Bootstrap icon for funnel fill.
  static IconData funnelFill;
/// Bootstrap icon for funnel.
  static IconData funnel;
/// Bootstrap icon for gear fill.
  static IconData gearFill;
/// Bootstrap icon for gear wide connected.
  static IconData gearWideConnected;
/// Bootstrap icon for gear wide.
  static IconData gearWide;
/// Bootstrap icon for gear.
  static IconData gear;
/// Bootstrap icon for gem.
  static IconData gem;
/// Bootstrap icon for geo alt fill.
  static IconData geoAltFill;
/// Bootstrap icon for geo alt.
  static IconData geoAlt;
/// Bootstrap icon for geo fill.
  static IconData geoFill;
/// Bootstrap icon for geo.
  static IconData geo;
/// Bootstrap icon for gift fill.
  static IconData giftFill;
/// Bootstrap icon for gift.
  static IconData gift;
/// Bootstrap icon for github.
  static IconData github;
/// Bootstrap icon for globe.
  static IconData globe;
/// Bootstrap icon for globe2.
  static IconData globe2;
/// Bootstrap icon for google.
  static IconData google;
/// Bootstrap icon for graph down.
  static IconData graphDown;
/// Bootstrap icon for graph up.
  static IconData graphUp;
/// Bootstrap icon for grid1x2 fill.
  static IconData grid1x2Fill;
/// Bootstrap icon for grid1x2.
  static IconData grid1x2;
/// Bootstrap icon for grid3x2 gap fill.
  static IconData grid3x2GapFill;
/// Bootstrap icon for grid3x2 gap.
  static IconData grid3x2Gap;
/// Bootstrap icon for grid3x2.
  static IconData grid3x2;
/// Bootstrap icon for grid3x3 gap fill.
  static IconData grid3x3GapFill;
/// Bootstrap icon for grid3x3 gap.
  static IconData grid3x3Gap;
/// Bootstrap icon for grid3x3.
  static IconData grid3x3;
/// Bootstrap icon for grid fill.
  static IconData gridFill;
/// Bootstrap icon for grid.
  static IconData grid;
/// Bootstrap icon for grip horizontal.
  static IconData gripHorizontal;
/// Bootstrap icon for grip vertical.
  static IconData gripVertical;
/// Bootstrap icon for hammer.
  static IconData hammer;
/// Bootstrap icon for hand index fill.
  static IconData handIndexFill;
/// Bootstrap icon for hand index thumb fill.
  static IconData handIndexThumbFill;
/// Bootstrap icon for hand index thumb.
  static IconData handIndexThumb;
/// Bootstrap icon for hand index.
  static IconData handIndex;
/// Bootstrap icon for hand thumbs down fill.
  static IconData handThumbsDownFill;
/// Bootstrap icon for hand thumbs down.
  static IconData handThumbsDown;
/// Bootstrap icon for hand thumbs up fill.
  static IconData handThumbsUpFill;
/// Bootstrap icon for hand thumbs up.
  static IconData handThumbsUp;
/// Bootstrap icon for handbag fill.
  static IconData handbagFill;
/// Bootstrap icon for handbag.
  static IconData handbag;
/// Bootstrap icon for hash.
  static IconData hash;
/// Bootstrap icon for hdd fill.
  static IconData hddFill;
/// Bootstrap icon for hdd network fill.
  static IconData hddNetworkFill;
/// Bootstrap icon for hdd network.
  static IconData hddNetwork;
/// Bootstrap icon for hdd rack fill.
  static IconData hddRackFill;
/// Bootstrap icon for hdd rack.
  static IconData hddRack;
/// Bootstrap icon for hdd stack fill.
  static IconData hddStackFill;
/// Bootstrap icon for hdd stack.
  static IconData hddStack;
/// Bootstrap icon for hdd.
  static IconData hdd;
/// Bootstrap icon for headphones.
  static IconData headphones;
/// Bootstrap icon for headset.
  static IconData headset;
/// Bootstrap icon for heart fill.
  static IconData heartFill;
/// Bootstrap icon for heart half.
  static IconData heartHalf;
/// Bootstrap icon for heart.
  static IconData heart;
/// Bootstrap icon for heptagon fill.
  static IconData heptagonFill;
/// Bootstrap icon for heptagon half.
  static IconData heptagonHalf;
/// Bootstrap icon for heptagon.
  static IconData heptagon;
/// Bootstrap icon for hexagon fill.
  static IconData hexagonFill;
/// Bootstrap icon for hexagon half.
  static IconData hexagonHalf;
/// Bootstrap icon for hexagon.
  static IconData hexagon;
/// Bootstrap icon for hourglass bottom.
  static IconData hourglassBottom;
/// Bootstrap icon for hourglass split.
  static IconData hourglassSplit;
/// Bootstrap icon for hourglass top.
  static IconData hourglassTop;
/// Bootstrap icon for hourglass.
  static IconData hourglass;
/// Bootstrap icon for house door fill.
  static IconData houseDoorFill;
/// Bootstrap icon for house door.
  static IconData houseDoor;
/// Bootstrap icon for house fill.
  static IconData houseFill;
/// Bootstrap icon for house.
  static IconData house;
/// Bootstrap icon for hr.
  static IconData hr;
/// Bootstrap icon for hurricane.
  static IconData hurricane;
/// Bootstrap icon for image alt.
  static IconData imageAlt;
/// Bootstrap icon for image fill.
  static IconData imageFill;
/// Bootstrap icon for image.
  static IconData image;
/// Bootstrap icon for images.
  static IconData images;
/// Bootstrap icon for inbox fill.
  static IconData inboxFill;
/// Bootstrap icon for inbox.
  static IconData inbox;
/// Bootstrap icon for inboxes fill.
  static IconData inboxesFill;
/// Bootstrap icon for inboxes.
  static IconData inboxes;
/// Bootstrap icon for info circle fill.
  static IconData infoCircleFill;
/// Bootstrap icon for info circle.
  static IconData infoCircle;
/// Bootstrap icon for info square fill.
  static IconData infoSquareFill;
/// Bootstrap icon for info square.
  static IconData infoSquare;
/// Bootstrap icon for info.
  static IconData info;
/// Bootstrap icon for input cursor text.
  static IconData inputCursorText;
/// Bootstrap icon for input cursor.
  static IconData inputCursor;
/// Bootstrap icon for instagram.
  static IconData instagram;
/// Bootstrap icon for intersect.
  static IconData intersect;
/// Bootstrap icon for journal album.
  static IconData journalAlbum;
/// Bootstrap icon for journal arrow down.
  static IconData journalArrowDown;
/// Bootstrap icon for journal arrow up.
  static IconData journalArrowUp;
/// Bootstrap icon for journal bookmark fill.
  static IconData journalBookmarkFill;
/// Bootstrap icon for journal bookmark.
  static IconData journalBookmark;
/// Bootstrap icon for journal check.
  static IconData journalCheck;
/// Bootstrap icon for journal code.
  static IconData journalCode;
/// Bootstrap icon for journal medical.
  static IconData journalMedical;
/// Bootstrap icon for journal minus.
  static IconData journalMinus;
/// Bootstrap icon for journal plus.
  static IconData journalPlus;
/// Bootstrap icon for journal richtext.
  static IconData journalRichtext;
/// Bootstrap icon for journal text.
  static IconData journalText;
/// Bootstrap icon for journal x.
  static IconData journalX;
/// Bootstrap icon for journal.
  static IconData journal;
/// Bootstrap icon for journals.
  static IconData journals;
/// Bootstrap icon for joystick.
  static IconData joystick;
/// Bootstrap icon for justify left.
  static IconData justifyLeft;
/// Bootstrap icon for justify right.
  static IconData justifyRight;
/// Bootstrap icon for justify.
  static IconData justify;
/// Bootstrap icon for kanban fill.
  static IconData kanbanFill;
/// Bootstrap icon for kanban.
  static IconData kanban;
/// Bootstrap icon for key fill.
  static IconData keyFill;
/// Bootstrap icon for key.
  static IconData key;
/// Bootstrap icon for keyboard fill.
  static IconData keyboardFill;
/// Bootstrap icon for keyboard.
  static IconData keyboard;
/// Bootstrap icon for ladder.
  static IconData ladder;
/// Bootstrap icon for lamp fill.
  static IconData lampFill;
/// Bootstrap icon for lamp.
  static IconData lamp;
/// Bootstrap icon for laptop fill.
  static IconData laptopFill;
/// Bootstrap icon for laptop.
  static IconData laptop;
/// Bootstrap icon for layer backward.
  static IconData layerBackward;
/// Bootstrap icon for layer forward.
  static IconData layerForward;
/// Bootstrap icon for layers fill.
  static IconData layersFill;
/// Bootstrap icon for layers half.
  static IconData layersHalf;
/// Bootstrap icon for layers.
  static IconData layers;
/// Bootstrap icon for layout sidebar inset reverse.
  static IconData layoutSidebarInsetReverse;
/// Bootstrap icon for layout sidebar inset.
  static IconData layoutSidebarInset;
/// Bootstrap icon for layout sidebar reverse.
  static IconData layoutSidebarReverse;
/// Bootstrap icon for layout sidebar.
  static IconData layoutSidebar;
/// Bootstrap icon for layout split.
  static IconData layoutSplit;
/// Bootstrap icon for layout text sidebar reverse.
  static IconData layoutTextSidebarReverse;
/// Bootstrap icon for layout text sidebar.
  static IconData layoutTextSidebar;
/// Bootstrap icon for layout text window reverse.
  static IconData layoutTextWindowReverse;
/// Bootstrap icon for layout text window.
  static IconData layoutTextWindow;
/// Bootstrap icon for layout three columns.
  static IconData layoutThreeColumns;
/// Bootstrap icon for layout wtf.
  static IconData layoutWtf;
/// Bootstrap icon for life preserver.
  static IconData lifePreserver;
/// Bootstrap icon for lightbulb fill.
  static IconData lightbulbFill;
/// Bootstrap icon for lightbulb off fill.
  static IconData lightbulbOffFill;
/// Bootstrap icon for lightbulb off.
  static IconData lightbulbOff;
/// Bootstrap icon for lightbulb.
  static IconData lightbulb;
/// Bootstrap icon for lightning charge fill.
  static IconData lightningChargeFill;
/// Bootstrap icon for lightning charge.
  static IconData lightningCharge;
/// Bootstrap icon for lightning fill.
  static IconData lightningFill;
/// Bootstrap icon for lightning.
  static IconData lightning;
/// Bootstrap icon for link45deg.
  static IconData link45deg;
/// Bootstrap icon for link.
  static IconData link;
/// Bootstrap icon for linkedin.
  static IconData linkedin;
/// Bootstrap icon for list check.
  static IconData listCheck;
/// Bootstrap icon for list nested.
  static IconData listNested;
/// Bootstrap icon for list ol.
  static IconData listOl;
/// Bootstrap icon for list stars.
  static IconData listStars;
/// Bootstrap icon for list task.
  static IconData listTask;
/// Bootstrap icon for list ul.
  static IconData listUl;
/// Bootstrap icon for list.
  static IconData list;
/// Bootstrap icon for lock fill.
  static IconData lockFill;
/// Bootstrap icon for lock.
  static IconData lock;
/// Bootstrap icon for mailbox.
  static IconData mailbox;
/// Bootstrap icon for mailbox2.
  static IconData mailbox2;
/// Bootstrap icon for map fill.
  static IconData mapFill;
/// Bootstrap icon for map.
  static IconData map;
/// Bootstrap icon for markdown fill.
  static IconData markdownFill;
/// Bootstrap icon for markdown.
  static IconData markdown;
/// Bootstrap icon for mask.
  static IconData mask;
/// Bootstrap icon for megaphone fill.
  static IconData megaphoneFill;
/// Bootstrap icon for megaphone.
  static IconData megaphone;
/// Bootstrap icon for menu app fill.
  static IconData menuAppFill;
/// Bootstrap icon for menu app.
  static IconData menuApp;
/// Bootstrap icon for menu button fill.
  static IconData menuButtonFill;
/// Bootstrap icon for menu button wide fill.
  static IconData menuButtonWideFill;
/// Bootstrap icon for menu button wide.
  static IconData menuButtonWide;
/// Bootstrap icon for menu button.
  static IconData menuButton;
/// Bootstrap icon for menu down.
  static IconData menuDown;
/// Bootstrap icon for menu up.
  static IconData menuUp;
/// Bootstrap icon for mic fill.
  static IconData micFill;
/// Bootstrap icon for mic mute fill.
  static IconData micMuteFill;
/// Bootstrap icon for mic mute.
  static IconData micMute;
/// Bootstrap icon for mic.
  static IconData mic;
/// Bootstrap icon for minecart loaded.
  static IconData minecartLoaded;
/// Bootstrap icon for minecart.
  static IconData minecart;
/// Bootstrap icon for moisture.
  static IconData moisture;
/// Bootstrap icon for moon fill.
  static IconData moonFill;
/// Bootstrap icon for moon stars fill.
  static IconData moonStarsFill;
/// Bootstrap icon for moon stars.
  static IconData moonStars;
/// Bootstrap icon for moon.
  static IconData moon;
/// Bootstrap icon for mouse fill.
  static IconData mouseFill;
/// Bootstrap icon for mouse.
  static IconData mouse;
/// Bootstrap icon for mouse2 fill.
  static IconData mouse2Fill;
/// Bootstrap icon for mouse2.
  static IconData mouse2;
/// Bootstrap icon for mouse3 fill.
  static IconData mouse3Fill;
/// Bootstrap icon for mouse3.
  static IconData mouse3;
/// Bootstrap icon for music note beamed.
  static IconData musicNoteBeamed;
/// Bootstrap icon for music note list.
  static IconData musicNoteList;
/// Bootstrap icon for music note.
  static IconData musicNote;
/// Bootstrap icon for music player fill.
  static IconData musicPlayerFill;
/// Bootstrap icon for music player.
  static IconData musicPlayer;
/// Bootstrap icon for newspaper.
  static IconData newspaper;
/// Bootstrap icon for node minus fill.
  static IconData nodeMinusFill;
/// Bootstrap icon for node minus.
  static IconData nodeMinus;
/// Bootstrap icon for node plus fill.
  static IconData nodePlusFill;
/// Bootstrap icon for node plus.
  static IconData nodePlus;
/// Bootstrap icon for nut fill.
  static IconData nutFill;
/// Bootstrap icon for nut.
  static IconData nut;
/// Bootstrap icon for octagon fill.
  static IconData octagonFill;
/// Bootstrap icon for octagon half.
  static IconData octagonHalf;
/// Bootstrap icon for octagon.
  static IconData octagon;
/// Bootstrap icon for option.
  static IconData option;
/// Bootstrap icon for outlet.
  static IconData outlet;
/// Bootstrap icon for paint bucket.
  static IconData paintBucket;
/// Bootstrap icon for palette fill.
  static IconData paletteFill;
/// Bootstrap icon for palette.
  static IconData palette;
/// Bootstrap icon for palette2.
  static IconData palette2;
/// Bootstrap icon for paperclip.
  static IconData paperclip;
/// Bootstrap icon for paragraph.
  static IconData paragraph;
/// Bootstrap icon for patch check fill.
  static IconData patchCheckFill;
/// Bootstrap icon for patch check.
  static IconData patchCheck;
/// Bootstrap icon for patch exclamation fill.
  static IconData patchExclamationFill;
/// Bootstrap icon for patch exclamation.
  static IconData patchExclamation;
/// Bootstrap icon for patch minus fill.
  static IconData patchMinusFill;
/// Bootstrap icon for patch minus.
  static IconData patchMinus;
/// Bootstrap icon for patch plus fill.
  static IconData patchPlusFill;
/// Bootstrap icon for patch plus.
  static IconData patchPlus;
/// Bootstrap icon for patch question fill.
  static IconData patchQuestionFill;
/// Bootstrap icon for patch question.
  static IconData patchQuestion;
/// Bootstrap icon for pause btn fill.
  static IconData pauseBtnFill;
/// Bootstrap icon for pause btn.
  static IconData pauseBtn;
/// Bootstrap icon for pause circle fill.
  static IconData pauseCircleFill;
/// Bootstrap icon for pause circle.
  static IconData pauseCircle;
/// Bootstrap icon for pause fill.
  static IconData pauseFill;
/// Bootstrap icon for pause.
  static IconData pause;
/// Bootstrap icon for peace fill.
  static IconData peaceFill;
/// Bootstrap icon for peace.
  static IconData peace;
/// Bootstrap icon for pen fill.
  static IconData penFill;
/// Bootstrap icon for pen.
  static IconData pen;
/// Bootstrap icon for pencil fill.
  static IconData pencilFill;
/// Bootstrap icon for pencil square.
  static IconData pencilSquare;
/// Bootstrap icon for pencil.
  static IconData pencil;
/// Bootstrap icon for pentagon fill.
  static IconData pentagonFill;
/// Bootstrap icon for pentagon half.
  static IconData pentagonHalf;
/// Bootstrap icon for pentagon.
  static IconData pentagon;
/// Bootstrap icon for people fill.
  static IconData peopleFill;
/// Bootstrap icon for people.
  static IconData people;
/// Bootstrap icon for percent.
  static IconData percent;
/// Bootstrap icon for person badge fill.
  static IconData personBadgeFill;
/// Bootstrap icon for person badge.
  static IconData personBadge;
/// Bootstrap icon for person bounding box.
  static IconData personBoundingBox;
/// Bootstrap icon for person check fill.
  static IconData personCheckFill;
/// Bootstrap icon for person check.
  static IconData personCheck;
/// Bootstrap icon for person circle.
  static IconData personCircle;
/// Bootstrap icon for person dash fill.
  static IconData personDashFill;
/// Bootstrap icon for person dash.
  static IconData personDash;
/// Bootstrap icon for person fill.
  static IconData personFill;
/// Bootstrap icon for person lines fill.
  static IconData personLinesFill;
/// Bootstrap icon for person plus fill.
  static IconData personPlusFill;
/// Bootstrap icon for person plus.
  static IconData personPlus;
/// Bootstrap icon for person square.
  static IconData personSquare;
/// Bootstrap icon for person x fill.
  static IconData personXFill;
/// Bootstrap icon for person x.
  static IconData personX;
/// Bootstrap icon for person.
  static IconData person;
/// Bootstrap icon for phone fill.
  static IconData phoneFill;
/// Bootstrap icon for phone landscape fill.
  static IconData phoneLandscapeFill;
/// Bootstrap icon for phone landscape.
  static IconData phoneLandscape;
/// Bootstrap icon for phone vibrate fill.
  static IconData phoneVibrateFill;
/// Bootstrap icon for phone vibrate.
  static IconData phoneVibrate;
/// Bootstrap icon for phone.
  static IconData phone;
/// Bootstrap icon for pie chart fill.
  static IconData pieChartFill;
/// Bootstrap icon for pie chart.
  static IconData pieChart;
/// Bootstrap icon for pin angle fill.
  static IconData pinAngleFill;
/// Bootstrap icon for pin angle.
  static IconData pinAngle;
/// Bootstrap icon for pin fill.
  static IconData pinFill;
/// Bootstrap icon for pin.
  static IconData pin;
/// Bootstrap icon for pip fill.
  static IconData pipFill;
/// Bootstrap icon for pip.
  static IconData pip;
/// Bootstrap icon for play btn fill.
  static IconData playBtnFill;
/// Bootstrap icon for play btn.
  static IconData playBtn;
/// Bootstrap icon for play circle fill.
  static IconData playCircleFill;
/// Bootstrap icon for play circle.
  static IconData playCircle;
/// Bootstrap icon for play fill.
  static IconData playFill;
/// Bootstrap icon for play.
  static IconData play;
/// Bootstrap icon for plug fill.
  static IconData plugFill;
/// Bootstrap icon for plug.
  static IconData plug;
/// Bootstrap icon for plus circle dotted.
  static IconData plusCircleDotted;
/// Bootstrap icon for plus circle fill.
  static IconData plusCircleFill;
/// Bootstrap icon for plus circle.
  static IconData plusCircle;
/// Bootstrap icon for plus square dotted.
  static IconData plusSquareDotted;
/// Bootstrap icon for plus square fill.
  static IconData plusSquareFill;
/// Bootstrap icon for plus square.
  static IconData plusSquare;
/// Bootstrap icon for plus.
  static IconData plus;
/// Bootstrap icon for power.
  static IconData power;
/// Bootstrap icon for printer fill.
  static IconData printerFill;
/// Bootstrap icon for printer.
  static IconData printer;
/// Bootstrap icon for puzzle fill.
  static IconData puzzleFill;
/// Bootstrap icon for puzzle.
  static IconData puzzle;
/// Bootstrap icon for question circle fill.
  static IconData questionCircleFill;
/// Bootstrap icon for question circle.
  static IconData questionCircle;
/// Bootstrap icon for question diamond fill.
  static IconData questionDiamondFill;
/// Bootstrap icon for question diamond.
  static IconData questionDiamond;
/// Bootstrap icon for question octagon fill.
  static IconData questionOctagonFill;
/// Bootstrap icon for question octagon.
  static IconData questionOctagon;
/// Bootstrap icon for question square fill.
  static IconData questionSquareFill;
/// Bootstrap icon for question square.
  static IconData questionSquare;
/// Bootstrap icon for question.
  static IconData question;
/// Bootstrap icon for rainbow.
  static IconData rainbow;
/// Bootstrap icon for receipt cutoff.
  static IconData receiptCutoff;
/// Bootstrap icon for receipt.
  static IconData receipt;
/// Bootstrap icon for reception0.
  static IconData reception0;
/// Bootstrap icon for reception1.
  static IconData reception1;
/// Bootstrap icon for reception2.
  static IconData reception2;
/// Bootstrap icon for reception3.
  static IconData reception3;
/// Bootstrap icon for reception4.
  static IconData reception4;
/// Bootstrap icon for record btn fill.
  static IconData recordBtnFill;
/// Bootstrap icon for record btn.
  static IconData recordBtn;
/// Bootstrap icon for record circle fill.
  static IconData recordCircleFill;
/// Bootstrap icon for record circle.
  static IconData recordCircle;
/// Bootstrap icon for record fill.
  static IconData recordFill;
/// Bootstrap icon for record.
  static IconData record;
/// Bootstrap icon for record2 fill.
  static IconData record2Fill;
/// Bootstrap icon for record2.
  static IconData record2;
/// Bootstrap icon for reply all fill.
  static IconData replyAllFill;
/// Bootstrap icon for reply all.
  static IconData replyAll;
/// Bootstrap icon for reply fill.
  static IconData replyFill;
/// Bootstrap icon for reply.
  static IconData reply;
/// Bootstrap icon for rss fill.
  static IconData rssFill;
/// Bootstrap icon for rss.
  static IconData rss;
/// Bootstrap icon for rulers.
  static IconData rulers;
/// Bootstrap icon for save fill.
  static IconData saveFill;
/// Bootstrap icon for save.
  static IconData save;
/// Bootstrap icon for save2 fill.
  static IconData save2Fill;
/// Bootstrap icon for save2.
  static IconData save2;
/// Bootstrap icon for scissors.
  static IconData scissors;
/// Bootstrap icon for screwdriver.
  static IconData screwdriver;
/// Bootstrap icon for search.
  static IconData search;
/// Bootstrap icon for segmented nav.
  static IconData segmentedNav;
/// Bootstrap icon for server.
  static IconData server;
/// Bootstrap icon for share fill.
  static IconData shareFill;
/// Bootstrap icon for share.
  static IconData share;
/// Bootstrap icon for shield check.
  static IconData shieldCheck;
/// Bootstrap icon for shield exclamation.
  static IconData shieldExclamation;
/// Bootstrap icon for shield fill check.
  static IconData shieldFillCheck;
/// Bootstrap icon for shield fill exclamation.
  static IconData shieldFillExclamation;
/// Bootstrap icon for shield fill minus.
  static IconData shieldFillMinus;
/// Bootstrap icon for shield fill plus.
  static IconData shieldFillPlus;
/// Bootstrap icon for shield fill x.
  static IconData shieldFillX;
/// Bootstrap icon for shield fill.
  static IconData shieldFill;
/// Bootstrap icon for shield lock fill.
  static IconData shieldLockFill;
/// Bootstrap icon for shield lock.
  static IconData shieldLock;
/// Bootstrap icon for shield minus.
  static IconData shieldMinus;
/// Bootstrap icon for shield plus.
  static IconData shieldPlus;
/// Bootstrap icon for shield shaded.
  static IconData shieldShaded;
/// Bootstrap icon for shield slash fill.
  static IconData shieldSlashFill;
/// Bootstrap icon for shield slash.
  static IconData shieldSlash;
/// Bootstrap icon for shield x.
  static IconData shieldX;
/// Bootstrap icon for shield.
  static IconData shield;
/// Bootstrap icon for shift fill.
  static IconData shiftFill;
/// Bootstrap icon for shift.
  static IconData shift;
/// Bootstrap icon for shop window.
  static IconData shopWindow;
/// Bootstrap icon for shop.
  static IconData shop;
/// Bootstrap icon for shuffle.
  static IconData shuffle;
/// Bootstrap icon for signpost2 fill.
  static IconData signpost2Fill;
/// Bootstrap icon for signpost2.
  static IconData signpost2;
/// Bootstrap icon for signpost fill.
  static IconData signpostFill;
/// Bootstrap icon for signpost split fill.
  static IconData signpostSplitFill;
/// Bootstrap icon for signpost split.
  static IconData signpostSplit;
/// Bootstrap icon for signpost.
  static IconData signpost;
/// Bootstrap icon for sim fill.
  static IconData simFill;
/// Bootstrap icon for sim.
  static IconData sim;
/// Bootstrap icon for skip backward btn fill.
  static IconData skipBackwardBtnFill;
/// Bootstrap icon for skip backward btn.
  static IconData skipBackwardBtn;
/// Bootstrap icon for skip backward circle fill.
  static IconData skipBackwardCircleFill;
/// Bootstrap icon for skip backward circle.
  static IconData skipBackwardCircle;
/// Bootstrap icon for skip backward fill.
  static IconData skipBackwardFill;
/// Bootstrap icon for skip backward.
  static IconData skipBackward;
/// Bootstrap icon for skip end btn fill.
  static IconData skipEndBtnFill;
/// Bootstrap icon for skip end btn.
  static IconData skipEndBtn;
/// Bootstrap icon for skip end circle fill.
  static IconData skipEndCircleFill;
/// Bootstrap icon for skip end circle.
  static IconData skipEndCircle;
/// Bootstrap icon for skip end fill.
  static IconData skipEndFill;
/// Bootstrap icon for skip end.
  static IconData skipEnd;
/// Bootstrap icon for skip forward btn fill.
  static IconData skipForwardBtnFill;
/// Bootstrap icon for skip forward btn.
  static IconData skipForwardBtn;
/// Bootstrap icon for skip forward circle fill.
  static IconData skipForwardCircleFill;
/// Bootstrap icon for skip forward circle.
  static IconData skipForwardCircle;
/// Bootstrap icon for skip forward fill.
  static IconData skipForwardFill;
/// Bootstrap icon for skip forward.
  static IconData skipForward;
/// Bootstrap icon for skip start btn fill.
  static IconData skipStartBtnFill;
/// Bootstrap icon for skip start btn.
  static IconData skipStartBtn;
/// Bootstrap icon for skip start circle fill.
  static IconData skipStartCircleFill;
/// Bootstrap icon for skip start circle.
  static IconData skipStartCircle;
/// Bootstrap icon for skip start fill.
  static IconData skipStartFill;
/// Bootstrap icon for skip start.
  static IconData skipStart;
/// Bootstrap icon for slack.
  static IconData slack;
/// Bootstrap icon for slash circle fill.
  static IconData slashCircleFill;
/// Bootstrap icon for slash circle.
  static IconData slashCircle;
/// Bootstrap icon for slash square fill.
  static IconData slashSquareFill;
/// Bootstrap icon for slash square.
  static IconData slashSquare;
/// Bootstrap icon for slash.
  static IconData slash;
/// Bootstrap icon for sliders.
  static IconData sliders;
/// Bootstrap icon for smartwatch.
  static IconData smartwatch;
/// Bootstrap icon for snow.
  static IconData snow;
/// Bootstrap icon for snow2.
  static IconData snow2;
/// Bootstrap icon for snow3.
  static IconData snow3;
/// Bootstrap icon for sort alpha down alt.
  static IconData sortAlphaDownAlt;
/// Bootstrap icon for sort alpha down.
  static IconData sortAlphaDown;
/// Bootstrap icon for sort alpha up alt.
  static IconData sortAlphaUpAlt;
/// Bootstrap icon for sort alpha up.
  static IconData sortAlphaUp;
/// Bootstrap icon for sort down alt.
  static IconData sortDownAlt;
/// Bootstrap icon for sort down.
  static IconData sortDown;
/// Bootstrap icon for sort numeric down alt.
  static IconData sortNumericDownAlt;
/// Bootstrap icon for sort numeric down.
  static IconData sortNumericDown;
/// Bootstrap icon for sort numeric up alt.
  static IconData sortNumericUpAlt;
/// Bootstrap icon for sort numeric up.
  static IconData sortNumericUp;
/// Bootstrap icon for sort up alt.
  static IconData sortUpAlt;
/// Bootstrap icon for sort up.
  static IconData sortUp;
/// Bootstrap icon for soundwave.
  static IconData soundwave;
/// Bootstrap icon for speaker fill.
  static IconData speakerFill;
/// Bootstrap icon for speaker.
  static IconData speaker;
/// Bootstrap icon for speedometer.
  static IconData speedometer;
/// Bootstrap icon for speedometer2.
  static IconData speedometer2;
/// Bootstrap icon for spellcheck.
  static IconData spellcheck;
/// Bootstrap icon for square fill.
  static IconData squareFill;
/// Bootstrap icon for square half.
  static IconData squareHalf;
/// Bootstrap icon for square.
  static IconData square;
/// Bootstrap icon for stack.
  static IconData stack;
/// Bootstrap icon for star fill.
  static IconData starFill;
/// Bootstrap icon for star half.
  static IconData starHalf;
/// Bootstrap icon for star.
  static IconData star;
/// Bootstrap icon for stars.
  static IconData stars;
/// Bootstrap icon for stickies fill.
  static IconData stickiesFill;
/// Bootstrap icon for stickies.
  static IconData stickies;
/// Bootstrap icon for sticky fill.
  static IconData stickyFill;
/// Bootstrap icon for sticky.
  static IconData sticky;
/// Bootstrap icon for stop btn fill.
  static IconData stopBtnFill;
/// Bootstrap icon for stop btn.
  static IconData stopBtn;
/// Bootstrap icon for stop circle fill.
  static IconData stopCircleFill;
/// Bootstrap icon for stop circle.
  static IconData stopCircle;
/// Bootstrap icon for stop fill.
  static IconData stopFill;
/// Bootstrap icon for stop.
  static IconData stop;
/// Bootstrap icon for stoplights fill.
  static IconData stoplightsFill;
/// Bootstrap icon for stoplights.
  static IconData stoplights;
/// Bootstrap icon for stopwatch fill.
  static IconData stopwatchFill;
/// Bootstrap icon for stopwatch.
  static IconData stopwatch;
/// Bootstrap icon for subtract.
  static IconData subtract;
/// Bootstrap icon for suit club fill.
  static IconData suitClubFill;
/// Bootstrap icon for suit club.
  static IconData suitClub;
/// Bootstrap icon for suit diamond fill.
  static IconData suitDiamondFill;
/// Bootstrap icon for suit diamond.
  static IconData suitDiamond;
/// Bootstrap icon for suit heart fill.
  static IconData suitHeartFill;
/// Bootstrap icon for suit heart.
  static IconData suitHeart;
/// Bootstrap icon for suit spade fill.
  static IconData suitSpadeFill;
/// Bootstrap icon for suit spade.
  static IconData suitSpade;
/// Bootstrap icon for sun fill.
  static IconData sunFill;
/// Bootstrap icon for sun.
  static IconData sun;
/// Bootstrap icon for sunglasses.
  static IconData sunglasses;
/// Bootstrap icon for sunrise fill.
  static IconData sunriseFill;
/// Bootstrap icon for sunrise.
  static IconData sunrise;
/// Bootstrap icon for sunset fill.
  static IconData sunsetFill;
/// Bootstrap icon for sunset.
  static IconData sunset;
/// Bootstrap icon for symmetry horizontal.
  static IconData symmetryHorizontal;
/// Bootstrap icon for symmetry vertical.
  static IconData symmetryVertical;
/// Bootstrap icon for table.
  static IconData table;
/// Bootstrap icon for tablet fill.
  static IconData tabletFill;
/// Bootstrap icon for tablet landscape fill.
  static IconData tabletLandscapeFill;
/// Bootstrap icon for tablet landscape.
  static IconData tabletLandscape;
/// Bootstrap icon for tablet.
  static IconData tablet;
/// Bootstrap icon for tag fill.
  static IconData tagFill;
/// Bootstrap icon for tag.
  static IconData tag;
/// Bootstrap icon for tags fill.
  static IconData tagsFill;
/// Bootstrap icon for tags.
  static IconData tags;
/// Bootstrap icon for telegram.
  static IconData telegram;
/// Bootstrap icon for telephone fill.
  static IconData telephoneFill;
/// Bootstrap icon for telephone forward fill.
  static IconData telephoneForwardFill;
/// Bootstrap icon for telephone forward.
  static IconData telephoneForward;
/// Bootstrap icon for telephone inbound fill.
  static IconData telephoneInboundFill;
/// Bootstrap icon for telephone inbound.
  static IconData telephoneInbound;
/// Bootstrap icon for telephone minus fill.
  static IconData telephoneMinusFill;
/// Bootstrap icon for telephone minus.
  static IconData telephoneMinus;
/// Bootstrap icon for telephone outbound fill.
  static IconData telephoneOutboundFill;
/// Bootstrap icon for telephone outbound.
  static IconData telephoneOutbound;
/// Bootstrap icon for telephone plus fill.
  static IconData telephonePlusFill;
/// Bootstrap icon for telephone plus.
  static IconData telephonePlus;
/// Bootstrap icon for telephone x fill.
  static IconData telephoneXFill;
/// Bootstrap icon for telephone x.
  static IconData telephoneX;
/// Bootstrap icon for telephone.
  static IconData telephone;
/// Bootstrap icon for terminal fill.
  static IconData terminalFill;
/// Bootstrap icon for terminal.
  static IconData terminal;
/// Bootstrap icon for text center.
  static IconData textCenter;
/// Bootstrap icon for text indent left.
  static IconData textIndentLeft;
/// Bootstrap icon for text indent right.
  static IconData textIndentRight;
/// Bootstrap icon for text left.
  static IconData textLeft;
/// Bootstrap icon for text paragraph.
  static IconData textParagraph;
/// Bootstrap icon for text right.
  static IconData textRight;
/// Bootstrap icon for textarea resize.
  static IconData textareaResize;
/// Bootstrap icon for textarea t.
  static IconData textareaT;
/// Bootstrap icon for textarea.
  static IconData textarea;
/// Bootstrap icon for thermometer half.
  static IconData thermometerHalf;
/// Bootstrap icon for thermometer high.
  static IconData thermometerHigh;
/// Bootstrap icon for thermometer low.
  static IconData thermometerLow;
/// Bootstrap icon for thermometer snow.
  static IconData thermometerSnow;
/// Bootstrap icon for thermometer sun.
  static IconData thermometerSun;
/// Bootstrap icon for thermometer.
  static IconData thermometer;
/// Bootstrap icon for three dots vertical.
  static IconData threeDotsVertical;
/// Bootstrap icon for three dots.
  static IconData threeDots;
/// Bootstrap icon for toggle off.
  static IconData toggleOff;
/// Bootstrap icon for toggle on.
  static IconData toggleOn;
/// Bootstrap icon for toggle2 off.
  static IconData toggle2Off;
/// Bootstrap icon for toggle2 on.
  static IconData toggle2On;
/// Bootstrap icon for toggles.
  static IconData toggles;
/// Bootstrap icon for toggles2.
  static IconData toggles2;
/// Bootstrap icon for tools.
  static IconData tools;
/// Bootstrap icon for tornado.
  static IconData tornado;
/// Bootstrap icon for trash fill.
  static IconData trashFill;
/// Bootstrap icon for trash.
  static IconData trash;
/// Bootstrap icon for trash2 fill.
  static IconData trash2Fill;
/// Bootstrap icon for trash2.
  static IconData trash2;
/// Bootstrap icon for tree fill.
  static IconData treeFill;
/// Bootstrap icon for tree.
  static IconData tree;
/// Bootstrap icon for triangle fill.
  static IconData triangleFill;
/// Bootstrap icon for triangle half.
  static IconData triangleHalf;
/// Bootstrap icon for triangle.
  static IconData triangle;
/// Bootstrap icon for trophy fill.
  static IconData trophyFill;
/// Bootstrap icon for trophy.
  static IconData trophy;
/// Bootstrap icon for tropical storm.
  static IconData tropicalStorm;
/// Bootstrap icon for truck flatbed.
  static IconData truckFlatbed;
/// Bootstrap icon for truck.
  static IconData truck;
/// Bootstrap icon for tsunami.
  static IconData tsunami;
/// Bootstrap icon for tv fill.
  static IconData tvFill;
/// Bootstrap icon for tv.
  static IconData tv;
/// Bootstrap icon for twitch.
  static IconData twitch;
/// Bootstrap icon for twitter.
  static IconData twitter;
/// Bootstrap icon for type bold.
  static IconData typeBold;
/// Bootstrap icon for type h1.
  static IconData typeH1;
/// Bootstrap icon for type h2.
  static IconData typeH2;
/// Bootstrap icon for type h3.
  static IconData typeH3;
/// Bootstrap icon for type italic.
  static IconData typeItalic;
/// Bootstrap icon for type strikethrough.
  static IconData typeStrikethrough;
/// Bootstrap icon for type underline.
  static IconData typeUnderline;
/// Bootstrap icon for type.
  static IconData type;
/// Bootstrap icon for ui checks grid.
  static IconData uiChecksGrid;
/// Bootstrap icon for ui checks.
  static IconData uiChecks;
/// Bootstrap icon for ui radios grid.
  static IconData uiRadiosGrid;
/// Bootstrap icon for ui radios.
  static IconData uiRadios;
/// Bootstrap icon for umbrella fill.
  static IconData umbrellaFill;
/// Bootstrap icon for umbrella.
  static IconData umbrella;
/// Bootstrap icon for union.
  static IconData union;
/// Bootstrap icon for unlock fill.
  static IconData unlockFill;
/// Bootstrap icon for unlock.
  static IconData unlock;
/// Bootstrap icon for upc scan.
  static IconData upcScan;
/// Bootstrap icon for upc.
  static IconData upc;
/// Bootstrap icon for upload.
  static IconData upload;
/// Bootstrap icon for vector pen.
  static IconData vectorPen;
/// Bootstrap icon for view list.
  static IconData viewList;
/// Bootstrap icon for view stacked.
  static IconData viewStacked;
/// Bootstrap icon for vinyl fill.
  static IconData vinylFill;
/// Bootstrap icon for vinyl.
  static IconData vinyl;
/// Bootstrap icon for voicemail.
  static IconData voicemail;
/// Bootstrap icon for volume down fill.
  static IconData volumeDownFill;
/// Bootstrap icon for volume down.
  static IconData volumeDown;
/// Bootstrap icon for volume mute fill.
  static IconData volumeMuteFill;
/// Bootstrap icon for volume mute.
  static IconData volumeMute;
/// Bootstrap icon for volume off fill.
  static IconData volumeOffFill;
/// Bootstrap icon for volume off.
  static IconData volumeOff;
/// Bootstrap icon for volume up fill.
  static IconData volumeUpFill;
/// Bootstrap icon for volume up.
  static IconData volumeUp;
/// Bootstrap icon for vr.
  static IconData vr;
/// Bootstrap icon for wallet fill.
  static IconData walletFill;
/// Bootstrap icon for wallet.
  static IconData wallet;
/// Bootstrap icon for wallet2.
  static IconData wallet2;
/// Bootstrap icon for watch.
  static IconData watch;
/// Bootstrap icon for water.
  static IconData water;
/// Bootstrap icon for whatsapp.
  static IconData whatsapp;
/// Bootstrap icon for wifi1.
  static IconData wifi1;
/// Bootstrap icon for wifi2.
  static IconData wifi2;
/// Bootstrap icon for wifi off.
  static IconData wifiOff;
/// Bootstrap icon for wifi.
  static IconData wifi;
/// Bootstrap icon for wind.
  static IconData wind;
/// Bootstrap icon for window dock.
  static IconData windowDock;
/// Bootstrap icon for window sidebar.
  static IconData windowSidebar;
/// Bootstrap icon for window.
  static IconData window;
/// Bootstrap icon for wrench.
  static IconData wrench;
/// Bootstrap icon for x circle fill.
  static IconData xCircleFill;
/// Bootstrap icon for x circle.
  static IconData xCircle;
/// Bootstrap icon for x diamond fill.
  static IconData xDiamondFill;
/// Bootstrap icon for x diamond.
  static IconData xDiamond;
/// Bootstrap icon for x octagon fill.
  static IconData xOctagonFill;
/// Bootstrap icon for x octagon.
  static IconData xOctagon;
/// Bootstrap icon for x square fill.
  static IconData xSquareFill;
/// Bootstrap icon for x square.
  static IconData xSquare;
/// Bootstrap icon for x.
  static IconData x;
/// Bootstrap icon for youtube.
  static IconData youtube;
/// Bootstrap icon for zoom in.
  static IconData zoomIn;
/// Bootstrap icon for zoom out.
  static IconData zoomOut;
/// Bootstrap icon for bank.
  static IconData bank;
/// Bootstrap icon for bank2.
  static IconData bank2;
/// Bootstrap icon for bell slash fill.
  static IconData bellSlashFill;
/// Bootstrap icon for bell slash.
  static IconData bellSlash;
/// Bootstrap icon for cash coin.
  static IconData cashCoin;
/// Bootstrap icon for check lg.
  static IconData checkLg;
/// Bootstrap icon for coin.
  static IconData coin;
/// Bootstrap icon for currency bitcoin.
  static IconData currencyBitcoin;
/// Bootstrap icon for currency dollar.
  static IconData currencyDollar;
/// Bootstrap icon for currency euro.
  static IconData currencyEuro;
/// Bootstrap icon for currency exchange.
  static IconData currencyExchange;
/// Bootstrap icon for currency pound.
  static IconData currencyPound;
/// Bootstrap icon for currency yen.
  static IconData currencyYen;
/// Bootstrap icon for dash lg.
  static IconData dashLg;
/// Bootstrap icon for exclamation lg.
  static IconData exclamationLg;
/// Bootstrap icon for file earmark pdf fill.
  static IconData fileEarmarkPdfFill;
/// Bootstrap icon for file earmark pdf.
  static IconData fileEarmarkPdf;
/// Bootstrap icon for file pdf fill.
  static IconData filePdfFill;
/// Bootstrap icon for file pdf.
  static IconData filePdf;
/// Bootstrap icon for gender ambiguous.
  static IconData genderAmbiguous;
/// Bootstrap icon for gender female.
  static IconData genderFemale;
/// Bootstrap icon for gender male.
  static IconData genderMale;
/// Bootstrap icon for gender trans.
  static IconData genderTrans;
/// Bootstrap icon for headset vr.
  static IconData headsetVr;
/// Bootstrap icon for info lg.
  static IconData infoLg;
/// Bootstrap icon for mastodon.
  static IconData mastodon;
/// Bootstrap icon for messenger.
  static IconData messenger;
/// Bootstrap icon for piggy bank fill.
  static IconData piggyBankFill;
/// Bootstrap icon for piggy bank.
  static IconData piggyBank;
/// Bootstrap icon for pin map fill.
  static IconData pinMapFill;
/// Bootstrap icon for pin map.
  static IconData pinMap;
/// Bootstrap icon for plus lg.
  static IconData plusLg;
/// Bootstrap icon for question lg.
  static IconData questionLg;
/// Bootstrap icon for recycle.
  static IconData recycle;
/// Bootstrap icon for reddit.
  static IconData reddit;
/// Bootstrap icon for safe fill.
  static IconData safeFill;
/// Bootstrap icon for safe2 fill.
  static IconData safe2Fill;
/// Bootstrap icon for safe2.
  static IconData safe2;
/// Bootstrap icon for sd card fill.
  static IconData sdCardFill;
/// Bootstrap icon for sd card.
  static IconData sdCard;
/// Bootstrap icon for skype.
  static IconData skype;
/// Bootstrap icon for slash lg.
  static IconData slashLg;
/// Bootstrap icon for translate.
  static IconData translate;
/// Bootstrap icon for x lg.
  static IconData xLg;
/// Bootstrap icon for safe.
  static IconData safe;
/// Bootstrap icon for apple.
  static IconData apple;
/// Bootstrap icon for microsoft.
  static IconData microsoft;
/// Bootstrap icon for windows.
  static IconData windows;
/// Bootstrap icon for behance.
  static IconData behance;
/// Bootstrap icon for dribbble.
  static IconData dribbble;
/// Bootstrap icon for line.
  static IconData line;
/// Bootstrap icon for medium.
  static IconData medium;
/// Bootstrap icon for paypal.
  static IconData paypal;
/// Bootstrap icon for pinterest.
  static IconData pinterest;
/// Bootstrap icon for signal.
  static IconData signal;
/// Bootstrap icon for snapchat.
  static IconData snapchat;
/// Bootstrap icon for spotify.
  static IconData spotify;
/// Bootstrap icon for stack overflow.
  static IconData stackOverflow;
/// Bootstrap icon for strava.
  static IconData strava;
/// Bootstrap icon for wordpress.
  static IconData wordpress;
/// Bootstrap icon for vimeo.
  static IconData vimeo;
/// Bootstrap icon for activity.
  static IconData activity;
/// Bootstrap icon for easel2 fill.
  static IconData easel2Fill;
/// Bootstrap icon for easel2.
  static IconData easel2;
/// Bootstrap icon for easel3 fill.
  static IconData easel3Fill;
/// Bootstrap icon for easel3.
  static IconData easel3;
/// Bootstrap icon for fan.
  static IconData fan;
/// Bootstrap icon for fingerprint.
  static IconData fingerprint;
/// Bootstrap icon for graph down arrow.
  static IconData graphDownArrow;
/// Bootstrap icon for graph up arrow.
  static IconData graphUpArrow;
/// Bootstrap icon for hypnotize.
  static IconData hypnotize;
/// Bootstrap icon for magic.
  static IconData magic;
/// Bootstrap icon for person rolodex.
  static IconData personRolodex;
/// Bootstrap icon for person video.
  static IconData personVideo;
/// Bootstrap icon for person video2.
  static IconData personVideo2;
/// Bootstrap icon for person video3.
  static IconData personVideo3;
/// Bootstrap icon for person workspace.
  static IconData personWorkspace;
/// Bootstrap icon for radioactive.
  static IconData radioactive;
/// Bootstrap icon for webcam fill.
  static IconData webcamFill;
/// Bootstrap icon for webcam.
  static IconData webcam;
/// Bootstrap icon for yin yang.
  static IconData yinYang;
/// Bootstrap icon for bandaid fill.
  static IconData bandaidFill;
/// Bootstrap icon for bandaid.
  static IconData bandaid;
/// Bootstrap icon for bluetooth.
  static IconData bluetooth;
/// Bootstrap icon for body text.
  static IconData bodyText;
/// Bootstrap icon for boombox.
  static IconData boombox;
/// Bootstrap icon for boxes.
  static IconData boxes;
/// Bootstrap icon for dpad fill.
  static IconData dpadFill;
/// Bootstrap icon for dpad.
  static IconData dpad;
/// Bootstrap icon for ear fill.
  static IconData earFill;
/// Bootstrap icon for ear.
  static IconData ear;
/// Bootstrap icon for envelope check fill.
  static IconData envelopeCheckFill;
/// Bootstrap icon for envelope check.
  static IconData envelopeCheck;
/// Bootstrap icon for envelope dash fill.
  static IconData envelopeDashFill;
/// Bootstrap icon for envelope dash.
  static IconData envelopeDash;
/// Bootstrap icon for envelope exclamation fill.
  static IconData envelopeExclamationFill;
/// Bootstrap icon for envelope exclamation.
  static IconData envelopeExclamation;
/// Bootstrap icon for envelope plus fill.
  static IconData envelopePlusFill;
/// Bootstrap icon for envelope plus.
  static IconData envelopePlus;
/// Bootstrap icon for envelope slash fill.
  static IconData envelopeSlashFill;
/// Bootstrap icon for envelope slash.
  static IconData envelopeSlash;
/// Bootstrap icon for envelope x fill.
  static IconData envelopeXFill;
/// Bootstrap icon for envelope x.
  static IconData envelopeX;
/// Bootstrap icon for explicit fill.
  static IconData explicitFill;
/// Bootstrap icon for explicit.
  static IconData explicit;
/// Bootstrap icon for git.
  static IconData git;
/// Bootstrap icon for infinity.
  static IconData infinity;
/// Bootstrap icon for list columns reverse.
  static IconData listColumnsReverse;
/// Bootstrap icon for list columns.
  static IconData listColumns;
/// Bootstrap icon for meta.
  static IconData meta;
/// Bootstrap icon for nintendo switch.
  static IconData nintendoSwitch;
/// Bootstrap icon for pc display horizontal.
  static IconData pcDisplayHorizontal;
/// Bootstrap icon for pc display.
  static IconData pcDisplay;
/// Bootstrap icon for pc horizontal.
  static IconData pcHorizontal;
/// Bootstrap icon for pc.
  static IconData pc;
/// Bootstrap icon for playstation.
  static IconData playstation;
/// Bootstrap icon for plus slash minus.
  static IconData plusSlashMinus;
/// Bootstrap icon for projector fill.
  static IconData projectorFill;
/// Bootstrap icon for projector.
  static IconData projector;
/// Bootstrap icon for qr code scan.
  static IconData qrCodeScan;
/// Bootstrap icon for qr code.
  static IconData qrCode;
/// Bootstrap icon for quora.
  static IconData quora;
/// Bootstrap icon for quote.
  static IconData quote;
/// Bootstrap icon for robot.
  static IconData robot;
/// Bootstrap icon for send check fill.
  static IconData sendCheckFill;
/// Bootstrap icon for send check.
  static IconData sendCheck;
/// Bootstrap icon for send dash fill.
  static IconData sendDashFill;
/// Bootstrap icon for send dash.
  static IconData sendDash;
/// Bootstrap icon for send exclamation fill.
  static IconData sendExclamationFill;
/// Bootstrap icon for send exclamation.
  static IconData sendExclamation;
/// Bootstrap icon for send fill.
  static IconData sendFill;
/// Bootstrap icon for send plus fill.
  static IconData sendPlusFill;
/// Bootstrap icon for send plus.
  static IconData sendPlus;
/// Bootstrap icon for send slash fill.
  static IconData sendSlashFill;
/// Bootstrap icon for send slash.
  static IconData sendSlash;
/// Bootstrap icon for send x fill.
  static IconData sendXFill;
/// Bootstrap icon for send x.
  static IconData sendX;
/// Bootstrap icon for send.
  static IconData send;
/// Bootstrap icon for steam.
  static IconData steam;
/// Bootstrap icon for terminal dash.
  static IconData terminalDash;
/// Bootstrap icon for terminal plus.
  static IconData terminalPlus;
/// Bootstrap icon for terminal split.
  static IconData terminalSplit;
/// Bootstrap icon for ticket detailed fill.
  static IconData ticketDetailedFill;
/// Bootstrap icon for ticket detailed.
  static IconData ticketDetailed;
/// Bootstrap icon for ticket fill.
  static IconData ticketFill;
/// Bootstrap icon for ticket perforated fill.
  static IconData ticketPerforatedFill;
/// Bootstrap icon for ticket perforated.
  static IconData ticketPerforated;
/// Bootstrap icon for ticket.
  static IconData ticket;
/// Bootstrap icon for tiktok.
  static IconData tiktok;
/// Bootstrap icon for window dash.
  static IconData windowDash;
/// Bootstrap icon for window desktop.
  static IconData windowDesktop;
/// Bootstrap icon for window fullscreen.
  static IconData windowFullscreen;
/// Bootstrap icon for window plus.
  static IconData windowPlus;
/// Bootstrap icon for window split.
  static IconData windowSplit;
/// Bootstrap icon for window stack.
  static IconData windowStack;
/// Bootstrap icon for window x.
  static IconData windowX;
/// Bootstrap icon for xbox.
  static IconData xbox;
/// Bootstrap icon for ethernet.
  static IconData ethernet;
/// Bootstrap icon for hdmi fill.
  static IconData hdmiFill;
/// Bootstrap icon for hdmi.
  static IconData hdmi;
/// Bootstrap icon for usb c fill.
  static IconData usbCFill;
/// Bootstrap icon for usb c.
  static IconData usbC;
/// Bootstrap icon for usb fill.
  static IconData usbFill;
/// Bootstrap icon for usb plug fill.
  static IconData usbPlugFill;
/// Bootstrap icon for usb plug.
  static IconData usbPlug;
/// Bootstrap icon for usb symbol.
  static IconData usbSymbol;
/// Bootstrap icon for usb.
  static IconData usb;
/// Bootstrap icon for boombox fill.
  static IconData boomboxFill;
/// Bootstrap icon for displayport.
  static IconData displayport;
/// Bootstrap icon for gpu card.
  static IconData gpuCard;
/// Bootstrap icon for memory.
  static IconData memory;
/// Bootstrap icon for modem fill.
  static IconData modemFill;
/// Bootstrap icon for modem.
  static IconData modem;
/// Bootstrap icon for motherboard fill.
  static IconData motherboardFill;
/// Bootstrap icon for motherboard.
  static IconData motherboard;
/// Bootstrap icon for optical audio fill.
  static IconData opticalAudioFill;
/// Bootstrap icon for optical audio.
  static IconData opticalAudio;
/// Bootstrap icon for pci card.
  static IconData pciCard;
/// Bootstrap icon for router fill.
  static IconData routerFill;
/// Bootstrap icon for router.
  static IconData router;
/// Bootstrap icon for thunderbolt fill.
  static IconData thunderboltFill;
/// Bootstrap icon for thunderbolt.
  static IconData thunderbolt;
/// Bootstrap icon for usb drive fill.
  static IconData usbDriveFill;
/// Bootstrap icon for usb drive.
  static IconData usbDrive;
/// Bootstrap icon for usb micro fill.
  static IconData usbMicroFill;
/// Bootstrap icon for usb micro.
  static IconData usbMicro;
/// Bootstrap icon for usb mini fill.
  static IconData usbMiniFill;
/// Bootstrap icon for usb mini.
  static IconData usbMini;
/// Bootstrap icon for cloud haze2.
  static IconData cloudHaze2;
/// Bootstrap icon for device hdd fill.
  static IconData deviceHddFill;
/// Bootstrap icon for device hdd.
  static IconData deviceHdd;
/// Bootstrap icon for device ssd fill.
  static IconData deviceSsdFill;
/// Bootstrap icon for device ssd.
  static IconData deviceSsd;
/// Bootstrap icon for displayport fill.
  static IconData displayportFill;
/// Bootstrap icon for mortarboard fill.
  static IconData mortarboardFill;
/// Bootstrap icon for mortarboard.
  static IconData mortarboard;
/// Bootstrap icon for terminal x.
  static IconData terminalX;
/// Bootstrap icon for arrow through heart fill.
  static IconData arrowThroughHeartFill;
/// Bootstrap icon for arrow through heart.
  static IconData arrowThroughHeart;
/// Bootstrap icon for badge sd fill.
  static IconData badgeSdFill;
/// Bootstrap icon for badge sd.
  static IconData badgeSd;
/// Bootstrap icon for bag heart fill.
  static IconData bagHeartFill;
/// Bootstrap icon for bag heart.
  static IconData bagHeart;
/// Bootstrap icon for balloon fill.
  static IconData balloonFill;
/// Bootstrap icon for balloon heart fill.
  static IconData balloonHeartFill;
/// Bootstrap icon for balloon heart.
  static IconData balloonHeart;
/// Bootstrap icon for balloon.
  static IconData balloon;
/// Bootstrap icon for box2 fill.
  static IconData box2Fill;
/// Bootstrap icon for box2 heart fill.
  static IconData box2HeartFill;
/// Bootstrap icon for box2 heart.
  static IconData box2Heart;
/// Bootstrap icon for box2.
  static IconData box2;
/// Bootstrap icon for braces asterisk.
  static IconData bracesAsterisk;
/// Bootstrap icon for calendar heart fill.
  static IconData calendarHeartFill;
/// Bootstrap icon for calendar heart.
  static IconData calendarHeart;
/// Bootstrap icon for calendar2 heart fill.
  static IconData calendar2HeartFill;
/// Bootstrap icon for calendar2 heart.
  static IconData calendar2Heart;
/// Bootstrap icon for chat heart fill.
  static IconData chatHeartFill;
/// Bootstrap icon for chat heart.
  static IconData chatHeart;
/// Bootstrap icon for chat left heart fill.
  static IconData chatLeftHeartFill;
/// Bootstrap icon for chat left heart.
  static IconData chatLeftHeart;
/// Bootstrap icon for chat right heart fill.
  static IconData chatRightHeartFill;
/// Bootstrap icon for chat right heart.
  static IconData chatRightHeart;
/// Bootstrap icon for chat square heart fill.
  static IconData chatSquareHeartFill;
/// Bootstrap icon for chat square heart.
  static IconData chatSquareHeart;
/// Bootstrap icon for clipboard check fill.
  static IconData clipboardCheckFill;
/// Bootstrap icon for clipboard data fill.
  static IconData clipboardDataFill;
/// Bootstrap icon for clipboard fill.
  static IconData clipboardFill;
/// Bootstrap icon for clipboard heart fill.
  static IconData clipboardHeartFill;
/// Bootstrap icon for clipboard heart.
  static IconData clipboardHeart;
/// Bootstrap icon for clipboard minus fill.
  static IconData clipboardMinusFill;
/// Bootstrap icon for clipboard plus fill.
  static IconData clipboardPlusFill;
/// Bootstrap icon for clipboard pulse.
  static IconData clipboardPulse;
/// Bootstrap icon for clipboard x fill.
  static IconData clipboardXFill;
/// Bootstrap icon for clipboard2 check fill.
  static IconData clipboard2CheckFill;
/// Bootstrap icon for clipboard2 check.
  static IconData clipboard2Check;
/// Bootstrap icon for clipboard2 data fill.
  static IconData clipboard2DataFill;
/// Bootstrap icon for clipboard2 data.
  static IconData clipboard2Data;
/// Bootstrap icon for clipboard2 fill.
  static IconData clipboard2Fill;
/// Bootstrap icon for clipboard2 heart fill.
  static IconData clipboard2HeartFill;
/// Bootstrap icon for clipboard2 heart.
  static IconData clipboard2Heart;
/// Bootstrap icon for clipboard2 minus fill.
  static IconData clipboard2MinusFill;
/// Bootstrap icon for clipboard2 minus.
  static IconData clipboard2Minus;
/// Bootstrap icon for clipboard2 plus fill.
  static IconData clipboard2PlusFill;
/// Bootstrap icon for clipboard2 plus.
  static IconData clipboard2Plus;
/// Bootstrap icon for clipboard2 pulse fill.
  static IconData clipboard2PulseFill;
/// Bootstrap icon for clipboard2 pulse.
  static IconData clipboard2Pulse;
/// Bootstrap icon for clipboard2 x fill.
  static IconData clipboard2XFill;
/// Bootstrap icon for clipboard2 x.
  static IconData clipboard2X;
/// Bootstrap icon for clipboard2.
  static IconData clipboard2;
/// Bootstrap icon for emoji kiss fill.
  static IconData emojiKissFill;
/// Bootstrap icon for emoji kiss.
  static IconData emojiKiss;
/// Bootstrap icon for envelope heart fill.
  static IconData envelopeHeartFill;
/// Bootstrap icon for envelope heart.
  static IconData envelopeHeart;
/// Bootstrap icon for envelope open heart fill.
  static IconData envelopeOpenHeartFill;
/// Bootstrap icon for envelope open heart.
  static IconData envelopeOpenHeart;
/// Bootstrap icon for envelope paper fill.
  static IconData envelopePaperFill;
/// Bootstrap icon for envelope paper heart fill.
  static IconData envelopePaperHeartFill;
/// Bootstrap icon for envelope paper heart.
  static IconData envelopePaperHeart;
/// Bootstrap icon for envelope paper.
  static IconData envelopePaper;
/// Bootstrap icon for filetype aac.
  static IconData filetypeAac;
/// Bootstrap icon for filetype ai.
  static IconData filetypeAi;
/// Bootstrap icon for filetype bmp.
  static IconData filetypeBmp;
/// Bootstrap icon for filetype cs.
  static IconData filetypeCs;
/// Bootstrap icon for filetype css.
  static IconData filetypeCss;
/// Bootstrap icon for filetype csv.
  static IconData filetypeCsv;
/// Bootstrap icon for filetype doc.
  static IconData filetypeDoc;
/// Bootstrap icon for filetype docx.
  static IconData filetypeDocx;
/// Bootstrap icon for filetype exe.
  static IconData filetypeExe;
/// Bootstrap icon for filetype gif.
  static IconData filetypeGif;
/// Bootstrap icon for filetype heic.
  static IconData filetypeHeic;
/// Bootstrap icon for filetype html.
  static IconData filetypeHtml;
/// Bootstrap icon for filetype java.
  static IconData filetypeJava;
/// Bootstrap icon for filetype jpg.
  static IconData filetypeJpg;
/// Bootstrap icon for filetype js.
  static IconData filetypeJs;
/// Bootstrap icon for filetype jsx.
  static IconData filetypeJsx;
/// Bootstrap icon for filetype key.
  static IconData filetypeKey;
/// Bootstrap icon for filetype m4p.
  static IconData filetypeM4p;
/// Bootstrap icon for filetype md.
  static IconData filetypeMd;
/// Bootstrap icon for filetype mdx.
  static IconData filetypeMdx;
/// Bootstrap icon for filetype mov.
  static IconData filetypeMov;
/// Bootstrap icon for filetype mp3.
  static IconData filetypeMp3;
/// Bootstrap icon for filetype mp4.
  static IconData filetypeMp4;
/// Bootstrap icon for filetype otf.
  static IconData filetypeOtf;
/// Bootstrap icon for filetype pdf.
  static IconData filetypePdf;
/// Bootstrap icon for filetype php.
  static IconData filetypePhp;
/// Bootstrap icon for filetype png.
  static IconData filetypePng;
/// Bootstrap icon for filetype ppt.
  static IconData filetypePpt;
/// Bootstrap icon for filetype psd.
  static IconData filetypePsd;
/// Bootstrap icon for filetype py.
  static IconData filetypePy;
/// Bootstrap icon for filetype raw.
  static IconData filetypeRaw;
/// Bootstrap icon for filetype rb.
  static IconData filetypeRb;
/// Bootstrap icon for filetype sass.
  static IconData filetypeSass;
/// Bootstrap icon for filetype scss.
  static IconData filetypeScss;
/// Bootstrap icon for filetype sh.
  static IconData filetypeSh;
/// Bootstrap icon for filetype svg.
  static IconData filetypeSvg;
/// Bootstrap icon for filetype tiff.
  static IconData filetypeTiff;
/// Bootstrap icon for filetype tsx.
  static IconData filetypeTsx;
/// Bootstrap icon for filetype ttf.
  static IconData filetypeTtf;
/// Bootstrap icon for filetype txt.
  static IconData filetypeTxt;
/// Bootstrap icon for filetype wav.
  static IconData filetypeWav;
/// Bootstrap icon for filetype woff.
  static IconData filetypeWoff;
/// Bootstrap icon for filetype xls.
  static IconData filetypeXls;
/// Bootstrap icon for filetype xml.
  static IconData filetypeXml;
/// Bootstrap icon for filetype yml.
  static IconData filetypeYml;
/// Bootstrap icon for heart arrow.
  static IconData heartArrow;
/// Bootstrap icon for heart pulse fill.
  static IconData heartPulseFill;
/// Bootstrap icon for heart pulse.
  static IconData heartPulse;
/// Bootstrap icon for heartbreak fill.
  static IconData heartbreakFill;
/// Bootstrap icon for heartbreak.
  static IconData heartbreak;
/// Bootstrap icon for hearts.
  static IconData hearts;
/// Bootstrap icon for hospital fill.
  static IconData hospitalFill;
/// Bootstrap icon for hospital.
  static IconData hospital;
/// Bootstrap icon for house heart fill.
  static IconData houseHeartFill;
/// Bootstrap icon for house heart.
  static IconData houseHeart;
/// Bootstrap icon for incognito.
  static IconData incognito;
/// Bootstrap icon for magnet fill.
  static IconData magnetFill;
/// Bootstrap icon for magnet.
  static IconData magnet;
/// Bootstrap icon for person heart.
  static IconData personHeart;
/// Bootstrap icon for person hearts.
  static IconData personHearts;
/// Bootstrap icon for phone flip.
  static IconData phoneFlip;
/// Bootstrap icon for plugin.
  static IconData plugin;
/// Bootstrap icon for postage fill.
  static IconData postageFill;
/// Bootstrap icon for postage heart fill.
  static IconData postageHeartFill;
/// Bootstrap icon for postage heart.
  static IconData postageHeart;
/// Bootstrap icon for postage.
  static IconData postage;
/// Bootstrap icon for postcard fill.
  static IconData postcardFill;
/// Bootstrap icon for postcard heart fill.
  static IconData postcardHeartFill;
/// Bootstrap icon for postcard heart.
  static IconData postcardHeart;
/// Bootstrap icon for postcard.
  static IconData postcard;
/// Bootstrap icon for search heart fill.
  static IconData searchHeartFill;
/// Bootstrap icon for search heart.
  static IconData searchHeart;
/// Bootstrap icon for sliders2 vertical.
  static IconData sliders2Vertical;
/// Bootstrap icon for sliders2.
  static IconData sliders2;
/// Bootstrap icon for trash3 fill.
  static IconData trash3Fill;
/// Bootstrap icon for trash3.
  static IconData trash3;
/// Bootstrap icon for valentine.
  static IconData valentine;
/// Bootstrap icon for valentine2.
  static IconData valentine2;
/// Bootstrap icon for wrench adjustable circle fill.
  static IconData wrenchAdjustableCircleFill;
/// Bootstrap icon for wrench adjustable circle.
  static IconData wrenchAdjustableCircle;
/// Bootstrap icon for wrench adjustable.
  static IconData wrenchAdjustable;
/// Bootstrap icon for filetype json.
  static IconData filetypeJson;
/// Bootstrap icon for filetype pptx.
  static IconData filetypePptx;
/// Bootstrap icon for filetype xlsx.
  static IconData filetypeXlsx;
/// Bootstrap icon for icon1 circle fill.
  static IconData icon1CircleFill;
/// Bootstrap icon for icon1 circle.
  static IconData icon1Circle;
/// Bootstrap icon for icon1 square fill.
  static IconData icon1SquareFill;
/// Bootstrap icon for icon1 square.
  static IconData icon1Square;
/// Bootstrap icon for icon2 circle fill.
  static IconData icon2CircleFill;
/// Bootstrap icon for icon2 circle.
  static IconData icon2Circle;
/// Bootstrap icon for icon2 square fill.
  static IconData icon2SquareFill;
/// Bootstrap icon for icon2 square.
  static IconData icon2Square;
/// Bootstrap icon for icon3 circle fill.
  static IconData icon3CircleFill;
/// Bootstrap icon for icon3 circle.
  static IconData icon3Circle;
/// Bootstrap icon for icon3 square fill.
  static IconData icon3SquareFill;
/// Bootstrap icon for icon3 square.
  static IconData icon3Square;
/// Bootstrap icon for icon4 circle fill.
  static IconData icon4CircleFill;
/// Bootstrap icon for icon4 circle.
  static IconData icon4Circle;
/// Bootstrap icon for icon4 square fill.
  static IconData icon4SquareFill;
/// Bootstrap icon for icon4 square.
  static IconData icon4Square;
/// Bootstrap icon for icon5 circle fill.
  static IconData icon5CircleFill;
/// Bootstrap icon for icon5 circle.
  static IconData icon5Circle;
/// Bootstrap icon for icon5 square fill.
  static IconData icon5SquareFill;
/// Bootstrap icon for icon5 square.
  static IconData icon5Square;
/// Bootstrap icon for icon6 circle fill.
  static IconData icon6CircleFill;
/// Bootstrap icon for icon6 circle.
  static IconData icon6Circle;
/// Bootstrap icon for icon6 square fill.
  static IconData icon6SquareFill;
/// Bootstrap icon for icon6 square.
  static IconData icon6Square;
/// Bootstrap icon for icon7 circle fill.
  static IconData icon7CircleFill;
/// Bootstrap icon for icon7 circle.
  static IconData icon7Circle;
/// Bootstrap icon for icon7 square fill.
  static IconData icon7SquareFill;
/// Bootstrap icon for icon7 square.
  static IconData icon7Square;
/// Bootstrap icon for icon8 circle fill.
  static IconData icon8CircleFill;
/// Bootstrap icon for icon8 circle.
  static IconData icon8Circle;
/// Bootstrap icon for icon8 square fill.
  static IconData icon8SquareFill;
/// Bootstrap icon for icon8 square.
  static IconData icon8Square;
/// Bootstrap icon for icon9 circle fill.
  static IconData icon9CircleFill;
/// Bootstrap icon for icon9 circle.
  static IconData icon9Circle;
/// Bootstrap icon for icon9 square fill.
  static IconData icon9SquareFill;
/// Bootstrap icon for icon9 square.
  static IconData icon9Square;
/// Bootstrap icon for airplane engines fill.
  static IconData airplaneEnginesFill;
/// Bootstrap icon for airplane engines.
  static IconData airplaneEngines;
/// Bootstrap icon for airplane fill.
  static IconData airplaneFill;
/// Bootstrap icon for airplane.
  static IconData airplane;
/// Bootstrap icon for alexa.
  static IconData alexa;
/// Bootstrap icon for alipay.
  static IconData alipay;
/// Bootstrap icon for android.
  static IconData android;
/// Bootstrap icon for android2.
  static IconData android2;
/// Bootstrap icon for box fill.
  static IconData boxFill;
/// Bootstrap icon for box seam fill.
  static IconData boxSeamFill;
/// Bootstrap icon for browser chrome.
  static IconData browserChrome;
/// Bootstrap icon for browser edge.
  static IconData browserEdge;
/// Bootstrap icon for browser firefox.
  static IconData browserFirefox;
/// Bootstrap icon for browser safari.
  static IconData browserSafari;
/// Bootstrap icon for c circle fill.
  static IconData cCircleFill;
/// Bootstrap icon for c circle.
  static IconData cCircle;
/// Bootstrap icon for c square fill.
  static IconData cSquareFill;
/// Bootstrap icon for c square.
  static IconData cSquare;
/// Bootstrap icon for capsule pill.
  static IconData capsulePill;
/// Bootstrap icon for capsule.
  static IconData capsule;
/// Bootstrap icon for car front fill.
  static IconData carFrontFill;
/// Bootstrap icon for car front.
  static IconData carFront;
/// Bootstrap icon for cassette fill.
  static IconData cassetteFill;
/// Bootstrap icon for cassette.
  static IconData cassette;
/// Bootstrap icon for cc circle fill.
  static IconData ccCircleFill;
/// Bootstrap icon for cc circle.
  static IconData ccCircle;
/// Bootstrap icon for cc square fill.
  static IconData ccSquareFill;
/// Bootstrap icon for cc square.
  static IconData ccSquare;
/// Bootstrap icon for cup hot fill.
  static IconData cupHotFill;
/// Bootstrap icon for cup hot.
  static IconData cupHot;
/// Bootstrap icon for currency rupee.
  static IconData currencyRupee;
/// Bootstrap icon for dropbox.
  static IconData dropbox;
/// Bootstrap icon for escape.
  static IconData escape;
/// Bootstrap icon for fast forward btn fill.
  static IconData fastForwardBtnFill;
/// Bootstrap icon for fast forward btn.
  static IconData fastForwardBtn;
/// Bootstrap icon for fast forward circle fill.
  static IconData fastForwardCircleFill;
/// Bootstrap icon for fast forward circle.
  static IconData fastForwardCircle;
/// Bootstrap icon for fast forward fill.
  static IconData fastForwardFill;
/// Bootstrap icon for fast forward.
  static IconData fastForward;
/// Bootstrap icon for filetype sql.
  static IconData filetypeSql;
/// Bootstrap icon for fire.
  static IconData fire;
/// Bootstrap icon for google play.
  static IconData googlePlay;
/// Bootstrap icon for h circle fill.
  static IconData hCircleFill;
/// Bootstrap icon for h circle.
  static IconData hCircle;
/// Bootstrap icon for h square fill.
  static IconData hSquareFill;
/// Bootstrap icon for h square.
  static IconData hSquare;
/// Bootstrap icon for indent.
  static IconData indent;
/// Bootstrap icon for lungs fill.
  static IconData lungsFill;
/// Bootstrap icon for lungs.
  static IconData lungs;
/// Bootstrap icon for microsoft teams.
  static IconData microsoftTeams;
/// Bootstrap icon for p circle fill.
  static IconData pCircleFill;
/// Bootstrap icon for p circle.
  static IconData pCircle;
/// Bootstrap icon for p square fill.
  static IconData pSquareFill;
/// Bootstrap icon for p square.
  static IconData pSquare;
/// Bootstrap icon for pass fill.
  static IconData passFill;
/// Bootstrap icon for pass.
  static IconData pass;
/// Bootstrap icon for prescription.
  static IconData prescription;
/// Bootstrap icon for prescription2.
  static IconData prescription2;
/// Bootstrap icon for r circle fill.
  static IconData rCircleFill;
/// Bootstrap icon for r circle.
  static IconData rCircle;
/// Bootstrap icon for r square fill.
  static IconData rSquareFill;
/// Bootstrap icon for r square.
  static IconData rSquare;
/// Bootstrap icon for repeat1.
  static IconData repeat1;
/// Bootstrap icon for repeat.
  static IconData repeat;
/// Bootstrap icon for rewind btn fill.
  static IconData rewindBtnFill;
/// Bootstrap icon for rewind btn.
  static IconData rewindBtn;
/// Bootstrap icon for rewind circle fill.
  static IconData rewindCircleFill;
/// Bootstrap icon for rewind circle.
  static IconData rewindCircle;
/// Bootstrap icon for rewind fill.
  static IconData rewindFill;
/// Bootstrap icon for rewind.
  static IconData rewind;
/// Bootstrap icon for train freight front fill.
  static IconData trainFreightFrontFill;
/// Bootstrap icon for train freight front.
  static IconData trainFreightFront;
/// Bootstrap icon for train front fill.
  static IconData trainFrontFill;
/// Bootstrap icon for train front.
  static IconData trainFront;
/// Bootstrap icon for train lightrail front fill.
  static IconData trainLightrailFrontFill;
/// Bootstrap icon for train lightrail front.
  static IconData trainLightrailFront;
/// Bootstrap icon for truck front fill.
  static IconData truckFrontFill;
/// Bootstrap icon for truck front.
  static IconData truckFront;
/// Bootstrap icon for ubuntu.
  static IconData ubuntu;
/// Bootstrap icon for unindent.
  static IconData unindent;
/// Bootstrap icon for unity.
  static IconData unity;
/// Bootstrap icon for universal access circle.
  static IconData universalAccessCircle;
/// Bootstrap icon for universal access.
  static IconData universalAccess;
/// Bootstrap icon for virus.
  static IconData virus;
/// Bootstrap icon for virus2.
  static IconData virus2;
/// Bootstrap icon for wechat.
  static IconData wechat;
/// Bootstrap icon for yelp.
  static IconData yelp;
/// Bootstrap icon for sign stop fill.
  static IconData signStopFill;
/// Bootstrap icon for sign stop lights fill.
  static IconData signStopLightsFill;
/// Bootstrap icon for sign stop lights.
  static IconData signStopLights;
/// Bootstrap icon for sign stop.
  static IconData signStop;
/// Bootstrap icon for sign turn left fill.
  static IconData signTurnLeftFill;
/// Bootstrap icon for sign turn left.
  static IconData signTurnLeft;
/// Bootstrap icon for sign turn right fill.
  static IconData signTurnRightFill;
/// Bootstrap icon for sign turn right.
  static IconData signTurnRight;
/// Bootstrap icon for sign turn slight left fill.
  static IconData signTurnSlightLeftFill;
/// Bootstrap icon for sign turn slight left.
  static IconData signTurnSlightLeft;
/// Bootstrap icon for sign turn slight right fill.
  static IconData signTurnSlightRightFill;
/// Bootstrap icon for sign turn slight right.
  static IconData signTurnSlightRight;
/// Bootstrap icon for sign yield fill.
  static IconData signYieldFill;
/// Bootstrap icon for sign yield.
  static IconData signYield;
/// Bootstrap icon for ev station fill.
  static IconData evStationFill;
/// Bootstrap icon for ev station.
  static IconData evStation;
/// Bootstrap icon for fuel pump diesel fill.
  static IconData fuelPumpDieselFill;
/// Bootstrap icon for fuel pump diesel.
  static IconData fuelPumpDiesel;
/// Bootstrap icon for fuel pump fill.
  static IconData fuelPumpFill;
/// Bootstrap icon for fuel pump.
  static IconData fuelPump;
/// Bootstrap icon for icon0 circle fill.
  static IconData icon0CircleFill;
/// Bootstrap icon for icon0 circle.
  static IconData icon0Circle;
/// Bootstrap icon for icon0 square fill.
  static IconData icon0SquareFill;
/// Bootstrap icon for icon0 square.
  static IconData icon0Square;
/// Bootstrap icon for rocket fill.
  static IconData rocketFill;
/// Bootstrap icon for rocket takeoff fill.
  static IconData rocketTakeoffFill;
/// Bootstrap icon for rocket takeoff.
  static IconData rocketTakeoff;
/// Bootstrap icon for rocket.
  static IconData rocket;
/// Bootstrap icon for stripe.
  static IconData stripe;
/// Bootstrap icon for subscript.
  static IconData subscript;
/// Bootstrap icon for superscript.
  static IconData superscript;
/// Bootstrap icon for trello.
  static IconData trello;
/// Bootstrap icon for envelope at fill.
  static IconData envelopeAtFill;
/// Bootstrap icon for envelope at.
  static IconData envelopeAt;
/// Bootstrap icon for regex.
  static IconData regex;
/// Bootstrap icon for text wrap.
  static IconData textWrap;
/// Bootstrap icon for sign dead end fill.
  static IconData signDeadEndFill;
/// Bootstrap icon for sign dead end.
  static IconData signDeadEnd;
/// Bootstrap icon for sign do not enter fill.
  static IconData signDoNotEnterFill;
/// Bootstrap icon for sign do not enter.
  static IconData signDoNotEnter;
/// Bootstrap icon for sign intersection fill.
  static IconData signIntersectionFill;
/// Bootstrap icon for sign intersection side fill.
  static IconData signIntersectionSideFill;
/// Bootstrap icon for sign intersection side.
  static IconData signIntersectionSide;
/// Bootstrap icon for sign intersection t fill.
  static IconData signIntersectionTFill;
/// Bootstrap icon for sign intersection t.
  static IconData signIntersectionT;
/// Bootstrap icon for sign intersection y fill.
  static IconData signIntersectionYFill;
/// Bootstrap icon for sign intersection y.
  static IconData signIntersectionY;
/// Bootstrap icon for sign intersection.
  static IconData signIntersection;
/// Bootstrap icon for sign merge left fill.
  static IconData signMergeLeftFill;
/// Bootstrap icon for sign merge left.
  static IconData signMergeLeft;
/// Bootstrap icon for sign merge right fill.
  static IconData signMergeRightFill;
/// Bootstrap icon for sign merge right.
  static IconData signMergeRight;
/// Bootstrap icon for sign no left turn fill.
  static IconData signNoLeftTurnFill;
/// Bootstrap icon for sign no left turn.
  static IconData signNoLeftTurn;
/// Bootstrap icon for sign no parking fill.
  static IconData signNoParkingFill;
/// Bootstrap icon for sign no parking.
  static IconData signNoParking;
/// Bootstrap icon for sign no right turn fill.
  static IconData signNoRightTurnFill;
/// Bootstrap icon for sign no right turn.
  static IconData signNoRightTurn;
/// Bootstrap icon for sign railroad fill.
  static IconData signRailroadFill;
/// Bootstrap icon for sign railroad.
  static IconData signRailroad;
/// Bootstrap icon for building add.
  static IconData buildingAdd;
/// Bootstrap icon for building check.
  static IconData buildingCheck;
/// Bootstrap icon for building dash.
  static IconData buildingDash;
/// Bootstrap icon for building down.
  static IconData buildingDown;
/// Bootstrap icon for building exclamation.
  static IconData buildingExclamation;
/// Bootstrap icon for building fill add.
  static IconData buildingFillAdd;
/// Bootstrap icon for building fill check.
  static IconData buildingFillCheck;
/// Bootstrap icon for building fill dash.
  static IconData buildingFillDash;
/// Bootstrap icon for building fill down.
  static IconData buildingFillDown;
/// Bootstrap icon for building fill exclamation.
  static IconData buildingFillExclamation;
/// Bootstrap icon for building fill gear.
  static IconData buildingFillGear;
/// Bootstrap icon for building fill lock.
  static IconData buildingFillLock;
/// Bootstrap icon for building fill slash.
  static IconData buildingFillSlash;
/// Bootstrap icon for building fill up.
  static IconData buildingFillUp;
/// Bootstrap icon for building fill x.
  static IconData buildingFillX;
/// Bootstrap icon for building fill.
  static IconData buildingFill;
/// Bootstrap icon for building gear.
  static IconData buildingGear;
/// Bootstrap icon for building lock.
  static IconData buildingLock;
/// Bootstrap icon for building slash.
  static IconData buildingSlash;
/// Bootstrap icon for building up.
  static IconData buildingUp;
/// Bootstrap icon for building x.
  static IconData buildingX;
/// Bootstrap icon for buildings fill.
  static IconData buildingsFill;
/// Bootstrap icon for buildings.
  static IconData buildings;
/// Bootstrap icon for bus front fill.
  static IconData busFrontFill;
/// Bootstrap icon for bus front.
  static IconData busFront;
/// Bootstrap icon for ev front fill.
  static IconData evFrontFill;
/// Bootstrap icon for ev front.
  static IconData evFront;
/// Bootstrap icon for globe americas.
  static IconData globeAmericas;
/// Bootstrap icon for globe asia australia.
  static IconData globeAsiaAustralia;
/// Bootstrap icon for globe central south asia.
  static IconData globeCentralSouthAsia;
/// Bootstrap icon for globe europe africa.
  static IconData globeEuropeAfrica;
/// Bootstrap icon for house add fill.
  static IconData houseAddFill;
/// Bootstrap icon for house add.
  static IconData houseAdd;
/// Bootstrap icon for house check fill.
  static IconData houseCheckFill;
/// Bootstrap icon for house check.
  static IconData houseCheck;
/// Bootstrap icon for house dash fill.
  static IconData houseDashFill;
/// Bootstrap icon for house dash.
  static IconData houseDash;
/// Bootstrap icon for house down fill.
  static IconData houseDownFill;
/// Bootstrap icon for house down.
  static IconData houseDown;
/// Bootstrap icon for house exclamation fill.
  static IconData houseExclamationFill;
/// Bootstrap icon for house exclamation.
  static IconData houseExclamation;
/// Bootstrap icon for house gear fill.
  static IconData houseGearFill;
/// Bootstrap icon for house gear.
  static IconData houseGear;
/// Bootstrap icon for house lock fill.
  static IconData houseLockFill;
/// Bootstrap icon for house lock.
  static IconData houseLock;
/// Bootstrap icon for house slash fill.
  static IconData houseSlashFill;
/// Bootstrap icon for house slash.
  static IconData houseSlash;
/// Bootstrap icon for house up fill.
  static IconData houseUpFill;
/// Bootstrap icon for house up.
  static IconData houseUp;
/// Bootstrap icon for house x fill.
  static IconData houseXFill;
/// Bootstrap icon for house x.
  static IconData houseX;
/// Bootstrap icon for person add.
  static IconData personAdd;
/// Bootstrap icon for person down.
  static IconData personDown;
/// Bootstrap icon for person exclamation.
  static IconData personExclamation;
/// Bootstrap icon for person fill add.
  static IconData personFillAdd;
/// Bootstrap icon for person fill check.
  static IconData personFillCheck;
/// Bootstrap icon for person fill dash.
  static IconData personFillDash;
/// Bootstrap icon for person fill down.
  static IconData personFillDown;
/// Bootstrap icon for person fill exclamation.
  static IconData personFillExclamation;
/// Bootstrap icon for person fill gear.
  static IconData personFillGear;
/// Bootstrap icon for person fill lock.
  static IconData personFillLock;
/// Bootstrap icon for person fill slash.
  static IconData personFillSlash;
/// Bootstrap icon for person fill up.
  static IconData personFillUp;
/// Bootstrap icon for person fill x.
  static IconData personFillX;
/// Bootstrap icon for person gear.
  static IconData personGear;
/// Bootstrap icon for person lock.
  static IconData personLock;
/// Bootstrap icon for person slash.
  static IconData personSlash;
/// Bootstrap icon for person up.
  static IconData personUp;
/// Bootstrap icon for scooter.
  static IconData scooter;
/// Bootstrap icon for taxi front fill.
  static IconData taxiFrontFill;
/// Bootstrap icon for taxi front.
  static IconData taxiFront;
/// Bootstrap icon for amd.
  static IconData amd;
/// Bootstrap icon for database add.
  static IconData databaseAdd;
/// Bootstrap icon for database check.
  static IconData databaseCheck;
/// Bootstrap icon for database dash.
  static IconData databaseDash;
/// Bootstrap icon for database down.
  static IconData databaseDown;
/// Bootstrap icon for database exclamation.
  static IconData databaseExclamation;
/// Bootstrap icon for database fill add.
  static IconData databaseFillAdd;
/// Bootstrap icon for database fill check.
  static IconData databaseFillCheck;
/// Bootstrap icon for database fill dash.
  static IconData databaseFillDash;
/// Bootstrap icon for database fill down.
  static IconData databaseFillDown;
/// Bootstrap icon for database fill exclamation.
  static IconData databaseFillExclamation;
/// Bootstrap icon for database fill gear.
  static IconData databaseFillGear;
/// Bootstrap icon for database fill lock.
  static IconData databaseFillLock;
/// Bootstrap icon for database fill slash.
  static IconData databaseFillSlash;
/// Bootstrap icon for database fill up.
  static IconData databaseFillUp;
/// Bootstrap icon for database fill x.
  static IconData databaseFillX;
/// Bootstrap icon for database fill.
  static IconData databaseFill;
/// Bootstrap icon for database gear.
  static IconData databaseGear;
/// Bootstrap icon for database lock.
  static IconData databaseLock;
/// Bootstrap icon for database slash.
  static IconData databaseSlash;
/// Bootstrap icon for database up.
  static IconData databaseUp;
/// Bootstrap icon for database x.
  static IconData databaseX;
/// Bootstrap icon for database.
  static IconData database;
/// Bootstrap icon for houses fill.
  static IconData housesFill;
/// Bootstrap icon for houses.
  static IconData houses;
/// Bootstrap icon for nvidia.
  static IconData nvidia;
/// Bootstrap icon for person vcard fill.
  static IconData personVcardFill;
/// Bootstrap icon for person vcard.
  static IconData personVcard;
/// Bootstrap icon for sina weibo.
  static IconData sinaWeibo;
/// Bootstrap icon for tencent qq.
  static IconData tencentQq;
/// Bootstrap icon for wikipedia.
  static IconData wikipedia;
/// Bootstrap icon for alphabet uppercase.
  static IconData alphabetUppercase;
/// Bootstrap icon for alphabet.
  static IconData alphabet;
/// Bootstrap icon for amazon.
  static IconData amazon;
/// Bootstrap icon for arrows collapse vertical.
  static IconData arrowsCollapseVertical;
/// Bootstrap icon for arrows expand vertical.
  static IconData arrowsExpandVertical;
/// Bootstrap icon for arrows vertical.
  static IconData arrowsVertical;
/// Bootstrap icon for arrows.
  static IconData arrows;
/// Bootstrap icon for ban fill.
  static IconData banFill;
/// Bootstrap icon for ban.
  static IconData ban;
/// Bootstrap icon for bing.
  static IconData bing;
/// Bootstrap icon for cake.
  static IconData cake;
/// Bootstrap icon for cake2.
  static IconData cake2;
/// Bootstrap icon for cookie.
  static IconData cookie;
/// Bootstrap icon for copy.
  static IconData copy;
/// Bootstrap icon for crosshair.
  static IconData crosshair;
/// Bootstrap icon for crosshair2.
  static IconData crosshair2;
/// Bootstrap icon for emoji astonished fill.
  static IconData emojiAstonishedFill;
/// Bootstrap icon for emoji astonished.
  static IconData emojiAstonished;
/// Bootstrap icon for emoji grimace fill.
  static IconData emojiGrimaceFill;
/// Bootstrap icon for emoji grimace.
  static IconData emojiGrimace;
/// Bootstrap icon for emoji grin fill.
  static IconData emojiGrinFill;
/// Bootstrap icon for emoji grin.
  static IconData emojiGrin;
/// Bootstrap icon for emoji surprise fill.
  static IconData emojiSurpriseFill;
/// Bootstrap icon for emoji surprise.
  static IconData emojiSurprise;
/// Bootstrap icon for emoji tear fill.
  static IconData emojiTearFill;
/// Bootstrap icon for emoji tear.
  static IconData emojiTear;
/// Bootstrap icon for envelope arrow down fill.
  static IconData envelopeArrowDownFill;
/// Bootstrap icon for envelope arrow down.
  static IconData envelopeArrowDown;
/// Bootstrap icon for envelope arrow up fill.
  static IconData envelopeArrowUpFill;
/// Bootstrap icon for envelope arrow up.
  static IconData envelopeArrowUp;
/// Bootstrap icon for feather.
  static IconData feather;
/// Bootstrap icon for feather2.
  static IconData feather2;
/// Bootstrap icon for floppy fill.
  static IconData floppyFill;
/// Bootstrap icon for floppy.
  static IconData floppy;
/// Bootstrap icon for floppy2 fill.
  static IconData floppy2Fill;
/// Bootstrap icon for floppy2.
  static IconData floppy2;
/// Bootstrap icon for gitlab.
  static IconData gitlab;
/// Bootstrap icon for highlighter.
  static IconData highlighter;
/// Bootstrap icon for marker tip.
  static IconData markerTip;
/// Bootstrap icon for nvme fill.
  static IconData nvmeFill;
/// Bootstrap icon for nvme.
  static IconData nvme;
/// Bootstrap icon for opencollective.
  static IconData opencollective;
/// Bootstrap icon for pci card network.
  static IconData pciCardNetwork;
/// Bootstrap icon for pci card sound.
  static IconData pciCardSound;
/// Bootstrap icon for radar.
  static IconData radar;
/// Bootstrap icon for send arrow down fill.
  static IconData sendArrowDownFill;
/// Bootstrap icon for send arrow down.
  static IconData sendArrowDown;
/// Bootstrap icon for send arrow up fill.
  static IconData sendArrowUpFill;
/// Bootstrap icon for send arrow up.
  static IconData sendArrowUp;
/// Bootstrap icon for sim slash fill.
  static IconData simSlashFill;
/// Bootstrap icon for sim slash.
  static IconData simSlash;
/// Bootstrap icon for sourceforge.
  static IconData sourceforge;
/// Bootstrap icon for substack.
  static IconData substack;
/// Bootstrap icon for threads fill.
  static IconData threadsFill;
/// Bootstrap icon for threads.
  static IconData threads;
/// Bootstrap icon for transparency.
  static IconData transparency;
/// Bootstrap icon for twitter x.
  static IconData twitterX;
/// Bootstrap icon for type h4.
  static IconData typeH4;
/// Bootstrap icon for type h5.
  static IconData typeH5;
/// Bootstrap icon for type h6.
  static IconData typeH6;
/// Bootstrap icon for backpack fill.
  static IconData backpackFill;
/// Bootstrap icon for backpack.
  static IconData backpack;
/// Bootstrap icon for backpack2 fill.
  static IconData backpack2Fill;
/// Bootstrap icon for backpack2.
  static IconData backpack2;
/// Bootstrap icon for backpack3 fill.
  static IconData backpack3Fill;
/// Bootstrap icon for backpack3.
  static IconData backpack3;
/// Bootstrap icon for backpack4 fill.
  static IconData backpack4Fill;
/// Bootstrap icon for backpack4.
  static IconData backpack4;
/// Bootstrap icon for brilliance.
  static IconData brilliance;
/// Bootstrap icon for cake fill.
  static IconData cakeFill;
/// Bootstrap icon for cake2 fill.
  static IconData cake2Fill;
/// Bootstrap icon for duffle fill.
  static IconData duffleFill;
/// Bootstrap icon for duffle.
  static IconData duffle;
/// Bootstrap icon for exposure.
  static IconData exposure;
/// Bootstrap icon for gender neuter.
  static IconData genderNeuter;
/// Bootstrap icon for highlights.
  static IconData highlights;
/// Bootstrap icon for luggage fill.
  static IconData luggageFill;
/// Bootstrap icon for luggage.
  static IconData luggage;
/// Bootstrap icon for mailbox flag.
  static IconData mailboxFlag;
/// Bootstrap icon for mailbox2 flag.
  static IconData mailbox2Flag;
/// Bootstrap icon for noise reduction.
  static IconData noiseReduction;
/// Bootstrap icon for passport fill.
  static IconData passportFill;
/// Bootstrap icon for passport.
  static IconData passport;
/// Bootstrap icon for person arms up.
  static IconData personArmsUp;
/// Bootstrap icon for person raised hand.
  static IconData personRaisedHand;
/// Bootstrap icon for person standing dress.
  static IconData personStandingDress;
/// Bootstrap icon for person standing.
  static IconData personStanding;
/// Bootstrap icon for person walking.
  static IconData personWalking;
/// Bootstrap icon for person wheelchair.
  static IconData personWheelchair;
/// Bootstrap icon for shadows.
  static IconData shadows;
/// Bootstrap icon for suitcase fill.
  static IconData suitcaseFill;
/// Bootstrap icon for suitcase lg fill.
  static IconData suitcaseLgFill;
/// Bootstrap icon for suitcase lg.
  static IconData suitcaseLg;
/// Bootstrap icon for suitcase.
  static IconData suitcase;
/// Bootstrap icon for suitcase2 fill.
  static IconData suitcase2Fill;
/// Bootstrap icon for suitcase2.
  static IconData suitcase2;
/// Bootstrap icon for vignette.
  static IconData vignette;
}
/// Represents a resizable item in a resizable layout.
///
/// Each item has a current size, minimum/maximum constraints, and can be
/// collapsed to a smaller size. Items can be marked as non-resizable.
class ResizableItem {
/// Minimum size this item can be resized to.
  double min;
/// Maximum size this item can be resized to.
  double max;
/// Whether this item is currently in collapsed state.
  bool collapsed;
/// Size of the item when collapsed. If null, collapsed size is 0.
  double? collapsedSize;
/// Whether this item can be resized.
  bool resizable;
/// Creates a resizable item with the given constraints.
///
/// [value] is the initial size of the item.
/// [min] is the minimum size (defaults to 0).
/// [max] is the maximum size (defaults to infinity).
/// [collapsed] indicates if the item starts collapsed.
/// [collapsedSize] is the size when collapsed (defaults to 0 if null).
/// [resizable] indicates if the item can be resized (defaults to true).
  ResizableItem({required double value, this.min = 0, this.max = double.infinity, this.collapsed = false, this.collapsedSize, this.resizable = true});
/// Whether this item is collapsed after resizing operations.
  bool get newCollapsed;
/// The size of this item after resizing operations.
  double get newValue;
/// The current size of this item before any resize operations.
  double get value;
  String toString();
}
/// Manages the resizing of multiple [ResizableItem]s in a layout.
///
/// This class handles complex resize operations including:
/// - Dragging dividers between items
/// - Expanding and collapsing items
/// - Borrowing and redistributing space between items
/// - Respecting min/max constraints
class Resizer {
/// The list of resizable items being managed.
  List<ResizableItem> items;
/// Ratio threshold for collapsing an item (0.0 to 1.0).
/// When an item gets smaller than `min + (collapsedSize - min) * collapseRatio`,
/// it will collapse.
  double collapseRatio;
/// Ratio threshold for expanding a collapsed item (0.0 to 1.0).
/// When dragging past `(min - collapsedSize) * expandRatio`,
/// a collapsed item will expand.
  double expandRatio;
/// Creates a resizer for the given [items].
///
/// [collapseRatio] controls when items collapse (defaults to 0.5).
/// [expandRatio] controls when collapsed items expand (defaults to 0.5).
  Resizer(this.items, {this.collapseRatio = 0.5, this.expandRatio = 0.5});
/// Attempts to expand an item at [index] by [delta] in the given [direction].
///
/// [direction] can be -1 (borrow from left), 0 (borrow from both sides),
/// or 1 (borrow from right).
/// Returns true if the expansion was successful.
  bool attemptExpand(int index, int direction, double delta);
/// Attempts to collapse an item at [index] in the given [direction].
///
/// [direction] can be -1 (give space to left), 0 (give to both sides),
/// or 1 (give space to right).
/// Returns true if the collapse was successful.
  bool attemptCollapse(int index, int direction);
/// Attempts to expand a collapsed item at [index] in the given [direction].
///
/// [direction] can be -1 (borrow from left), 0 (borrow from both sides),
/// or 1 (borrow from right).
/// Returns true if the expansion was successful.
  bool attemptExpandCollapsed(int index, int direction);
/// Handles dragging a divider at [index] by [delta] pixels.
///
/// This is the main method for interactive resizing. It redistributes space
/// between items, handles collapsing/expanding, and respects constraints.
/// The divider at [index] is between item [index-1] and item [index].
  void dragDivider(int index, double delta);
/// Resets all items to their original state.
///
/// Clears any pending resize operations and restores items to their
/// original values and collapsed states.
  void reset();
}
/// Defines a direction along an axis, either vertical or horizontal.
///
/// This is similar to [AxisDirection] but includes support for directional
/// values (start/end) that resolve based on [TextDirection].
enum AxisDirectional { up, down, start, end }
/// Base class for axis-based insets.
///
/// This allows defining insets along a single axis (start/end) which can be
/// resolved to concrete values based on [TextDirection].
abstract class AxisInsetsGeometry {
/// Creates an [AxisInsetsGeometry].
  const AxisInsetsGeometry();
/// Resolves the insets to a concrete [AxisInsets] based on the text direction.
///
/// Parameters:
/// - [textDirection] (`TextDirection`, required): The text direction to resolve against.
///
/// Returns:
/// An [AxisInsets] with resolved start/end values.
  AxisInsets resolve(TextDirection textDirection);
}
/// Insets along an axis with support for directionality.
class AxisInsets extends AxisInsetsGeometry {
/// The text direction, if any.
  TextDirection? direction;
/// The start value.
  double start;
/// The end value.
  double end;
/// Creates an [AxisInsets].
///
/// Parameters:
/// - [start] (`double`, required): The start value.
/// - [end] (`double`, required): The end value.
  const AxisInsets({required this.start, required this.end});
/// Resolves the start and end values for a specific axis.
///
/// Parameters:
/// - [axis] (`Axis`, required): The axis to resolve for.
///
/// Returns:
/// A record containing the start and end values.
  ({double start, double end}) resolveValue(Axis axis);
  AxisInsets resolve(TextDirection textDirection);
}
/// Directional insets along an axis.
///
/// These insets are defined as start and end, and resolve to left/right or
/// right/left based on the [TextDirection].
class AxisInsetsDirectional extends AxisInsetsGeometry {
/// The start value.
  double start;
/// The end value.
  double end;
/// Creates an [AxisInsetsDirectional].
///
/// Parameters:
/// - [start] (`double`, required): The start value.
/// - [end] (`double`, required): The end value.
  const AxisInsetsDirectional({required this.start, required this.end});
  AxisInsets resolve(TextDirection textDirection);
}
/// Base class for axis-based alignment.
///
/// This allows defining alignment along a single axis which can be
/// resolved to concrete values based on [TextDirection].
abstract class AxisAlignmentGeometry {
/// Creates an [AxisAlignmentGeometry].
  const AxisAlignmentGeometry();
/// Resolves the alignment to a concrete [AxisAlignment] based on the text direction.
///
/// Parameters:
/// - [textDirection] (`TextDirection`, required): The text direction to resolve against.
///
/// Returns:
/// An [AxisAlignment] corresponding to the resolved alignment.
  AxisAlignment resolve(TextDirection textDirection);
}
/// Alignment along an axis.
///
/// Values range from -1.0 (start/left/top) to 1.0 (end/right/bottom).
class AxisAlignment extends AxisAlignmentGeometry {
/// Alignment to the left (-1.0).
  static const AxisAlignment left = AxisAlignment(-1.0);
/// Alignment to the right (1.0).
  static const AxisAlignment right = AxisAlignment(1.0);
/// Alignment to the center (0.0).
  static const AxisAlignment center = AxisAlignment(0.0);
/// The text direction, if any.
  TextDirection? direction;
/// The alignment value.
  double value;
/// Creates an [AxisAlignment].
///
/// Parameters:
/// - [value] (`double`, required): The alignment value (-1.0 to 1.0).
  const AxisAlignment(this.value);
/// Resolves the alignment value for a specific axis.
///
/// Parameters:
/// - [axis] (`Axis`, required): The axis to resolve for.
///
/// Returns:
/// The resolved alignment value.
  double resolveValue(Axis axis);
/// Calculates the position along an axis for a given size.
///
/// Parameters:
/// - [axis] (`Axis`, required): The axis to calculate along.
/// - [size] (`double`, required): The total size along the axis.
///
/// Returns:
/// The calculated position.
  double alongValue(Axis axis, double size);
/// Converts this alignment to a standard [Alignment] with this as the horizontal component.
///
/// Parameters:
/// - [crossAxisAlignment] (`AxisAlignment`, required): The vertical alignment component.
///
/// Returns:
/// An [Alignment] combining this horizontal alignment with the given vertical alignment.
  Alignment asHorizontalAlignment(AxisAlignment crossAxisAlignment);
/// Converts this alignment to a standard [Alignment] with this as the vertical component.
///
/// Parameters:
/// - [crossAxisAlignment] (`AxisAlignment`, required): The horizontal alignment component.
///
/// Returns:
/// An [Alignment] combining this vertical alignment with the given horizontal alignment.
  Alignment asVerticalAlignment(AxisAlignment crossAxisAlignment);
  AxisAlignment resolve(TextDirection textDirection);
}
/// Directional alignment along an axis.
///
/// Values range from -1.0 (start) to 1.0 (end).
class AxisAlignmentDirectional extends AxisAlignmentGeometry {
/// Alignment to the start (-1.0).
  static const AxisAlignmentDirectional start = AxisAlignmentDirectional(-1.0);
/// Alignment to the end (1.0).
  static const AxisAlignmentDirectional end = AxisAlignmentDirectional(1.0);
/// Alignment to the center (0.0).
  static const AxisAlignmentDirectional center = AxisAlignmentDirectional(0.0);
/// The alignment value.
  double value;
/// Creates an [AxisAlignmentDirectional].
///
/// Parameters:
/// - [value] (`double`, required): The alignment value (-1.0 to 1.0).
  const AxisAlignmentDirectional(this.value);
  AxisAlignment resolve(TextDirection textDirection);
}
/// Default animation duration for UI transitions (150ms).
const kDefaultDuration = Duration(milliseconds: 150);
/// Converts degrees to radians.
///
/// Parameters:
/// - [deg] (double, required): Angle in degrees
///
/// Returns angle in radians.
double degToRad(double deg);
/// Converts radians to degrees.
///
/// Parameters:
/// - [rad] (double, required): Angle in radians
///
/// Returns angle in degrees.
double radToDeg(double rad);
/// The direction for sorting.
enum SortDirection { none, ascending, descending }
/// A context action that executes a callback.
class CallbackContextAction<T extends Intent> extends ContextAction<T> {
/// Callback to execute when action is invoked.
  OnContextInvokeCallback onInvoke;
/// Creates a [CallbackContextAction] with the given callback.
/// Parameters:
/// - [onInvoke] (OnContextInvokeCallback, required): Callback to execute
  CallbackContextAction({required this.onInvoke});
  Object? invoke(T intent, [BuildContext? context]);
}
/// A utility for safely interpolating between values of type [T].
class SafeLerp<T> {
/// Nullable lerp function that can handle null values.
  T? Function(T? a, T? b, double t) nullableLerp;
/// Creates a SafeLerp with the given nullable lerp function.
  const SafeLerp(this.nullableLerp);
/// Interpolates between non-null values.
///
/// Asserts that the result is non-null.
///
/// Parameters:
/// - [a] (T, required): Start value
/// - [b] (T, required): End value
/// - [t] (double, required): Interpolation position (0.0 to 1.0)
///
/// Returns interpolated value.
  T lerp(T a, T b, double t);
}
/// Extension on nullable lerp functions to create non-null lerp helpers.
extension SafeLerpExtension<T> on T? Function(T? a, T? b, double t) {
/// Wraps this nullable lerp function to work with non-null values.
///
/// Asserts that the lerp result is non-null.
///
/// Parameters:
/// - [a] (T, required): Start value
/// - [b] (T, required): End value
/// - [t] (double, required): Interpolation position
///
/// Returns interpolated non-null value.
  T nonNull(T a, T b, double t);
}
/// Extension methods for List operations with null-safe variants.
extension ListExtension<T> on List<T> {
/// Finds the first index of an element, returning null if not found.
///
/// Parameters:
/// - [obj] (T, required): Element to find
/// - [start] (int): Index to start searching from, defaults to 0
///
/// Returns index or null if not found.
  int? indexOfOrNull(T obj, [int start = 0]);
/// Finds the last index of an element, returning null if not found.
///
/// Parameters:
/// - [obj] (T, required): Element to find
/// - [start] (int?): Index to search backwards from
///
/// Returns last index or null if not found.
  int? lastIndexOfOrNull(T obj, [int? start]);
/// Finds the first index where test is true, returning null if not found.
///
/// Parameters:
/// - [test] (`Predicate<T>`, required): Test function
/// - [start] (int): Index to start searching from, defaults to 0
///
/// Returns index or null if no match found.
  int? indexWhereOrNull(Predicate<T> test, [int start = 0]);
/// Finds the last index where test is true, returning null if not found.
///
/// Parameters:
/// - [test] (`Predicate<T>`, required): Test function
/// - [start] (int?): Index to search backwards from
///
/// Returns last index or null if no match found.
  int? lastIndexWhereOrNull(Predicate<T> test, [int? start]);
/// Moves an element to a target index in the list.
///
/// If the element doesn't exist, inserts it at the target index.
/// If targetIndex >= length, moves element to the end.
///
/// Parameters:
/// - [element] (T, required): Element to move
/// - [targetIndex] (int, required): Destination index
///
/// Returns true if operation succeeded.
  bool swapItem(T element, int targetIndex);
/// Moves the first element matching test to a target index.
///
/// Returns false if no element matches the test.
///
/// Parameters:
/// - [test] (`Predicate<T>`, required): Test function to find element
/// - [targetIndex] (int, required): Destination index
///
/// Returns true if element was found and moved.
  bool swapItemWhere(Predicate<T> test, int targetIndex);
/// Safely gets an element at index, returning null if out of bounds.
///
/// Parameters:
/// - [index] (int, required): Index to access
///
/// Returns element at index or null if index is out of bounds.
  T? optGet(int index);
}
/// Inverse lerp: finds the interpolation parameter given a value.
///
/// Given a value between min and max, returns the interpolation parameter t
/// (typically 0.0 to 1.0) that would produce that value.
///
/// Parameters:
/// - [value] (double, required): Value to unlerp
/// - [min] (double, required): Minimum bound
/// - [max] (double, required): Maximum bound
///
/// Returns interpolation parameter.
double unlerpDouble(double value, double min, double max);
/// Swaps an element between multiple lists.
///
/// Removes the element from all lists except the target list, then moves it
/// to the specified index in the target list.
///
/// Parameters:
/// - [lists] (`List<List<T>>`, required): Lists to manage
/// - [element] (T, required): Element to swap
/// - [targetList] (`List<T>`, required): Destination list
/// - [targetIndex] (int, required): Destination index in target list
void swapItemInLists<T>(List<List<T>> lists, T element, List<T> targetList, int targetIndex);
/// Resolves a BorderRadiusGeometry to BorderRadius if needed.
///
/// Returns null if radius is null, returns radius as-is if already BorderRadius,
/// otherwise resolves using text directionality from context.
///
/// Parameters:
/// - [context] (BuildContext, required): Build context for directionality
/// - [radius] (BorderRadiusGeometry?): Border radius to resolve
///
/// Returns resolved BorderRadius or null.
BorderRadius? optionallyResolveBorderRadius(BuildContext context, BorderRadiusGeometry? radius);
/// A style helper function that returns the value from the widget, theme, or default value.
T styleValue<T>({T? widgetValue, T? themeValue, required T defaultValue});
/// Extension methods for FutureOr transformation operations.
extension FutureOrExtension<T> on FutureOr<T> {
/// Transforms the value using a synchronous function.
///
/// If this is a Future, applies transform asynchronously.
/// Otherwise applies it synchronously.
///
/// Parameters:
/// - [transform] (Function, required): Transformation function
///
/// Returns transformed value as FutureOr.
  FutureOr<R> map<R>(R Function(T value) transform);
/// Transforms the value using a function that returns FutureOr.
///
/// Flattens nested FutureOr results. If this is a Future, chains the
/// transformation. Otherwise applies it synchronously.
///
/// Parameters:
/// - [transform] (Function, required): Transformation function returning FutureOr
///
/// Returns flattened transformed value as FutureOr.
  FutureOr<R> flatMap<R>(FutureOr<R> Function(T value) transform);
/// Alias for flatMap - transforms with FutureOr function.
///
/// Parameters:
/// - [transform] (Function, required): Transformation function
///
/// Returns transformed value as FutureOr.
  FutureOr<R> then<R>(FutureOr<R> Function(T value) transform);
/// Catches errors in a [Future] or passes through non-Future values.
///
/// If this [FutureOr] is a [Future], calls [catchError] on it.
/// Otherwise, returns the value unchanged.
///
/// Parameters:
/// - [onError] (`Function`, required): Error handler callback.
/// - [test] (`bool Function(Object)?`, optional): Predicate to filter errors.
///
/// Returns: `FutureOr<T>` ‚Äî the result with error handling applied.
  FutureOr<T> catchError(Function onError, {bool Function(Object error)? test});
}
/// Extension adding resolution optimization for [AlignmentGeometry].
extension AlignmentExtension on AlignmentGeometry {
/// Resolves to [Alignment], skipping resolution if already resolved.
///
/// Optimizes by checking if this is already an [Alignment] before
/// resolving based on text directionality. This avoids unnecessary
/// directionality lookups when the alignment is already concrete.
///
/// Parameters:
/// - [context] (`BuildContext`, required): Context for directionality.
///
/// Returns: `Alignment` ‚Äî the resolved alignment.
  Alignment optionallyResolve(BuildContext context);
}
/// Extension adding resolution optimization for [BorderRadiusGeometry].
extension BorderRadiusExtension on BorderRadiusGeometry {
/// Resolves to [BorderRadius], skipping resolution if already resolved.
///
/// Optimizes by checking if this is already a [BorderRadius] before
/// resolving based on text directionality.
///
/// Parameters:
/// - [context] (`BuildContext`, required): Context for directionality.
///
/// Returns: `BorderRadius` ‚Äî the resolved border radius.
  BorderRadius optionallyResolve(BuildContext context);
}
/// Extension adding resolution optimization for [EdgeInsetsGeometry].
extension EdgeInsetsExtension on EdgeInsetsGeometry {
/// Resolves to [EdgeInsets], skipping resolution if already resolved.
///
/// Optimizes by checking if this is already an [EdgeInsets] before
/// resolving based on text directionality.
///
/// Parameters:
/// - [context] (`BuildContext`, required): Context for directionality.
///
/// Returns: `EdgeInsets` ‚Äî the resolved edge insets.
  EdgeInsets optionallyResolve(BuildContext context);
}
/// Subtracts a border width from a border radius.
///
/// Reduces each corner's radius by the border width, ensuring the inner
/// radius accounts for the border thickness. Prevents negative radii.
///
/// Parameters:
/// - [radius] (`BorderRadius`, required): Original border radius.
/// - [borderWidth] (`double`, required): Border width to subtract.
///
/// Returns: `BorderRadius` ‚Äî adjusted border radius.
BorderRadius subtractByBorder(BorderRadius radius, double borderWidth);
/// Determines if a platform is mobile.
///
/// Returns `true` for Android, iOS, and Fuchsia platforms.
///
/// Parameters:
/// - [platform] (`TargetPlatform`, required): Platform to check.
///
/// Returns: `bool` ‚Äî `true` if mobile, `false` otherwise.
bool isMobile(TargetPlatform platform);
/// A widget that wraps a child with captured themes and data.
///
/// Applies previously captured inherited themes and data to the widget tree.
/// This is useful for maintaining theme and data context when moving widgets
/// across different parts of the tree.
class CapturedWrapper extends StatefulWidget {
/// Captured theme data to apply.
  CapturedThemes? themes;
/// Captured inherited data to apply.
  CapturedData? data;
/// The child widget to wrap.
  Widget child;
/// Creates a [CapturedWrapper].
///
/// Parameters:
/// - [themes] (`CapturedThemes?`, optional): Themes to apply.
/// - [data] (`CapturedData?`, optional): Data to apply.
/// - [child] (`Widget`, required): Child widget.
  const CapturedWrapper({super.key, this.themes, this.data, required this.child});
  State<CapturedWrapper> createState();
}
/// Linearly interpolates between two numeric values.
///
/// Uses the formula: `begin + (end - begin) * t`.
///
/// Parameters:
/// - [begin] (`T`, required): Start value.
/// - [end] (`T`, required): End value.
/// - [t] (`double`, required): Interpolation factor (0.0 to 1.0).
///
/// Returns: `T` ‚Äî interpolated value.
T tweenValue<T>(T begin, T end, double t);
/// Wraps a value within a specified range.
///
/// If the value exceeds the range, it wraps around to the beginning.
/// Returns the minimum value if the range is zero.
///
/// Parameters:
/// - [value] (`double`, required): Value to wrap.
/// - [min] (`double`, required): Minimum value of range.
/// - [max] (`double`, required): Maximum value of range.
///
/// Returns: `double` ‚Äî wrapped value within [min, max).
double wrapDouble(double value, double min, double max);
/// A widget that detects changes in the widget tree.
class WidgetTreeChangeDetector extends StatefulWidget {
/// The child widget to monitor.
  Widget child;
/// Callback invoked when the widget tree changes.
  void Function() onWidgetTreeChange;
/// Creates a [WidgetTreeChangeDetector].
///
/// Parameters:
/// - [child] (`Widget`, required): Child widget.
/// - [onWidgetTreeChange] (`VoidCallback`, required): Change callback.
  const WidgetTreeChangeDetector({super.key, required this.child, required this.onWidgetTreeChange});
  WidgetTreeChangeDetectorState createState();
}
/// State for [WidgetTreeChangeDetector].
class WidgetTreeChangeDetectorState extends State<WidgetTreeChangeDetector> {
  void initState();
  Widget build(BuildContext context);
}
/// Creates a gap widget with specified spacing.
///
/// Parameters:
/// - [gap] (`double`, required): Main axis spacing.
/// - [crossGap] (`double?`, optional): Cross axis spacing.
///
/// Returns: `Widget` ‚Äî a Gap widget.
Widget gap(double gap, {double? crossGap});
/// Extension for joining lists of widgets with a separator.
extension Joinable<T extends Widget> on List<T> {
/// Joins widgets with a separator between each item.
///
/// Parameters:
/// - [separator] (`T`, required): Widget to insert between items.
///
/// Returns: `List<T>` ‚Äî list with separators inserted.
  List<T> joinSeparator(T separator);
}
/// Extension adding separator joining for iterables.
extension IterableExtension<T> on Iterable<T> {
/// Joins iterable items with a separator between each.
///
/// Parameters:
/// - [separator] (`T`, required): Item to insert between elements.
///
/// Returns: `Iterable<T>` ‚Äî iterable with separators inserted.
  Iterable<T> joinSeparator(T separator);
/// Joins iterable items with dynamically built separators.
///
/// Each separator is created by calling the builder function.
///
/// Parameters:
/// - [separator] (`ValueGetter<T>`, required): Builder for separator items.
///
/// Returns: `Iterable<T>` ‚Äî iterable with separators inserted.
  Iterable<T> buildSeparator(ValueGetter<T> separator);
}
/// Extension adding layout and styling utilities to widgets.
extension WidgetExtension on Widget {
/// Converts this widget to a builder function.
///
/// Returns a [NeverWidgetBuilder] that ignores all parameters and returns this widget.
  NeverWidgetBuilder get asBuilder;
/// Wraps this widget in a [SizedBox] with specified dimensions.
///
/// If this widget is already a [SizedBox], merges the dimensions.
///
/// Parameters:
/// - [width] (`double?`, optional): Desired width.
/// - [height] (`double?`, optional): Desired height.
///
/// Returns: `Widget` ‚Äî sized widget.
  Widget sized({double? width, double? height, double? size});
/// Wraps this widget in a [ConstrainedBox] with specified constraints.
///
/// If this widget is already a [ConstrainedBox], merges the constraints.
///
/// Parameters:
/// - [minWidth] (`double?`, optional): Minimum width.
/// - [maxWidth] (`double?`, optional): Maximum width.
/// - [minHeight] (`double?`, optional): Minimum height.
/// - [maxHeight] (`double?`, optional): Maximum height.
/// - [width] (`double?`, optional): Fixed width (sets both min and max).
/// - [height] (`double?`, optional): Fixed height (sets both min and max).
///
/// Returns: `Widget` ‚Äî constrained widget.
  Widget constrained({double? minWidth, double? maxWidth, double? minHeight, double? maxHeight, double? width, double? height});
/// Wraps this widget in a [Padding] widget.
///
/// Provides flexible padding specification via individual edges,
/// combined directions, or uniform padding.
///
/// Parameters:
/// - [top] (`double?`, optional): Top padding.
/// - [bottom] (`double?`, optional): Bottom padding.
/// - [left] (`double?`, optional): Left padding.
/// - [right] (`double?`, optional): Right padding.
/// - [horizontal] (`double?`, optional): Left and right padding (cannot use with left/right).
/// - [vertical] (`double?`, optional): Top and bottom padding (cannot use with top/bottom).
/// - [all] (`double?`, optional): Uniform padding on all sides (cannot use with others).
/// - [padding] (`EdgeInsetsGeometry?`, optional): Direct padding value (overrides all other params).
///
/// Returns: `Widget` ‚Äî padded widget.
///
/// Throws [FlutterError] if conflicting parameters are used.
  Widget withPadding({double? top, double? bottom, double? left, double? right, double? horizontal, double? vertical, double? all, EdgeInsetsGeometry? padding});
/// Centers this widget horizontally and vertically.
///
/// Parameters:
/// - [key] (`Key?`, optional): Widget key.
///
/// Returns: `Widget` ‚Äî centered widget.
  Widget center({Key? key});
/// Aligns this widget within its parent.
///
/// Parameters:
/// - [alignment] (`AlignmentGeometry`, required): Alignment position.
///
/// Returns: `Widget` ‚Äî aligned widget.
  Widget withAlign(AlignmentGeometry alignment);
/// Positions this widget absolutely within a [Stack].
///
/// Parameters:
/// - [key] (`Key?`, optional): Widget key.
/// - [left] (`double?`, optional): Left offset.
/// - [top] (`double?`, optional): Top offset.
/// - [right] (`double?`, optional): Right offset.
/// - [bottom] (`double?`, optional): Bottom offset.
///
/// Returns: `Widget` ‚Äî positioned widget.
  Widget positioned({Key? key, double? left, double? top, double? right, double? bottom});
/// Makes this widget expanded within a [Flex] parent (Row/Column).
///
/// Parameters:
/// - [flex] (`int`, default: 1): Flex factor for space distribution.
///
/// Returns: `Widget` ‚Äî expanded widget.
  Widget expanded({int flex = 1});
/// Applies opacity to this widget.
///
/// Parameters:
/// - [opacity] (`double`, required): Opacity value (0.0 to 1.0).
///
/// Returns: `Widget` ‚Äî widget with opacity.
  Widget withOpacity(double opacity);
/// Clips this widget to a rectangle.
///
/// Parameters:
/// - [clipBehavior] (`Clip`, default: `Clip.hardEdge`): Clipping behavior.
///
/// Returns: `Widget` ‚Äî clipped widget.
  Widget clip({Clip clipBehavior = Clip.hardEdge});
/// Clips this widget to a rounded rectangle.
///
/// Parameters:
/// - [borderRadius] (`BorderRadiusGeometry`, default: `BorderRadius.zero`): Corner radii.
/// - [clipBehavior] (`Clip`, default: `Clip.antiAlias`): Clipping behavior.
///
/// Returns: `Widget` ‚Äî clipped widget.
  Widget clipRRect({BorderRadiusGeometry borderRadius = BorderRadius.zero, Clip clipBehavior = Clip.antiAlias});
/// Clips this widget to an oval shape.
///
/// Parameters:
/// - [clipBehavior] (`Clip`, default: `Clip.antiAlias`): Clipping behavior.
///
/// Returns: `Widget` ‚Äî clipped widget.
  Widget clipOval({Clip clipBehavior = Clip.antiAlias});
/// Clips this widget to a custom path.
///
/// Parameters:
/// - [clipBehavior] (`Clip`, default: `Clip.antiAlias`): Clipping behavior.
/// - [clipper] (`CustomClipper<Path>`, required): Custom clipper for the path.
///
/// Returns: `Widget` ‚Äî clipped widget.
  Widget clipPath({Clip clipBehavior = Clip.antiAlias, required CustomClipper<Path> clipper});
/// Applies a transformation matrix to this widget.
///
/// Parameters:
/// - [key] (`Key?`, optional): Widget key.
/// - [transform] (`Matrix4`, required): Transformation matrix.
///
/// Returns: `Widget` ‚Äî transformed widget.
  Widget transform({Key? key, required Matrix4 transform});
/// Sizes this widget to its intrinsic width.
///
/// Parameters:
/// - [stepWidth] (`double?`, optional): Stepping for width.
/// - [stepHeight] (`double?`, optional): Stepping for height.
///
/// Returns: `Widget` ‚Äî intrinsically sized widget.
  Widget intrinsicWidth({double? stepWidth, double? stepHeight});
/// Sizes this widget to its intrinsic height.
///
/// Returns: `Widget` ‚Äî intrinsically sized widget.
  Widget intrinsicHeight();
/// Sizes this widget to both intrinsic width and height.
///
/// Parameters:
/// - [stepWidth] (`double?`, optional): Stepping for width.
/// - [stepHeight] (`double?`, optional): Stepping for height.
///
/// Returns: `Widget` ‚Äî intrinsically sized widget.
  Widget intrinsic({double? stepWidth, double? stepHeight});
}
/// Extension adding gap and separator utilities to [Column].
extension ColumnExtension on Column {
/// Adds gaps between column children.
///
/// Parameters:
/// - [gap] (`double`, required): Vertical spacing between children.
///
/// Returns: `Widget` ‚Äî column with gaps.
  Widget gap(double gap);
/// Adds separators between column children.
///
/// Parameters:
/// - [separator] (`Widget`, required): Widget to insert between children.
///
/// Returns: `Widget` ‚Äî column with separators.
  Widget separator(Widget separator);
}
/// Extension adding gap and separator utilities to [Row].
extension RowExtension on Row {
/// Adds gaps between row children.
///
/// Parameters:
/// - [gap] (`double`, required): Horizontal spacing between children.
///
/// Returns: `Widget` ‚Äî row with gaps.
  Widget gap(double gap);
/// Adds separators between row children.
///
/// Parameters:
/// - [separator] (`Widget`, required): Widget to insert between children.
///
/// Returns: `Widget` ‚Äî row with separators.
  Widget separator(Widget separator);
}
/// A flex widget that adds separators between children.
///
/// Used internally by [ColumnExtension] and [RowExtension] to insert
/// separators between flex children while maintaining flex properties.
class SeparatedFlex extends StatefulWidget {
/// Main axis alignment for flex children.
  MainAxisAlignment mainAxisAlignment;
/// Main axis size constraint for the flex.
  MainAxisSize mainAxisSize;
/// Cross axis alignment for flex children.
  CrossAxisAlignment crossAxisAlignment;
/// Text direction for the flex.
  TextDirection? textDirection;
/// Vertical direction for laying out children.
  VerticalDirection verticalDirection;
/// Text baseline for aligning text children.
  TextBaseline? textBaseline;
/// Children widgets to display with separators.
  List<Widget> children;
/// Flex direction (horizontal or vertical).
  Axis direction;
/// Separator widget to insert between children.
  Widget separator;
/// Clipping behavior for the flex.
  Clip clipBehavior;
/// Creates a [SeparatedFlex].
///
/// All flex-related parameters match [Flex] widget parameters.
  const SeparatedFlex({super.key, required this.mainAxisAlignment, required this.mainAxisSize, required this.crossAxisAlignment, this.textDirection, required this.verticalDirection, this.textBaseline, required this.children, required this.separator, required this.direction, this.clipBehavior = Clip.none});
  State<SeparatedFlex> createState();
}
/// Extension adding gap and separator utilities to [Flex].
extension FlexExtension on Flex {
/// Adds gaps between flex children.
///
/// The gap direction depends on the flex direction (vertical or horizontal).
///
/// Parameters:
/// - [gap] (`double`, required): Spacing between children.
///
/// Returns: `Widget` ‚Äî flex with gaps.
  Widget gap(double gap);
/// Adds separators between flex children.
///
/// Parameters:
/// - [separator] (`Widget`, required): Widget to insert between children.
///
/// Returns: `Widget` ‚Äî flex with separators.
  Widget separator(Widget separator);
}
/// An iterable that inserts a separator between each widget.
///
/// Parameters:
/// - [widgets] (`Iterable<Widget>`, required): Original widgets.
/// - [separator] (`Widget`, required): Widget to insert between items.
Iterable<Widget> join(Iterable<Widget> widgets, Widget separator);
/// Extension adding min/max utilities to [double].
extension DoubleExtension on double {
/// Returns the minimum of this value and another.
///
/// Parameters:
/// - [other] (`double`, required): Value to compare.
///
/// Returns: `double` ‚Äî the smaller value.
  double min(double other);
/// Returns the maximum of this value and another.
///
/// Parameters:
/// - [other] (`double`, required): Value to compare.
///
/// Returns: `double` ‚Äî the larger value.
  double max(double other);
}
/// Extension adding min/max utilities to [int].
extension IntExtension on int {
/// Returns the minimum of this value and another.
///
/// Parameters:
/// - [other] (`int`, required): Value to compare.
///
/// Returns: `int` ‚Äî the smaller value.
  int min(int other);
/// Returns the maximum of this value and another.
///
/// Parameters:
/// - [other] (`int`, required): Value to compare.
///
/// Returns: `int` ‚Äî the larger value.
  int max(int other);
}
/// A tween for animating between two [IconThemeData] values.
class IconThemeDataTween extends Tween<IconThemeData> {
/// Creates an [IconThemeDataTween].
///
/// Parameters:
/// - [begin] (`IconThemeData?`, optional): Starting icon theme.
/// - [end] (`IconThemeData?`, optional): Ending icon theme.
  IconThemeDataTween({super.begin, super.end});
  IconThemeData lerp(double t);
}
/// Extension adding color manipulation utilities to [Color].
extension ColorExtension on Color {
/// Scales the alpha channel by a factor.
///
/// Parameters:
/// - [factor] (`double`, required): Multiplier for alpha (0.0 to 1.0+).
///
/// Returns: `Color` ‚Äî color with scaled alpha.
  Color scaleAlpha(double factor);
/// Gets a contrasting color based on luminance.
///
/// Adjusts luminance to create contrast. If current lightness >= 0.5,
/// reduces it; otherwise increases it.
///
/// Parameters:
/// - [luminanceContrast] (`double`, default: 1): Contrast factor (0.0 to 1.0).
///
/// Returns: `Color` ‚Äî contrasting color.
  Color getContrastColor([double luminanceContrast = 1]);
/// Sets the luminance (lightness) of this color.
///
/// Parameters:
/// - [luminance] (`double`, required): Target luminance (0.0 to 1.0).
///
/// Returns: `Color` ‚Äî color with specified luminance.
  Color withLuminance(double luminance);
/// Converts this color to hexadecimal string.
///
/// Parameters:
/// - [includeHashSign] (`bool`, default: false): Whether to prefix with '#'.
/// - [includeAlpha] (`bool`, default: true): Whether to include alpha channel.
///
/// Returns: `String` ‚Äî hexadecimal color representation.
///
/// Example:
/// ```dart
/// Color.fromARGB(255, 255, 0, 0).toHex() // 'ffff0000'
/// Color.fromARGB(255, 255, 0, 0).toHex(includeHashSign: true) // '#ffff0000'
/// Color.fromARGB(255, 255, 0, 0).toHex(includeAlpha: false) // 'ff0000'
/// ```
  String toHex({bool includeHashSign = false, bool includeAlpha = true});
/// Converts this color to HSL color space.
///
/// Returns: `HSLColor` ‚Äî HSL representation.
  HSLColor toHSL();
/// Converts this color to HSV color space.
///
/// Returns: `HSVColor` ‚Äî HSV representation.
  HSVColor toHSV();
}
/// Extension for converting [HSLColor] to other color spaces.
extension HSLColorExtension on HSLColor {
/// Converts this HSL color to HSV color space.
///
/// Returns: `HSVColor` ‚Äî HSV representation.
  HSVColor toHSV();
}
/// Extension for converting [HSVColor] to other color spaces.
extension HSVColorExtension on HSVColor {
/// Converts this HSV color to HSL color space.
///
/// Returns: `HSLColor` ‚Äî HSL representation.
  HSLColor toHSL();
}
/// Represents a time of day with hour, minute, and second.
///
/// Provides constructors for various time representations including
/// AM/PM notation, DateTime conversion, and Duration conversion.
class TimeOfDay {
/// Hour component (0-23).
  int hour;
/// Minute component (0-59).
  int minute;
/// Second component (0-59).
  int second;
/// Creates a [TimeOfDay] with specified components.
///
/// Parameters:
/// - [hour] (`int`, required): Hour (0-23).
/// - [minute] (`int`, required): Minute (0-59).
/// - [second] (`int`, default: 0): Second (0-59).
  const TimeOfDay({required this.hour, required this.minute, this.second = 0});
/// Creates a PM time (adds 12 to the hour).
///
/// Parameters:
/// - [hour] (`int`, required): Hour in 12-hour format (1-12).
/// - [minute] (`int`, required): Minute (0-59).
/// - [second] (`int`, default: 0): Second (0-59).
  const TimeOfDay.pm({required int hour, required this.minute, this.second = 0});
/// Creates an AM time.
///
/// Parameters:
/// - [hour] (`int`, required): Hour in 12-hour format (0-11).
/// - [minute] (`int`, required): Minute (0-59).
/// - [second] (`int`, default: 0): Second (0-59).
  const TimeOfDay.am({required this.hour, required this.minute, this.second = 0});
/// Creates a [TimeOfDay] from a [DateTime].
///
/// Parameters:
/// - [dateTime] (`DateTime`, required): DateTime to extract time from.
  TimeOfDay.fromDateTime(DateTime dateTime);
/// Creates a [TimeOfDay] from a [Duration].
///
/// Parameters:
/// - [duration] (`Duration`, required): Duration to convert.
  TimeOfDay.fromDuration(Duration duration);
/// Creates a [TimeOfDay] representing the current time.
  TimeOfDay.now();
/// Creates a copy with specified fields replaced.
///
/// Parameters:
/// - [hour] (`ValueGetter<int>?`, optional): New hour value.
/// - [minute] (`ValueGetter<int>?`, optional): New minute value.
/// - [second] (`ValueGetter<int>?`, optional): New second value.
///
/// Returns: `TimeOfDay` ‚Äî copy with updated values.
  TimeOfDay copyWith({ValueGetter<int>? hour, ValueGetter<int>? minute, ValueGetter<int>? second});
/// For backward compatibility
  TimeOfDay replacing({int? hour, int? minute, int? second});
  bool operator ==(Object other);
  int get hashCode;
  String toString();
}
/// Invokes an action on the currently focused widget.
///
/// Attempts to find and invoke an action associated with the given intent
/// on the widget that currently has focus. This is useful for triggering
/// actions programmatically.
///
/// Parameters:
/// - [intent] (`Intent`, required): The intent to invoke.
///
/// Returns: `(bool enabled, Object? invokeResult)` ‚Äî a record containing
/// whether the action was enabled and the result of invoking it.
///
/// Example:
/// ```dart
/// final (enabled, result) = invokeActionOnFocusedWidget(
///   ActivateIntent(),
/// );
/// ```
(bool enabled, Object? invokeResult) invokeActionOnFocusedWidget(Intent intent);
/// Extension adding word-related utilities to [TextEditingController].
extension TextEditingControllerExtension on TextEditingController {
/// Gets the word at the current cursor position.
///
/// Returns `null` if the text is empty or the selection is not collapsed.
  String? get currentWord;
}
/// Gets the word at the caret position in a text string.
///
/// Finds the word boundaries around the caret position using the specified
/// separator characters.
///
/// Parameters:
/// - [text] (`String`, required): The text to search in.
/// - [caret] (`int`, required): The caret position (0 to text.length).
/// - [separator] (`String`, default: ' '): Characters that separate words.
///
/// Returns: `WordInfo` ‚Äî a record `(int start, String word)` containing
/// the start index and the word at the caret.
///
/// Throws [RangeError] if caret is out of bounds.
///
/// Example:
/// ```dart
/// final (start, word) = getWordAtCaret('Hello world', 7);
/// // Returns (6, 'world')
/// ```
WordInfo getWordAtCaret(String text, int caret, [String separator = ' ']);
/// Replaces the word at the caret position with a new string.
///
/// Finds the word boundaries around the caret using the separator predicate
/// and replaces that word with the provided replacement string.
///
/// Parameters:
/// - [text] (`String`, required): The text to modify.
/// - [caret] (`int`, required): The caret position (0 to text.length).
/// - [replacement] (`String`, required): The replacement text.
/// - [isSeparator] (`bool Function(String)`, required): Predicate to identify separator characters.
///
/// Returns: `ReplacementInfo` ‚Äî a record `(int start, String newText)` containing
/// the start index of the replacement and the new text.
///
/// Throws [RangeError] if caret is out of bounds.
///
/// Example:
/// ```dart
/// final (start, newText) = replaceWordAtCaret(
///   'Hello world',
///   7,
///   'universe',
///   (ch) => ch == ' ',
/// );
/// // Returns (6, 'Hello universe')
/// ```
ReplacementInfo replaceWordAtCaret(String text, int caret, String replacement, bool Function(String char) isSeparator);
/// Clears the currently active text input field.
///
/// Invokes a [TextFieldClearIntent] on the focused widget to clear its content.
/// This is useful for programmatically clearing text fields that have focus.
///
/// Example:
/// ```dart
/// clearActiveTextInput(); // Clears the focused text field
/// ```
void clearActiveTextInput();
/// Mixin for values that need custom rebuild logic.
///
/// Implement this mixin to control when a [CachedValueWidget] should rebuild
/// based on custom comparison logic.
mixin CachedValue {
/// Determines if the widget should rebuild when value changes.
///
/// Parameters:
/// - [oldValue] (`CachedValue`, required): Previous value to compare against.
///
/// Returns: `bool` ‚Äî `true` if rebuild is needed.
  bool shouldRebuild(covariant CachedValue oldValue);
}
/// A widget that caches a computed value.
///
/// Caches the result of [builder] and only rebuilds when [value] changes.
/// If [value] implements [CachedValue], uses custom rebuild logic.
class CachedValueWidget<T> extends StatefulWidget {
/// The value to cache and pass to builder.
  T value;
/// Builder function that creates the widget from the value.
  Widget Function(BuildContext context, T value) builder;
/// Creates a [CachedValueWidget].
///
/// Parameters:
/// - [value] (`T`, required): Value to cache.
/// - [builder] (`Widget Function(BuildContext, T)`, required): Widget builder.
  const CachedValueWidget({super.key, required this.value, required this.builder});
  State<StatefulWidget> createState();
}
/// A bidirectional converter between types [A] and [B].
///
/// Encapsulates conversion logic in both directions, allowing seamless
/// transformation between two types.
class BiDirectionalConvert<A, B> {
/// Converter from type A to type B.
  Convert<A, B> aToB;
/// Converter from type B to type A.
  Convert<B, A> bToA;
/// Creates a [BiDirectionalConvert].
///
/// Parameters:
/// - [aToB] (`Convert<A, B>`, required): A to B converter.
/// - [bToA] (`Convert<B, A>`, required): B to A converter.
  const BiDirectionalConvert(this.aToB, this.bToA);
/// Converts a value from type A to type B.
///
/// Parameters:
/// - [value] (`A`, required): Value to convert.
///
/// Returns: `B` ‚Äî converted value.
  B convertA(A value);
/// Converts a value from type B to type A.
///
/// Parameters:
/// - [value] (`B`, required): Value to convert.
///
/// Returns: `A` ‚Äî converted value.
  A convertB(B value);
  String toString();
  bool operator ==(Object other);
  int get hashCode;
}
/// A controller that converts between types [F] and [T].
///
/// Maintains bidirectional synchronization between two value notifiers
/// with different types using a [BiDirectionalConvert].
class ConvertedController<F, T> extends ChangeNotifier implements ComponentController<T> {
/// Creates a [ConvertedController].
///
/// Parameters:
/// - [other] (`ValueNotifier<F>`, required): Source value notifier.
/// - [convert] (`BiDirectionalConvert<F, T>`, required): Bidirectional converter.
  ConvertedController(ValueNotifier<F> other, BiDirectionalConvert<F, T> convert);
  T get value;
  set value(T newValue);
  void dispose();
}
/// Extension adding text replacement utilities to [TextEditingValue].
extension TextEditingValueExtension on TextEditingValue {
/// Replaces the text while preserving selection within bounds.
///
/// Adjusts the selection to stay within the new text length.
///
/// Parameters:
/// - [newText] (`String`, required): Replacement text.
///
/// Returns: `TextEditingValue` ‚Äî value with new text and adjusted selection.
  TextEditingValue replaceText(String newText);
}
/// A context action that executes a callback with context.
class ContextCallbackAction<T extends Intent> extends ContextAction<T> {
/// The callback to execute when the action is invoked.
  OnContextedCallback<T> onInvoke;
/// Creates a [ContextCallbackAction].
///
/// Parameters:
/// - [onInvoke] (`OnContextedCallback<T>`, required): Callback function.
  ContextCallbackAction({required this.onInvoke});
  Object? invoke(T intent, [BuildContext? context]);
}
/// A widget that filters duplicate Flutter errors, logging each unique error only once.
///
/// Wrap your app or subtree with [ErrorFilter] to avoid repeated error logs for the same error.
///
/// Example:
/// ```dart
/// ErrorFilter(
///   child: MyApp(),
/// )
/// ```
class ErrorFilter extends StatefulWidget {
/// Child widget to wrap with error filtering.
  Widget child;
/// Creates an [ErrorFilter].
///
/// Parameters:
/// - [child] (`Widget`, required): Child widget to wrap.
  const ErrorFilter({super.key, required this.child});
  State<ErrorFilter> createState();
}
# File: ./lib/pages/docs/components/toast/toast_example_1.dart
import 'package:shadcn_flutter/shadcn_flutter.dart';
// Demonstrates toast overlays in different screen locations with a custom
// content builder and programmatic close via the overlay handle.
class ToastExample1 extends StatefulWidget {
  const ToastExample1({super.key});
  @override
  State<ToastExample1> createState() => _ToastExample1State();
}
class _ToastExample1State extends State<ToastExample1> {
  // Builder for the toast content; receives an overlay handle so we can close it.
  Widget buildToast(BuildContext context, ToastOverlay overlay) {
    return SurfaceCard(
      child: Basic(
        title: const Text('Event has been created'),
        subtitle: const Text('Sunday, July 07, 2024 at 12:00 PM'),
        trailing: PrimaryButton(
            size: ButtonSize.small,
            onPressed: () {
              // Close the toast programmatically when clicking Undo.
              overlay.close();
            },
            child: const Text('Undo')),
        trailingAlignment: Alignment.center,
      ),
    );
  }
  @override
  Widget build(BuildContext context) {
    return Wrap(
      spacing: 8,
      runSpacing: 8,
      children: [
        PrimaryButton(
          onPressed: () {
            showToast(
              context: context,
              builder: buildToast,
              // Position bottom-left.
              location: ToastLocation.bottomLeft,
            );
          },
          child: const Text('Show Bottom Left Toast'),
        ),
        PrimaryButton(
          onPressed: () {
            showToast(
              context: context,
              builder: buildToast,
              // Position bottom-right.
              location: ToastLocation.bottomRight,
            );
          },
          child: const Text('Show Bottom Right Toast'),
        ),
        PrimaryButton(
          onPressed: () {
            showToast(
              context: context,
              builder: buildToast,
              // Position top-left.
              location: ToastLocation.topLeft,
            );
          },
          child: const Text('Show Top Left Toast'),
        ),
        PrimaryButton(
          onPressed: () {
            showToast(
              context: context,
              builder: buildToast,
              // Position top-right.
              location: ToastLocation.topRight,
            );
          },
          child: const Text('Show Top Right Toast'),
        ),
        // bottom center
        PrimaryButton(
          onPressed: () {
            showToast(
              context: context,
              builder: buildToast,
              location: ToastLocation.bottomCenter,
            );
          },
          child: const Text('Show Bottom Center Toast'),
        ),
        // top center
        PrimaryButton(
          onPressed: () {
            showToast(
              context: context,
              builder: buildToast,
              location: ToastLocation.topCenter,
            );
          },
          child: const Text('Show Top Center Toast'),
        ),
      ],
    );
  }
}
# File: ./lib/pages/docs/components/pagination/pagination_example_1.dart
import 'package:shadcn_flutter/shadcn_flutter.dart';
class PaginationExample1 extends StatefulWidget {
  const PaginationExample1({super.key});
  @override
  State<PaginationExample1> createState() => _PaginationExample1State();
}
class _PaginationExample1State extends State<PaginationExample1> {
  int page = 1;
  @override
  Widget build(BuildContext context) {
    return Pagination(
      page: page,
      totalPages: 20,
      // Limit how many page buttons are visible at once (rest via ellipsis).
      onPageChanged: (value) {
        setState(() {
          page = value;
        });
      },
      maxPages: 3,
    );
  }
}
# File: ./lib/pages/docs/components/number_input/number_input_example_2.dart
import 'package:shadcn_flutter/shadcn_flutter.dart';
class NumberInputExample2 extends StatefulWidget {
  const NumberInputExample2({super.key});
  @override
  State<NumberInputExample2> createState() => _NumberInputExample2State();
}
class _NumberInputExample2State extends State<NumberInputExample2> {
  double value = 0;
  @override
  Widget build(BuildContext context) {
    return Column(
      children: [
        SizedBox(
          width: 150,
          child: TextField(
            initialValue: value.toString(),
            onChanged: (value) {
              setState(() {
                this.value = double.tryParse(value) ?? 0;
              });
            },
            features: const [
              InputFeature.incrementButton(max: 10),
              InputFeature.decrementButton(min: -10),
            ],
            submitFormatters: [
              // Allow math expressions (e.g., 1+2*3) that resolve on submit.
              TextInputFormatters.mathExpression(),
            ],
          ),
        ),
        gap(8),
        Text('Value: $value'),
      ],
    );
  }
}
# File: ./lib/pages/docs/components/number_input/number_input_example_3.dart
import 'package:shadcn_flutter/shadcn_flutter.dart';
class NumberInputExample3 extends StatefulWidget {
  const NumberInputExample3({super.key});
  @override
  State<NumberInputExample3> createState() => _NumberInputExample3State();
}
class _NumberInputExample3State extends State<NumberInputExample3> {
  double value = 0;
  @override
  Widget build(BuildContext context) {
    return Column(
      children: [
        SizedBox(
          width: 150,
          child: TextField(
            initialValue: value.toString(),
            onChanged: (value) {
              setState(() {
                this.value = double.tryParse(value) ?? 0;
              });
            },
            features: const [
              // Increment button on the left, decrement button on the right.
              InputFeature.incrementButton(
                  position: InputFeaturePosition.leading),
              InputFeature.decrementButton(),
            ],
            submitFormatters: [
              // Allow math expressions (e.g., 1+2*3) that resolve on submit.
              TextInputFormatters.mathExpression(),
            ],
          ),
        ),
        gap(8),
        Text('Value: $value'),
      ],
    );
  }
}
# File: ./lib/pages/docs/components/number_input/number_input_example_1.dart
import 'package:shadcn_flutter/shadcn_flutter.dart';
class NumberInputExample1 extends StatefulWidget {
  const NumberInputExample1({super.key});
  @override
  State<NumberInputExample1> createState() => _NumberInputExample1State();
}
class _NumberInputExample1State extends State<NumberInputExample1> {
  double value = 0;
  @override
  Widget build(BuildContext context) {
    return Column(
      children: [
        SizedBox(
          width: 100,
          child: TextField(
            initialValue: value.toString(),
            onChanged: (value) {
              setState(() {
                this.value = double.tryParse(value) ?? 0;
              });
            },
            features: const [
              // Adds stepper/spinner controls to nudge the value up/down.
              InputFeature.spinner(min: -50, max: 50),
            ],
            submitFormatters: [
              // Allow math expressions (e.g., 1+2*3) that resolve on submit.
              TextInputFormatters.mathExpression(),
            ],
          ),
        ),
        gap(8),
        Text('Value: $value'),
      ],
    );
  }
}
# File: ./lib/pages/docs/components/switcher/switcher_example_2.dart
import 'package:shadcn_flutter/shadcn_flutter.dart';
class SwitcherExample2 extends StatefulWidget {
  const SwitcherExample2({super.key});
  @override
  State<SwitcherExample2> createState() => _SwitcherExample2State();
}
class _SwitcherExample2State extends State<SwitcherExample2> {
  bool _isRegister = false;
  final _registerController = FormController();
  final _loginController = FormController();
  @override
  Widget build(BuildContext context) {
    return Switcher(
      // Toggle between login (index 0) and register (index 1) forms.
      index: _isRegister ? 1 : 0,
      onIndexChanged: (index) {
        setState(() {
          _isRegister = index == 1;
        });
      },
      direction: AxisDirection.left,
      children: [
        Container(
          key: const Key('login'),
          width: 350,
          padding: const EdgeInsets.all(16),
          child: Form(
            controller: _loginController,
            child: Column(
              crossAxisAlignment: CrossAxisAlignment.stretch,
              spacing: 16,
              children: [
                FormField(
                  key: const TextFieldKey(#email),
                  label: const Text('Email'),
                  validator: const EmailValidator() & const NotEmptyValidator(),
                  showErrors: const {
                    FormValidationMode.changed,
                    FormValidationMode.submitted,
                  },
                  child: TextField(
                    initialValue:
                        _loginController.getValue(const TextFieldKey(#email)),
                    keyboardType: TextInputType.emailAddress,
                    autocorrect: false,
                    enableSuggestions: false,
                  ),
                ),
                const FormField(
                  key: TextFieldKey(#password),
                  label: Text('Password'),
                  validator: NotEmptyValidator(),
                  showErrors: {
                    FormValidationMode.changed,
                    FormValidationMode.submitted,
                  },
                  child: TextField(obscureText: true),
                ),
                const SubmitButton(
                  child: Text('Login'),
                ),
                const Text('Don\'t have an account? ').thenButton(
                    onPressed: () {
                      setState(() {
                        // Switch to the register form.
                        _isRegister = true;
                      });
                    },
                    child: const Text('Sign Up!')),
              ],
            ),
          ),
        ),
        Container(
          key: const Key('register-form'),
          width: 350,
          padding: const EdgeInsets.all(16),
          child: Form(
            controller: _registerController,
            child: Column(
              crossAxisAlignment: CrossAxisAlignment.stretch,
              spacing: 16,
              children: [
                FormField(
                  key: const TextFieldKey(#email),
                  label: const Text('Email'),
                  validator: const EmailValidator() & const NotEmptyValidator(),
                  showErrors: const {
                    FormValidationMode.changed,
                    FormValidationMode.submitted,
                  },
                  child: TextField(
                    initialValue: _registerController
                        .getValue(const TextFieldKey(#email)),
                    keyboardType: TextInputType.emailAddress,
                    autocorrect: false,
                    enableSuggestions: false,
                  ),
                ),
                const FormField(
                  key: TextFieldKey(#password),
                  label: Text('Password'),
                  validator: LengthValidator(
                      min: 6,
                      message: 'Password must be at least 6 characters'),
                  showErrors: {
                    FormValidationMode.changed,
                    FormValidationMode.submitted,
                  },
                  child: TextField(obscureText: true),
                ),
                const FormField(
                  key: TextFieldKey(#confirmPassword),
                  label: Text('Confirm Password'),
                  validator: CompareWith.equal(TextFieldKey(#password),
                      message: 'Passwords do not match'),
                  showErrors: {
                    FormValidationMode.changed,
                    FormValidationMode.submitted,
                  },
                  child: TextField(obscureText: true),
                ),
                const SubmitButton(
                  child: Text('Register'),
                ),
                const Text('Already have an account? ').thenButton(
                    onPressed: () {
                      setState(() {
                        // Switch back to the login form.
                        _isRegister = false;
                      });
                    },
                    child: const Text('Login!')),
              ],
            ),
          ),
        ),
      ],
    );
  }
}
# File: ./lib/pages/docs/components/switcher/switcher_example_1.dart
import 'package:docs/pages/docs/components/carousel_example.dart';
import 'package:shadcn_flutter/shadcn_flutter.dart';
class SwitcherExample1 extends StatefulWidget {
  const SwitcherExample1({super.key});
  @override
  State<SwitcherExample1> createState() => _SwitcherExample1State();
}
class _SwitcherExample1State extends State<SwitcherExample1> {
  List<AxisDirection> directions = const [
    AxisDirection.up,
    AxisDirection.down,
    AxisDirection.left,
    AxisDirection.right,
  ];
  List<Size> sizes = const [
    Size(200, 300),
    Size(300, 200),
  ];
  int directionIndex = 0;
  int index = 0;
  @override
  Widget build(BuildContext context) {
    return Column(
      mainAxisSize: MainAxisSize.min,
      children: [
        PrimaryButton(
            child: Text(
                'Switch Direction (${directions[directionIndex % directions.length]})'),
            onPressed: () {
              setState(() {
                directionIndex++;
              });
            }),
        gap(8),
        PrimaryButton(
            child: const Text('Next Item'),
            onPressed: () {
              setState(() {
                index++;
              });
            }),
        gap(24),
        ClipRect(
          child: Switcher(
            // The index selects which child is visible; transitions are directional.
            index: index,
            direction: directions[directionIndex % directions.length],
            onIndexChanged: (index) {
              setState(() {
                this.index = index;
              });
            },
            children: [
              for (int i = 0; i < 100; i++)
                NumberedContainer(
                  index: i,
                  // Demonstrate different sizes to show animated size transitions.
                  width: sizes[i % sizes.length].width,
                  height: sizes[i % sizes.length].height,
                )
            ],
          ),
        ),
      ],
    );
  }
}
# File: ./lib/pages/docs/components/avatar/avatar_example_1.dart
import 'package:shadcn_flutter/shadcn_flutter.dart';
/// Avatar with image and initials fallback.
///
/// If the image fails to load, the [initials] will be shown over the
/// [backgroundColor]. This example uses a remote GitHub avatar URL.
class AvatarExample1 extends StatelessWidget {
  const AvatarExample1({super.key});
  @override
  Widget build(BuildContext context) {
    return Avatar(
      backgroundColor: Colors.red,
      // Helper to derive initials from a username or full name.
      initials: Avatar.getInitials('sunarya-thito'),
      provider: const NetworkImage(
          'https://avatars.githubusercontent.com/u/64018564?v=4'),
    );
  }
}
# File: ./lib/pages/docs/components/avatar/avatar_example_2.dart
import 'package:shadcn_flutter/shadcn_flutter.dart';
/// Simple Avatar with initials only.
///
/// Demonstrates customizing the avatar [size] while displaying
/// just the text initials (no image provider).
class AvatarExample2 extends StatelessWidget {
  const AvatarExample2({super.key});
  @override
  Widget build(BuildContext context) {
    return Avatar(
      // Use initials when you don't have an image.
      initials: Avatar.getInitials('sunarya-thito'),
      size: 64,
    );
  }
}
# File: ./lib/pages/docs/components/avatar/avatar_example_3.dart
import 'package:shadcn_flutter/shadcn_flutter.dart';
/// Avatar with a status badge.
///
/// Shows how to attach an [AvatarBadge] to indicate presence/status
/// (e.g., online/offline) or any small highlight.
class AvatarExample3 extends StatelessWidget {
  const AvatarExample3({super.key});
  @override
  Widget build(BuildContext context) {
    return Avatar(
      initials: Avatar.getInitials('sunarya-thito'),
      size: 64,
      badge: const AvatarBadge(
        size: 20,
        color: Colors.green,
      ),
    );
  }
}
# File: ./lib/pages/docs/components/repeated_animation_builder/repeated_animation_builder_example_2.dart
import 'package:shadcn_flutter/shadcn_flutter.dart';
class RepeatedAnimationBuilderExample2 extends StatelessWidget {
  const RepeatedAnimationBuilderExample2({super.key});
  @override
  Widget build(BuildContext context) {
    return RepeatedAnimationBuilder(
      start: const Offset(-100, 0),
      end: const Offset(100, 0),
      duration: const Duration(seconds: 1),
      // Apply a non-linear easing curve.
      curve: Curves.easeInOutCubic,
      // Reverse mode plays forward to 'end', then backward to 'start', and repeats.
      mode: LoopingMode.reverse,
      builder: (context, value, child) {
        return Transform.translate(
          offset: value,
          child: Container(
            width: 100,
            height: 100,
            color: Colors.red,
          ),
        );
      },
    );
  }
}
# File: ./lib/pages/docs/components/repeated_animation_builder/repeated_animation_builder_example_1.dart
import 'package:shadcn_flutter/shadcn_flutter.dart';
class RepeatedAnimationBuilderExample1 extends StatelessWidget {
  const RepeatedAnimationBuilderExample1({super.key});
  @override
  Widget build(BuildContext context) {
    return RepeatedAnimationBuilder(
      // Animate a value from 'start' to 'end' and repeat.
      // The builder below receives the animated Offset each tick.
      start: const Offset(-100, 0),
      end: const Offset(100, 0),
      // One second per run from start to end.
      duration: const Duration(seconds: 1),
      builder: (context, value, child) {
        return Transform.translate(
          // Move a square horizontally based on the current animated value.
          offset: value,
          child: Container(
            width: 100,
            height: 100,
            color: Colors.red,
          ),
        );
      },
    );
  }
}
# File: ./lib/pages/docs/components/repeated_animation_builder/repeated_animation_builder_example_3.dart
import 'package:shadcn_flutter/shadcn_flutter.dart';
class RepeatedAnimationBuilderExample3 extends StatefulWidget {
  const RepeatedAnimationBuilderExample3({super.key});
  @override
  State<RepeatedAnimationBuilderExample3> createState() =>
      _RepeatedAnimationBuilderExample3State();
}
class _RepeatedAnimationBuilderExample3State
    extends State<RepeatedAnimationBuilderExample3> {
  // Whether the animation is currently playing. Toggled by the button below.
  bool play = true;
  @override
  Widget build(BuildContext context) {
    return Column(
      mainAxisSize: MainAxisSize.min,
      children: [
        RepeatedAnimationBuilder(
          // Drive play/pause from local state.
          play: play,
          start: const Offset(-100, 0),
          end: const Offset(100, 0),
          duration: const Duration(seconds: 1),
          // Provide a different reverse duration to show asymmetric timing.
          reverseDuration: const Duration(seconds: 5),
          // Use separate forward/reverse curves.
          curve: Curves.linear,
          reverseCurve: Curves.easeInOutCubic,
          // Ping-pong between start and end, reversing the direction each cycle.
          mode: LoopingMode.pingPongReverse,
          builder: (context, value, child) {
            return Transform.translate(
              offset: value,
              child: Container(
                width: 100,
                height: 100,
                color: Colors.red,
              ),
            );
          },
        ),
        const Gap(24),
        PrimaryButton(
          onPressed: () {
            setState(() {
              // Toggle the 'play' flag, which starts/stops the animation.
              play = !play;
            });
          },
          child: Text(play ? 'Stop' : 'Play'),
        )
      ],
    );
  }
}
# File: ./lib/pages/docs/components/slider/slider_example_1.dart
import 'package:shadcn_flutter/shadcn_flutter.dart';
class SliderExample1 extends StatefulWidget {
  const SliderExample1({super.key});
  @override
  State<SliderExample1> createState() => _SliderExample1State();
}
class _SliderExample1State extends State<SliderExample1> {
  // A single-value slider in the 0‚Äì1 range (default).
  SliderValue value = const SliderValue.single(0.5);
  @override
  Widget build(BuildContext context) {
    return Slider(
      value: value,
      onChanged: (value) {
        setState(() {
          // Update local state when the thumb is dragged.
          this.value = value;
        });
      },
    );
  }
}
# File: ./lib/pages/docs/components/slider/slider_example_3.dart
import 'package:shadcn_flutter/shadcn_flutter.dart';
class SliderExample3 extends StatefulWidget {
  const SliderExample3({super.key});
  @override
  State<SliderExample3> createState() => _SliderExample3State();
}
class _SliderExample3State extends State<SliderExample3> {
  // Single-value slider with a custom range and discrete divisions.
  SliderValue value = const SliderValue.single(0.5);
  @override
  Widget build(BuildContext context) {
    return Column(
      mainAxisSize: MainAxisSize.min,
      children: [
        Slider(
          // Allow values from 0 to 2 with 10 discrete steps.
          max: 2,
          divisions: 10,
          value: value,
          onChanged: (value) {
            setState(() {
              this.value = value;
            });
          },
        ),
        const Gap(16),
        // Show the current numeric value.
        Text('Value: ${value.value}'),
      ],
    );
  }
}
# File: ./lib/pages/docs/components/slider/slider_example_2.dart
import 'package:shadcn_flutter/shadcn_flutter.dart';
class SliderExample2 extends StatefulWidget {
  const SliderExample2({super.key});
  @override
  State<SliderExample2> createState() => _SliderExample2State();
}
class _SliderExample2State extends State<SliderExample2> {
  // A ranged slider has a start and end thumb/value.
  SliderValue value = const SliderValue.ranged(0.5, 0.75);
  @override
  Widget build(BuildContext context) {
    return Column(
      mainAxisSize: MainAxisSize.min,
      children: [
        Slider(
          value: value,
          onChanged: (value) {
            setState(() {
              this.value = value;
            });
          },
        ),
        const Gap(16),
        // Display the current ranged values below the slider.
        Text('Value: ${value.start} - ${value.end}'),
      ],
    );
  }
}
# File: ./lib/pages/docs/components/hover_card/hover_card_example_1.dart
import 'package:shadcn_flutter/shadcn_flutter.dart';
class HoverCardExample1 extends StatelessWidget {
  const HoverCardExample1({super.key});
  @override
  Widget build(BuildContext context) {
    // HoverCard shows a floating panel when the user hovers over the child.
    // - hoverBuilder builds the content of the floating card.
    // - child is the anchor widget users point at/hover to reveal the card.
    return HoverCard(
      hoverBuilder: (context) {
        // SurfaceCard provides an elevated container with default padding and
        // surface styling. We constrain the width so the text wraps nicely.
        return const SurfaceCard(
          child: Basic(
            leading: FlutterLogo(),
            title: Text('@flutter'),
            content: Text(
                'The Flutter SDK provides the tools to build beautiful apps for mobile, web, and desktop from a single codebase.'),
          ),
        ).sized(width: 300);
      },
      child: LinkButton(
        // The LinkButton acts as the hover target. onPressed is provided for
        // completeness but not used in this example.
        onPressed: () {},
        child: const Text('@flutter'),
      ),
    );
  }
}
# File: ./lib/pages/docs/components/skeleton/skeleton_example_1.dart
import 'package:shadcn_flutter/shadcn_flutter.dart';
class SkeletonExample1 extends StatelessWidget {
  const SkeletonExample1({super.key});
  @override
  Widget build(BuildContext context) {
    return Column(
      children: [
        const Basic(
          title: Text('Skeleton Example 1'),
          content:
              Text('Lorem ipsum dolor sit amet, consectetur adipiscing elit.'),
          leading: Avatar(
            initials: '',
          ),
          trailing: Icon(Icons.arrow_forward),
        ),
        const Gap(24),
        Basic(
          title: const Text('Skeleton Example 1'),
          content: const Text(
              'Lorem ipsum dolor sit amet, consectetur adipiscing elit.'),
          leading: const Avatar(
            initials: '',
          ).asSkeleton(),
          // Note: Avatar and other Image related widget needs its own skeleton
          trailing: const Icon(Icons.arrow_forward),
        )
            // Wrap the whole row in a skeleton to show a loading placeholder for text and icons.
            .asSkeleton(),
      ],
    );
  }
}
# File: ./lib/pages/docs/components/navigation_sidebar/navigation_sidebar_example_1.dart
import 'package:shadcn_flutter/shadcn_flutter.dart';
// Demonstrates a vertical NavigationSidebar with labels, dividers, and gaps.
// Selection is index-based and controlled by local state.
class NavigationSidebarExample1 extends StatefulWidget {
  const NavigationSidebarExample1({super.key});
  @override
  State<NavigationSidebarExample1> createState() =>
      _NavigationSidebarExample1State();
}
class _NavigationSidebarExample1State extends State<NavigationSidebarExample1> {
  // Currently selected item index in the sidebar.
  Key? selected = const ValueKey(0);
  Widget buildButton(String label, IconData icon, Key key) {
    // Helper for a standard navigation item with text label and icon.
    return NavigationItem(
      key: key,
      label: Text(label),
      child: Icon(icon),
    );
  }
  @override
  Widget build(BuildContext context) {
    return SizedBox(
      height: 400,
      child: OutlinedContainer(
        child: NavigationSidebar(
          // Wire selection to local state.
          selectedKey: selected,
          onSelected: (key) {
            setState(() {
              selected = key;
            });
          },
          children: [
            // A mix of labels, gaps, dividers, and items can be used to
            // structure the navigation list into logical sections.
            NavigationGroup(
              label: const Text('Discovery'),
              children: [
                buildButton(
                    'Listen Now', BootstrapIcons.playCircle, const ValueKey(0)),
                buildButton('Browse', BootstrapIcons.grid, const ValueKey(1)),
                buildButton(
                    'Radio', BootstrapIcons.broadcast, const ValueKey(2)),
              ],
            ),
            const NavigationGap(24),
            const NavigationDivider(),
            NavigationGroup(
              label: const Text('Library'),
              children: [
                buildButton('Playlist', BootstrapIcons.musicNoteList,
                    const ValueKey(3)),
                buildButton(
                    'Songs', BootstrapIcons.musicNote, const ValueKey(4)),
                buildButton(
                    'For You', BootstrapIcons.person, const ValueKey(5)),
                buildButton('Artists', BootstrapIcons.mic, const ValueKey(6)),
                buildButton(
                    'Albums', BootstrapIcons.record2, const ValueKey(7)),
              ],
            ),
            const NavigationGap(24),
            const NavigationDivider(),
            NavigationGroup(
              label: const Text('Playlists'),
              children: [
                buildButton('Recently Added', BootstrapIcons.musicNoteList,
                    const ValueKey(8)),
                buildButton('Recently Played', BootstrapIcons.musicNoteList,
                    const ValueKey(9)),
                buildButton('Top Songs', BootstrapIcons.musicNoteList,
                    const ValueKey(10)),
                buildButton('Top Albums', BootstrapIcons.musicNoteList,
                    const ValueKey(11)),
                buildButton('Top Artists', BootstrapIcons.musicNoteList,
                    const ValueKey(12)),
                buildButton('Logic Discography With Some Spice',
                    BootstrapIcons.musicNoteList, const ValueKey(13)),
                buildButton('Bedtime Beats', BootstrapIcons.musicNoteList,
                    const ValueKey(14)),
                buildButton('Feeling Happy', BootstrapIcons.musicNoteList,
                    const ValueKey(15)),
                buildButton('I miss Y2K Pop', BootstrapIcons.musicNoteList,
                    const ValueKey(16)),
                buildButton('Runtober', BootstrapIcons.musicNoteList,
                    const ValueKey(17)),
              ],
            ),
          ],
        ),
      ),
    );
  }
}
# File: ./lib/pages/docs/components/accordion/accordion_example_1.dart
import 'package:shadcn_flutter/shadcn_flutter.dart';
/// A minimal Accordion demo.
///
/// This example shows how to create a vertically stacked set of
/// expandable/collapsible items using [Accordion] and [AccordionItem].
///
/// Key points:
/// - [Accordion] manages the expansion state of its [items].
/// - Each [AccordionItem] defines a [trigger] (the clickable header)
///   and a [content] (the body shown when expanded).
/// - All text and layout here are simple to keep focus on the API usage.
class AccordionExample1 extends StatelessWidget {
  const AccordionExample1({super.key});
  @override
  Widget build(BuildContext context) {
    // The Accordion itself simply receives a list of items.
    // Note: Using `const` here keeps the widget tree immutable since
    // the items are static in this example.
    return const Accordion(
      items: [
        // Item 1: Demonstrates a basic trigger and a longer content body.
        AccordionItem(
          trigger: AccordionTrigger(child: Text('Lorem ipsum dolor sit amet')),
          content: Text(
              'Lorem ipsum dolor sit amet, consectetur adipiscing elit. '
              'Sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. '
              'Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. '
              'Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. '
              'Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum.'),
        ),
        // Item 2: Another entry with its own header and body.
        AccordionItem(
          trigger: AccordionTrigger(
              child: Text(
                  'Sed do eiusmod tempor incididunt ut labore et dolore magna aliqua')),
          content: Text(
              'Sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. '
              'Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. '
              'Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. '
              'Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum.'),
        ),
        // Item 3: A third example to show multiple items expand independently.
        AccordionItem(
          trigger: AccordionTrigger(
              child: Text(
                  'Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat')),
          content: Text(
              'Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. '
              'Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. '
              'Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum.'),
        ),
      ],
    );
  }
}
# File: ./lib/pages/docs/components/radio_card/radio_card_example_1.dart
import 'package:shadcn_flutter/shadcn_flutter.dart';
class RadioCardExample1 extends StatefulWidget {
  const RadioCardExample1({super.key});
  @override
  State<RadioCardExample1> createState() => _RadioCardExample1State();
}
class _RadioCardExample1State extends State<RadioCardExample1> {
  // Currently selected option. The RadioGroup below binds to this value.
  int value = 1;
  @override
  Widget build(BuildContext context) {
    return RadioGroup(
      // Provide the selected value so RadioCard children can render checked state.
      value: value,
      onChanged: (value) {
        setState(() {
          // Update selection when any RadioCard is tapped.
          this.value = value;
        });
      },
      child: const Row(
        mainAxisSize: MainAxisSize.min,
        children: [
          // Each RadioCard acts as a large tappable radio option.
          // Assign a unique 'value' for identification within the RadioGroup.
          RadioCard(
            value: 1,
            child: Basic(
              // 'Basic' is a helper layout that shows a title and a content line.
              title: Text('8-core CPU'),
              content: Text('32 GB RAM'),
            ),
          ),
          RadioCard(
            value: 2,
            child: Basic(
              title: Text('6-core CPU'),
              content: Text('24 GB RAM'),
            ),
          ),
          RadioCard(
            value: 3,
            child: Basic(
              title: Text('4-core CPU'),
              content: Text('16 GB RAM'),
            ),
          ),
        ],
      )
          // Add horizontal spacing between the cards via the .gap extension.
          .gap(12),
    );
  }
}
# File: ./lib/pages/docs/components/tracker/tracker_example_1.dart
import 'package:shadcn_flutter/shadcn_flutter.dart';
// Demonstrates a Tracker strip with varying levels (fine/warning/critical)
// and per-cell tooltips, similar to a heatmap timeline.
class TrackerExample1 extends StatefulWidget {
  const TrackerExample1({super.key});
  @override
  State<TrackerExample1> createState() => _TrackerExample1State();
}
class _TrackerExample1State extends State<TrackerExample1> {
  @override
  Widget build(BuildContext context) {
    // Build a simple sequence of tracker cells with different severity levels.
    List<TrackerData> data = [];
    for (int i = 0; i < 80; i++) {
      data.add(const TrackerData(
        tooltip: Text('Tracker Fine'),
        level: TrackerLevel.fine,
      ));
    }
    // Mark some indices as warnings.
    data[40] = data[35] = const TrackerData(
      tooltip: Text('Tracker Warning'),
      level: TrackerLevel.warning,
    );
    // And a few as critical.
    data[60] = data[68] = data[72] = const TrackerData(
      tooltip: Text('Tracker Critical'),
      level: TrackerLevel.critical,
    );
    // Unknown levels to show a broader legend.
    for (int i = 8; i < 16; i++) {
      data[i] = const TrackerData(
        tooltip: Text('Tracker Unknown'),
        level: TrackerLevel.unknown,
      );
    }
    // Tracker renders a compact heatmap-like strip with tooltips per cell.
    return Tracker(data: data);
  }
}
# File: ./lib/pages/docs/components/timeline/timeline_example_1.dart
import 'package:shadcn_flutter/shadcn_flutter.dart';
// Demonstrates a static Timeline with entries showing time, title, and content.
class TimelineExample1 extends StatelessWidget {
  const TimelineExample1({super.key});
  @override
  Widget build(BuildContext context) {
    return Timeline(
      // Each TimelineData item renders a time, title, and detailed content.
      // Styling/layout comes from the Timeline widget; content is plain widgets.
      data: [
        TimelineData(
          time: const Text('2022-01-01'),
          title: const Text('First event'),
          content: const Text(
              'Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Odio euismod lacinia at quis risus sed vulputate odio ut. Quam viverra orci sagittis eu volutpat odio facilisis mauris.'),
        ),
        TimelineData(
          time: const Text('2022-01-02'),
          title: const Text('Second event'),
          content: const Text(
              'Aut eius excepturi ex recusandae eius est minima molestiae. Nam dolores iusto ad fugit reprehenderit hic dolorem quisquam et quia omnis non suscipit nihil sit libero distinctio. Ad dolorem tempora sit nostrum voluptatem qui tempora unde? Sit rerum magnam nam ipsam nesciunt aut rerum necessitatibus est quia esse non magni quae.'),
        ),
        TimelineData(
          time: const Text('2022-01-03'),
          title: const Text('Third event'),
          content: const Text(
            'Sit culpa quas ex nulla animi qui deleniti minus rem placeat mollitia. Et enim doloremque et quia sequi ea dolores voluptatem ea rerum vitae. Aut itaque incidunt est aperiam vero sit explicabo fuga id optio quis et molestiae nulla ex quae quam. Ab eius dolores ab tempora dolorum eos beatae soluta At ullam placeat est incidunt cumque.',
          ),
        ),
      ],
    );
  }
}
# File: ./lib/pages/docs/components/refresh_trigger/refresh_trigger_example_1.dart
import 'package:shadcn_flutter/shadcn_flutter.dart';
class RefreshTriggerExample1 extends StatefulWidget {
  const RefreshTriggerExample1({super.key});
  @override
  State<RefreshTriggerExample1> createState() => _RefreshTriggerExample1State();
}
class _RefreshTriggerExample1State extends State<RefreshTriggerExample1> {
  // A GlobalKey lets us access the RefreshTrigger's state so we can
  // trigger a programmatic refresh (via a button) in addition to pull-to-refresh.
  final GlobalKey<RefreshTriggerState> _refreshTriggerKey =
      GlobalKey<RefreshTriggerState>();
  @override
  Widget build(BuildContext context) {
    return RefreshTrigger(
      key: _refreshTriggerKey,
      // Called when the user pulls down far enough or when we call .refresh().
      // Here we simulate a network call with a short delay.
      onRefresh: () async {
        await Future.delayed(const Duration(seconds: 2));
      },
      child: SingleChildScrollView(
        child: Container(
          // Give the scroll view some height so pull-to-refresh can be triggered.
          height: 800,
          padding: const EdgeInsets.only(top: 32),
          alignment: Alignment.topCenter,
          child: Column(
            children: [
              const Text('Pull Me'),
              const Gap(16),
              PrimaryButton(
                onPressed: () {
                  // Programmatically trigger the refresh without a pull gesture.
                  _refreshTriggerKey.currentState!.refresh();
                },
                child: const Text('Refresh'),
              ),
            ],
          ),
        ),
      ),
    );
  }
}
# File: ./lib/pages/docs/components/input/input_example_1.dart
import 'package:shadcn_flutter/shadcn_flutter.dart';
class InputExample1 extends StatelessWidget {
  const InputExample1({super.key});
  @override
  Widget build(BuildContext context) {
    // Basic text input using shadcn_flutter's TextField.
    // placeholder is rendered inside the input when it's empty.
    return const TextField(
      placeholder: Text('Enter your name'),
    );
  }
}
# File: ./lib/pages/docs/components/input/input_example_4.dart
import 'package:shadcn_flutter/shadcn_flutter.dart';
class InputExample4 extends StatelessWidget {
  const InputExample4({super.key});
  @override
  Widget build(BuildContext context) {
    return Form(
      child: FormField(
        // Use a stable key for form state lookups and debugging.
        key: const InputKey(#test),
        label: const Text('Username'),
        // Async validator simulating server-side availability check.
        // Returns `false` (invalid) when the username is taken.
        validator: ConditionalValidator((value) async {
          // Simulate a network delay for demonstration purposes
          await Future.delayed(const Duration(seconds: 1));
          return !['sunarya-thito', 'septogeddon', 'admin'].contains(value);
        }, message: 'Username already taken'),
        child: const TextField(
          placeholder: Text('Enter your username'),
          initialValue: 'sunarya-thito',
          features: [
            // Manually triggers the validator again (useful after edits or on demand).
            InputFeature.revalidate(),
          ],
        ),
      ),
    );
  }
}
# File: ./lib/pages/docs/components/input/input_example_2.dart
import 'package:shadcn_flutter/shadcn_flutter.dart';
class InputExample2 extends StatefulWidget {
  const InputExample2({super.key});
  @override
  State<InputExample2> createState() => _InputExample2State();
}
class _InputExample2State extends State<InputExample2> {
  @override
  Widget build(BuildContext context) {
    // Demonstrates input features:
    // - A leading search icon that reacts to the hover state when the field is empty
    // - A clear button that appears when there's text and the field is focused or hovered
    return TextField(
        initialValue: 'Hello World!',
        placeholder: const Text('Search something...'),
        features: [
          // Leading icon only visible when the text is empty
          InputFeature.leading(StatedWidget.builder(
            builder: (context, states) {
              // Use a muted icon normally, switch to the full icon on hover
              if (states.hovered) {
                return const Icon(Icons.search);
              } else {
                return const Icon(Icons.search).iconMutedForeground();
              }
            },
          ), visibility: InputFeatureVisibility.textEmpty),
          // Clear button visible when there is text and the field is focused,
          // or whenever the field is hovered
          InputFeature.clear(
            visibility: (InputFeatureVisibility.textNotEmpty &
                    InputFeatureVisibility.focused) |
                InputFeatureVisibility.hovered,
          ),
        ]);
  }
}
# File: ./lib/pages/docs/components/input/input_example_3.dart
import 'package:shadcn_flutter/shadcn_flutter.dart';
class InputExample3 extends StatelessWidget {
  const InputExample3({super.key});
  @override
  Widget build(BuildContext context) {
    return Column(
      children: [
        TextField(
          placeholder: const Text('Enter your name'),
          features: [
            const InputFeature.clear(),
            // Hint shows a small tooltip-like popup for the input field.
            InputFeature.hint(
              popupBuilder: (context) {
                return const TooltipContainer(
                    child: Text('This is for your username'));
              },
            ),
            // Convenience actions for copying/pasting directly from the text field UI.
            const InputFeature.copy(),
            const InputFeature.paste(),
          ],
        ),
        const Gap(24),
        const TextField(
          placeholder: Text('Enter your password'),
          features: [
            InputFeature.clear(
              visibility: InputFeatureVisibility.textNotEmpty,
            ),
            // Password toggle configured with `hold` mode: press-and-hold to peek,
            // release to hide again.
            InputFeature.passwordToggle(mode: PasswordPeekMode.hold),
          ],
        ),
      ],
    );
  }
}
# File: ./lib/pages/docs/components/input/input_example_5.dart
import 'package:shadcn_flutter/shadcn_flutter.dart';
/// This example demonstrates grouping multiple input fields together
/// using the `ButtonGroup` component.
class InputExample5 extends StatelessWidget {
  const InputExample5({super.key});
  @override
  Widget build(BuildContext context) {
    return const Column(
      mainAxisSize: MainAxisSize.min,
      spacing: 16,
      children: [
        ButtonGroup(children: [
          // Its important to set width constraints on the TextFields
          SizedBox(
            width: 75,
            child: TextField(placeholder: Text('Red')),
          ),
          SizedBox(
            width: 75,
            child: TextField(placeholder: Text('Green')),
          ),
          SizedBox(
            width: 75,
            child: TextField(placeholder: Text('Blue')),
          ),
          SizedBox(
            width: 75,
            child: TextField(placeholder: Text('Alpha')),
          ),
        ]),
        ButtonGroup.vertical(
          children: [
            // Its important to set width constraints on the TextFields
            SizedBox(
              width: 200,
              child: TextField(placeholder: Text('First Name')),
            ),
            ButtonGroup.horizontal(
              children: [
                SizedBox(
                  width: 100,
                  child: TextField(placeholder: Text('Middle Name')),
                ),
                SizedBox(
                  width: 100,
                  child: TextField(placeholder: Text('Last Name')),
                ),
              ],
            )
          ],
        ),
      ],
    );
  }
}
# File: ./lib/pages/docs/components/badge/badge_example_2.dart
import 'package:shadcn_flutter/shadcn_flutter.dart';
/// Secondary badge style.
///
/// Use `SecondaryBadge` for a lighter emphasis compared to primary.
class BadgeExample2 extends StatelessWidget {
  const BadgeExample2({super.key});
  @override
  Widget build(BuildContext context) {
    return const SecondaryBadge(
      child: Text('Secondary'),
    );
  }
}
# File: ./lib/pages/docs/components/badge/badge_example_3.dart
import 'package:shadcn_flutter/shadcn_flutter.dart';
/// Outline badge style.
///
/// Outlined appearance for a more subtle badge.
class BadgeExample3 extends StatelessWidget {
  const BadgeExample3({super.key});
  @override
  Widget build(BuildContext context) {
    return const OutlineBadge(
      child: Text('Outline'),
    );
  }
}
# File: ./lib/pages/docs/components/badge/badge_example_4.dart
import 'package:shadcn_flutter/shadcn_flutter.dart';
/// Destructive badge style.
///
/// Use `DestructiveBadge` to call attention to critical or dangerous states.
class BadgeExample4 extends StatelessWidget {
  const BadgeExample4({super.key});
  @override
  Widget build(BuildContext context) {
    return const DestructiveBadge(
      child: Text('Destructive'),
    );
  }
}
# File: ./lib/pages/docs/components/badge/badge_example_1.dart
import 'package:shadcn_flutter/shadcn_flutter.dart';
/// Primary badge style.
///
/// Badges are small, attention-grabbing labels. Use `PrimaryBadge` for the
/// default emphasis.
class BadgeExample1 extends StatelessWidget {
  const BadgeExample1({super.key});
  @override
  Widget build(BuildContext context) {
    return const PrimaryBadge(
      child: Text('Primary'),
    );
  }
}
# File: ./lib/pages/docs/components/drawer/drawer_example_1.dart
import 'package:shadcn_flutter/shadcn_flutter.dart';
/// Drawer overlay opened from different screen edges.
///
/// Repeatedly opens nested drawers cycling through positions to showcase
/// [openDrawer] and how to close using [closeOverlay].
class DrawerExample1 extends StatefulWidget {
  const DrawerExample1({super.key});
  @override
  State<DrawerExample1> createState() => _DrawerExample1State();
}
class _DrawerExample1State extends State<DrawerExample1> {
  // Sequence of positions to cycle through as drawers are stacked.
  List<OverlayPosition> positions = [
    OverlayPosition.end,
    OverlayPosition.end,
    OverlayPosition.bottom,
    OverlayPosition.bottom,
    OverlayPosition.top,
    OverlayPosition.top,
    OverlayPosition.start,
    OverlayPosition.start,
  ];
  // Open a drawer and optionally open another from within it.
  void open(BuildContext context, int count) {
    openDrawer(
      context: context,
      expands: true,
      builder: (context) {
        return Container(
          padding: const EdgeInsets.all(48),
          child: IntrinsicWidth(
            child: Column(
              mainAxisSize: MainAxisSize.min,
              crossAxisAlignment: CrossAxisAlignment.stretch,
              children: [
                Text(
                    'Drawer ${count + 1} at ${positions[count % positions.length].name}'),
                const Gap(16),
                PrimaryButton(
                  onPressed: () {
                    // Open another drawer on top.
                    open(context, count + 1);
                  },
                  child: const Text('Open Another Drawer'),
                ),
                const Gap(8),
                SecondaryButton(
                  onPressed: () {
                    // Close the current top-most overlay.
                    closeOverlay(context);
                  },
                  child: const Text('Close Drawer'),
                ),
              ],
            ),
          ),
        );
      },
      position: positions[count % positions.length],
    );
  }
  @override
  Widget build(BuildContext context) {
    return PrimaryButton(
      onPressed: () {
        open(context, 0);
      },
      child: const Text('Open Drawer'),
    );
  }
}
# File: ./lib/pages/docs/components/navigation_rail/navigation_rail_example_1.dart
import 'package:shadcn_flutter/shadcn_flutter.dart';
class NavigationRailExample1 extends StatefulWidget {
  const NavigationRailExample1({super.key});
  @override
  State<NavigationRailExample1> createState() => _NavigationRailExample1State();
}
class _NavigationRailExample1State extends State<NavigationRailExample1> {
  NavigationRailAlignment alignment = NavigationRailAlignment.start;
  NavigationLabelType labelType = NavigationLabelType.none;
  NavigationLabelPosition labelPosition = NavigationLabelPosition.bottom;
  bool customButtonStyle = false;
  bool expanded = true;
  String selected = 'Home';
  NavigationItem buildButton(String label, IconData icon) {
    return NavigationItem(
      selected: selected == label,
      style: customButtonStyle
          ? const ButtonStyle.muted(density: ButtonDensity.icon)
          : null,
      selectedStyle: customButtonStyle
          ? const ButtonStyle.fixed(density: ButtonDensity.icon)
          : null,
      onChanged: (selected) {
        if (selected) {
          setState(() {
            this.selected = label;
          });
        }
      },
      label: Text(label),
      child: Icon(icon),
    );
  }
  @override
  Widget build(BuildContext context) {
    return Scaffold(
      child: Row(
        crossAxisAlignment: CrossAxisAlignment.stretch,
        children: [
          NavigationRail(
            alignment: alignment,
            labelType: labelType,
            labelPosition: labelPosition,
            expanded: expanded,
            children: [
              buildButton('Home', BootstrapIcons.house),
              buildButton('Explore', BootstrapIcons.compass),
              buildButton('Library', BootstrapIcons.musicNoteList),
              const NavigationDivider(),
              NavigationGroup(
                label: const Text('Settings'),
                children: [
                  buildButton('Profile', BootstrapIcons.person),
                  buildButton('App', BootstrapIcons.appIndicator),
                ],
              ),
              const NavigationDivider(),
              const NavigationGap(12),
              const FlutterLogo(),
            ],
          ),
          const VerticalDivider(),
          Expanded(
            child: Container(
              color:
                  Colors.primaries[selected.hashCode % Colors.primaries.length],
              padding: const EdgeInsets.all(24),
              child: Card(
                child: Wrap(
                  alignment: WrapAlignment.center,
                  runAlignment: WrapAlignment.center,
                  crossAxisAlignment: WrapCrossAlignment.center,
                  runSpacing: 8,
                  spacing: 8,
                  children: [
                    // Alignment of items within the rail.
                    Select<NavigationRailAlignment>(
                      value: alignment,
                      itemBuilder:
                          (BuildContext context, NavigationRailAlignment item) {
                        return Text(item.name);
                      },
                      popupWidthConstraint: PopoverConstraint.anchorFixedSize,
                      onChanged: (value) {
                        if (value != null) {
                          setState(() {
                            alignment = value;
                          });
                        }
                      },
                      popup: SelectPopup(
                          items: SelectItemList(children: [
                        for (var value in NavigationRailAlignment.values)
                          SelectItemButton(
                            value: value,
                            child: Text(value.name),
                          ),
                      ])),
                    ),
                    // Label visibility behavior for each destination.
                    Select<NavigationLabelType>(
                      value: labelType,
                      itemBuilder:
                          (BuildContext context, NavigationLabelType item) {
                        return Text(item.name);
                      },
                      popupConstraints:
                          BoxConstraints.tight(const Size(200, 200)),
                      onChanged: (value) {
                        if (value != null) {
                          setState(() {
                            labelType = value;
                          });
                        }
                      },
                      popup: SelectPopup(
                        items: SelectItemList(
                          children: [
                            for (var value in NavigationLabelType.values)
                              SelectItemButton(
                                value: value,
                                child: Text(value.name),
                              ),
                          ],
                        ),
                      ),
                    ),
                    // Where the label appears relative to the icon.
                    Select<NavigationLabelPosition>(
                      value: labelPosition,
                      itemBuilder:
                          (BuildContext context, NavigationLabelPosition item) {
                        return Text(item.name);
                      },
                      onChanged: (value) {
                        if (value != null) {
                          setState(() {
                            labelPosition = value;
                          });
                        }
                      },
                      popup: SelectPopup(
                        items: SelectItemList(
                          children: [
                            for (var value in NavigationLabelPosition.values)
                              SelectItemButton(
                                value: value,
                                child: Text(value.name),
                              ),
                          ],
                        ),
                      ),
                    ),
                    // Toggle custom vs default button styles for normal/selected.
                    Checkbox(
                      state: customButtonStyle
                          ? CheckboxState.checked
                          : CheckboxState.unchecked,
                      onChanged: (value) {
                        setState(() {
                          customButtonStyle = value == CheckboxState.checked;
                        });
                      },
                      trailing: const Text('Custom Button Style'),
                    ),
                    // Whether the rail is in expanded mode (shows labels, etc.).
                    Checkbox(
                      state: expanded
                          ? CheckboxState.checked
                          : CheckboxState.unchecked,
                      onChanged: (value) {
                        setState(() {
                          expanded = value == CheckboxState.checked;
                        });
                      },
                      trailing: const Text('Expanded'),
                    ),
                  ],
                ),
              ),
            ),
          ),
        ],
      ),
    );
  }
}
# File: ./lib/pages/docs/components/sortable/sortable_example_5.dart
import 'package:shadcn_flutter/shadcn_flutter.dart';
class SortableExample5 extends StatefulWidget {
  const SortableExample5({super.key});
  @override
  State<SortableExample5> createState() => _SortableExample5State();
}
class _SortableExample5State extends State<SortableExample5> {
  List<SortableData<String>> names = [
    const SortableData('James'),
    const SortableData('John'),
    const SortableData('Robert'),
    const SortableData('Michael'),
    const SortableData('William'),
  ];
  @override
  Widget build(BuildContext context) {
    return SortableLayer(
      lock: true,
      child: SortableDropFallback<int>(
        // Dropping outside edge targets appends the item to the end.
        onAccept: (value) {
          setState(() {
            names.add(names.removeAt(value.data));
          });
        },
        child: Column(
          crossAxisAlignment: CrossAxisAlignment.stretch,
          children: [
            for (int i = 0; i < names.length; i++)
              Sortable<String>(
                key: ValueKey(i),
                data: names[i],
                // we only want user to drag the item from the handle,
                // so we disable the drag on the item itself
                enabled: false,
                onAcceptTop: (value) {
                  setState(() {
                    names.swapItem(value, i);
                  });
                },
                onAcceptBottom: (value) {
                  setState(() {
                    names.swapItem(value, i + 1);
                  });
                },
                child: OutlinedContainer(
                  padding: const EdgeInsets.all(12),
                  child: Row(
                    children: [
                      // Only this handle starts the drag; the rest of the row is inert.
                      const SortableDragHandle(child: Icon(Icons.drag_handle)),
                      const SizedBox(width: 8),
                      Expanded(child: Text(names[i].data)),
                    ],
                  ),
                ),
              ),
          ],
        ),
      ),
    );
  }
}
# File: ./lib/pages/docs/components/sortable/sortable_example_4.dart
import 'package:shadcn_flutter/shadcn_flutter.dart';
class SortableExample4 extends StatefulWidget {
  const SortableExample4({super.key});
  @override
  State<SortableExample4> createState() => _SortableExample4State();
}
class _SortableExample4State extends State<SortableExample4> {
  List<SortableData<String>> names = [
    const SortableData('James'),
    const SortableData('John'),
    const SortableData('Robert'),
    const SortableData('Michael'),
    const SortableData('William'),
    const SortableData('David'),
    const SortableData('Richard'),
    const SortableData('Joseph'),
    const SortableData('Thomas'),
    const SortableData('Charles'),
    const SortableData('Daniel'),
    const SortableData('Matthew'),
    const SortableData('Anthony'),
    const SortableData('Donald'),
    const SortableData('Mark'),
    const SortableData('Paul'),
    const SortableData('Steven'),
    const SortableData('Andrew'),
    const SortableData('Kenneth'),
  ];
  final ScrollController controller = ScrollController();
  @override
  Widget build(BuildContext context) {
    return SizedBox(
      height: 400,
      child: SortableLayer(
        // Constrain drag overlays to the layer bounds so they scroll within the list.
        lock: true,
        child: SortableDropFallback<int>(
          // If dropped outside a specific edge target, append to the end.
          onAccept: (value) {
            setState(() {
              names.add(names.removeAt(value.data));
            });
          },
          // Wrap the scrollable so auto-scrolling can occur while dragging near edges.
          child: ScrollableSortableLayer(
            controller: controller,
            child: ListView.builder(
              controller: controller,
              itemBuilder: (context, i) {
                return Sortable<String>(
                  // Stable key helps maintain drag state with virtualization.
                  key: ValueKey(i),
                  data: names[i],
                  onAcceptTop: (value) {
                    setState(() {
                      names.swapItem(value, i);
                    });
                  },
                  onAcceptBottom: (value) {
                    setState(() {
                      names.swapItem(value, i + 1);
                    });
                  },
                  child: OutlinedContainer(
                    padding: const EdgeInsets.all(12),
                    child: Center(child: Text(names[i].data)),
                  ),
                );
              },
              itemCount: names.length,
            ),
          ),
        ),
      ),
    );
  }
}
# File: ./lib/pages/docs/components/sortable/sortable_example_1.dart
import 'package:shadcn_flutter/shadcn_flutter.dart';
class SortableExample1 extends StatefulWidget {
  const SortableExample1({super.key});
  @override
  State<SortableExample1> createState() => _SortableExample1State();
}
class _SortableExample1State extends State<SortableExample1> {
  // Two separate lists for demonstrating cross-list drag-and-drop.
  List<SortableData<String>> invited = [
    const SortableData('James'),
    const SortableData('John'),
    const SortableData('Robert'),
    const SortableData('Michael'),
    const SortableData('William'),
  ];
  List<SortableData<String>> reserved = [
    const SortableData('David'),
    const SortableData('Richard'),
    const SortableData('Joseph'),
    const SortableData('Thomas'),
    const SortableData('Charles'),
  ];
  @override
  void initState() {
    super.initState();
  }
  @override
  Widget build(BuildContext context) {
    return SizedBox(
      height: 500,
      child: SortableLayer(
        // The SortableLayer coordinates drag-over/accept behavior for nested Sortable zones.
        child: Row(
          crossAxisAlignment: CrossAxisAlignment.stretch,
          children: [
            Expanded(
              child: Card(
                child: SortableDropFallback<String>(
                  // If dropped into empty space in this list, append to the end.
                  onAccept: (value) {
                    setState(() {
                      swapItemInLists(
                          [invited, reserved], value, invited, invited.length);
                    });
                  },
                  child: Column(
                    crossAxisAlignment: CrossAxisAlignment.stretch,
                    children: [
                      for (int i = 0; i < invited.length; i++)
                        Sortable<String>(
                          data: invited[i],
                          // Insert above the current index when dropped at the top edge.
                          onAcceptTop: (value) {
                            setState(() {
                              swapItemInLists(
                                  [invited, reserved], value, invited, i);
                            });
                          },
                          // Insert below the current index when dropped at the bottom edge.
                          onAcceptBottom: (value) {
                            setState(() {
                              swapItemInLists(
                                  [invited, reserved], value, invited, i + 1);
                            });
                          },
                          child: OutlinedContainer(
                            padding: const EdgeInsets.all(12),
                            child: Center(child: Text(invited[i].data)),
                          ),
                        ),
                    ],
                  ),
                ),
              ),
            ),
            gap(12),
            Expanded(
              child: Card(
                child: SortableDropFallback<String>(
                  // Same behavior for the second list.
                  onAccept: (value) {
                    setState(() {
                      swapItemInLists([invited, reserved], value, reserved,
                          reserved.length);
                    });
                  },
                  child: Column(
                    crossAxisAlignment: CrossAxisAlignment.stretch,
                    children: [
                      for (int i = 0; i < reserved.length; i++)
                        Sortable<String>(
                          data: reserved[i],
                          onAcceptTop: (value) {
                            setState(() {
                              swapItemInLists(
                                  [invited, reserved], value, reserved, i);
                            });
                          },
                          onAcceptBottom: (value) {
                            setState(() {
                              swapItemInLists(
                                  [invited, reserved], value, reserved, i + 1);
                            });
                          },
                          child: OutlinedContainer(
                            padding: const EdgeInsets.all(12),
                            child: Center(child: Text(reserved[i].data)),
                          ),
                        ),
                    ],
                  ),
                ),
              ),
            ),
          ],
        ),
      ),
    );
  }
}
# File: ./lib/pages/docs/components/sortable/sortable_example_2.dart
import 'package:shadcn_flutter/shadcn_flutter.dart';
class SortableExample2 extends StatefulWidget {
  const SortableExample2({super.key});
  @override
  State<SortableExample2> createState() => _SortableExample2State();
}
class _SortableExample2State extends State<SortableExample2> {
  List<SortableData<String>> names = [
    const SortableData('James'),
    const SortableData('John'),
    const SortableData('Robert'),
    const SortableData('Michael'),
    const SortableData('William'),
  ];
  @override
  Widget build(BuildContext context) {
    return SortableLayer(
      // With lock enabled, the drag overlay is constrained within the layer.
      lock: true,
      child: SortableDropFallback<int>(
        // Dropping outside specific edge targets appends the item to the end.
        onAccept: (value) {
          setState(() {
            names.add(names.removeAt(value.data));
          });
        },
        child: Column(
          crossAxisAlignment: CrossAxisAlignment.stretch,
          children: [
            for (int i = 0; i < names.length; i++)
              Sortable<String>(
                // Use a stable key for better drag/reorder behavior.
                key: ValueKey(i),
                data: names[i],
                // Swap into the target index when dropped on the top edge.
                onAcceptTop: (value) {
                  setState(() {
                    names.swapItem(value, i);
                  });
                },
                // Insert after the target when dropped on the bottom edge.
                onAcceptBottom: (value) {
                  setState(() {
                    names.swapItem(value, i + 1);
                  });
                },
                child: OutlinedContainer(
                  padding: const EdgeInsets.all(12),
                  child: Center(child: Text(names[i].data)),
                ),
              ),
          ],
        ),
      ),
    );
  }
}
# File: ./lib/pages/docs/components/sortable/sortable_example_6.dart
import 'package:shadcn_flutter/shadcn_flutter.dart';
class SortableExample6 extends StatefulWidget {
  const SortableExample6({super.key});
  @override
  State<SortableExample6> createState() => _SortableExample6State();
}
class _SortableExample6State extends State<SortableExample6> {
  late List<SortableData<String>> names;
  @override
  void initState() {
    super.initState();
    _reset();
  }
  void _reset() {
    names = [
      const SortableData('James'),
      const SortableData('John'),
      const SortableData('Robert'),
      const SortableData('Michael'),
      const SortableData('William'),
    ];
  }
  @override
  Widget build(BuildContext context) {
    return SortableLayer(
      child: Builder(
          // this builder is needed to access the context of the SortableLayer
          builder: (context) {
        return SortableDropFallback<int>(
          onAccept: (value) {
            setState(() {
              names.add(names.removeAt(value.data));
            });
          },
          child: Column(
            crossAxisAlignment: CrossAxisAlignment.stretch,
            children: [
              PrimaryButton(
                onPressed: () {
                  setState(() {
                    _reset();
                  });
                },
                child: const Text('Reset'),
              ),
              for (int i = 0; i < names.length; i++)
                Sortable<String>(
                  key: ValueKey(i),
                  data: names[i],
                  // we only want user to drag the item from the handle,
                  // so we disable the drag on the item itself
                  enabled: false,
                  onAcceptTop: (value) {
                    setState(() {
                      names.swapItem(value, i);
                    });
                  },
                  onAcceptBottom: (value) {
                    setState(() {
                      names.swapItem(value, i + 1);
                    });
                  },
                  onDropFailed: () {
                    // Remove the item from the list if the drop failed
                    setState(() {
                      var removed = names.removeAt(i);
                      // Ensure the drag overlay exists and then dismiss it so
                      // the item does not animate back to its original position.
                      SortableLayer.ensureAndDismissDrop(context, removed);
                      // Dismissing drop will prevent the SortableLayer from
                      // animating the item back to its original position
                    });
                  },
                  child: OutlinedContainer(
                    padding: const EdgeInsets.all(12),
                    child: Row(
                      children: [
                        const SortableDragHandle(
                            child: Icon(Icons.drag_handle)),
                        const SizedBox(width: 8),
                        Expanded(child: Text(names[i].data)),
                      ],
                    ),
                  ),
                ),
            ],
          ),
        );
      }),
    );
  }
}
# File: ./lib/pages/docs/components/sortable/sortable_example_3.dart
import 'package:shadcn_flutter/shadcn_flutter.dart';
class SortableExample3 extends StatefulWidget {
  const SortableExample3({super.key});
  @override
  State<SortableExample3> createState() => _SortableExample3State();
}
class _SortableExample3State extends State<SortableExample3> {
  List<SortableData<String>> names = [
    const SortableData('James'),
    const SortableData('John'),
    const SortableData('Robert'),
    const SortableData('Michael'),
    const SortableData('William'),
  ];
  @override
  Widget build(BuildContext context) {
    return SortableLayer(
      // Constrain the drag overlay within the horizontal strip.
      lock: true,
      child: SortableDropFallback<int>(
        onAccept: (value) {
          setState(() {
            names.add(names.removeAt(value.data));
          });
        },
        child: SizedBox(
          height: 50,
          child: Row(
            crossAxisAlignment: CrossAxisAlignment.stretch,
            mainAxisSize: MainAxisSize.min,
            children: [
              for (int i = 0; i < names.length; i++)
                Sortable<String>(
                  key: ValueKey(i),
                  data: names[i],
                  // For horizontal sorting, drop on the left/right edges to reorder.
                  onAcceptLeft: (value) {
                    setState(() {
                      names.swapItem(value, i);
                    });
                  },
                  onAcceptRight: (value) {
                    setState(() {
                      names.swapItem(value, i + 1);
                    });
                  },
                  child: OutlinedContainer(
                    width: 100,
                    padding: const EdgeInsets.all(12),
                    child: Center(child: Text(names[i].data)),
                  ),
                ),
            ],
          ),
        ),
      ),
    );
  }
}
# File: ./lib/pages/docs/components/tab_pane/tab_pane_example_1.dart
import 'package:shadcn_flutter/shadcn_flutter.dart';
// Demonstrates TabPane with sortable, closable tabs backed by custom data.
// Tracks a focused index and renders a content area for the active tab.
class TabPaneExample1 extends StatefulWidget {
  const TabPaneExample1({super.key});
  @override
  State<TabPaneExample1> createState() => _TabPaneExample1State();
}
class MyTab {
  final String title;
  final int count;
  final String content;
  MyTab(this.title, this.count, this.content);
  @override
  String toString() {
    return 'TabData{title: $title, count: $count, content: $content}';
  }
}
class _TabPaneExample1State extends State<TabPaneExample1> {
  late List<TabPaneData<MyTab>> tabs;
  int focused = 0;
  @override
  void didChangeDependencies() {
    super.didChangeDependencies();
    // Build the initial set of tabs. TabPaneData wraps your custom data type
    // (here, MyTab) and adds selection/drag metadata.
    tabs = [
      for (int i = 0; i < 3; i++)
        TabPaneData(MyTab('Tab ${i + 1}', i + 1, 'Content ${i + 1}')),
    ];
  }
  // Render a single tab header item. It shows a badge-like count and a close button.
  TabItem _buildTabItem(MyTab data) {
    return TabItem(
      child: ConstrainedBox(
        constraints: const BoxConstraints(minWidth: 150),
        child: Label(
          leading: OutlinedContainer(
            backgroundColor: Colors.white,
            width: 18,
            height: 18,
            borderRadius: Theme.of(context).borderRadiusMd,
            child: Center(
              child: Text(
                data.count.toString(),
                style: const TextStyle(color: Colors.black),
              ).xSmall().bold(),
            ),
          ),
          trailing: IconButton.ghost(
            shape: ButtonShape.circle,
            size: ButtonSize.xSmall,
            icon: const Icon(Icons.close),
            onPressed: () {
              setState(() {
                tabs.remove(data);
              });
            },
          ),
          child: Text(data.title),
        ),
      ),
    );
  }
  @override
  Widget build(BuildContext context) {
    return TabPane<MyTab>(
      // children: tabs.map((e) => _buildTabItem(e)).toList(),
      // Provide the items and how to render each tab header.
      items: tabs,
      itemBuilder: (context, item, index) {
        return _buildTabItem(item.data);
      },
      // The currently focused tab index.
      focused: focused,
      onFocused: (value) {
        setState(() {
          focused = value;
        });
      },
      // Allow reordering via drag-and-drop; update the list with the new order.
      onSort: (value) {
        setState(() {
          tabs = value;
        });
      },
      // Optional leading/trailing actions for the tab strip.
      leading: [
        IconButton.secondary(
          icon: const Icon(Icons.arrow_drop_down),
          size: ButtonSize.small,
          density: ButtonDensity.iconDense,
          onPressed: () {},
        ),
      ],
      trailing: [
        IconButton.ghost(
          icon: const Icon(Icons.add),
          size: ButtonSize.small,
          density: ButtonDensity.iconDense,
          onPressed: () {
            setState(() {
              int max = tabs.fold<int>(0, (previousValue, element) {
                return element.data.count > previousValue
                    ? element.data.count
                    : previousValue;
              });
              tabs.add(TabPaneData(
                  MyTab('Tab ${max + 1}', max + 1, 'Content ${max + 1}')));
            });
          },
        )
      ],
      // The content area; you can render based on the focused index.
      child: SizedBox(
        height: 400,
        child: Center(
          child: Text('Tab ${focused + 1}').xLarge().bold(),
        ),
      ),
    );
  }
}
# File: ./lib/pages/docs/components/chat/chat_example_1.dart
import 'package:shadcn_flutter/shadcn_flutter.dart';
class ChatExample1 extends StatefulWidget {
  const ChatExample1({super.key});
  @override
  State<ChatExample1> createState() => _ChatExample1State();
}
class _ChatExample1State extends State<ChatExample1> {
  AxisDirectional selfPosition = AxisDirectional.end;
  AxisDirectional otherPosition = AxisDirectional.start;
  AxisAlignmentDirectional selfAlignment = AxisAlignmentDirectional.end;
  AxisAlignmentDirectional otherAlignment = AxisAlignmentDirectional.start;
  AxisAlignmentDirectional selfTailAlignment = AxisAlignmentDirectional.end;
  AxisAlignmentDirectional otherTailAlignment = AxisAlignmentDirectional.end;
  TailBehavior selfBehavior = TailBehavior.last;
  TailBehavior otherBehavior = TailBehavior.last;
  ChatType type = ChatType.tail;
  ChatBubbleType get selfType => switch (type) {
        ChatType.tail => ChatBubbleType.tail.copyWith(
            position: () => selfPosition,
            tailAlignment: () => selfTailAlignment,
            tailBehavior: () => selfBehavior,
          ),
        ChatType.sharpCorner => ChatBubbleType.sharpCorner.copyWith(
            tailBehavior: () => selfBehavior,
          ),
        _ => ChatBubbleType.plain,
      };
  ChatBubbleType get otherType => switch (type) {
        ChatType.tail => ChatBubbleType.tail.copyWith(
            position: () => otherPosition,
            tailAlignment: () => otherTailAlignment,
            tailBehavior: () => otherBehavior,
          ),
        ChatType.sharpCorner => ChatBubbleType.sharpCorner.copyWith(
            tailBehavior: () => otherBehavior,
          ),
        _ => ChatBubbleType.plain,
      };
  @override
  Widget build(BuildContext context) {
    return Column(
      spacing: 8,
      children: [
        // ChatGroup example
        ChatGroup(
          color: Colors.blue,
          type: selfType,
          alignment: selfAlignment,
          children: const [
            ChatBubble(
                child: Text(
                    'John, did you remember what time you took the call with Mrs. Smith?')),
            ChatBubble(child: Text('Reply ASAP')),
          ],
        ),
        ChatGroup(
          color: Colors.gray,
          avatarPrefix: const Avatar(initials: 'JO'),
          type: otherType,
          alignment: otherAlignment,
          children: const [
            ChatBubble(child: Text('Around 6 or 7?')),
            ChatBubble(child: Text('New phone who dis?')),
          ],
        ),
        ChatBubble(
          color: Colors.blue,
          type: selfType,
          alignment: selfAlignment,
          child: const Text('SIX SEVENNN ü§§ü§™'),
        ),
        ChatGroup(
          color: Colors.gray,
          avatarPrefix: const Avatar(initials: 'JO'),
          type: otherType,
          alignment: otherAlignment,
          children: const [
            ChatBubble(child: Text('?')),
            ChatBubble(child: Text('Seriously who is this')),
            ChatBubble(child: Text('gonna have to block you')),
          ],
        ),
        // controls
        gap(24),
        Wrap(spacing: 8, runSpacing: 8, children: [
          _withLabel(
            label: 'Type',
            child: Select(
              value: type,
              onChanged: (value) {
                if (value != null) {
                  setState(() {
                    type = value;
                  });
                }
              },
              popup: SelectPopup.noVirtualization(
                  items: SelectItemList(children: [
                for (var e in ChatType.values)
                  SelectItemButton(value: e, child: Text(e.name)),
              ])),
              itemBuilder: (BuildContext context, ChatType value) {
                return Text(value.name);
              },
            ),
          ),
          _withLabel(
            label: 'Self Position',
            child: Select(
              value: selfPosition,
              onChanged: (value) {
                if (value != null) {
                  setState(() {
                    selfPosition = value;
                  });
                }
              },
              popup: const SelectPopup.noVirtualization(
                  items: SelectItemList(children: [
                SelectItemButton(
                    value: AxisDirectional.start, child: Text('Start')),
                SelectItemButton(
                    value: AxisDirectional.end, child: Text('End')),
                SelectItemButton(value: AxisDirectional.up, child: Text('Up')),
                SelectItemButton(
                    value: AxisDirectional.down, child: Text('Down')),
              ])),
              itemBuilder: (BuildContext context, AxisDirectional value) {
                return Text(value == AxisDirectional.start ? 'Start' : 'End');
              },
            ),
          ),
          _withLabel(
            label: 'Other Position',
            child: Select(
              value: otherPosition,
              onChanged: (value) {
                if (value != null) {
                  setState(() {
                    otherPosition = value;
                  });
                }
              },
              popup: const SelectPopup.noVirtualization(
                  items: SelectItemList(children: [
                SelectItemButton(
                    value: AxisDirectional.start, child: Text('Start')),
                SelectItemButton(
                    value: AxisDirectional.end, child: Text('End')),
              ])),
              itemBuilder: (BuildContext context, AxisDirectional value) {
                return Text(value == AxisDirectional.start ? 'Start' : 'End');
              },
            ),
          ),
          _withLabel(
            label: 'Self Alignment',
            child: Select(
              value: selfAlignment,
              onChanged: (value) {
                if (value != null) {
                  setState(() {
                    selfAlignment = value;
                  });
                }
              },
              popup: const SelectPopup.noVirtualization(
                  items: SelectItemList(children: [
                SelectItemButton(
                    value: AxisAlignmentDirectional.start,
                    child: Text('Start')),
                SelectItemButton(
                    value: AxisAlignmentDirectional.end, child: Text('End')),
              ])),
              itemBuilder:
                  (BuildContext context, AxisAlignmentDirectional value) {
                return Text(
                    value == AxisAlignmentDirectional.start ? 'Start' : 'End');
              },
            ),
          ),
          _withLabel(
            label: 'Self Tail Alignment',
            child: Select(
              value: selfTailAlignment,
              onChanged: (value) {
                if (value != null) {
                  setState(() {
                    selfTailAlignment = value;
                  });
                }
              },
              popup: const SelectPopup.noVirtualization(
                  items: SelectItemList(children: [
                SelectItemButton(
                    value: AxisAlignmentDirectional.start,
                    child: Text('Start')),
                SelectItemButton(
                    value: AxisAlignmentDirectional.end, child: Text('End')),
              ])),
              itemBuilder:
                  (BuildContext context, AxisAlignmentDirectional value) {
                return Text(
                    value == AxisAlignmentDirectional.start ? 'Start' : 'End');
              },
            ),
          ),
          _withLabel(
              label: 'Self Behavior',
              child: Select(
                value: selfBehavior,
                onChanged: (value) {
                  if (value != null) {
                    setState(() {
                      selfBehavior = value;
                    });
                  }
                },
                popup: const SelectPopup.noVirtualization(
                    items: SelectItemList(children: [
                  SelectItemButton(
                      value: TailBehavior.first, child: Text('First')),
                  SelectItemButton(
                      value: TailBehavior.last, child: Text('Last')),
                ])),
                itemBuilder: (BuildContext context, TailBehavior value) {
                  return Text(value == TailBehavior.first ? 'First' : 'Last');
                },
              )),
        ]),
        gap(24),
        Wrap(spacing: 8, runSpacing: 8, children: [
          _withLabel(
            label: 'Other Position',
            child: Select(
              value: otherPosition,
              onChanged: (value) {
                if (value != null) {
                  setState(() {
                    otherPosition = value;
                  });
                }
              },
              popup: const SelectPopup.noVirtualization(
                  items: SelectItemList(children: [
                SelectItemButton(
                    value: AxisDirectional.start, child: Text('Start')),
                SelectItemButton(
                    value: AxisDirectional.end, child: Text('End')),
                SelectItemButton(value: AxisDirectional.up, child: Text('Up')),
                SelectItemButton(
                    value: AxisDirectional.down, child: Text('Down')),
              ])),
              itemBuilder: (BuildContext context, AxisDirectional value) {
                return Text(value == AxisDirectional.start ? 'Start' : 'End');
              },
            ),
          ),
          _withLabel(
              label: 'Other Alignment',
              child: Select(
                value: otherAlignment,
                onChanged: (value) {
                  if (value != null) {
                    setState(() {
                      otherAlignment = value;
                    });
                  }
                },
                popup: const SelectPopup.noVirtualization(
                    items: SelectItemList(children: [
                  SelectItemButton(
                      value: AxisAlignmentDirectional.start,
                      child: Text('Start')),
                  SelectItemButton(
                      value: AxisAlignmentDirectional.end, child: Text('End')),
                ])),
                itemBuilder:
                    (BuildContext context, AxisAlignmentDirectional value) {
                  return Text(value == AxisAlignmentDirectional.start
                      ? 'Start'
                      : 'End');
                },
              )),
          _withLabel(
              label: 'Other Tail Alignment',
              child: Select(
                value: otherTailAlignment,
                onChanged: (value) {
                  if (value != null) {
                    setState(() {
                      otherTailAlignment = value;
                    });
                  }
                },
                popup: const SelectPopup.noVirtualization(
                    items: SelectItemList(children: [
                  SelectItemButton(
                      value: AxisAlignmentDirectional.start,
                      child: Text('Start')),
                  SelectItemButton(
                      value: AxisAlignmentDirectional.end, child: Text('End')),
                ])),
                itemBuilder:
                    (BuildContext context, AxisAlignmentDirectional value) {
                  return Text(value == AxisAlignmentDirectional.start
                      ? 'Start'
                      : 'End');
                },
              )),
          _withLabel(
              label: 'Other Behavior',
              child: Select(
                value: otherBehavior,
                onChanged: (value) {
                  if (value != null) {
                    setState(() {
                      otherBehavior = value;
                    });
                  }
                },
                popup: const SelectPopup.noVirtualization(
                    items: SelectItemList(children: [
                  SelectItemButton(
                      value: TailBehavior.first, child: Text('First')),
                  SelectItemButton(
                      value: TailBehavior.last, child: Text('Last')),
                ])),
                itemBuilder: (BuildContext context, TailBehavior value) {
                  return Text(value == TailBehavior.first ? 'First' : 'Last');
                },
              )),
        ]),
      ],
    );
  }
  Widget _withLabel({required String label, required Widget child}) {
    return IntrinsicWidth(
      child: Column(
        mainAxisSize: MainAxisSize.min,
        crossAxisAlignment: CrossAxisAlignment.stretch,
        children: [
          Text(label),
          gap(8),
          child,
        ],
      ),
    );
  }
}
enum ChatType {
  plain,
  tail,
  sharpCorner,
}
# File: ./lib/pages/docs/components/chat/chat_example_2.dart
import 'package:shadcn_flutter/shadcn_flutter.dart';
class ChatExample2 extends StatefulWidget {
  const ChatExample2({super.key});
  @override
  State<ChatExample2> createState() => _ChatExample2State();
}
class _ChatExample2State extends State<ChatExample2> {
  @override
  Widget build(BuildContext context) {
    return Column(
      spacing: 8,
      children: [
        // ChatGroup example
        ChatGroup(
          color: Colors.blue,
          type:
              ChatBubbleType.tail.copyWith(position: () => AxisDirectional.end),
          alignment: AxisAlignmentDirectional.end,
          children: const [
            ChatBubble(
                child: Text(
                    'John, did you remember what time you took the call with Mrs. Smith?')),
            ChatBubble(child: Text('Reply ASAP')),
          ],
        ),
        ChatGroup(
          color: Colors.gray,
          avatarPrefix: const Avatar(initials: 'JO'),
          alignment: AxisAlignmentDirectional.start,
          type: ChatBubbleType.tail.copyWith(
              position: () => AxisDirectional.start,
              tailAlignment: () => AxisAlignmentDirectional.end),
          children: const [
            ChatBubble(child: Text('Around 6 or 7?')),
            ChatBubble(child: Text('New phone who dis?')),
          ],
        ),
        ChatBubble(
          color: Colors.blue,
          alignment: AxisAlignmentDirectional.end,
          type:
              ChatBubbleType.tail.copyWith(position: () => AxisDirectional.end),
          child: const Text('SIX SEVENNN ü§§ü§™'),
        ),
        ChatGroup(
          color: Colors.gray,
          avatarPrefix: const Avatar(initials: 'JO'),
          alignment: AxisAlignmentDirectional.start,
          type: ChatBubbleType.tail.copyWith(
              position: () => AxisDirectional.start,
              tailAlignment: () => AxisAlignmentDirectional.end),
          children: const [
            ChatBubble(child: Text('?')),
            ChatBubble(child: Text('Seriously who is this')),
            ChatBubble(child: Text('gonna have to block you')),
          ],
        ),
      ],
    );
  }
}
enum ChatType {
  plain,
  tail,
  sharpCorner,
}
# File: ./lib/pages/docs/components/stepper/stepper_example_3.dart
import 'package:docs/pages/docs/components/carousel_example.dart';
import 'package:shadcn_flutter/shadcn_flutter.dart';
class StepperExample3 extends StatefulWidget {
  const StepperExample3({super.key});
  @override
  State<StepperExample3> createState() => _StepperExample3State();
}
class _StepperExample3State extends State<StepperExample3> {
  final StepperController controller = StepperController(
    stepStates: {
      1: StepState.failed,
    },
    currentStep: 1,
  );
  @override
  Widget build(BuildContext context) {
    return Stepper(
      controller: controller,
      direction: Axis.horizontal,
      steps: [
        Step(
          title: const Text('Step 1'),
          contentBuilder: (context) {
            return const StepContainer(
              actions: [
                SecondaryButton(
                  child: Text('Prev'),
                ),
                PrimaryButton(
                  child: Text('Next'),
                ),
              ],
              child: NumberedContainer(
                index: 1,
                height: 200,
              ),
            );
          },
        ),
        Step(
          title: const Text('Step 2'),
          contentBuilder: (context) {
            return const StepContainer(
              actions: [
                SecondaryButton(
                  child: Text('Prev'),
                ),
                PrimaryButton(
                  child: Text('Next'),
                ),
              ],
              child: NumberedContainer(
                index: 2,
                height: 200,
              ),
            );
          },
        ),
        Step(
          title: const Text('Step 3'),
          contentBuilder: (context) {
            return const StepContainer(
              actions: [
                SecondaryButton(
                  child: Text('Prev'),
                ),
                PrimaryButton(
                  child: Text('Finish'),
                ),
              ],
              child: NumberedContainer(
                index: 3,
                height: 200,
              ),
            );
          },
        ),
      ],
    );
  }
}
# File: ./lib/pages/docs/components/stepper/stepper_example_2.dart
import 'package:docs/pages/docs/components/carousel_example.dart';
import 'package:shadcn_flutter/shadcn_flutter.dart';
class StepperExample2 extends StatefulWidget {
  const StepperExample2({super.key});
  @override
  State<StepperExample2> createState() => _StepperExample2State();
}
class _StepperExample2State extends State<StepperExample2> {
  final StepperController controller = StepperController();
  @override
  Widget build(BuildContext context) {
    return Stepper(
      controller: controller,
      // Horizontal layout using the same 3-step flow.
      direction: Axis.horizontal,
      steps: [
        Step(
          title: const Text('Step 1'),
          contentBuilder: (context) {
            return StepContainer(
              actions: [
                const SecondaryButton(
                  child: Text('Prev'),
                ),
                PrimaryButton(
                    child: const Text('Next'),
                    onPressed: () {
                      controller.nextStep();
                    }),
              ],
              child: const NumberedContainer(
                index: 1,
                height: 200,
              ),
            );
          },
        ),
        Step(
          title: const Text('Step 2'),
          contentBuilder: (context) {
            return StepContainer(
              actions: [
                SecondaryButton(
                  child: const Text('Prev'),
                  onPressed: () {
                    controller.previousStep();
                  },
                ),
                PrimaryButton(
                    child: const Text('Next'),
                    onPressed: () {
                      controller.nextStep();
                    }),
              ],
              child: const NumberedContainer(
                index: 2,
                height: 200,
              ),
            );
          },
        ),
        Step(
          title: const Text('Step 3'),
          contentBuilder: (context) {
            return StepContainer(
              actions: [
                SecondaryButton(
                  child: const Text('Prev'),
                  onPressed: () {
                    controller.previousStep();
                  },
                ),
                PrimaryButton(
                    child: const Text('Finish'),
                    onPressed: () {
                      controller.nextStep();
                    }),
              ],
              child: const NumberedContainer(
                index: 3,
                height: 200,
              ),
            );
          },
        ),
      ],
    );
  }
}
# File: ./lib/pages/docs/components/stepper/stepper_example_5.dart
import 'package:docs/pages/docs/components/carousel_example.dart';
import 'package:shadcn_flutter/shadcn_flutter.dart';
class StepperExample5 extends StatefulWidget {
  const StepperExample5({super.key});
  @override
  State<StepperExample5> createState() => _StepperExample5State();
}
class _StepperExample5State extends State<StepperExample5> {
  final StepperController controller = StepperController();
  @override
  Widget build(BuildContext context) {
    return Stepper(
      controller: controller,
      direction: Axis.horizontal,
      steps: [
        Step(
          title: const Text('Step 1'),
          icon: const StepNumber(
            // You can customize the step icon, e.g., use a person icon.
            icon: Icon(Icons.person),
          ),
          contentBuilder: (context) {
            return StepContainer(
              actions: [
                const SecondaryButton(
                  child: Text('Prev'),
                ),
                PrimaryButton(
                    child: const Text('Next'),
                    onPressed: () {
                      controller.nextStep();
                    }),
              ],
              child: const NumberedContainer(
                index: 1,
                height: 200,
              ),
            );
          },
        ),
        Step(
          title: const Text('Step 2'),
          icon: const StepNumber(
            // Another custom icon for the second step.
            icon: Icon(Icons.house_outlined),
          ),
          contentBuilder: (context) {
            return StepContainer(
              actions: [
                SecondaryButton(
                  child: const Text('Prev'),
                  onPressed: () {
                    controller.previousStep();
                  },
                ),
                PrimaryButton(
                    child: const Text('Next'),
                    onPressed: () {
                      controller.nextStep();
                    }),
              ],
              child: const NumberedContainer(
                index: 2,
                height: 200,
              ),
            );
          },
        ),
        Step(
          title: const Text('Step 3'),
          icon: const StepNumber(
            // And a briefcase icon for the third.
            icon: Icon(Icons.work_outline),
          ),
          contentBuilder: (context) {
            return StepContainer(
              actions: [
                SecondaryButton(
                  child: const Text('Prev'),
                  onPressed: () {
                    controller.previousStep();
                  },
                ),
                PrimaryButton(
                    child: const Text('Finish'),
                    onPressed: () {
                      controller.nextStep();
                    }),
              ],
              child: const NumberedContainer(
                index: 3,
                height: 200,
              ),
            );
          },
        ),
      ],
    );
  }
}
# File: ./lib/pages/docs/components/stepper/stepper_example_1.dart
import 'package:docs/pages/docs/components/carousel_example.dart';
import 'package:shadcn_flutter/shadcn_flutter.dart';
class StepperExample1 extends StatefulWidget {
  const StepperExample1({super.key});
  @override
  State<StepperExample1> createState() => _StepperExample1State();
}
class _StepperExample1State extends State<StepperExample1> {
  final StepperController controller = StepperController();
  @override
  Widget build(BuildContext context) {
    return Stepper(
      controller: controller,
      // Vertical layout with 3 steps and Next/Prev actions.
      direction: Axis.vertical,
      steps: [
        Step(
          title: const Text('Step 1'),
          contentBuilder: (context) {
            return StepContainer(
              actions: [
                const SecondaryButton(
                  child: Text('Prev'),
                ),
                PrimaryButton(
                    child: const Text('Next'),
                    onPressed: () {
                      // Advance to the next step.
                      controller.nextStep();
                    }),
              ],
              child: const NumberedContainer(
                index: 1,
                height: 200,
              ),
            );
          },
        ),
        Step(
          title: const Text('Step 2'),
          contentBuilder: (context) {
            return StepContainer(
              actions: [
                SecondaryButton(
                  child: const Text('Prev'),
                  onPressed: () {
                    // Move back one step.
                    controller.previousStep();
                  },
                ),
                PrimaryButton(
                    child: const Text('Next'),
                    onPressed: () {
                      controller.nextStep();
                    }),
              ],
              child: const NumberedContainer(
                index: 2,
                height: 200,
              ),
            );
          },
        ),
        Step(
          title: const Text('Step 3'),
          contentBuilder: (context) {
            return StepContainer(
              actions: [
                SecondaryButton(
                  child: const Text('Prev'),
                  onPressed: () {
                    controller.previousStep();
                  },
                ),
                PrimaryButton(
                    child: const Text('Finish'),
                    onPressed: () {
                      controller.nextStep();
                    }),
              ],
              child: const NumberedContainer(
                index: 3,
                height: 200,
              ),
            );
          },
        ),
      ],
    );
  }
}
# File: ./lib/pages/docs/components/stepper/stepper_example_6.dart
import 'package:docs/pages/docs/components/carousel_example.dart';
import 'package:shadcn_flutter/shadcn_flutter.dart';
class StepperExample6 extends StatefulWidget {
  const StepperExample6({super.key});
  @override
  State<StepperExample6> createState() => _StepperExample6State();
}
class _StepperExample6State extends State<StepperExample6> {
  static const List<StepVariant> _variants = [
    StepVariant.circle,
    StepVariant.circleAlt,
    StepVariant.line,
  ];
  static const List<String> _variantNames = [
    'Circle',
    'Circle Alt',
    'Line',
  ];
  static const List<StepSize> _stepSize = StepSize.values;
  static const List<String> _stepSizeNames = [
    'Small',
    'Medium',
    'Large',
  ];
  final StepperController controller = StepperController();
  int _currentVariant = 0;
  int _currentStepSize = 0;
  Axis direction = Axis.horizontal;
  @override
  Widget build(BuildContext context) {
    return Column(
      children: [
        Wrap(
          spacing: 8,
          runSpacing: 8,
          alignment: WrapAlignment.center,
          crossAxisAlignment: WrapCrossAlignment.center,
          runAlignment: WrapAlignment.center,
          children: [
            Toggle(
              value: direction == Axis.horizontal,
              onChanged: (value) {
                if (value) {
                  setState(() {
                    direction = Axis.horizontal;
                  });
                } else {
                  setState(() {
                    direction = Axis.vertical;
                  });
                }
              },
              child: const Text('Horizontal'),
            ),
            Toggle(
              value: direction == Axis.vertical,
              onChanged: (value) {
                if (value) {
                  setState(() {
                    direction = Axis.vertical;
                  });
                } else {
                  setState(() {
                    direction = Axis.horizontal;
                  });
                }
              },
              child: const Text('Vertical'),
            ),
            const VerticalDivider().sized(height: 16),
            for (var i = 0; i < _variants.length; i++)
              Toggle(
                value: _currentVariant == i,
                onChanged: (value) {
                  setState(() {
                    // Choose among visual variants (circle, alt circle, line).
                    _currentVariant = i;
                  });
                },
                child: Text(_variantNames[i]),
              ),
            const VerticalDivider().sized(height: 16),
            for (var i = 0; i < _stepSize.length; i++)
              Toggle(
                value: _currentStepSize == i,
                onChanged: (value) {
                  setState(() {
                    // Pick the step size used by the Stepper.
                    _currentStepSize = i;
                  });
                },
                child: Text(_stepSizeNames[i]),
              ),
            const VerticalDivider().sized(height: 16),
            AnimatedBuilder(
              animation: controller,
              builder: (context, child) {
                return Toggle(
                  value: controller.value.stepStates[1] == StepState.failed,
                  onChanged: (value) {
                    if (value) {
                      // Mark step 2 as failed to demo error state.
                      controller.setStatus(1, StepState.failed);
                    } else {
                      controller.setStatus(1, null);
                    }
                  },
                  child: const Text('Toggle Error'),
                );
              },
            ),
          ],
        ),
        const Gap(16),
        Stepper(
          controller: controller,
          direction: direction,
          // Apply the chosen size and visual variant.
          size: _stepSize[_currentStepSize],
          variant: _variants[_currentVariant],
          steps: [
            Step(
              title: const Text('Step 1'),
              contentBuilder: (context) {
                return StepContainer(
                  actions: [
                    const SecondaryButton(
                      child: Text('Prev'),
                    ),
                    PrimaryButton(
                        child: const Text('Next'),
                        onPressed: () {
                          controller.nextStep();
                        }),
                  ],
                  child: const NumberedContainer(
                    index: 1,
                    height: 200,
                  ),
                );
              },
            ),
            Step(
              title: const StepTitle(
                title: Text('Step 2'),
                subtitle: Text('Optional Step'),
              ),
              contentBuilder: (context) {
                return StepContainer(
                  actions: [
                    SecondaryButton(
                      child: const Text('Prev'),
                      onPressed: () {
                        controller.previousStep();
                      },
                    ),
                    PrimaryButton(
                        child: const Text('Next'),
                        onPressed: () {
                          controller.nextStep();
                        }),
                  ],
                  child: const NumberedContainer(
                    index: 2,
                    height: 200,
                  ),
                );
              },
            ),
            Step(
              title: const Text('Step 3'),
              contentBuilder: (context) {
                return StepContainer(
                  actions: [
                    SecondaryButton(
                      child: const Text('Prev'),
                      onPressed: () {
                        controller.previousStep();
                      },
                    ),
                    PrimaryButton(
                        child: const Text('Finish'),
                        onPressed: () {
                          controller.nextStep();
                        }),
                  ],
                  child: const NumberedContainer(
                    index: 3,
                    height: 200,
                  ),
                );
              },
            ),
          ],
        ),
      ],
    );
  }
}
# File: ./lib/pages/docs/components/stepper/stepper_example_4.dart
import 'package:docs/pages/docs/components/carousel_example.dart';
import 'package:shadcn_flutter/shadcn_flutter.dart';
class StepperExample4 extends StatefulWidget {
  const StepperExample4({super.key});
  @override
  State<StepperExample4> createState() => _StepperExample4State();
}
class _StepperExample4State extends State<StepperExample4> {
  final StepperController controller = StepperController();
  @override
  Widget build(BuildContext context) {
    return Stepper(
      controller: controller,
      direction: Axis.vertical,
      steps: [
        Step(
          title: const Text('Step 1'),
          icon: StepNumber(
            onPressed: () {
              // Tap on the step icon to jump directly to the step.
              controller.jumpToStep(0);
            },
          ),
          contentBuilder: (context) {
            return StepContainer(
              actions: [
                const SecondaryButton(
                  child: Text('Prev'),
                ),
                PrimaryButton(
                    child: const Text('Next'),
                    onPressed: () {
                      controller.nextStep();
                    }),
              ],
              child: const NumberedContainer(
                index: 1,
                height: 200,
              ),
            );
          },
        ),
        Step(
          title: const Text('Step 2'),
          icon: StepNumber(
            onPressed: () {
              controller.jumpToStep(1);
            },
          ),
          contentBuilder: (context) {
            return StepContainer(
              actions: [
                SecondaryButton(
                  child: const Text('Prev'),
                  onPressed: () {
                    controller.previousStep();
                  },
                ),
                PrimaryButton(
                    child: const Text('Next'),
                    onPressed: () {
                      controller.nextStep();
                    }),
              ],
              child: const NumberedContainer(
                index: 2,
                height: 200,
              ),
            );
          },
        ),
        Step(
          title: const Text('Step 3'),
          icon: StepNumber(
            onPressed: () {
              controller.jumpToStep(2);
            },
          ),
          contentBuilder: (context) {
            return StepContainer(
              actions: [
                SecondaryButton(
                  child: const Text('Prev'),
                  onPressed: () {
                    controller.previousStep();
                  },
                ),
                PrimaryButton(
                    child: const Text('Finish'),
                    onPressed: () {
                      controller.nextStep();
                    }),
              ],
              child: const NumberedContainer(
                index: 3,
                height: 200,
              ),
            );
          },
        ),
      ],
    );
  }
}
# File: ./lib/pages/docs/components/keyboard_display/keyboard_display_example_1.dart
import 'package:flutter/services.dart';
import 'package:shadcn_flutter/shadcn_flutter.dart';
class KeyboardDisplayExample1 extends StatelessWidget {
  const KeyboardDisplayExample1({super.key});
  @override
  Widget build(BuildContext context) {
    // KeyboardDisplay renders keycaps/shortcuts inline.
    // Below we show two variants: explicit key list and a SingleActivator.
    return const Column(
      children: [
        KeyboardDisplay(keys: [
          LogicalKeyboardKey.control,
          LogicalKeyboardKey.alt,
          LogicalKeyboardKey.delete,
        ]),
        Gap(24),
        KeyboardDisplay.fromActivator(
          activator: SingleActivator(
            LogicalKeyboardKey.keyA,
            control: true,
            shift: true,
          ),
        )
      ],
    ).textSmall();
  }
}
# File: ./lib/pages/docs/components/chip/chip_example_1.dart
import 'package:shadcn_flutter/shadcn_flutter.dart';
/// Chips with trailing remove buttons in different styles.
///
/// Demonstrates how to compose [Chip] with a [ChipButton] trailing action,
/// and how to apply various [ButtonStyle] presets.
class ChipExample1 extends StatelessWidget {
  const ChipExample1({super.key});
  @override
  Widget build(BuildContext context) {
    return Wrap(
      spacing: 8,
      runSpacing: 8,
      children: [
        Chip(
          // Trailing action; in real apps you might remove the chip.
          trailing: ChipButton(
            onPressed: () {},
            child: const Icon(Icons.close),
          ),
          child: const Text('Apple'),
        ),
        Chip(
          // Primary-styled chip.
          style: const ButtonStyle.primary(),
          trailing: ChipButton(
            onPressed: () {},
            child: const Icon(Icons.close),
          ),
          child: const Text('Banana'),
        ),
        Chip(
          // Outlined chip.
          style: const ButtonStyle.outline(),
          trailing: ChipButton(
            onPressed: () {},
            child: const Icon(Icons.close),
          ),
          child: const Text('Cherry'),
        ),
        Chip(
          // Ghost chip (very subtle background).
          style: const ButtonStyle.ghost(),
          trailing: ChipButton(
            onPressed: () {},
            child: const Icon(Icons.close),
          ),
          child: const Text('Durian'),
        ),
        Chip(
          // Destructive-styled chip for warning/critical labels.
          style: const ButtonStyle.destructive(),
          trailing: ChipButton(
            onPressed: () {},
            child: const Icon(Icons.close),
          ),
          child: const Text('Elderberry'),
        ),
      ],
    );
  }
}
# File: ./lib/pages/docs/components/file_picker/file_picker_example_1.dart
import 'package:shadcn_flutter/shadcn_flutter.dart';
class FilePickerExample1 extends StatefulWidget {
  const FilePickerExample1({super.key});
  @override
  State<FilePickerExample1> createState() => _FilePickerExample1State();
}
class _FilePickerExample1State extends State<FilePickerExample1> {
  // final List<XFile> _files = [];
  @override
  Widget build(BuildContext context) {
    // Placeholder for a file picker demo. The `_files` list would store the
    // selected files after invoking a picker (e.g., pickFiles()). Left empty
    // intentionally in this example to show the scaffold for state.
    return Container();
  }
}
# File: ./lib/pages/docs/components/sheet/sheet_example_1.dart
import 'package:shadcn_flutter/shadcn_flutter.dart';
class SheetExample1 extends StatefulWidget {
  const SheetExample1({super.key});
  @override
  State<SheetExample1> createState() => _SheetExample1State();
}
class _SheetExample1State extends State<SheetExample1> {
  // A form controller to read values and validation state inside the sheet.
  final FormController controller = FormController();
  void saveProfile() {
    showDialog(
      context: context,
      builder: (context) {
        return AlertDialog(
          title: const Text('Profile updated'),
          // For demo, show raw form values.
          content: Text('Content: ${controller.values}'),
          actions: [
            PrimaryButton(
              onPressed: () {
                Navigator.pop(context);
              },
              child: const Text('Close'),
            ),
          ],
        );
      },
    );
  }
  Widget buildSheet(BuildContext context) {
    return Container(
      padding: const EdgeInsets.all(24),
      constraints: const BoxConstraints(maxWidth: 400),
      child: Form(
        controller: controller,
        child: Column(
          mainAxisSize: MainAxisSize.min,
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            Row(
              mainAxisSize: MainAxisSize.min,
              children: [
                Expanded(
                  child: const Text('Edit profile').large().medium(),
                ),
                TextButton(
                  density: ButtonDensity.icon,
                  child: const Icon(Icons.close),
                  onPressed: () {
                    // Close the sheet without saving.
                    closeSheet(context);
                  },
                ),
              ],
            ),
            const Gap(8),
            const Text(
                    'Make changes to your profile here. Click save when you\'re done.')
                .muted(),
            const Gap(16),
            FormTableLayout(
              rows: [
                FormField<String>(
                  key: const FormKey(#name),
                  label: const Text('Name'),
                  validator:
                      const NotEmptyValidator() & const LengthValidator(min: 4),
                  child: const TextField(
                    initialValue: 'Thito Yalasatria Sunarya',
                    placeholder: Text('Your fullname'),
                  ),
                ),
                FormField<String>(
                  key: const FormKey(#username),
                  label: const Text('Username'),
                  validator:
                      const NotEmptyValidator() & const LengthValidator(min: 4),
                  child: const TextField(
                    initialValue: '@sunarya-thito',
                    placeholder: Text('Your username'),
                  ),
                ),
              ],
            ),
            const Gap(16),
            Align(
              alignment: AlignmentDirectional.centerEnd,
              child: FormErrorBuilder(
                builder: (context, errors, child) {
                  return PrimaryButton(
                    // Disable save while there are validation errors.
                    onPressed: errors.isNotEmpty
                        ? null
                        : () {
                            // Attempt to submit the form; close the sheet when successful
                            // and show a confirmation dialog.
                            context.submitForm().then(
                              (value) {
                                if (value.errors.isEmpty) {
                                  closeSheet(context).then(
                                    (value) {
                                      saveProfile();
                                    },
                                  );
                                }
                              },
                            );
                          },
                    child: const Text('Save changes'),
                  );
                },
              ),
            ),
          ],
        ),
      ),
    );
  }
  @override
  Widget build(BuildContext context) {
    return PrimaryButton(
      onPressed: () {
        openSheet(
          context: context,
          builder: (context) {
            // Build the sheet content; keep it small and focused on the form.
            return buildSheet(context);
          },
          // Slide in from the end (right on LTR).
          position: OverlayPosition.end,
        );
      },
      child: const Text('Open Sheet'),
    );
  }
}
# File: ./lib/pages/docs/components/divider/divider_example_4.dart
import 'package:shadcn_flutter/shadcn_flutter.dart';
class DividerExample4 extends StatelessWidget {
  const DividerExample4({super.key});
  @override
  Widget build(BuildContext context) {
    return OutlinedContainer(
      width: 600,
      height: 400,
      child: Row(
        crossAxisAlignment: CrossAxisAlignment.stretch,
        children: [
          Container(
            color: Theme.of(context).colorScheme.border.withAlpha(64),
            width: 100,
            child: ListView.builder(
              itemCount: 50,
              itemBuilder: (context, index) {
                return Button.ghost(
                  onPressed: () {},
                  child: Text('Button $index'),
                );
              },
            ),
          ),
          PaintOrder(
            paintOrder: 3,
            child: VerticalDivider(
              childAlignment: const AxisAlignment(-0.6),
              padding: EdgeInsets.zero,
              child: IconButton.outline(
                icon: const Icon(Icons.arrow_back_ios_new),
                shape: ButtonShape.circle,
                size: ButtonSize.small,
                onPressed: () {},
              ),
            ),
          ),
          Expanded(
            child: Container(
              color: Colors.black,
            ),
          ),
        ],
      ),
    );
  }
}
# File: ./lib/pages/docs/components/divider/divider_example_2.dart
import 'package:shadcn_flutter/shadcn_flutter.dart';
/// Vertical dividers between columns.
///
/// Use [VerticalDivider] to separate horizontally-arranged content.
class DividerExample2 extends StatelessWidget {
  const DividerExample2({super.key});
  @override
  Widget build(BuildContext context) {
    return const SizedBox(
      width: 300,
      height: 100,
      child: Row(
        crossAxisAlignment: CrossAxisAlignment.stretch,
        children: [
          Expanded(child: Text('Item 1')),
          VerticalDivider(),
          Expanded(child: Text('Item 2')),
          VerticalDivider(),
          Expanded(child: Text('Item 3')),
        ],
      ),
    );
  }
}
# File: ./lib/pages/docs/components/divider/divider_example_3.dart
import 'package:shadcn_flutter/shadcn_flutter.dart';
/// Dividers with centered labels.
///
/// [Divider.child] can render text or other widgets inline with the rule.
class DividerExample3 extends StatelessWidget {
  const DividerExample3({super.key});
  @override
  Widget build(BuildContext context) {
    return const SizedBox(
      width: 300,
      child: Column(
        crossAxisAlignment: CrossAxisAlignment.stretch,
        children: [
          Text('Item 1'),
          Divider(
            child: Text('Divider'),
          ),
          Text('Item 2'),
          Divider(
            child: Text('Divider'),
          ),
          Text('Item 3'),
        ],
      ),
    );
  }
}
# File: ./lib/pages/docs/components/divider/divider_example_1.dart
import 'package:shadcn_flutter/shadcn_flutter.dart';
/// Horizontal dividers between list items.
///
/// Use [Divider] to visually separate vertically-stacked content.
class DividerExample1 extends StatelessWidget {
  const DividerExample1({super.key});
  @override
  Widget build(BuildContext context) {
    return const SizedBox(
      width: 300,
      child: Column(
        crossAxisAlignment: CrossAxisAlignment.stretch,
        children: [
          Text('Item 1'),
          Divider(),
          Text('Item 2'),
          Divider(),
          Text('Item 3'),
        ],
      ),
    );
  }
}
# File: ./lib/pages/docs/components/steps/steps_example_1.dart
import 'package:shadcn_flutter/shadcn_flutter.dart';
class StepsExample1 extends StatelessWidget {
  const StepsExample1({super.key});
  @override
  Widget build(BuildContext context) {
    return const Steps(
      // Static steps list with titles and supporting content lines.
      children: [
        StepItem(
          title: Text('Create a project'),
          content: [
            Text('Create a new project in the project manager.'),
            Text('Add the required files to the project.'),
          ],
        ),
        StepItem(
          title: Text('Add dependencies'),
          content: [
            Text('Add the required dependencies to the project.'),
          ],
        ),
        StepItem(
          title: Text('Run the project'),
          content: [
            Text('Run the project in the project manager.'),
          ],
        ),
      ],
    );
  }
}
# File: ./lib/pages/docs/components/chip_input/chip_input_example_1.dart
import 'package:shadcn_flutter/shadcn_flutter.dart';
/// ChipInput with inline autocomplete suggestions.
///
/// Shows how to:
/// - Listen to a [ChipEditingController] to compute suggestions based on
///   the current token being typed (using [textAtCursor]).
/// - Wrap [ChipInput] with [AutoComplete] to display suggestions.
/// - Transform submitted chips (here we prepend '@').
class ChipInputExample1 extends StatefulWidget {
  const ChipInputExample1({super.key});
  @override
  State<ChipInputExample1> createState() => _ChipInputExample1State();
}
class _ChipInputExample1State extends State<ChipInputExample1> {
  // Current filtered suggestions for the token at the cursor.
  List<String> _suggestions = [];
  // Controller manages both chips and text entry.
  final ChipEditingController<String> _controller = ChipEditingController();
  // Static suggestion pool to match against.
  static const List<String> _availableSuggestions = [
    'hello world',
    'lorem ipsum',
    'do re mi',
    'foo bar',
    'flutter dart',
  ];
  @override
  void initState() {
    super.initState();
    _controller.addListener(
      () {
        setState(() {
          // IMPORTANT: use textAtCursor instead of text so we only consider
          // the current token under the caret when filtering suggestions.
          var value = _controller.textAtCursor;
          if (value.isNotEmpty) {
            _suggestions = _availableSuggestions.where((element) {
              return element.startsWith(value);
            }).toList();
          } else {
            _suggestions = [];
          }
        });
      },
    );
  }
  @override
  Widget build(BuildContext context) {
    return Column(
      mainAxisSize: MainAxisSize.min,
      children: [
        AutoComplete(
          // Provide suggestions to show below the input as the user types.
          suggestions: _suggestions,
          child: ChipInput<String>(
            controller: _controller,
            onChipSubmitted: (value) {
              setState(() {
                _suggestions = [];
              });
              // Transform the chip value before storing it.
              return '@$value';
            },
            chipBuilder: (context, chip) {
              return Text(chip);
            },
          ),
        ),
        gap(24),
        ListenableBuilder(
          listenable: _controller,
          builder: (context, child) {
            // Reflect the current chip list for demonstration.
            return Text('Current chips: ${_controller.chips.join(', ')}');
          },
        ),
      ],
    );
  }
}
# File: ./lib/pages/docs/components/context_menu/context_menu_example_1.dart
import 'package:flutter/services.dart';
import 'package:shadcn_flutter/shadcn_flutter.dart';
/// Context menu with shortcuts, submenu, checkboxes, and radio group.
///
/// Right-click (or long-press) the dashed area to open the menu. This
/// demonstrates:
/// - [MenuButton] items with keyboard [MenuShortcut]s.
/// - Nested submenu via [MenuButton.subMenu].
/// - [MenuCheckbox] with `autoClose: false` to keep menu open while toggling.
/// - [MenuRadioGroup] for mutually exclusive choices.
class ContextMenuExample1 extends StatefulWidget {
  const ContextMenuExample1({super.key});
  @override
  State<ContextMenuExample1> createState() => _ContextMenuExample1State();
}
class _ContextMenuExample1State extends State<ContextMenuExample1> {
  int people = 0;
  bool showBookmarksBar = false;
  bool showFullUrls = true;
  @override
  Widget build(BuildContext context) {
    final theme = Theme.of(context);
    return ContextMenu(
        items: [
          // Simple command with Ctrl+[ shortcut.
          const MenuButton(
            trailing: MenuShortcut(
              activator: SingleActivator(
                LogicalKeyboardKey.bracketLeft,
                control: true,
              ),
            ),
            child: Text('Back'),
          ),
          // Disabled command example with Ctrl+] shortcut.
          const MenuButton(
            trailing: MenuShortcut(
              activator: SingleActivator(
                LogicalKeyboardKey.bracketRight,
                control: true,
              ),
            ),
            enabled: false,
            child: Text('Forward'),
          ),
          // Enabled command with Ctrl+R shortcut.
          const MenuButton(
            trailing: MenuShortcut(
              activator: SingleActivator(
                LogicalKeyboardKey.keyR,
                control: true,
              ),
            ),
            child: Text('Reload'),
          ),
          // Submenu with additional tools and a divider.
          const MenuButton(
            subMenu: [
              MenuButton(
                trailing: MenuShortcut(
                  activator: SingleActivator(
                    LogicalKeyboardKey.keyS,
                    control: true,
                  ),
                ),
                child: Text('Save Page As...'),
              ),
              MenuButton(
                child: Text('Create Shortcut...'),
              ),
              MenuButton(
                child: Text('Name Window...'),
              ),
              MenuDivider(),
              MenuButton(
                child: Text('Developer Tools'),
              ),
            ],
            child: Text('More Tools'),
          ),
          const MenuDivider(),
          // Checkbox item; keep menu open while toggling for quick changes.
          MenuCheckbox(
            value: showBookmarksBar,
            onChanged: (context, value) {
              setState(() {
                showBookmarksBar = value;
              });
            },
            autoClose: false,
            trailing: const MenuShortcut(
              activator: SingleActivator(
                LogicalKeyboardKey.keyB,
                control: true,
                shift: true,
              ),
            ),
            child: const Text('Show Bookmarks Bar'),
          ),
          MenuCheckbox(
            value: showFullUrls,
            onChanged: (context, value) {
              setState(() {
                showFullUrls = value;
              });
            },
            autoClose: false,
            child: const Text('Show Full URLs'),
          ),
          const MenuDivider(),
          const MenuLabel(child: Text('People')),
          const MenuDivider(),
          // Radio group; only one person can be selected at a time.
          MenuRadioGroup(
            value: people,
            onChanged: (context, value) {
              setState(() {
                people = value;
              });
            },
            children: const [
              MenuRadio(
                value: 0,
                autoClose: false,
                child: Text('Pedro Duarte'),
              ),
              MenuRadio(
                value: 1,
                autoClose: false,
                child: Text('Colm Tuite'),
              ),
            ],
          ),
        ],
        child: DashedContainer(
          // Right-click target with a dashed border and rounded corners.
          borderRadius: BorderRadius.circular(theme.radiusMd),
          strokeWidth: 2,
          gap: 2,
          child: const Text('Right click here').center(),
        ).constrained(
          maxWidth: 300,
          maxHeight: 200,
        ));
  }
}
# File: ./lib/pages/docs/components/tooltip/tooltip_example_1.dart
import 'package:shadcn_flutter/shadcn_flutter.dart';
// Demonstrates a Tooltip wrapping a button; shows tooltip content on
// hover/focus.
class TooltipExample1 extends StatelessWidget {
  const TooltipExample1({super.key});
  @override
  Widget build(BuildContext context) {
    return Tooltip(
      // Tooltip wraps a target widget and shows TooltipContainer on hover/focus.
      tooltip: const TooltipContainer(
        child: Text('This is a tooltip.'),
      ),
      child: PrimaryButton(
        onPressed: () {},
        child: const Text('Hover over me'),
      ),
    );
  }
}
# File: ./lib/pages/docs/components/menubar/menubar_example_1.dart
import 'package:flutter/services.dart';
import 'package:shadcn_flutter/shadcn_flutter.dart';
class MenubarExample1 extends StatefulWidget {
  const MenubarExample1({super.key});
  @override
  State<MenubarExample1> createState() => _MenubarExample1State();
}
class _MenubarExample1State extends State<MenubarExample1> {
  bool _showBookmarksBar = false;
  bool _showFullURLs = true;
  int _selectedProfile = 1;
  @override
  Widget build(BuildContext context) {
    // Typical desktop-style menubar with nested submenus, shortcuts,
    // checkboxes (non-closing), and a radio group.
    return Menubar(
      children: [
        const MenuButton(
          subMenu: [
            MenuButton(
              leading: Icon(RadixIcons.filePlus),
              trailing: MenuShortcut(
                activator: SingleActivator(
                  LogicalKeyboardKey.keyT,
                  control: true,
                ),
              ),
              child: Text('New Tab'),
            ),
            MenuButton(
              trailing: MenuShortcut(
                activator: SingleActivator(
                  LogicalKeyboardKey.keyN,
                  control: true,
                ),
              ),
              child: Text('New Window'),
            ),
            MenuButton(
              enabled: false,
              child: Text('New Incognito Window'),
            ),
            MenuDivider(),
            MenuButton(
              subMenu: [
                MenuButton(
                  child: Text('Email Link'),
                ),
                MenuButton(
                  child: Text('Messages'),
                ),
                MenuButton(
                  child: Text('Notes'),
                ),
              ],
              child: Text('Share'),
            ),
            MenuButton(
              trailing: MenuShortcut(
                activator: SingleActivator(
                  LogicalKeyboardKey.keyP,
                  control: true,
                ),
              ),
              child: Text('Print'),
            ),
            MenuButton(
              subMenu: [
                MenuButton(
                  child: Text('Save and Exit'),
                ),
                MenuButton(
                  child: Text('Discard and Exit'),
                ),
              ],
              child: Text('Exit'),
            ),
          ],
          child: Text('File'),
        ),
        const MenuButton(
          subMenu: [
            MenuButton(
              trailing: MenuShortcut(
                activator: SingleActivator(
                  LogicalKeyboardKey.keyZ,
                  control: true,
                ),
              ),
              child: Text('Undo'),
            ),
            MenuButton(
              trailing: MenuShortcut(
                activator: SingleActivator(
                  LogicalKeyboardKey.keyZ,
                  control: true,
                  shift: true,
                ),
              ),
              child: Text('Redo'),
            ),
            MenuDivider(),
            MenuButton(
              subMenu: [
                MenuButton(
                  child: Text('Search the Web'),
                ),
                MenuDivider(),
                MenuButton(
                  child: Text('Find...'),
                ),
                MenuButton(
                  child: Text('Find Next'),
                ),
                MenuButton(
                  child: Text('Find Previous'),
                ),
              ],
              child: Text('Find'),
            ),
            MenuDivider(),
            MenuButton(
              child: Text('Cut'),
            ),
            MenuButton(
              child: Text('Copy'),
            ),
            MenuButton(
              child: Text('Paste'),
            ),
          ],
          child: Text('Edit'),
        ),
        MenuButton(
          subMenu: [
            MenuCheckbox(
              value: _showBookmarksBar,
              onChanged: (context, value) {
                setState(() {
                  _showBookmarksBar = value;
                });
              },
              // Keep the submenu open while toggling for quicker multi-actions.
              autoClose: false,
              child: const Text('Always Show Bookmarks Bar'),
            ),
            MenuCheckbox(
              value: _showFullURLs,
              onChanged: (context, value) {
                setState(() {
                  _showFullURLs = value;
                });
              },
              // Also keep open here to demonstrate autoClose control.
              autoClose: false,
              child: const Text('Always Show Full URLs'),
            ),
            const MenuDivider(),
            const MenuButton(
              trailing: MenuShortcut(
                activator: SingleActivator(
                  LogicalKeyboardKey.keyR,
                  control: true,
                ),
              ),
              child: Text('Reload'),
            ),
            const MenuButton(
              enabled: false,
              trailing: MenuShortcut(
                activator: SingleActivator(
                  LogicalKeyboardKey.keyR,
                  control: true,
                  shift: true,
                ),
              ),
              child: Text('Force Reload'),
            ),
            const MenuDivider(),
            const MenuButton(
              child: Text('Toggle Full Screen'),
            ),
            const MenuDivider(),
            const MenuButton(
              child: Text('Hide Sidebar'),
            ),
          ],
          child: const Text('View'),
        ),
        MenuButton(
          subMenu: [
            MenuRadioGroup<int>(
              value: _selectedProfile,
              onChanged: (context, value) {
                setState(() {
                  _selectedProfile = value;
                });
              },
              children: const [
                MenuRadio<int>(
                  value: 0,
                  // Disable auto-close to let users quickly toggle multiple options.
                  autoClose: false,
                  child: Text('Andy'),
                ),
                MenuRadio<int>(
                  value: 1,
                  autoClose: false,
                  child: Text('Benoit'),
                ),
                MenuRadio<int>(
                  value: 2,
                  autoClose: false,
                  child: Text('Luis'),
                ),
              ],
            ),
            const MenuDivider(),
            const MenuButton(
              child: Text('Edit...'),
            ),
            const MenuDivider(),
            const MenuButton(
              child: Text('Add Profile...'),
            ),
          ],
          child: const Text('Profiles'),
        ),
      ],
    );
  }
}
# File: ./lib/pages/docs/components/item_picker/item_picker_example_1.dart
import 'package:shadcn_flutter/shadcn_flutter.dart';
class ItemPickerExample1 extends StatelessWidget {
  const ItemPickerExample1({super.key});
  @override
  Widget build(BuildContext context) {
    return PrimaryButton(
      onPressed: () {
        // Show a popover item picker (non-dialog) with a virtual list of 1000 items.
        showItemPicker<int>(
          context,
          title: const Text('Pick an item'),
          items: ItemBuilder(
            itemCount: 1000,
            itemBuilder: (index) {
              return index;
            },
          ),
          builder: (context, item) {
            return ItemPickerOption(
                value: item, child: Text(item.toString()).large);
          },
        ).then(
          (value) {
            if (value != null && context.mounted) {
              // Feedback via toast when a selection is made.
              showToast(
                context: context,
                builder: (context, overlay) {
                  return SurfaceCard(
                    child: Text('You picked $value!'),
                  );
                },
              );
            } else if (context.mounted) {
              showToast(
                context: context,
                builder: (context, overlay) {
                  return const SurfaceCard(
                    child: Text('You picked nothing!'),
                  );
                },
              );
            }
          },
        );
      },
      child: const Text('Show Item Picker'),
    );
  }
}
# File: ./lib/pages/docs/components/item_picker/item_picker_example_4.dart
import 'package:shadcn_flutter/shadcn_flutter.dart';
class NamedColor {
  final String name;
  final Color color;
  const NamedColor(this.name, this.color);
}
class ItemPickerExample4 extends StatefulWidget {
  const ItemPickerExample4({super.key});
  @override
  State<ItemPickerExample4> createState() => _ItemPickerExample4State();
}
class _ItemPickerExample4State extends State<ItemPickerExample4> {
  final List<NamedColor> colors = const [
    NamedColor('Red', Colors.red),
    NamedColor('Green', Colors.green),
    NamedColor('Blue', Colors.blue),
    NamedColor('Yellow', Colors.yellow),
    NamedColor('Purple', Colors.purple),
    NamedColor('Cyan', Colors.cyan),
    NamedColor('Orange', Colors.orange),
    NamedColor('Pink', Colors.pink),
    NamedColor('Teal', Colors.teal),
    NamedColor('Amber', Colors.amber),
  ];
  int selectedColor = 0;
  @override
  Widget build(BuildContext context) {
    return PrimaryButton(
      onPressed: () {
        showItemPickerDialog<NamedColor>(
          context,
          items: ItemList(colors),
          initialValue: colors[selectedColor],
          // Force a list layout instead of a grid for narrower rows.
          layout: ItemPickerLayout.list,
          title: const Text('Pick a color'),
          builder: (context, item) {
            return ItemPickerOption(
                value: item,
                label: Text(item.name),
                child: Container(
                  width: 40,
                  height: 40,
                  decoration: BoxDecoration(
                    color: item.color,
                    shape: BoxShape.circle,
                  ),
                ));
          },
        ).then(
          (value) {
            if (value != null) {
              selectedColor = colors.indexOf(value);
              if (context.mounted) {
                showToast(
                  context: context,
                  builder: (context, overlay) {
                    return SurfaceCard(
                      child: Text('You picked ${value.name}!'),
                    );
                  },
                );
              }
            } else if (context.mounted) {
              showToast(
                context: context,
                builder: (context, overlay) {
                  return const SurfaceCard(
                    child: Text('You picked nothing!'),
                  );
                },
              );
            }
          },
        );
      },
      child: const Text('Show Item Picker'),
    );
  }
}
# File: ./lib/pages/docs/components/item_picker/item_picker_example_5.dart
import 'package:flutter/foundation.dart';
import 'package:shadcn_flutter/shadcn_flutter.dart';
class NamedColor {
  final String name;
  final Color color;
  const NamedColor(this.name, this.color);
}
class ItemPickerExample5 extends StatefulWidget {
  const ItemPickerExample5({super.key});
  @override
  State<ItemPickerExample5> createState() => _ItemPickerExample5State();
}
class _ItemPickerExample5State extends State<ItemPickerExample5> {
  final List<NamedColor> colors = const [
    NamedColor('Red', Colors.red),
    NamedColor('Green', Colors.green),
    NamedColor('Blue', Colors.blue),
    NamedColor('Yellow', Colors.yellow),
    NamedColor('Purple', Colors.purple),
    NamedColor('Cyan', Colors.cyan),
    NamedColor('Orange', Colors.orange),
    NamedColor('Pink', Colors.pink),
    NamedColor('Teal', Colors.teal),
    NamedColor('Amber', Colors.amber),
  ];
  int selectedColor = 0;
  @override
  Widget build(BuildContext context) {
    return ItemPicker<NamedColor>(
      items: ItemList(colors),
      mode: PromptMode.popover,
      title: const Text('Pick a color'),
      builder: (context, item) {
        return ItemPickerOption(
          value: item,
          label: Text(item.name),
          style: const ButtonStyle.ghostIcon(
            shape: ButtonShape.circle,
          ),
          selectedStyle: const ButtonStyle.primary(
            shape: ButtonShape.circle,
          ),
          child: Container(
            constraints: const BoxConstraints(minWidth: 40, minHeight: 40),
            decoration: BoxDecoration(
              color: item.color,
              shape: BoxShape.circle,
            ),
          ),
        );
      },
      value: colors[selectedColor],
      placeholder: const Text('Pick a color'),
      onChanged: (value) {
        if (kDebugMode) {
          print('You picked $value!');
        }
        if (value != null) {
          setState(() {
            selectedColor = colors.indexOf(value);
          });
        }
      },
    );
  }
}
# File: ./lib/pages/docs/components/item_picker/item_picker_example_2.dart
import 'package:shadcn_flutter/shadcn_flutter.dart';
class ItemPickerExample2 extends StatelessWidget {
  const ItemPickerExample2({super.key});
  @override
  Widget build(BuildContext context) {
    return PrimaryButton(
      onPressed: () {
        // Dialog variant of the item picker for a more prominent selection flow.
        showItemPickerDialog<int>(
          context,
          title: const Text('Pick a number'),
          items: ItemBuilder(
            itemBuilder: (index) {
              return index;
            },
          ),
          builder: (context, item) {
            return ItemPickerOption(
                value: item, child: Text(item.toString()).large);
          },
        ).then(
          (value) {
            if (value != null && context.mounted) {
              showToast(
                context: context,
                builder: (context, overlay) {
                  return SurfaceCard(
                    child: Text('You picked $value!'),
                  );
                },
              );
            } else if (context.mounted) {
              showToast(
                context: context,
                builder: (context, overlay) {
                  return const SurfaceCard(
                    child: Text('You picked nothing!'),
                  );
                },
              );
            }
          },
        );
      },
      child: const Text('Show Item Picker'),
    );
  }
}
# File: ./lib/pages/docs/components/item_picker/item_picker_example_3.dart
import 'package:shadcn_flutter/shadcn_flutter.dart';
class NamedColor {
  final String name;
  final Color color;
  const NamedColor(this.name, this.color);
}
class ItemPickerExample3 extends StatefulWidget {
  const ItemPickerExample3({super.key});
  @override
  State<ItemPickerExample3> createState() => _ItemPickerExample3State();
}
class _ItemPickerExample3State extends State<ItemPickerExample3> {
  final List<NamedColor> colors = const [
    NamedColor('Red', Colors.red),
    NamedColor('Green', Colors.green),
    NamedColor('Blue', Colors.blue),
    NamedColor('Yellow', Colors.yellow),
    NamedColor('Purple', Colors.purple),
    NamedColor('Cyan', Colors.cyan),
    NamedColor('Orange', Colors.orange),
    NamedColor('Pink', Colors.pink),
    NamedColor('Teal', Colors.teal),
    NamedColor('Amber', Colors.amber),
  ];
  int selectedColor = 0;
  @override
  Widget build(BuildContext context) {
    return PrimaryButton(
      onPressed: () {
        showItemPickerDialog<NamedColor>(
          context,
          items: ItemList(colors),
          initialValue: colors[selectedColor],
          title: const Text('Pick a color'),
          builder: (context, item) {
            return ItemPickerOption(
              value: item,
              selectedStyle: const ButtonStyle.primary(
                shape: ButtonShape.circle,
              ),
              style: const ButtonStyle.ghost(
                shape: ButtonShape.circle,
              ),
              label: Text(item.name),
              child: Container(
                padding: const EdgeInsets.all(8),
                width: 100,
                height: 100,
                alignment: Alignment.center,
                decoration:
                    BoxDecoration(color: item.color, shape: BoxShape.circle),
              ),
            );
          },
        ).then(
          (value) {
            if (value != null) {
              selectedColor = colors.indexOf(value);
              if (context.mounted) {
                showToast(
                  context: context,
                  builder: (context, overlay) {
                    return SurfaceCard(
                      child: Text('You picked ${value.name}!'),
                    );
                  },
                );
              }
            } else if (context.mounted) {
              showToast(
                context: context,
                builder: (context, overlay) {
                  return const SurfaceCard(
                    child: Text('You picked nothing!'),
                  );
                },
              );
            }
          },
        );
      },
      child: const Text('Show Item Picker'),
    );
  }
}
# File: ./lib/pages/docs/components/date_picker/date_picker_example_2.dart
import 'package:shadcn_flutter/shadcn_flutter.dart';
/// DateRangePicker in popover and dialog modes.
///
/// Similar to the single-date picker, but selects a [DateTimeRange].
class DatePickerExample2 extends StatefulWidget {
  const DatePickerExample2({super.key});
  @override
  State<DatePickerExample2> createState() => _DatePickerExample2State();
}
class _DatePickerExample2State extends State<DatePickerExample2> {
  DateTimeRange? _value;
  @override
  Widget build(BuildContext context) {
    return Column(
      children: [
        DateRangePicker(
          value: _value,
          mode: PromptMode.popover,
          onChanged: (value) {
            setState(() {
              _value = value;
            });
          },
        ),
        const Gap(16),
        DateRangePicker(
          value: _value,
          mode: PromptMode.dialog,
          // Title for the dialog variant.
          dialogTitle: const Text('Select Date Range'),
          onChanged: (value) {
            setState(() {
              _value = value;
            });
          },
        ),
      ],
    );
  }
}
# File: ./lib/pages/docs/components/date_picker/date_picker_example_1.dart
import 'package:shadcn_flutter/shadcn_flutter.dart';
/// DatePicker in popover and dialog modes with disabled future dates.
///
/// Demonstrates single-date selection with two different prompt UIs:
/// - [PromptMode.popover]: inline, anchored overlay.
/// - [PromptMode.dialog]: modal dialog with a custom [dialogTitle].
class DatePickerExample1 extends StatefulWidget {
  const DatePickerExample1({super.key});
  @override
  State<DatePickerExample1> createState() => _DatePickerExample1State();
}
class _DatePickerExample1State extends State<DatePickerExample1> {
  DateTime? _value;
  @override
  Widget build(BuildContext context) {
    return Column(
      children: [
        DatePicker(
          value: _value,
          mode: PromptMode.popover,
          // Disable selecting dates after "today".
          stateBuilder: (date) {
            if (date.isAfter(DateTime.now())) {
              return DateState.disabled;
            }
            return DateState.enabled;
          },
          onChanged: (value) {
            setState(() {
              _value = value;
            });
          },
        ),
        const Gap(16),
        DatePicker(
          value: _value,
          mode: PromptMode.dialog,
          // Title shown at the top of the dialog variant.
          dialogTitle: const Text('Select Date'),
          stateBuilder: (date) {
            if (date.isAfter(DateTime.now())) {
              return DateState.disabled;
            }
            return DateState.enabled;
          },
          onChanged: (value) {
            setState(() {
              _value = value;
            });
          },
        ),
      ],
    );
  }
}
# File: ./lib/pages/docs/components/input_otp/input_otp_example_1.dart
import 'package:shadcn_flutter/shadcn_flutter.dart';
class InputOTPExample1 extends StatefulWidget {
  const InputOTPExample1({super.key});
  @override
  State<InputOTPExample1> createState() => _InputOTPExample1State();
}
class _InputOTPExample1State extends State<InputOTPExample1> {
  String value = '';
  String? submittedValue;
  @override
  Widget build(BuildContext context) {
    // Basic OTP input with onChanged and onSubmitted callbacks.
    // The example groups 3 digits, a visual separator, then 3 more digits.
    return Column(
      mainAxisSize: MainAxisSize.min,
      children: [
        InputOTP(
          onChanged: (value) {
            setState(() {
              this.value = value.otpToString();
            });
          },
          onSubmitted: (value) {
            setState(() {
              submittedValue = value.otpToString();
            });
          },
          children: [
            // Each character cell allows digits. The separator is a visual divider only.
            InputOTPChild.character(allowDigit: true),
            InputOTPChild.character(allowDigit: true),
            InputOTPChild.character(allowDigit: true),
            InputOTPChild.separator,
            InputOTPChild.character(allowDigit: true),
            InputOTPChild.character(allowDigit: true),
            InputOTPChild.character(allowDigit: true),
          ],
        ),
        gap(16),
        Text('Value: $value'),
        Text('Submitted Value: $submittedValue'),
      ],
    );
  }
}
# File: ./lib/pages/docs/components/input_otp/input_otp_example_2.dart
import 'package:shadcn_flutter/shadcn_flutter.dart';
class InputOTPExample2 extends StatelessWidget {
  const InputOTPExample2({super.key});
  @override
  Widget build(BuildContext context) {
    // Pre-populate the first group using the characters from the string '123'.
    // InputOTP takes a list of code units for its initial value.
    return InputOTP(
      initialValue: '123'.codeUnits,
      children: [
        InputOTPChild.character(allowDigit: true),
        InputOTPChild.character(allowDigit: true),
        InputOTPChild.character(allowDigit: true),
        InputOTPChild.separator,
        InputOTPChild.character(allowDigit: true),
        InputOTPChild.character(allowDigit: true),
        InputOTPChild.character(allowDigit: true),
      ],
    );
  }
}
# File: ./lib/pages/docs/components/input_otp/input_otp_example_4.dart
import 'package:shadcn_flutter/shadcn_flutter.dart';
class InputOTPExample4 extends StatelessWidget {
  const InputOTPExample4({super.key});
  @override
  Widget build(BuildContext context) {
    // OTP comprised of uppercase alphabet characters only, split into
    // multiple groups with separators. Each InputOTPChild.character controls
    // what kinds of characters are permitted.
    return InputOTP(
      children: [
        InputOTPChild.character(
            allowLowercaseAlphabet: true,
            allowUppercaseAlphabet: true,
            onlyUppercaseAlphabet: true),
        InputOTPChild.character(
            allowLowercaseAlphabet: true,
            allowUppercaseAlphabet: true,
            onlyUppercaseAlphabet: true),
        InputOTPChild.character(
            allowLowercaseAlphabet: true,
            allowUppercaseAlphabet: true,
            onlyUppercaseAlphabet: true),
        InputOTPChild.separator,
        InputOTPChild.character(
            allowLowercaseAlphabet: true,
            allowUppercaseAlphabet: true,
            onlyUppercaseAlphabet: true),
        InputOTPChild.character(
            allowLowercaseAlphabet: true,
            allowUppercaseAlphabet: true,
            onlyUppercaseAlphabet: true),
        InputOTPChild.character(
            allowLowercaseAlphabet: true,
            allowUppercaseAlphabet: true,
            onlyUppercaseAlphabet: true),
        InputOTPChild.separator,
        InputOTPChild.character(
            allowLowercaseAlphabet: true,
            allowUppercaseAlphabet: true,
            onlyUppercaseAlphabet: true),
        InputOTPChild.character(
            allowLowercaseAlphabet: true,
            allowUppercaseAlphabet: true,
            onlyUppercaseAlphabet: true),
        InputOTPChild.character(
            allowLowercaseAlphabet: true,
            allowUppercaseAlphabet: true,
            onlyUppercaseAlphabet: true),
      ],
    );
  }
}
# File: ./lib/pages/docs/components/input_otp/input_otp_example_3.dart
import 'package:shadcn_flutter/shadcn_flutter.dart';
class InputOTPExample3 extends StatelessWidget {
  const InputOTPExample3({super.key});
  @override
  Widget build(BuildContext context) {
    // Same layout as before but with obscured input to hide the characters
    // (useful for sensitive OTP codes).
    return InputOTP(
      children: [
        InputOTPChild.character(allowDigit: true, obscured: true),
        InputOTPChild.character(allowDigit: true, obscured: true),
        InputOTPChild.character(allowDigit: true, obscured: true),
        InputOTPChild.separator,
        InputOTPChild.character(allowDigit: true, obscured: true),
        InputOTPChild.character(allowDigit: true, obscured: true),
        InputOTPChild.character(allowDigit: true, obscured: true),
      ],
    );
  }
}
# File: ./lib/pages/docs/components/progress/progress_example_1.dart
import 'package:shadcn_flutter/shadcn_flutter.dart';
class ProgressExample1 extends StatefulWidget {
  const ProgressExample1({super.key});
  @override
  State<ProgressExample1> createState() => _ProgressExample1State();
}
class _ProgressExample1State extends State<ProgressExample1> {
  // Track the current progress value as a percentage (0‚Äì100).
  // This is a controlled example: UI buttons below update this state.
  double _progress = 0.0;
  @override
  Widget build(BuildContext context) {
    return Column(
      mainAxisSize: MainAxisSize.min,
      children: [
        // Constrain the progress bar width so it doesn't grow to the full page width in docs.
        SizedBox(
          width: 400,
          child: Progress(
            // Clamp the provided value so the widget never receives out-of-range input.
            // Alternatively, you can ensure only 0‚Äì100 values are set in state.
            progress: _progress.clamp(0, 100),
            // The logical domain for the progress value. Values outside will be coerced by clamp above.
            min: 0,
            max: 100,
          ),
        ),
        const Gap(16),
        // Simple controls to demonstrate changing progress.
        Row(
          children: [
            DestructiveButton(
              onPressed: () {
                setState(() {
                  // Reset back to 0%.
                  _progress = 0;
                });
              },
              child: const Text('Reset'),
            ),
            const Gap(16),
            PrimaryButton(
              onPressed: () {
                // Defensive check so we don't go below 0.
                if (_progress > 0) {
                  setState(() {
                    // Decrease by a fixed step.
                    _progress -= 10;
                  });
                }
              },
              child: const Text('Decrease by 10'),
            ),
            const Gap(16),
            PrimaryButton(
              onPressed: () {
                // Defensive check so we don't go above 100.
                if (_progress < 100) {
                  setState(() {
                    // Increase by a fixed step.
                    _progress += 10;
                  });
                }
              },
              child: const Text('Increase by 10'),
            ),
          ],
        )
      ],
    );
  }
}
# File: ./lib/pages/docs/components/phone_input/phone_input_example_1.dart
import 'package:shadcn_flutter/shadcn_flutter.dart';
class PhoneInputExample1 extends StatefulWidget {
  const PhoneInputExample1({super.key});
  @override
  State<PhoneInputExample1> createState() => _PhoneInputExample1State();
}
class _PhoneInputExample1State extends State<PhoneInputExample1> {
  PhoneNumber? _phoneNumber;
  @override
  Widget build(BuildContext context) {
    return Column(
      mainAxisSize: MainAxisSize.min,
      children: [
        PhoneInput(
          // Preselect a country; phone parsing/formatting adapt accordingly.
          initialCountry: Country.indonesia,
          onChanged: (value) {
            setState(() {
              _phoneNumber = value;
            });
          },
        ),
        const Gap(24),
        Text(
          _phoneNumber?.value ?? '(No value)',
        ),
      ],
    );
  }
}
# File: ./lib/pages/docs/components/carousel/carousel_example_2.dart
import 'package:shadcn_flutter/shadcn_flutter.dart';
import '../carousel_example.dart';
/// Vertical carousel centered in a column with manual controls.
///
/// Demonstrates changing [direction] to [Axis.vertical] and centering items
/// using [CarouselAlignment.center].
class CarouselExample2 extends StatefulWidget {
  const CarouselExample2({super.key});
  @override
  State<CarouselExample2> createState() => _CarouselExample2State();
}
class _CarouselExample2State extends State<CarouselExample2> {
  final CarouselController controller = CarouselController();
  @override
  Widget build(BuildContext context) {
    return SizedBox(
      height: 500,
      child: Column(
        mainAxisSize: MainAxisSize.min,
        children: [
          OutlineButton(
              shape: ButtonShape.circle,
              onPressed: () {
                // Move to previous item (upwards).
                controller.animatePrevious(const Duration(milliseconds: 500));
              },
              child: const Icon(Icons.arrow_upward)),
          const Gap(24),
          Expanded(
            child: SizedBox(
              width: 200,
              child: Carousel(
                transition: const CarouselTransition.sliding(gap: 24),
                // Center the visible item.
                alignment: CarouselAlignment.center,
                controller: controller,
                // Rotate layout to vertical flow.
                direction: Axis.vertical,
                // Fix item extent to 200.
                sizeConstraint: const CarouselFixedConstraint(200),
                itemBuilder: (context, index) {
                  return NumberedContainer(index: index);
                },
              ),
            ),
          ),
          const Gap(24),
          OutlineButton(
              shape: ButtonShape.circle,
              onPressed: () {
                // Move to next item (downwards).
                controller.animateNext(const Duration(milliseconds: 500));
              },
              child: const Icon(Icons.arrow_downward)),
        ],
      ),
    );
  }
}
# File: ./lib/pages/docs/components/carousel/carousel_example_3.dart
import 'package:shadcn_flutter/shadcn_flutter.dart';
import '../carousel_example.dart';
/// Carousel with fading transition and dot indicators.
///
/// Items fade in/out instead of sliding. Draggable is disabled and the
/// [CarouselDotIndicator] syncs with the same [CarouselController].
class CarouselExample3 extends StatefulWidget {
  const CarouselExample3({super.key});
  @override
  State<CarouselExample3> createState() => _CarouselExample3State();
}
class _CarouselExample3State extends State<CarouselExample3> {
  final CarouselController controller = CarouselController();
  @override
  Widget build(BuildContext context) {
    return SizedBox(
      width: 800,
      child: Column(
        mainAxisSize: MainAxisSize.min,
        children: [
          SizedBox(
            height: 200,
            child: Carousel(
              // Use a fading transition instead of sliding.
              transition: const CarouselTransition.fading(),
              controller: controller,
              // Disable gesture dragging; navigation is via controls below.
              draggable: false,
              // Automatically switch items.
              autoplaySpeed: const Duration(seconds: 1),
              itemCount: 5,
              itemBuilder: (context, index) {
                return NumberedContainer(index: index);
              },
              // Fade duration.
              duration: const Duration(seconds: 1),
            ),
          ),
          const Gap(8),
          Row(
            mainAxisSize: MainAxisSize.min,
            children: [
              // Dots reflect and control the current index via controller.
              CarouselDotIndicator(itemCount: 5, controller: controller),
              const Spacer(),
              OutlineButton(
                  shape: ButtonShape.circle,
                  onPressed: () {
                    controller
                        .animatePrevious(const Duration(milliseconds: 500));
                  },
                  child: const Icon(Icons.arrow_back)),
              const Gap(8),
              OutlineButton(
                  shape: ButtonShape.circle,
                  onPressed: () {
                    controller.animateNext(const Duration(milliseconds: 500));
                  },
                  child: const Icon(Icons.arrow_forward)),
            ],
          ),
        ],
      ),
    );
  }
}
# File: ./lib/pages/docs/components/carousel/carousel_example_4.dart
import 'package:shadcn_flutter/shadcn_flutter.dart';
import '../carousel_example.dart';
/// Continuous sliding carousel.
///
/// Uses a sliding transition with a linear curve and `duration: Duration.zero`
/// to produce a smooth, continuous marquee-like movement when combined with
/// `autoplaySpeed`.
class CarouselExample4 extends StatefulWidget {
  const CarouselExample4({super.key});
  @override
  State<CarouselExample4> createState() => _CarouselExample4State();
}
class _CarouselExample4State extends State<CarouselExample4> {
  final CarouselController controller = CarouselController();
  @override
  Widget build(BuildContext context) {
    return SizedBox(
      width: 800,
      height: 200,
      child: Carousel(
        // Slide items horizontally with a gap.
        transition: const CarouselTransition.sliding(gap: 24),
        controller: controller,
        // Disable user drag to keep the motion continuous.
        draggable: false,
        // Tick forward every 2 seconds.
        autoplaySpeed: const Duration(seconds: 2),
        // Linear curve keeps velocity constant between ticks.
        curve: Curves.linear,
        itemCount: 5,
        sizeConstraint: const CarouselSizeConstraint.fixed(200),
        itemBuilder: (context, index) {
          return NumberedContainer(index: index);
        },
        // Instant transition per tick for a marquee-like feel.
        duration: Duration.zero,
      ),
    );
  }
}
# File: ./lib/pages/docs/components/carousel/carousel_example_1.dart
import 'package:shadcn_flutter/shadcn_flutter.dart';
import '../carousel_example.dart';
/// Horizontal carousel with manual next/previous controls.
///
/// Uses a [CarouselController] to programmatically navigate slides and
/// a sliding transition with a fixed item size and autoplay.
class CarouselExample1 extends StatefulWidget {
  const CarouselExample1({super.key});
  @override
  State<CarouselExample1> createState() => _CarouselExample1State();
}
class _CarouselExample1State extends State<CarouselExample1> {
  final CarouselController controller = CarouselController();
  @override
  Widget build(BuildContext context) {
    return SizedBox(
      width: 800,
      child: Row(
        children: [
          OutlineButton(
              shape: ButtonShape.circle,
              onPressed: () {
                // Animate to previous slide.
                controller.animatePrevious(const Duration(milliseconds: 500));
              },
              child: const Icon(Icons.arrow_back)),
          const Gap(24),
          Expanded(
            child: SizedBox(
              height: 200,
              child: Carousel(
                // frameTransform: Carousel.fadingTransform,
                // Slide items with a 24px gap.
                transition: const CarouselTransition.sliding(gap: 24),
                controller: controller,
                // Each item has a fixed dimension of 200.
                sizeConstraint: const CarouselFixedConstraint(200),
                // Automatically advance every 2 seconds.
                autoplaySpeed: const Duration(seconds: 2),
                itemCount: 5,
                itemBuilder: (context, index) {
                  return NumberedContainer(index: index);
                },
                // Duration of the slide transition animation.
                duration: const Duration(seconds: 1),
              ),
            ),
          ),
          const Gap(24),
          OutlineButton(
              shape: ButtonShape.circle,
              onPressed: () {
                // Animate to next slide.
                controller.animateNext(const Duration(milliseconds: 500));
              },
              child: const Icon(Icons.arrow_forward)),
        ],
      ),
    );
  }
}
# File: ./lib/pages/docs/components/radio_group/radio_group_example_1.dart
import 'package:shadcn_flutter/shadcn_flutter.dart';
class RadioGroupExample1 extends StatefulWidget {
  const RadioGroupExample1({super.key});
  @override
  State<RadioGroupExample1> createState() => _RadioGroupExample1State();
}
class _RadioGroupExample1State extends State<RadioGroupExample1> {
  // Start with no selection (null). The UI reflects this until the user picks an option.
  int? selectedValue;
  @override
  Widget build(BuildContext context) {
    return Column(
      crossAxisAlignment: CrossAxisAlignment.start,
      children: [
        // A generic RadioGroup for int values. It controls selection for its RadioItem children.
        RadioGroup<int>(
          value: selectedValue,
          onChanged: (value) {
            setState(() {
              // Save the selected value emitted by the tapped RadioItem.
              selectedValue = value;
            });
          },
          child: const Column(
            crossAxisAlignment: CrossAxisAlignment.start,
            children: [
              // Each RadioItem represents a single choice with an associated integer value.
              RadioItem(
                value: 1,
                trailing: Text('Option 1'),
              ),
              RadioItem(
                value: 2,
                trailing: Text('Option 2'),
              ),
              RadioItem(
                value: 3,
                trailing: Text('Option 3'),
              ),
            ],
          ),
        ),
        const Gap(16),
        // Echo the selection below for demonstration purposes.
        Text('Selected: $selectedValue'),
      ],
    );
  }
}
# File: ./lib/pages/docs/components/app/app_example_3.dart
import 'package:go_router/go_router.dart';
import 'package:shadcn_flutter/shadcn_flutter.dart';
// ShadcnApp.router example using GoRouter for declarative navigation.
// Defines two routes ('/' and '/about') and renders a simple Scaffold for each.
class AppExample3 extends StatelessWidget {
  const AppExample3({super.key});
  @override
  Widget build(BuildContext context) {
    return ShadcnApp.router(
      routerConfig: GoRouter(routes: [
        GoRoute(
          path: '/',
          // Home page with AppBar and greeting text.
          builder: (context, state) => const Scaffold(
            headers: [
              AppBar(
                title: Text('Shadcn App Example with GoRouter'),
              ),
              Divider(),
            ],
            child: Center(
              child: Text('Hello, Shadcn Flutter with GoRouter!'),
            ),
          ),
        ),
        GoRoute(
          path: '/about',
          // About page demonstrates a second route.
          builder: (context, state) => const Scaffold(
            headers: [
              AppBar(
                title: Text('About Page'),
              ),
              Divider(),
            ],
            child: Center(
              child: Text('This is the about page.'),
            ),
          ),
        ),
      ]),
      theme: const ThemeData(
        colorScheme: ColorSchemes.lightSlate,
      ),
      darkTheme: const ThemeData.dark(
        colorScheme: ColorSchemes.darkSlate,
      ),
    );
  }
}
# File: ./lib/pages/docs/components/app/app_example_2.dart
import 'package:shadcn_flutter/shadcn_flutter.dart';
// Demonstrates ShadcnApp with custom light/dark themes.
// Highlights theme knobs like colorScheme, radius, scaling, surfaceOpacity,
// surfaceBlur, and custom typography families.
class AppExample2 extends StatelessWidget {
  const AppExample2({super.key});
  @override
  Widget build(BuildContext context) {
    return const ShadcnApp(
      theme: ThemeData(
          // Customize light mode colors and design tokens.
          colorScheme: ColorSchemes.lightSlate,
          // Corner radius scale applied across components.
          radius: 0.25,
          // Global size scale multiplier.
          scaling: 1.2,
          // Semi-translucent surfaces with blur create a glassy look.
          surfaceOpacity: 0.8,
          surfaceBlur: 10,
          // Swap default fonts for sans/mono text styles.
          typography: Typography.geist(
            sans: TextStyle(
              fontFamily: 'Inter',
            ),
            mono: TextStyle(
              fontFamily: 'FiraCode',
            ),
          )),
      darkTheme: ThemeData.dark(
          // Mirror customizations for dark mode.
          colorScheme: ColorSchemes.darkSlate,
          radius: 0.25,
          scaling: 1.2,
          surfaceOpacity: 0.8,
          surfaceBlur: 10,
          typography: Typography.geist(
            sans: TextStyle(
              fontFamily: 'Inter',
            ),
            mono: TextStyle(
              fontFamily: 'FiraCode',
            ),
          )),
      home: Scaffold(
        headers: [
          AppBar(
            title: Text('Shadcn App Example'),
          ),
          Divider(),
        ],
        child: Center(
          child: Text('Hello, Shadcn Flutter!'),
        ),
      ),
    );
  }
}
# File: ./lib/pages/docs/components/app/app_example_1.dart
import 'package:shadcn_flutter/shadcn_flutter.dart';
// Minimal ShadcnApp usage: provides theming and routing scaffolding similar to
// MaterialApp/CupertinoApp, then renders a basic Scaffold with an AppBar.
// This example focuses on the default setup ‚Äî no custom theme or routing.
class AppExample1 extends StatelessWidget {
  const AppExample1({super.key});
  @override
  Widget build(BuildContext context) {
    return const ShadcnApp(
      home: Scaffold(
        headers: [
          // Use Shadcn AppBar in the Scaffold header area.
          AppBar(
            title: Text('Shadcn App Example'),
          ),
          // A divider beneath the AppBar to separate header and body.
          Divider(),
        ],
        child: Center(
          child: Text('Hello, Shadcn Flutter!'),
        ),
      ),
    );
  }
}
# File: ./lib/pages/docs/components/linear_progress/linear_progress_example_1.dart
import 'package:shadcn_flutter/shadcn_flutter.dart';
class LinearProgressExample1 extends StatelessWidget {
  const LinearProgressExample1({super.key});
  @override
  Widget build(BuildContext context) {
    // Indeterminate linear progress indicator with a fixed width.
    // When no `value` is provided, it displays an animated looping bar.
    return const SizedBox(
      width: 200,
      child: LinearProgressIndicator(),
    );
  }
}
# File: ./lib/pages/docs/components/linear_progress/linear_progress_example_2.dart
import 'package:shadcn_flutter/shadcn_flutter.dart';
class LinearProgressExample2 extends StatefulWidget {
  const LinearProgressExample2({super.key});
  @override
  State<LinearProgressExample2> createState() => _LinearProgressExample2State();
}
class _LinearProgressExample2State extends State<LinearProgressExample2> {
  double value = 0;
  @override
  Widget build(BuildContext context) {
    return Column(
      mainAxisSize: MainAxisSize.min,
      children: [
        SizedBox(
          width: 200,
          child: LinearProgressIndicator(
            // Supplying a value (0.0..1.0) switches the indicator to determinate mode.
            value: value,
          ),
        ),
        const Gap(24),
        Row(
          mainAxisSize: MainAxisSize.min,
          children: [
            PrimaryButton(
              onPressed: () {
                setState(() {
                  value = 0;
                });
              },
              child: const Text('Reset'),
            ),
            const Gap(24),
            PrimaryButton(
              onPressed: () {
                if (value + 0.1 >= 1) {
                  return;
                }
                setState(() {
                  value += 0.1;
                });
              },
              child: const Text('Increase'),
            ),
            const Gap(24),
            PrimaryButton(
              onPressed: () {
                if (value - 0.1 <= 0) {
                  return;
                }
                setState(() {
                  value -= 0.1;
                });
              },
              child: const Text('Decrease'),
            ),
          ],
        )
      ],
    );
  }
}
# File: ./lib/pages/docs/components/expandable_sidebar/expandable_sidebar_example_1.dart
import 'package:shadcn_flutter/shadcn_flutter.dart';
// Demonstrates an "expandable" navigation rail that can collapse/expand labels
// while keeping the same selection model. The left rail hosts sections and items;
// the right side is just an empty content area for demo framing.
class ExpandableSidebarExample1 extends StatefulWidget {
  const ExpandableSidebarExample1({super.key});
  @override
  State<ExpandableSidebarExample1> createState() =>
      _ExpandableSidebarExample1State();
}
class _ExpandableSidebarExample1State extends State<ExpandableSidebarExample1> {
  // When true, the rail expands to show labels; when false, it collapses to
  // an icon-only sidebar.
  bool expanded = false;
  String selected = 'Home';
  NavigationItem buildButton(String text, IconData icon) {
    // Convenience factory for a selectable navigation item with left alignment
    // and a primary icon style when selected.
    return NavigationItem(
      label: Text(text),
      // alignment: Alignment.centerLeft,
      selectedStyle: const ButtonStyle.primaryIcon(),
      selected: selected == text,
      onChanged: (selected) {
        if (selected) {
          setState(() {
            this.selected = text;
          });
        }
      },
      child: Icon(icon),
    );
  }
  NavigationGroup buildLabel(String label, List<Widget> children) {
    // Section header used to group related navigation items.
    return NavigationGroup(
      labelAlignment: Alignment.centerLeft,
      label: Text(label).semiBold.muted.xSmall,
      children: children,
    );
  }
  @override
  Widget build(BuildContext context) {
    final theme = Theme.of(context);
    return OutlinedContainer(
      // Frame the example and fix a size so expansion is obvious.
      height: 600,
      width: 800,
      child: Row(
        crossAxisAlignment: CrossAxisAlignment.stretch,
        children: [
          NavigationRail(
            backgroundColor: theme.colorScheme.accent.withValues(alpha: 0.4),
            // Expand/collapse behavior is handled by the `expanded` boolean.
            // With labelType.expanded, labels are hidden when collapsed.
            labelType: NavigationLabelType.expanded,
            labelPosition: NavigationLabelPosition.end,
            alignment: NavigationRailAlignment.start,
            expandedSize: 250,
            expanded: expanded,
            header: [
              Builder(builder: (context) {
                return NavigationSlot(
                  leading: IconContainer(
                    backgroundColor: Colors.blue,
                    icon: const Icon(LucideIcons.galleryVerticalEnd).iconMedium,
                  ),
                  title: const Text('Acme Inc').medium.small,
                  subtitle: const Text('Enterprise').xSmall.normal,
                  trailing: const Icon(LucideIcons.chevronsUpDown).iconSmall,
                  onPressed: () {
                    showDropdown(
                        context: context,
                        anchorAlignment: AlignmentDirectional.centerEnd,
                        alignment: AlignmentDirectional.centerStart,
                        offset: const Offset(16, 0),
                        builder: (context) {
                          return DropdownMenu(children: [
                            MenuButton(
                                leading: const Icon(Icons.person),
                                child: const Text('Profile'),
                                onPressed: (ctx) {}),
                            MenuButton(
                                leading: const Icon(Icons.settings),
                                child: const Text('Settings'),
                                onPressed: (ctx) {}),
                            const MenuDivider(),
                            MenuButton(
                                leading: const Icon(Icons.logout),
                                child: const Text('Logout'),
                                onPressed: (ctx) {}),
                          ]);
                        });
                  },
                );
              }),
            ],
            footer: [
              NavigationSlot(
                leading: Avatar(
                  size: 32,
                  initials: 'SU',
                  backgroundColor: Colors.green.shade800,
                ),
                title: const Text('sunarya-thito').medium.small,
                subtitle: const Text('m@gmail.com').xSmall.normal,
                trailing: const Icon(LucideIcons.chevronsUpDown).iconSmall,
                onPressed: () {},
              ),
            ],
            children: [
              buildLabel('You', [
                buildButton('Home', Icons.home_filled),
                buildButton('Trending', Icons.trending_up),
                buildButton('Subscription', Icons.subscriptions),
              ]),
              const NavigationDivider(),
              NavigationCollapsible(
                leading: const Icon(Icons.history),
                label: const Text('History'),
                children: [
                  buildButton('History', Icons.history),
                  buildButton('Watch Later', Icons.access_time_rounded),
                ],
              ),
              const NavigationDivider(),
              buildLabel('Movie', [
                buildButton('Action', Icons.movie_creation_outlined),
                buildButton('Horror', Icons.movie_creation_outlined),
                buildButton('Thriller', Icons.movie_creation_outlined),
              ]),
              const NavigationDivider(),
              NavigationCollapsible(
                leading: const Icon(Icons.movie_filter_outlined),
                label: const Text('Short Films'),
                children: [
                  buildButton('Action', Icons.movie_creation_outlined),
                  buildButton('Horror', Icons.movie_creation_outlined),
                ],
              ),
            ],
          ),
          const VerticalDivider(),
          // Placeholder for the main content area.
          Flexible(
            child: Padding(
              padding: const EdgeInsets.all(8.0),
              child: Column(
                crossAxisAlignment: CrossAxisAlignment.start,
                children: [
                  IconButton.ghost(
                    onPressed: () {
                      setState(() {
                        // Toggle between expanded and collapsed rail.
                        expanded = !expanded;
                      });
                    },
                    icon: const Icon(LucideIcons.panelLeft),
                  ),
                ],
              ),
            ),
          ),
        ],
      ),
    );
  }
}
# File: ./lib/pages/docs/components/tree/tree_example_1.dart
import 'package:shadcn_flutter/shadcn_flutter.dart';
// Demonstrates TreeView with expandable items, branch lines (path/line),
// and optional recursive selection behavior.
class TreeExample1 extends StatefulWidget {
  const TreeExample1({super.key});
  @override
  State<TreeExample1> createState() => _TreeExample1State();
}
class _TreeExample1State extends State<TreeExample1> {
  bool expandIcon = false;
  bool usePath = true;
  bool recursiveSelection = false;
  List<TreeNode<String>> treeItems = [
    TreeItem(
      data: 'Apple',
      expanded: true,
      children: [
        TreeItem(data: 'Red Apple', children: [
          TreeItem(data: 'Red Apple 1'),
          TreeItem(data: 'Red Apple 2'),
        ]),
        TreeItem(data: 'Green Apple'),
      ],
    ),
    TreeItem(
      data: 'Banana',
      children: [
        TreeItem(data: 'Yellow Banana'),
        TreeItem(data: 'Green Banana', children: [
          TreeItem(data: 'Green Banana 1'),
          TreeItem(data: 'Green Banana 2'),
          TreeItem(data: 'Green Banana 3'),
        ]),
      ],
    ),
    TreeItem(
      data: 'Cherry',
      children: [
        TreeItem(data: 'Red Cherry'),
        TreeItem(data: 'Green Cherry'),
      ],
    ),
    TreeItem(
      data: 'Date',
    ),
    // Tree Root acts as a parent node with no data,
    // it will flatten the children into the parent node
    TreeRoot(
      children: [
        TreeItem(
          data: 'Elderberry',
          children: [
            TreeItem(data: 'Black Elderberry'),
            TreeItem(data: 'Red Elderberry'),
          ],
        ),
        TreeItem(
          data: 'Fig',
          children: [
            TreeItem(data: 'Green Fig'),
            TreeItem(data: 'Purple Fig'),
          ],
        ),
      ],
    ),
  ];
  @override
  Widget build(BuildContext context) {
    return Column(
      mainAxisSize: MainAxisSize.min,
      children: [
        OutlinedContainer(
          child: SizedBox(
            height: 300,
            width: 250,
            child: TreeView(
              // Show a separate expand/collapse icon when true; otherwise use row affordance.
              expandIcon: expandIcon,
              shrinkWrap: true,
              // When true, selecting a parent can affect children (see below toggle).
              recursiveSelection: recursiveSelection,
              nodes: treeItems,
              // Draw connecting lines either as path curves or straight lines.
              branchLine: usePath ? BranchLine.path : BranchLine.line,
              // Use a built-in handler to update selection state across nodes.
              onSelectionChanged: TreeView.defaultSelectionHandler(
                treeItems,
                (value) {
                  setState(() {
                    treeItems = value;
                  });
                },
              ),
              builder: (context, node) {
                return TreeItemView(
                  onPressed: () {},
                  trailing: node.leaf
                      ? Container(
                          width: 16,
                          height: 16,
                          alignment: Alignment.center,
                          child: const CircularProgressIndicator(),
                        )
                      : null,
                  leading: node.leaf
                      ? const Icon(BootstrapIcons.fileImage)
                      : Icon(node.expanded
                          ? BootstrapIcons.folder2Open
                          : BootstrapIcons.folder2),
                  // Expand/collapse handling; updates treeItems with new expanded state.
                  onExpand: TreeView.defaultItemExpandHandler(treeItems, node,
                      (value) {
                    setState(() {
                      treeItems = value;
                    });
                  }),
                  child: Text(node.data),
                );
              },
            ),
          ),
        ),
        const Gap(16),
        Row(
          mainAxisSize: MainAxisSize.min,
          children: [
            PrimaryButton(
              onPressed: () {
                setState(() {
                  treeItems = treeItems.expandAll();
                });
              },
              child: const Text('Expand All'),
            ),
            const Gap(8),
            PrimaryButton(
              onPressed: () {
                setState(() {
                  treeItems = treeItems.collapseAll();
                });
              },
              child: const Text('Collapse All'),
            ),
          ],
        ),
        const Gap(8),
        Checkbox(
          state: expandIcon ? CheckboxState.checked : CheckboxState.unchecked,
          onChanged: (value) {
            setState(() {
              expandIcon = value == CheckboxState.checked;
            });
          },
          trailing: const Text('Expand Icon'),
        ),
        const Gap(8),
        Checkbox(
          state: usePath ? CheckboxState.checked : CheckboxState.unchecked,
          onChanged: (value) {
            setState(() {
              usePath = value == CheckboxState.checked;
            });
          },
          trailing: const Text('Use Path Branch Line'),
        ),
        const Gap(8),
        Checkbox(
          state: recursiveSelection
              ? CheckboxState.checked
              : CheckboxState.unchecked,
          onChanged: (value) {
            setState(() {
              recursiveSelection = value == CheckboxState.checked;
              if (recursiveSelection) {
                // Update nodes so parent/child reflect selected state recursively.
                treeItems = treeItems.updateRecursiveSelection();
              }
            });
          },
          trailing: const Text('Recursive Selection'),
        ),
      ],
    );
  }
}
# File: ./lib/pages/docs/components/dropdown_menu/dropdown_menu_example_1.dart
import 'package:flutter/foundation.dart';
import 'package:shadcn_flutter/shadcn_flutter.dart';
/// Dropdown menu anchored to a button.
///
/// Uses [showDropdown] to present a [DropdownMenu] overlay with labels,
/// dividers, buttons, and a nested submenu.
class DropdownMenuExample1 extends StatelessWidget {
  const DropdownMenuExample1({super.key});
  @override
  Widget build(BuildContext context) {
    return OutlineButton(
      onPressed: () {
        // Show the dropdown relative to the button.
        showDropdown(
          context: context,
          builder: (context) {
            return const DropdownMenu(
              children: [
                MenuLabel(child: Text('My Account')),
                MenuDivider(),
                MenuButton(
                  child: Text('Profile'),
                ),
                MenuButton(
                  child: Text('Billing'),
                ),
                MenuButton(
                  child: Text('Settings'),
                ),
                MenuButton(
                  child: Text('Keyboard shortcuts'),
                ),
                MenuDivider(),
                MenuButton(
                  child: Text('Team'),
                ),
                MenuButton(
                  // Demonstrates a nested submenu.
                  subMenu: [
                    MenuButton(
                      child: Text('Email'),
                    ),
                    MenuButton(
                      child: Text('Message'),
                    ),
                    MenuDivider(),
                    MenuButton(
                      child: Text('More...'),
                    ),
                  ],
                  child: Text('Invite users'),
                ),
                MenuButton(
                  child: Text('New Team'),
                ),
                MenuDivider(),
                MenuButton(
                  child: Text('GitHub'),
                ),
                MenuButton(
                  child: Text('Support'),
                ),
                MenuButton(
                  enabled: false,
                  child: Text('API'),
                ),
                MenuButton(
                  child: Text('Log out'),
                ),
              ],
            );
          },
        ).future.then((_) {
          // Called when the dropdown is closed.
          if (kDebugMode) {
            print('Closed');
          }
        });
      },
      child: const Text('Open'),
    );
  }
}
# File: ./lib/pages/docs/components/alert/alert_example_1.dart
import 'package:shadcn_flutter/shadcn_flutter.dart';
/// Basic Alert example.
///
/// This shows a non-destructive [Alert] with a title, content, and a
/// leading icon. Use alerts to communicate a status or message that
/// doesn't necessarily require immediate user action.
class AlertExample1 extends StatelessWidget {
  const AlertExample1({super.key});
  @override
  Widget build(BuildContext context) {
    // `Alert` supports optional leading/trailing widgets for icons or actions.
    return const Alert(
      title: Text('Alert title'),
      content: Text('This is alert content.'),
      leading: Icon(Icons.info_outline),
    );
  }
}
# File: ./lib/pages/docs/components/alert/alert_example_2.dart
import 'package:shadcn_flutter/shadcn_flutter.dart';
/// Destructive Alert example.
///
/// Demonstrates using the `destructive` style via the named constructor
/// [Alert.destructive], which is suitable for critical or dangerous states.
class AlertExample2 extends StatelessWidget {
  const AlertExample2({super.key});
  @override
  Widget build(BuildContext context) {
    // Destructive styling typically emphasizes caution to the user.
    return const Alert.destructive(
      title: Text('Alert title'),
      content: Text('This is alert content.'),
      trailing: Icon(Icons.dangerous_outlined),
    );
  }
}
# File: ./lib/pages/docs/components/collapsible/collapsible_example_1.dart
import 'package:shadcn_flutter/shadcn_flutter.dart';
/// Collapsible list with a trigger and multiple content sections.
///
/// The first item is a [CollapsibleTrigger] that toggles visibility of
/// subsequent [CollapsibleContent] sections.
class CollapsibleExample1 extends StatelessWidget {
  const CollapsibleExample1({super.key});
  @override
  Widget build(BuildContext context) {
    return Collapsible(
      children: [
        const CollapsibleTrigger(
          child: Text('@sunarya-thito starred 3 repositories'),
        ),
        OutlinedContainer(
          child: const Text('@sunarya-thito/shadcn_flutter')
              .small()
              .mono()
              .withPadding(horizontal: 16, vertical: 8),
        ).withPadding(top: 8),
        CollapsibleContent(
          child: OutlinedContainer(
            child: const Text('@flutter/flutter')
                .small()
                .mono()
                .withPadding(horizontal: 16, vertical: 8),
          ).withPadding(top: 8),
        ),
        CollapsibleContent(
          child: OutlinedContainer(
            child: const Text('@dart-lang/sdk')
                .small()
                .mono()
                .withPadding(horizontal: 16, vertical: 8),
          ).withPadding(top: 8),
        ),
      ],
    );
  }
}
# File: ./lib/pages/docs/components/text_area/text_area_example_3.dart
import 'package:shadcn_flutter/shadcn_flutter.dart';
// Demonstrates a TextArea that expands both horizontally and vertically.
class TextAreaExample3 extends StatelessWidget {
  const TextAreaExample3({super.key});
  @override
  Widget build(BuildContext context) {
    return const TextArea(
      initialValue: 'Hello, World!',
      // Enable both horizontal and vertical growth based on content.
      expandableWidth: true,
      expandableHeight: true,
      // Larger starting dimensions to make the behavior obvious.
      initialWidth: 500,
      initialHeight: 300,
    );
  }
}
# File: ./lib/pages/docs/components/text_area/text_area_example_2.dart
import 'package:shadcn_flutter/shadcn_flutter.dart';
// Demonstrates a TextArea that can expand horizontally as space permits.
class TextAreaExample2 extends StatelessWidget {
  const TextAreaExample2({super.key});
  @override
  Widget build(BuildContext context) {
    return const TextArea(
      initialValue: 'Hello, World!',
      // Allow the field to expand horizontally if space permits.
      expandableWidth: true,
      // Start wider to demonstrate horizontal growth.
      initialWidth: 500,
    );
  }
}
# File: ./lib/pages/docs/components/text_area/text_area_example_1.dart
import 'package:shadcn_flutter/shadcn_flutter.dart';
// Demonstrates a TextArea that expands vertically with its content.
class TextAreaExample1 extends StatelessWidget {
  const TextAreaExample1({super.key});
  @override
  Widget build(BuildContext context) {
    return const TextArea(
      initialValue: 'Hello, World!',
      // Let the text area grow vertically with content up to constraints.
      expandableHeight: true,
      // Start with a taller initial height to show multiple lines.
      initialHeight: 300,
    );
  }
}
# File: ./lib/pages/docs/components/toggle/toggle_example_2.dart
import 'package:shadcn_flutter/shadcn_flutter.dart';
// Demonstrates a group of mutually exclusive Toggles (B/I/U) where exactly
// one formatting option can be active at a time.
class ToggleExample2 extends StatefulWidget {
  const ToggleExample2({super.key});
  @override
  ToggleExample2State createState() => ToggleExample2State();
}
class ToggleExample2State extends State<ToggleExample2> {
  int flag = 0;
  @override
  Widget build(BuildContext context) {
    return Row(
      mainAxisSize: MainAxisSize.min,
      children: [
        Toggle(
          // Exactly one of three toggles is active at a time.
          value: flag == 0,
          style: const ButtonStyle.outline(density: ButtonDensity.compact),
          onChanged: (v) {
            setState(() {
              // Activate when pressed; deactivate to clear selection.
              flag = v ? 0 : -1;
            });
          },
          child: const Text('B').bold().center(),
        ).sized(width: 40, height: 40),
        Toggle(
          value: flag == 1,
          style: const ButtonStyle.outline(density: ButtonDensity.compact),
          onChanged: (v) {
            setState(() {
              flag = v ? 1 : -1;
            });
          },
          child: const Text('I').italic().center(),
        ).sized(width: 40, height: 40),
        Toggle(
          value: flag == 2,
          style: const ButtonStyle.outline(density: ButtonDensity.compact),
          onChanged: (v) {
            setState(() {
              flag = v ? 2 : -1;
            });
          },
          child: const Text('U').underline().center(),
        ).sized(width: 40, height: 40),
      ],
    ).gap(4);
  }
}
# File: ./lib/pages/docs/components/toggle/toggle_example_1.dart
import 'package:shadcn_flutter/shadcn_flutter.dart';
// Demonstrates a basic boolean Toggle that flips its value when pressed.
class ToggleExample1 extends StatefulWidget {
  const ToggleExample1({super.key});
  @override
  ToggleExample1State createState() => ToggleExample1State();
}
class ToggleExample1State extends State<ToggleExample1> {
  bool value = false;
  @override
  Widget build(BuildContext context) {
    return Toggle(
      // Simple boolean toggle; style/semantics similar to a ToggleButton.
      value: value,
      onChanged: (v) {
        setState(() {
          value = v;
        });
      },
      child: const Text('Toggle'),
    );
  }
}
# File: ./lib/pages/docs/components/alert_dialog/alert_dialog_example_1.dart
import 'package:shadcn_flutter/shadcn_flutter.dart';
/// AlertDialog demo with a trigger button.
///
/// Tapping the [PrimaryButton] opens a Material [showDialog] that
/// contains an [AlertDialog] with a title, content, and action buttons.
/// The actions simply dismiss the dialog using [Navigator.pop].
class AlertDialogExample1 extends StatelessWidget {
  const AlertDialogExample1({super.key});
  @override
  Widget build(BuildContext context) {
    return PrimaryButton(
      child: const Text('Click Here'),
      onPressed: () {
        // Standard Flutter API to present a dialog above the current route.
        showDialog(
          context: context,
          builder: (context) {
            return AlertDialog(
              title: const Text('Alert title'),
              content: const Text(
                  'Lorem ipsum dolor sit amet, consectetur adipiscing elit.'),
              actions: [
                // Secondary action to cancel/dismiss.
                OutlineButton(
                  child: const Text('Cancel'),
                  onPressed: () {
                    // Close the dialog.
                    Navigator.pop(context);
                  },
                ),
                // Primary action to accept/confirm.
                PrimaryButton(
                  child: const Text('OK'),
                  onPressed: () {
                    // Close the dialog. In real apps, perform work before closing.
                    Navigator.pop(context);
                  },
                ),
              ],
            );
          },
        );
      },
    );
  }
}
# File: ./lib/pages/docs/components/star_rating/star_rating_example_1.dart
import 'package:shadcn_flutter/shadcn_flutter.dart';
class StarRatingExample1 extends StatefulWidget {
  const StarRatingExample1({super.key});
  @override
  State<StarRatingExample1> createState() => _StarRatingExample1State();
}
class _StarRatingExample1State extends State<StarRatingExample1> {
  // The current rating value (supports fractional values like 1.5 for half-stars).
  double value = 1.5;
  @override
  Widget build(BuildContext context) {
    return StarRating(
      // Control the icon size used for each star.
      starSize: 32,
      value: value,
      onChanged: (value) {
        setState(() {
          // Update the rating when the user taps/drags on the stars.
          this.value = value;
        });
      },
    );
  }
}
# File: ./lib/pages/docs/components/table/table_example_1.dart
import 'package:shadcn_flutter/shadcn_flutter.dart';
// Demonstrates a basic Table with a header row and body rows,
// including right-aligned numeric cells for amounts.
class TableExample1 extends StatefulWidget {
  const TableExample1({super.key});
  @override
  State<TableExample1> createState() => _TableExample1State();
}
class _TableExample1State extends State<TableExample1> {
  // Helper to build a header cell with muted, semibold text.
  TableCell buildHeaderCell(String text, [bool alignRight = false]) {
    return TableCell(
      child: Container(
        padding: const EdgeInsets.all(8),
        alignment: alignRight ? Alignment.centerRight : null,
        child: Text(text).muted().semiBold(),
      ),
    );
  }
  // Helper to build a regular body cell with optional right alignment.
  TableCell buildCell(String text, [bool alignRight = false]) {
    return TableCell(
      child: Container(
        padding: const EdgeInsets.all(8),
        alignment: alignRight ? Alignment.centerRight : null,
        child: Text(text),
      ),
    );
  }
  @override
  Widget build(BuildContext context) {
    return Table(
      rows: [
        // Header row: typically use TableHeader, but a TableRow works for simple cases.
        TableRow(
          cells: [
            buildHeaderCell('Invoice'),
            buildHeaderCell('Status'),
            buildHeaderCell('Method'),
            buildHeaderCell('Amount', true),
          ],
        ),
        // Body rows with invoice data.
        TableRow(
          cells: [
            buildCell('INV001'),
            buildCell('Paid'),
            buildCell('Credit Card'),
            buildCell('\$250.00', true),
          ],
        ),
        TableRow(
          cells: [
            buildCell('INV002'),
            buildCell('Pending'),
            buildCell('PayPal'),
            buildCell('\$150.00', true),
          ],
        ),
        TableRow(
          cells: [
            buildCell('INV003'),
            buildCell('Unpaid'),
            buildCell('Bank Transfer'),
            buildCell('\$350.00', true),
          ],
        ),
        TableRow(
          cells: [
            buildCell('INV004'),
            buildCell('Paid'),
            buildCell('Credit Card'),
            buildCell('\$450.00', true),
          ],
        ),
        TableRow(
          cells: [
            buildCell('INV005'),
            buildCell('Paid'),
            buildCell('PayPal'),
            buildCell('\$550.00', true),
          ],
        ),
        TableRow(
          cells: [
            buildCell('INV006'),
            buildCell('Pending'),
            buildCell('Bank Transfer'),
            buildCell('\$200.00', true),
          ],
        ),
        TableRow(
          cells: [
            buildCell('INV007'),
            buildCell('Unpaid'),
            buildCell('Credit Card'),
            buildCell('\$300.00', true),
          ],
        ),
        // Footer supports spanning across columns via TableCell.columnSpan.
        TableFooter(
          cells: [
            TableCell(
              columnSpan: 4,
              child: Container(
                padding: const EdgeInsets.all(8),
                child: Row(
                  children: [
                    const Text('Total'),
                    Expanded(
                      child: Align(
                        alignment: Alignment.centerRight,
                        child: const Text('\$2,300.00').semiBold(),
                      ),
                    ),
                  ],
                ),
              ),
            ),
          ],
        ),
      ],
    );
  }
}
# File: ./lib/pages/docs/components/table/table_example_3.dart
import 'dart:ui';
import 'package:shadcn_flutter/shadcn_flutter.dart';
// Demonstrates a scrollable Table hooked to ScrollableClient with frozen
// rows/columns and diagonal drag panning.
class TableExample3 extends StatefulWidget {
  const TableExample3({super.key});
  @override
  State<TableExample3> createState() => _TableExample3State();
}
class _TableExample3State extends State<TableExample3> {
  // Builds a bordered cell; amounts can be right-aligned by passing true.
  TableCell buildCell(String text, [bool alignRight = false]) {
    final theme = Theme.of(context);
    return TableCell(
      theme: TableCellTheme(
        border: WidgetStatePropertyAll(
          Border.all(
            color: theme.colorScheme.border,
            strokeAlign: BorderSide.strokeAlignCenter,
          ),
        ),
      ),
      child: Container(
        padding: const EdgeInsets.all(8),
        alignment: alignRight ? Alignment.topRight : null,
        child: Text(text),
      ),
    );
  }
  @override
  Widget build(BuildContext context) {
    return ScrollConfiguration(
      behavior: ScrollConfiguration.of(context).copyWith(
        dragDevices: {
          PointerDeviceKind.touch,
          PointerDeviceKind.mouse,
          PointerDeviceKind.trackpad,
        },
        // Disable overscroll glow and bouncing to keep the table steady.
        overscroll: false,
      ),
      child: SizedBox(
        height: 400,
        child: OutlinedContainer(
          child: ScrollableClient(
              // Allow simultaneous horizontal and vertical drags for panning.
              diagonalDragBehavior: DiagonalDragBehavior.free,
              builder: (context, offset, viewportSize, child) {
                return Table(
                  // Hook the table's scroll offsets to the ScrollableClient.
                  horizontalOffset: offset.dx,
                  verticalOffset: offset.dy,
                  // The viewport tells the table how much content area is visible.
                  viewportSize: viewportSize,
                  // Fixed sizes for consistent cell dimensions.
                  defaultColumnWidth: const FixedTableSize(150),
                  defaultRowHeight: const FixedTableSize(40),
                  // Freeze the first and fourth rows, and the first and third columns.
                  // These rows/columns stay pinned while the rest scrolls.
                  frozenCells: const FrozenTableData(
                    frozenRows: [
                      TableRef(0),
                      TableRef(3),
                    ],
                    frozenColumns: [
                      TableRef(0),
                      TableRef(2),
                    ],
                  ),
                  rows: [
                    TableHeader(
                      cells: [
                        buildCell('Invoice'),
                        buildCell('Status'),
                        buildCell('Method'),
                        buildCell('Amount', true),
                        buildCell('Verification'),
                        buildCell('Last Updated'),
                      ],
                    ),
                    TableRow(
                      cells: [
                        buildCell('INV001'),
                        buildCell('Paid'),
                        buildCell('Credit Card'),
                        buildCell('\$250.00', true),
                        buildCell('Verified'),
                        buildCell('2 hours ago'),
                      ],
                    ),
                    TableRow(
                      cells: [
                        buildCell('INV002'),
                        buildCell('Pending'),
                        buildCell('PayPal'),
                        buildCell('\$150.00', true),
                        buildCell('Pending'),
                        buildCell('1 day ago'),
                      ],
                    ),
                    TableRow(
                      cells: [
                        buildCell('INV003'),
                        buildCell('Unpaid'),
                        buildCell('Bank Transfer'),
                        buildCell('\$350.00', true),
                        buildCell('Unverified'),
                        buildCell('1 week ago'),
                      ],
                    ),
                    TableRow(
                      cells: [
                        buildCell('INV004'),
                        buildCell('Paid'),
                        buildCell('Credit Card'),
                        buildCell('\$450.00', true),
                        buildCell('Verified'),
                        buildCell('2 weeks ago'),
                      ],
                    ),
                    TableRow(
                      cells: [
                        buildCell('INV005'),
                        buildCell('Paid'),
                        buildCell('PayPal'),
                        buildCell('\$550.00', true),
                        buildCell('Verified'),
                        buildCell('3 weeks ago'),
                      ],
                    ),
                    TableRow(
                      cells: [
                        buildCell('INV006'),
                        buildCell('Pending'),
                        buildCell('Bank Transfer'),
                        buildCell('\$200.00', true),
                        buildCell('Pending'),
                        buildCell('1 month ago'),
                      ],
                    ),
                    TableRow(
                      cells: [
                        buildCell('INV007'),
                        buildCell('Unpaid'),
                        buildCell('Credit Card'),
                        buildCell('\$300.00', true),
                        buildCell('Unverified'),
                        buildCell('1 year ago'),
                      ],
                    ),
                    TableRow(
                      cells: [
                        buildCell('INV008'),
                        buildCell('Paid'),
                        buildCell('Credit Card'),
                        buildCell('\$250.00', true),
                        buildCell('Verified'),
                        buildCell('2 hours ago'),
                      ],
                    ),
                    TableRow(
                      cells: [
                        buildCell('INV009'),
                        buildCell('Pending'),
                        buildCell('PayPal'),
                        buildCell('\$150.00', true),
                        buildCell('Pending'),
                        buildCell('1 day ago'),
                      ],
                    ),
                    TableRow(
                      cells: [
                        buildCell('INV010'),
                        buildCell('Unpaid'),
                        buildCell('Bank Transfer'),
                        buildCell('\$350.00', true),
                        buildCell('Unverified'),
                        buildCell('1 week ago'),
                      ],
                    ),
                    TableRow(
                      cells: [
                        buildCell('INV011'),
                        buildCell('Paid'),
                        buildCell('Credit Card'),
                        buildCell('\$450.00', true),
                        buildCell('Verified'),
                        buildCell('2 weeks ago'),
                      ],
                    ),
                    TableRow(
                      cells: [
                        buildCell('INV012'),
                        buildCell('Paid'),
                        buildCell('PayPal'),
                        buildCell('\$550.00', true),
                        buildCell('Verified'),
                        buildCell('3 weeks ago'),
                      ],
                    ),
                    TableRow(
                      cells: [
                        buildCell('INV013'),
                        buildCell('Pending'),
                        buildCell('Bank Transfer'),
                        buildCell('\$200.00', true),
                        buildCell('Pending'),
                        buildCell('1 month ago'),
                      ],
                    ),
                    TableRow(
                      cells: [
                        buildCell('INV014'),
                        buildCell('Unpaid'),
                        buildCell('Credit Card'),
                        buildCell('\$300.00', true),
                        buildCell('Unverified'),
                        buildCell('1 year ago'),
                      ],
                    ),
                  ],
                );
              }),
        ),
      ),
    );
  }
}
# File: ./lib/pages/docs/components/table/table_example_2.dart
import 'package:shadcn_flutter/shadcn_flutter.dart';
// Demonstrates ResizableTable with controller defaults (sizes/constraints)
// and thin per-cell borders; users can drag to resize columns/rows.
class TableExample2 extends StatefulWidget {
  const TableExample2({super.key});
  @override
  State<TableExample2> createState() => _TableExample2State();
}
class _TableExample2State extends State<TableExample2> {
  // Builds a single cell with a thin border using the theme's border color.
  // Optionally right-aligns the content (useful for numeric values).
  TableCell buildCell(String text, [bool alignRight = false]) {
    final theme = Theme.of(context);
    return TableCell(
      theme: TableCellTheme(
        border: WidgetStatePropertyAll(
          Border.all(
            color: theme.colorScheme.border,
            strokeAlign: BorderSide.strokeAlignCenter,
          ),
        ),
      ),
      child: Container(
        padding: const EdgeInsets.all(8),
        alignment: alignRight ? Alignment.topRight : null,
        child: Text(text),
      ),
    );
  }
  // Controller sets defaults for column/row sizes and min constraints.
  // Users can still drag to resize each column and row at runtime.
  final ResizableTableController controller = ResizableTableController(
    defaultColumnWidth: 150,
    defaultRowHeight: 40,
    defaultHeightConstraint: const ConstrainedTableSize(min: 40),
    defaultWidthConstraint: const ConstrainedTableSize(min: 80),
  );
  @override
  Widget build(BuildContext context) {
    return OutlinedContainer(
      child: ResizableTable(
        controller: controller,
        // A header row followed by regular rows; all cells share the same
        // border/spacing style via buildCell.
        rows: [
          TableHeader(
            cells: [
              buildCell('Invoice'),
              buildCell('Status'),
              buildCell('Method'),
              buildCell('Amount', true),
            ],
          ),
          TableRow(
            cells: [
              buildCell('INV001'),
              buildCell('Paid'),
              buildCell('Credit Card'),
              buildCell('\$250.00', true),
            ],
          ),
          TableRow(
            cells: [
              buildCell('INV002'),
              buildCell('Pending'),
              buildCell('PayPal'),
              buildCell('\$150.00', true),
            ],
          ),
          TableRow(
            cells: [
              buildCell('INV003'),
              buildCell('Unpaid'),
              buildCell('Bank Transfer'),
              buildCell('\$350.00', true),
            ],
          ),
          TableRow(
            cells: [
              buildCell('INV004'),
              buildCell('Paid'),
              buildCell('Credit Card'),
              buildCell('\$450.00', true),
            ],
          ),
          TableRow(
            cells: [
              buildCell('INV005'),
              buildCell('Paid'),
              buildCell('PayPal'),
              buildCell('\$550.00', true),
            ],
          ),
          TableRow(
            cells: [
              buildCell('INV006'),
              buildCell('Pending'),
              buildCell('Bank Transfer'),
              buildCell('\$200.00', true),
            ],
          ),
          TableRow(
            cells: [
              buildCell('INV007'),
              buildCell('Unpaid'),
              buildCell('Credit Card'),
              buildCell('\$300.00', true),
            ],
          ),
          TableRow(
            cells: [
              buildCell('INV008'),
              buildCell('Paid'),
              buildCell('Credit Card'),
              buildCell('\$250.00', true),
            ],
          ),
          TableRow(
            cells: [
              buildCell('INV009'),
              buildCell('Pending'),
              buildCell('PayPal'),
              buildCell('\$150.00', true),
            ],
          ),
          TableRow(
            cells: [
              buildCell('INV010'),
              buildCell('Unpaid'),
              buildCell('Bank Transfer'),
              buildCell('\$350.00', true),
            ],
          ),
        ],
      ),
    );
  }
}
# File: ./lib/pages/docs/components/dialog/dialog_example_1.dart
import 'package:shadcn_flutter/shadcn_flutter.dart';
/// Dialog with a simple profile edit form.
///
/// Opens an [AlertDialog] containing a small form. When the user taps
/// "Save changes", the dialog closes and returns the form values via
/// [Navigator.pop].
class DialogExample1 extends StatelessWidget {
  const DialogExample1({super.key});
  @override
  Widget build(BuildContext context) {
    return PrimaryButton(
      onPressed: () {
        // Present a Material dialog on top of the current route.
        showDialog(
          context: context,
          builder: (context) {
            final FormController controller = FormController();
            return AlertDialog(
              title: const Text('Edit profile'),
              content: Column(
                mainAxisSize: MainAxisSize.min,
                crossAxisAlignment: CrossAxisAlignment.start,
                children: [
                  const Text(
                      'Make changes to your profile here. Click save when you\'re done'),
                  const Gap(16),
                  ConstrainedBox(
                    constraints: const BoxConstraints(maxWidth: 400),
                    child: Form(
                      controller: controller,
                      child: const FormTableLayout(rows: [
                        FormField<String>(
                          key: FormKey(#name),
                          label: Text('Name'),
                          child: TextField(
                            initialValue: 'Thito Yalasatria Sunarya',
                            autofocus: true,
                          ),
                        ),
                        FormField<String>(
                          key: FormKey(#username),
                          label: Text('Username'),
                          child: TextField(
                            initialValue: '@sunaryathito',
                          ),
                        ),
                      ]),
                    ).withPadding(vertical: 16),
                  ),
                ],
              ),
              actions: [
                PrimaryButton(
                  child: const Text('Save changes'),
                  onPressed: () {
                    // Return the form values and close the dialog.
                    Navigator.of(context).pop(controller.values);
                  },
                ),
              ],
            );
          },
        );
      },
      child: const Text('Edit Profile'),
    );
  }
}
# File: ./lib/pages/docs/components/popover/popover_example_1.dart
import 'package:flutter/foundation.dart';
import 'package:shadcn_flutter/shadcn_flutter.dart';
// Shows how to open a contextual popover anchored to a button, with a custom
// overlay barrier and a simple form inside. The popover closes via
// closeOverlay(context) or when the user taps outside the barrier.
class PopoverExample1 extends StatelessWidget {
  const PopoverExample1({super.key});
  @override
  Widget build(BuildContext context) {
    final theme = Theme.of(context);
    return PrimaryButton(
      onPressed: () {
        showPopover(
          context: context,
          // Position the popover above the button, shifted by 8px.
          alignment: Alignment.topCenter,
          offset: const Offset(0, 8),
          // Unless you have full opacity surface,
          // you should explicitly set the overlay barrier.
          overlayBarrier: OverlayBarrier(
            borderRadius: theme.borderRadiusLg,
          ),
          builder: (context) {
            return ModalContainer(
              child: SizedBox(
                width: 300,
                child: Column(
                  mainAxisSize: MainAxisSize.min,
                  crossAxisAlignment: CrossAxisAlignment.stretch,
                  children: [
                    const Text('Dimensions').large().medium(),
                    const Text('Set the dimensions for the layer.').muted(),
                    Form(
                      controller: FormController(),
                      // Compact grid layout for label/field rows.
                      child: const FormTableLayout(
                        rows: [
                          FormField<double>(
                            key: FormKey(#width),
                            label: Text('Width'),
                            child: TextField(
                              initialValue: '100%',
                            ),
                          ),
                          FormField<double>(
                            key: FormKey(#maxWidth),
                            label: Text('Max. Width'),
                            child: TextField(
                              initialValue: '300px',
                            ),
                          ),
                          FormField<double>(
                            key: FormKey(#height),
                            label: Text('Height'),
                            child: TextField(
                              initialValue: '25px',
                            ),
                          ),
                          FormField<double>(
                            key: FormKey(#maxHeight),
                            label: Text('Max. Height'),
                            child: TextField(
                              initialValue: 'none',
                            ),
                          ),
                        ],
                        spacing: 8,
                      ),
                    ).withPadding(vertical: 16),
                    PrimaryButton(
                      onPressed: () {
                        // Close the popover and resolve the returned future.
                        closeOverlay(context);
                      },
                      child: const Text('Submit'),
                    ),
                  ],
                ),
              ),
            );
          },
        ).future.then((_) {
          // Optional completion hook after the popover is dismissed.
          if (kDebugMode) {
            print('Popover closed');
          }
        });
      },
      child: const Text('Open popover'),
    );
  }
}
# File: ./lib/pages/docs/components/breadcrumb/breadcrumb_example_1.dart
import 'package:shadcn_flutter/shadcn_flutter.dart';
/// Breadcrumb with arrow separators.
///
/// Demonstrates how to compose a [Breadcrumb] from a series of items,
/// mixing interactive [TextButton]s and static labels. The `separator`
/// controls the visual delimiter between items.
class BreadcrumbExample1 extends StatelessWidget {
  const BreadcrumbExample1({super.key});
  @override
  Widget build(BuildContext context) {
    return Breadcrumb(
      // Use a built-in arrow separator for a conventional look.
      separator: Breadcrumb.arrowSeparator,
      children: [
        TextButton(
          onPressed: () {},
          density: ButtonDensity.compact,
          child: const Text('Home'),
        ),
        const MoreDots(),
        TextButton(
          onPressed: () {},
          density: ButtonDensity.compact,
          child: const Text('Components'),
        ),
        // Final segment as a non-interactive label.
        const Text('Breadcrumb'),
      ],
    );
  }
}
# File: ./lib/pages/docs/components/dot_indicator/dot_indicator_example_1.dart
import 'package:shadcn_flutter/shadcn_flutter.dart';
class DotIndicatorExample1 extends StatefulWidget {
  const DotIndicatorExample1({super.key});
  @override
  State<DotIndicatorExample1> createState() => _DotIndicatorExample1State();
}
class _DotIndicatorExample1State extends State<DotIndicatorExample1> {
  int _index = 0;
  @override
  Widget build(BuildContext context) {
    // A simple pager-like dot indicator with 5 steps.
    // Tap/click updates the current index via onChanged.
    return DotIndicator(
        index: _index,
        length: 5,
        onChanged: (index) {
          setState(() {
            _index = index;
          });
        });
  }
}
# File: ./lib/pages/docs/components/resizable/resizable_example_7.dart
import 'dart:math';
import 'package:shadcn_flutter/shadcn_flutter.dart';
class ResizableExample7 extends StatefulWidget {
  const ResizableExample7({super.key});
  @override
  State<ResizableExample7> createState() => _ResizableExample7State();
}
class _ResizableExample7State extends State<ResizableExample7> {
  // Dynamic list of colors to render each resizable pane.
  final List<Color> _items = List.generate(2, (index) => _generateColor());
  static Color _generateColor() {
    Random random = Random();
    return HSVColor.fromAHSV(
      1.0,
      random.nextInt(360).toDouble(),
      0.8,
      0.8,
    ).toColor();
  }
  @override
  Widget build(BuildContext context) {
    return OutlinedContainer(
      clipBehavior: Clip.antiAlias,
      child: Column(
        mainAxisSize: MainAxisSize.min,
        spacing: 12,
        children: [
          ResizablePanel.vertical(
            children: [
              for (int i = 0; i < _items.length; i++)
                ResizablePane(
                  // Use a ValueKey derived from the color so Flutter can track panes across insert/remove.
                  key: ValueKey(_items[i].toARGB32()),
                  initialSize: 200,
                  minSize: 100,
                  child: Container(
                    color: _items[i],
                    child: Center(
                      child: Column(
                        mainAxisSize: MainAxisSize.min,
                        children: [
                          TextButton(
                            child: const Text('Insert Before'),
                            onPressed: () {
                              setState(() {
                                // Insert a new pane before the current one.
                                _items.insert(i, _generateColor());
                              });
                            },
                          ),
                          TextButton(
                            child: const Text('Remove'),
                            onPressed: () {
                              setState(() {
                                // Remove this pane.
                                _items.removeAt(i);
                              });
                            },
                          ),
                          TextButton(
                            child: const Text('Insert After'),
                            onPressed: () {
                              setState(() {
                                // Insert a new pane after the current one.
                                _items.insert(i + 1, _generateColor());
                              });
                            },
                          ),
                        ],
                      ),
                    ),
                  ),
                ),
            ],
          ),
          PrimaryButton(
            child: const Text('Add'),
            onPressed: () {
              setState(() {
                // Append a new pane at the end.
                _items.add(_generateColor());
              });
            },
          ),
        ],
      ),
    );
  }
}
# File: ./lib/pages/docs/components/resizable/resizable_example_4.dart
import 'package:docs/pages/docs/components/carousel_example.dart';
import 'package:shadcn_flutter/shadcn_flutter.dart';
class ResizableExample4 extends StatefulWidget {
  const ResizableExample4({super.key});
  @override
  State<ResizableExample4> createState() => _ResizableExample4State();
}
class _ResizableExample4State extends State<ResizableExample4> {
  // Controlled panes: each pane has its own controller so we can read/write size
  // and call helper methods (tryExpandSize, tryCollapse, etc.).
  final AbsoluteResizablePaneController controller1 =
      AbsoluteResizablePaneController(80);
  final AbsoluteResizablePaneController controller2 =
      AbsoluteResizablePaneController(80);
  final AbsoluteResizablePaneController controller3 =
      AbsoluteResizablePaneController(120);
  final AbsoluteResizablePaneController controller4 =
      AbsoluteResizablePaneController(80);
  final AbsoluteResizablePaneController controller5 =
      AbsoluteResizablePaneController(80);
  @override
  Widget build(BuildContext context) {
    return Column(
      children: [
        OutlinedContainer(
          clipBehavior: Clip.antiAlias,
          child: ResizablePanel.horizontal(
            children: [
              ResizablePane.controlled(
                // Bind pane size to controller1 (initial 80px).
                controller: controller1,
                child: const NumberedContainer(
                  index: 0,
                  height: 200,
                  fill: false,
                ),
              ),
              ResizablePane.controlled(
                controller: controller2,
                child: const NumberedContainer(
                  index: 1,
                  height: 200,
                  fill: false,
                ),
              ),
              ResizablePane.controlled(
                controller: controller3,
                // Optional constraint: this pane cannot grow beyond 200px.
                maxSize: 200,
                child: const NumberedContainer(
                  index: 2,
                  height: 200,
                  fill: false,
                ),
              ),
              ResizablePane.controlled(
                controller: controller4,
                child: const NumberedContainer(
                  index: 3,
                  height: 200,
                  fill: false,
                ),
              ),
              ResizablePane.controlled(
                controller: controller5,
                // Min size prevents the pane from being dragged smaller than 80px.
                minSize: 80,
                // When collapsed, this pane will reduce to 20px instead of disappearing.
                collapsedSize: 20,
                child: const NumberedContainer(
                  index: 4,
                  height: 200,
                  fill: false,
                ),
              ),
            ],
          ),
        ),
        const Gap(48),
        Wrap(
          spacing: 16,
          runSpacing: 16,
          children: [
            PrimaryButton(
              onPressed: () {
                // Restore all panes to their initial sizes.
                controller1.size = 80;
                controller2.size = 80;
                controller3.size = 120;
                controller4.size = 80;
                controller5.size = 80;
              },
              child: const Text('Reset'),
            ),
            PrimaryButton(
              onPressed: () {
                // Attempt to grow pane 2 (controller3) by +20px.
                controller3.tryExpandSize(20);
              },
              child: const Text('Expand Panel 2'),
            ),
            PrimaryButton(
              onPressed: () {
                // Attempt to shrink pane 2 (controller3) by -20px.
                controller3.tryExpandSize(-20);
              },
              child: const Text('Shrink Panel 2'),
            ),
            PrimaryButton(
              onPressed: () {
                // Modify another pane's size incrementally.
                controller2.tryExpandSize(20);
              },
              child: const Text('Expand Panel 1'),
            ),
            PrimaryButton(
              onPressed: () {
                controller2.tryExpandSize(-20);
              },
              child: const Text('Shrink Panel 1'),
            ),
            PrimaryButton(
              onPressed: () {
                controller5.tryExpandSize(20);
              },
              child: const Text('Expand Panel 4'),
            ),
            PrimaryButton(
              onPressed: () {
                controller5.tryExpandSize(-20);
              },
              child: const Text('Shrink Panel 4'),
            ),
            PrimaryButton(
              onPressed: () {
                // Collapse reduces the pane to its 'collapsedSize'.
                controller5.tryCollapse();
              },
              child: const Text('Collapse Panel 4'),
            ),
            PrimaryButton(
              onPressed: () {
                // Expand restores from the collapsed state.
                controller5.tryExpand();
              },
              child: const Text('Expand Panel 4'),
            ),
          ],
        )
      ],
    );
  }
}
# File: ./lib/pages/docs/components/resizable/resizable_example_2.dart
import 'package:docs/pages/docs/components/carousel_example.dart';
import 'package:shadcn_flutter/shadcn_flutter.dart';
class ResizableExample2 extends StatefulWidget {
  const ResizableExample2({super.key});
  @override
  State<ResizableExample2> createState() => _ResizableExample2State();
}
class _ResizableExample2State extends State<ResizableExample2> {
  @override
  Widget build(BuildContext context) {
    return const OutlinedContainer(
      clipBehavior: Clip.antiAlias,
      // A vertical panel splits available height into multiple resizable rows (panes).
      child: ResizablePanel.vertical(
        children: [
          ResizablePane(
            // Initial height in logical pixels for this row.
            initialSize: 80,
            child: NumberedContainer(
              index: 0,
              width: 200,
              fill: false,
            ),
          ),
          ResizablePane(
            initialSize: 120,
            child: NumberedContainer(
              index: 1,
              width: 200,
              fill: false,
            ),
          ),
          ResizablePane(
            initialSize: 80,
            child: NumberedContainer(
              index: 2,
              width: 200,
              fill: false,
            ),
          ),
        ],
      ),
    );
  }
}
# File: ./lib/pages/docs/components/resizable/resizable_example_3.dart
import 'package:docs/pages/docs/components/carousel_example.dart';
import 'package:shadcn_flutter/shadcn_flutter.dart';
class ResizableExample3 extends StatefulWidget {
  const ResizableExample3({super.key});
  @override
  State<ResizableExample3> createState() => _ResizableExample3State();
}
class _ResizableExample3State extends State<ResizableExample3> {
  @override
  Widget build(BuildContext context) {
    return OutlinedContainer(
      clipBehavior: Clip.antiAlias,
      child: ResizablePanel.horizontal(
        // Provide a custom dragger appearance/behavior for the splitters.
        draggerBuilder: (context) {
          return const HorizontalResizableDragger();
        },
        children: const [
          ResizablePane(
            initialSize: 80,
            child: NumberedContainer(
              index: 0,
              height: 200,
              fill: false,
            ),
          ),
          ResizablePane(
            initialSize: 80,
            child: NumberedContainer(
              index: 1,
              height: 200,
              fill: false,
            ),
          ),
          ResizablePane(
            initialSize: 120,
            child: NumberedContainer(
              index: 2,
              height: 200,
              fill: false,
            ),
          ),
          ResizablePane(
            initialSize: 80,
            child: NumberedContainer(
              index: 3,
              height: 200,
              fill: false,
            ),
          ),
          ResizablePane(
            initialSize: 80,
            child: NumberedContainer(
              index: 4,
              height: 200,
              fill: false,
            ),
          ),
        ],
      ),
    );
  }
}
# File: ./lib/pages/docs/components/resizable/resizable_example_5.dart
import 'package:shadcn_flutter/shadcn_flutter.dart';
class ResizableExample5 extends StatefulWidget {
  const ResizableExample5({super.key});
  @override
  State<ResizableExample5> createState() => _ResizableExample5State();
}
class _ResizableExample5State extends State<ResizableExample5> {
  final ResizablePaneController controller =
      AbsoluteResizablePaneController(120);
  final ResizablePaneController controller2 =
      AbsoluteResizablePaneController(120);
  @override
  Widget build(BuildContext context) {
    return OutlinedContainer(
      clipBehavior: Clip.antiAlias,
      child: ResizablePanel.horizontal(
        children: [
          ResizablePane.controlled(
            // This controlled pane supports collapsing with a minimum and collapsed size.
            minSize: 100,
            collapsedSize: 40,
            controller: controller,
            child: AnimatedBuilder(
              animation: controller,
              builder: (context, child) {
                // Render a different UI when the pane is collapsed.
                if (controller.collapsed) {
                  return Container(
                    alignment: Alignment.center,
                    height: 200,
                    child: const RotatedBox(
                      quarterTurns: -1,
                      child: Text('Collapsed'),
                    ),
                  );
                }
                return Container(
                  alignment: Alignment.center,
                  height: 200,
                  child: const Text('Expanded'),
                );
              },
            ),
          ),
          ResizablePane(
            // A standard resizable pane with an absolute initial width.
            initialSize: 300,
            child: Container(
              alignment: Alignment.center,
              height: 200,
              child: const Text('Resizable'),
            ),
          ),
          ResizablePane.controlled(
            minSize: 100,
            collapsedSize: 40,
            controller: controller2,
            child: AnimatedBuilder(
              animation: controller2,
              builder: (context, child) {
                if (controller2.collapsed) {
                  return Container(
                    alignment: Alignment.center,
                    height: 200,
                    child: const RotatedBox(
                      quarterTurns: -1,
                      child: Text('Collapsed'),
                    ),
                  );
                }
                return Container(
                  alignment: Alignment.center,
                  height: 200,
                  child: const Text('Expanded'),
                );
              },
            ),
          ),
        ],
      ),
    );
  }
}
# File: ./lib/pages/docs/components/resizable/resizable_example_1.dart
import 'package:docs/pages/docs/components/carousel_example.dart';
import 'package:shadcn_flutter/shadcn_flutter.dart';
class ResizableExample1 extends StatefulWidget {
  const ResizableExample1({super.key});
  @override
  State<ResizableExample1> createState() => _ResizableExample1State();
}
class _ResizableExample1State extends State<ResizableExample1> {
  @override
  Widget build(BuildContext context) {
    return const OutlinedContainer(
      clipBehavior: Clip.antiAlias,
      // A horizontal panel splits available width into multiple resizable panes.
      child: ResizablePanel.horizontal(
        children: [
          ResizablePane(
            // Initial width in logical pixels for this pane.
            initialSize: 80,
            child: NumberedContainer(
              index: 0,
              height: 200,
              fill: false,
            ),
          ),
          ResizablePane(
            initialSize: 80,
            child: NumberedContainer(
              index: 1,
              height: 200,
              fill: false,
            ),
          ),
          ResizablePane(
            initialSize: 120,
            child: NumberedContainer(
              index: 2,
              height: 200,
              fill: false,
            ),
          ),
          ResizablePane(
            initialSize: 80,
            child: NumberedContainer(
              index: 3,
              height: 200,
              fill: false,
            ),
          ),
          ResizablePane(
            initialSize: 80,
            child: NumberedContainer(
              index: 4,
              height: 200,
              fill: false,
            ),
          ),
        ],
      ),
    );
  }
}
# File: ./lib/pages/docs/components/resizable/resizable_example_6.dart
import 'package:docs/pages/docs/components/carousel_example.dart';
import 'package:shadcn_flutter/shadcn_flutter.dart';
class ResizableExample6 extends StatefulWidget {
  const ResizableExample6({super.key});
  @override
  State<ResizableExample6> createState() => _ResizableExample6State();
}
class _ResizableExample6State extends State<ResizableExample6> {
  @override
  Widget build(BuildContext context) {
    return const OutlinedContainer(
      clipBehavior: Clip.antiAlias,
      // Demonstrates nesting panels: horizontal root with vertical and horizontal children.
      child: ResizablePanel.horizontal(
        children: [
          ResizablePane(
            initialSize: 100,
            minSize: 40,
            child: NumberedContainer(
              index: 0,
              height: 200,
              fill: false,
            ),
          ),
          ResizablePane(
            minSize: 100,
            initialSize: 300,
            // Middle pane is its own vertical resizable group.
            child: ResizablePanel.vertical(
              children: [
                ResizablePane(
                  initialSize: 80,
                  minSize: 40,
                  child: NumberedContainer(
                    index: 1,
                    fill: false,
                  ),
                ),
                ResizablePane(
                  minSize: 40,
                  initialSize: 120,
                  // This pane contains a horizontal panel using flexible panes below.
                  child: ResizablePanel.horizontal(
                    children: [
                      // Flex panes share remaining space proportionally.
                      ResizablePane.flex(
                        child: NumberedContainer(
                          index: 2,
                          fill: false,
                        ),
                      ),
                      ResizablePane.flex(
                        child: NumberedContainer(
                          index: 3,
                          fill: false,
                        ),
                      ),
                      ResizablePane.flex(
                        child: NumberedContainer(
                          index: 4,
                          fill: false,
                        ),
                      ),
                    ],
                  ),
                ),
              ],
            ),
          ),
          ResizablePane(
            initialSize: 100,
            minSize: 40,
            child: NumberedContainer(
              index: 5,
              height: 200,
              fill: false,
            ),
          ),
        ],
      ),
    );
  }
}
# File: ./lib/pages/docs/components/animated_value_builder/animated_value_builder_example_2.dart
import 'package:shadcn_flutter/shadcn_flutter.dart';
/// AnimatedValueBuilder example with an initial value and manual rebuild key.
///
/// Compared to the first example, this one:
/// - Specifies [initialValue] so the animation starts from transparent.
/// - Provides a [ValueKey] tied to [rebuildCount] to force the widget to
///   reset its internal animation state when desired.
class AnimatedValueBuilderExample2 extends StatefulWidget {
  const AnimatedValueBuilderExample2({super.key});
  @override
  State<AnimatedValueBuilderExample2> createState() =>
      _AnimatedValueBuilderExample2State();
}
class _AnimatedValueBuilderExample2State
    extends State<AnimatedValueBuilderExample2> {
  // The same color palette as before.
  List<Color> colors = [
    Colors.red,
    Colors.green,
    Colors.blue,
  ];
  // Current target index.
  int index = 0;
  // Changing this key forces the AnimatedValueBuilder to rebuild from scratch.
  int rebuildCount = 0;
  @override
  Widget build(BuildContext context) {
    return Column(
      children: [
        AnimatedValueBuilder(
          // When the key changes, Flutter treats this as a new widget
          // instance and reinitializes the animation.
          key: ValueKey(rebuildCount),
          value: colors[index],
          // Start from the same color but fully transparent, then animate in.
          initialValue: colors[index].withValues(alpha: 0),
          duration: const Duration(seconds: 1),
          lerp: Color.lerp,
          builder: (context, value, child) {
            return Container(
              width: 100,
              height: 100,
              color: value,
            );
          },
        ),
        const Gap(32),
        Row(
          mainAxisSize: MainAxisSize.min,
          children: [
            PrimaryButton(
              onPressed: () {
                setState(() {
                  // Change the target color to trigger a new tween.
                  index = (index + 1) % colors.length;
                });
              },
              child: const Text('Change Color'),
            ),
            const Gap(24),
            PrimaryButton(
              onPressed: () {
                setState(() {
                  // Force the AnimatedValueBuilder to restart by changing the key.
                  rebuildCount++;
                });
              },
              child: const Text('Rebuild'),
            ),
          ],
        ),
      ],
    );
  }
}
# File: ./lib/pages/docs/components/animated_value_builder/animated_value_builder_example_1.dart
import 'package:shadcn_flutter/shadcn_flutter.dart';
/// AnimatedValueBuilder example: animating between colors.
///
/// This demonstrates how [AnimatedValueBuilder] can animate any value
/// given a `lerp` function. Here we animate a [Color] by using [Color.lerp]
/// as the interpolation function and switch the target color on button press.
class AnimatedValueBuilderExample1 extends StatefulWidget {
  const AnimatedValueBuilderExample1({super.key});
  @override
  State<AnimatedValueBuilderExample1> createState() =>
      _AnimatedValueBuilderExample1State();
}
class _AnimatedValueBuilderExample1State
    extends State<AnimatedValueBuilderExample1> {
  // A small palette to cycle through.
  List<Color> colors = [
    Colors.red,
    Colors.green,
    Colors.blue,
  ];
  // Index of the current target color.
  int index = 0;
  @override
  Widget build(BuildContext context) {
    return Column(
      children: [
        AnimatedValueBuilder(
          // The target value to animate towards.
          value: colors[index],
          // Duration of the tween between the previous and new value.
          duration: const Duration(seconds: 1),
          // The interpolation method between two colors.
          lerp: Color.lerp,
          // The builder exposes the current animated value on each frame.
          builder: (context, value, child) {
            return Container(
              width: 100,
              height: 100,
              color: value,
            );
          },
        ),
        const Gap(32),
        PrimaryButton(
          onPressed: () {
            setState(() {
              // Move to the next color cyclically to trigger a new animation.
              index = (index + 1) % colors.length;
            });
          },
          child: const Text('Change Color'),
        ),
      ],
    );
  }
}
# File: ./lib/pages/docs/components/multiselect/multiselect_example_3.dart
import 'dart:math';
import 'package:shadcn_flutter/shadcn_flutter.dart';
class MultiSelectExample3 extends StatefulWidget {
  const MultiSelectExample3({super.key});
  @override
  State<MultiSelectExample3> createState() => _MultiSelectExample3State();
}
class _MultiSelectExample3State extends State<MultiSelectExample3> {
  final Map<String, List<String>> fruits = {
    'Apple': ['Red Apple', 'Green Apple'],
    'Banana': ['Yellow Banana', 'Brown Banana'],
    'Lemon': ['Yellow Lemon', 'Green Lemon'],
    'Tomato': ['Red', 'Green', 'Yellow', 'Brown'],
  };
  Iterable<String>? selectedValues;
  Iterable<MapEntry<String, List<String>>> _filteredFruits(
      String searchQuery) sync* {
    for (final entry in fruits.entries) {
      final filteredValues = entry.value
          .where((value) => _filterName(value, searchQuery))
          .toList();
      if (filteredValues.isNotEmpty) {
        yield MapEntry(entry.key, filteredValues);
      } else if (_filterName(entry.key, searchQuery)) {
        yield entry;
      }
    }
  }
  bool _filterName(String name, String searchQuery) {
    return name.toLowerCase().contains(searchQuery);
  }
  Color _getColorByChip(String text) {
    Random random = Random(text.hashCode);
    double hue = random.nextDouble() * 360;
    return HSLColor.fromAHSL(1, hue, 0.5, 0.5).toColor();
  }
  @override
  Widget build(BuildContext context) {
    // Advanced multi-select with async loading, empty and loading builders,
    // and dynamic per-item styling.
    return MultiSelect<String>(
      itemBuilder: (context, item) {
        var color = _getColorByChip(item);
        return MultiSelectChip(
          value: item,
          style: const ButtonStyle.primary().withBackgroundColor(
            color: color,
            hoverColor: color.withLuminance(0.3),
          ),
          child: Text(item),
        );
      },
      popup: SelectPopup.builder(
        searchPlaceholder: const Text('Search fruit'),
        emptyBuilder: (context) {
          return const Center(
            child: Text('No fruit found'),
          );
        },
        loadingBuilder: (context) {
          return const Center(
            child: CircularProgressIndicator(),
          );
        },
        builder: (context, searchQuery) async {
          final filteredFruits = searchQuery == null
              ? fruits.entries.toList()
              : _filteredFruits(searchQuery).toList();
          // Simulate an async load to demonstrate loadingBuilder.
          await Future.delayed(const Duration(milliseconds: 500));
          return SelectItemBuilder(
            // Use childCount=0 to switch to emptyBuilder when there are no items.
            childCount: filteredFruits.isEmpty ? 0 : null,
            builder: (context, index) {
              final entry = filteredFruits[index % filteredFruits.length];
              return SelectGroup(
                headers: [
                  SelectLabel(
                    child: Text(entry.key),
                  ),
                ],
                children: [
                  for (final value in entry.value)
                    SelectItemButton(
                      value: value,
                      style: const ButtonStyle.ghost().withBackgroundColor(
                        hoverColor: _getColorByChip(value).withLuminance(0.3),
                      ),
                      child: Text(value),
                    ),
                ],
              );
            },
          );
        },
      ),
      onChanged: (value) {
        setState(() {
          selectedValues = value;
        });
      },
      constraints: const BoxConstraints(
        minWidth: 200,
      ),
      value: selectedValues,
      placeholder: const Text('Select a fruit'),
    );
  }
}
# File: ./lib/pages/docs/components/multiselect/multiselect_example_1.dart
import 'package:shadcn_flutter/shadcn_flutter.dart';
class MultiSelectExample1 extends StatefulWidget {
  const MultiSelectExample1({super.key});
  @override
  State<MultiSelectExample1> createState() => _MultiSelectExample1State();
}
class _MultiSelectExample1State extends State<MultiSelectExample1> {
  Iterable<String>? selectedValues;
  @override
  Widget build(BuildContext context) {
    // Basic multi-select with a popup list and chips as selected items.
    // onChanged returns the new iterable of selected values.
    return MultiSelect<String>(
      itemBuilder: (context, item) {
        // Render each selected value as a chip.
        return MultiSelectChip(value: item, child: Text(item));
      },
      popup: const SelectPopup(
          items: SelectItemList(children: [
        SelectItemButton(
          value: 'Apple',
          child: Text('Apple'),
        ),
        SelectItemButton(
          value: 'Banana',
          child: Text('Banana'),
        ),
        SelectItemButton(
          value: 'Cherry',
          child: Text('Cherry'),
        ),
      ])),
      onChanged: (value) {
        setState(() {
          selectedValues = value;
        });
      },
      constraints: const BoxConstraints(
        minWidth: 200,
      ),
      value: selectedValues,
      placeholder: const Text('Select a fruit'),
    );
  }
}
# File: ./lib/pages/docs/components/multiselect/multiselect_example_2.dart
import 'package:shadcn_flutter/shadcn_flutter.dart';
class MultiSelectExample2 extends StatefulWidget {
  const MultiSelectExample2({super.key});
  @override
  State<MultiSelectExample2> createState() => _MultiSelectExample2State();
}
class _MultiSelectExample2State extends State<MultiSelectExample2> {
  final Map<String, List<String>> fruits = {
    'Apple': ['Red Apple', 'Green Apple'],
    'Banana': ['Yellow Banana', 'Brown Banana'],
    'Lemon': ['Yellow Lemon', 'Green Lemon'],
    'Tomato': ['Red', 'Green', 'Yellow', 'Brown'],
  };
  Iterable<String>? selectedValues;
  Iterable<MapEntry<String, List<String>>> _filteredFruits(
      String searchQuery) sync* {
    for (final entry in fruits.entries) {
      final filteredValues = entry.value
          .where((value) => _filterName(value, searchQuery))
          .toList();
      if (filteredValues.isNotEmpty) {
        yield MapEntry(entry.key, filteredValues);
      } else if (_filterName(entry.key, searchQuery)) {
        yield entry;
      }
    }
  }
  bool _filterName(String name, String searchQuery) {
    return name.toLowerCase().contains(searchQuery);
  }
  @override
  Widget build(BuildContext context) {
    // Multi-select with grouped options and a search field.
    // The popup is built dynamically and groups items under a label.
    return MultiSelect<String>(
      itemBuilder: (context, item) {
        return MultiSelectChip(value: item, child: Text(item));
      },
      popup: SelectPopup.builder(
        searchPlaceholder: const Text('Search fruit'),
        builder: (context, searchQuery) {
          final filteredFruits = searchQuery == null
              ? fruits.entries
              : _filteredFruits(searchQuery);
          return SelectItemList(
            children: [
              for (final entry in filteredFruits)
                SelectGroup(
                  headers: [
                    SelectLabel(
                      child: Text(entry.key),
                    ),
                  ],
                  children: [
                    for (final value in entry.value)
                      SelectItemButton(
                        value: value,
                        child: Text(value),
                      ),
                  ],
                ),
            ],
          );
        },
      ),
      onChanged: (value) {
        setState(() {
          selectedValues = value;
        });
      },
      constraints: const BoxConstraints(
        minWidth: 200,
      ),
      value: selectedValues,
      placeholder: const Text('Select a fruit'),
    );
  }
}
# File: ./lib/pages/docs/components/material/cupertino_example_1.dart
import 'package:flutter/cupertino.dart';
import 'package:shadcn_flutter/shadcn_flutter.dart' as shadcnui;
class CupertinoExample1 extends StatefulWidget {
  const CupertinoExample1({super.key});
  @override
  State<CupertinoExample1> createState() => _CupertinoExample1State();
}
class _CupertinoExample1State extends State<CupertinoExample1> {
  int _counter = 0;
  @override
  Widget build(BuildContext context) {
    return CupertinoPageScaffold(
      navigationBar: const CupertinoNavigationBar(
        middle: Text('My Cupertino App'),
      ),
      child: Center(
        child: Column(
          mainAxisAlignment: MainAxisAlignment.center,
          children: <Widget>[
            Text(
              'You have pushed the button this many times:',
              style: CupertinoTheme.of(context).textTheme.textStyle,
            ),
            Text(
              '$_counter',
              style: CupertinoTheme.of(context).textTheme.navTitleTextStyle,
            ),
            const shadcnui.Gap(16),
            CupertinoButton.filled(
              onPressed: () => setState(() => _counter++),
              child: const Icon(CupertinoIcons.add),
            ),
            const shadcnui.Gap(64),
            // shadcn_flutter widgets can also be used in a Cupertino app.
            // This card mirrors the Material example but uses Cupertino dialogs.
            shadcnui.ShadcnUI(
                child: shadcnui.Card(
              child: Column(
                mainAxisSize: MainAxisSize.min,
                children: [
                  const Text(
                      'You can also use shadcn_flutter widgets inside Material widgets'),
                  const shadcnui.Gap(16),
                  shadcnui.PrimaryButton(
                    onPressed: () {
                      // Show a native Cupertino dialog
                      showCupertinoDialog(
                        context: context,
                        builder: (context) {
                          return CupertinoAlertDialog(
                            title: const Text('Hello'),
                            content: const Text('This is Cupertino dialog'),
                            actions: [
                              CupertinoDialogAction(
                                onPressed: () {
                                  Navigator.of(context).pop();
                                },
                                child: const Text('Close'),
                              ),
                            ],
                          );
                        },
                      );
                    },
                    child: const Text('Open Cupertino Dialog'),
                  ),
                  const shadcnui.Gap(8),
                  shadcnui.SecondaryButton(
                    onPressed: () {
                      // Show a shadcn_flutter dialog as a comparison
                      shadcnui.showDialog(
                        context: context,
                        builder: (context) {
                          return shadcnui.AlertDialog(
                            title: const Text('Hello'),
                            content:
                                const Text('This is shadcn_flutter dialog'),
                            actions: [
                              shadcnui.PrimaryButton(
                                onPressed: () {
                                  Navigator.of(context).pop();
                                },
                                child: const Text('Close'),
                              ),
                            ],
                          );
                        },
                      );
                    },
                    child: const Text('Open shadcn_flutter Dialog'),
                  ),
                ],
              ),
            )),
          ],
        ),
      ),
    );
  }
}
# File: ./lib/pages/docs/components/material/material_example_1.dart
import 'package:flutter/material.dart';
import 'package:shadcn_flutter/shadcn_flutter.dart' as shadcnui;
class MaterialExample1 extends StatefulWidget {
  const MaterialExample1({super.key});
  @override
  State<MaterialExample1> createState() => _MaterialExample1State();
}
class _MaterialExample1State extends State<MaterialExample1> {
  int _counter = 0;
  void _incrementCounter() {
    // Demonstrates using a Material SnackBar inside a typical Scaffold app.
    ScaffoldMessenger.of(context).showSnackBar(
      SnackBar(
        content: Text('You have pushed the button $_counter times'),
      ),
    );
    setState(() {
      _counter++;
    });
  }
  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(
        backgroundColor: Theme.of(context).colorScheme.inversePrimary,
        title: const Text('My Material App'),
      ),
      body: Center(
        child: Column(
          mainAxisAlignment: MainAxisAlignment.center,
          children: <Widget>[
            const Text(
              'You have pushed the button this many times:',
            ),
            Text(
              '$_counter',
              style: Theme.of(context).textTheme.headlineMedium,
            ),
            const shadcnui.Gap(64),
            // You can compose shadcn_flutter widgets inside a Material app.
            // Wrapping with ShadcnUI ensures inherited theme/semantics are properly applied.
            shadcnui.ShadcnUI(
                child: shadcnui.Card(
              child: Column(
                mainAxisSize: MainAxisSize.min,
                children: [
                  const Text(
                      'You can also use shadcn_flutter widgets inside Material widgets'),
                  const shadcnui.Gap(16),
                  shadcnui.PrimaryButton(
                    onPressed: () {
                      // Show a native Material dialog
                      showDialog(
                        context: context,
                        builder: (context) {
                          return AlertDialog(
                            title: const Text('Hello'),
                            content: const Text('This is Material dialog'),
                            actions: [
                              TextButton(
                                onPressed: () {
                                  Navigator.of(context).pop();
                                },
                                child: const Text('Close'),
                              ),
                            ],
                          );
                        },
                      );
                    },
                    child: const Text('Open Material Dialog'),
                  ),
                  const shadcnui.Gap(8),
                  shadcnui.SecondaryButton(
                    onPressed: () {
                      // Show a shadcn_flutter dialog side-by-side for comparison
                      shadcnui.showDialog(
                        context: context,
                        builder: (context) {
                          return shadcnui.AlertDialog(
                            title: const Text('Hello'),
                            content:
                                const Text('This is shadcn_flutter dialog'),
                            actions: [
                              shadcnui.PrimaryButton(
                                onPressed: () {
                                  Navigator.of(context).pop();
                                },
                                child: const Text('Close'),
                              ),
                            ],
                          );
                        },
                      );
                    },
                    child: const Text('Open shadcn_flutter Dialog'),
                  ),
                ],
              ),
            ))
          ],
        ),
      ),
      floatingActionButton: FloatingActionButton(
        onPressed: _incrementCounter,
        tooltip: 'Increment',
        child: const Icon(Icons.add),
      ),
    );
  }
}
# File: ./lib/pages/docs/components/select/select_example_4.dart
import 'package:shadcn_flutter/shadcn_flutter.dart';
class SelectExample4 extends StatefulWidget {
  const SelectExample4({super.key});
  @override
  State<SelectExample4> createState() => _SelectExample4State();
}
class _SelectExample4State extends State<SelectExample4> {
  String? selectedValue;
  @override
  Widget build(BuildContext context) {
    return Select<String>(
      itemBuilder: (context, item) {
        return Text(item);
      },
      popupConstraints: const BoxConstraints(
        maxHeight: 300,
        maxWidth: 200,
      ),
      onChanged: (value) {
        setState(() {
          selectedValue = value;
        });
      },
      value: selectedValue,
      placeholder: const Text('Select a fruit'),
      // Constrain popup width to its intrinsic content size (no virtualization in this variant).
      popupWidthConstraint: PopoverConstraint.intrinsic,
      // Use a simple non-virtualized popup; suitable for small lists.
      popup: const SelectPopup.noVirtualization(
        items: SelectItemList(
          children: [
            SelectItemButton(
              value: 'Apple',
              child: Text('Apple'),
            ),
            SelectItemButton(
              value: 'Banana',
              child: Text('Banana'),
            ),
            SelectItemButton(
              value: 'Cherry',
              child: Text('Cherry'),
            ),
          ],
        ),
      ),
    );
  }
}
# File: ./lib/pages/docs/components/select/select_example_2.dart
import 'package:shadcn_flutter/shadcn_flutter.dart';
class SelectExample2 extends StatefulWidget {
  const SelectExample2({super.key});
  @override
  State<SelectExample2> createState() => _SelectExample2State();
}
class _SelectExample2State extends State<SelectExample2> {
  final Map<String, List<String>> fruits = {
    'Apple': ['Red Apple', 'Green Apple'],
    'Banana': ['Yellow Banana', 'Brown Banana'],
    'Lemon': ['Yellow Lemon', 'Green Lemon'],
    'Tomato': ['Red', 'Green', 'Yellow', 'Brown'],
  };
  String? selectedValue;
  Iterable<MapEntry<String, List<String>>> _filteredFruits(
      String searchQuery) sync* {
    // Yield entries whose key or children match the current search query.
    for (final entry in fruits.entries) {
      final filteredValues = entry.value
          .where((value) => _filterName(value, searchQuery))
          .toList();
      if (filteredValues.isNotEmpty) {
        yield MapEntry(entry.key, filteredValues);
      } else if (_filterName(entry.key, searchQuery)) {
        yield entry;
      }
    }
  }
  bool _filterName(String name, String searchQuery) {
    // Case-insensitive substring filter.
    return name.toLowerCase().contains(searchQuery);
  }
  @override
  Widget build(BuildContext context) {
    return Select<String>(
      itemBuilder: (context, item) {
        return Text(item);
      },
      popup: SelectPopup.builder(
        // Provide a search field inside the popup.
        searchPlaceholder: const Text('Search fruit'),
        builder: (context, searchQuery) {
          // Filter entries by the user's search.
          final filteredFruits = searchQuery == null
              ? fruits.entries
              : _filteredFruits(searchQuery);
          return SelectItemList(
            children: [
              for (final entry in filteredFruits)
                SelectGroup(
                  // Group by category (e.g., Apple, Banana) with a header label.
                  headers: [
                    SelectLabel(
                      child: Text(entry.key),
                    ),
                  ],
                  children: [
                    for (final value in entry.value)
                      SelectItemButton(
                        value: value,
                        child: Text(value),
                      ),
                  ],
                ),
            ],
          );
        },
      ),
      onChanged: (value) {
        setState(() {
          selectedValue = value;
        });
      },
      constraints: const BoxConstraints(
        minWidth: 200,
      ),
      value: selectedValue,
      placeholder: const Text('Select a fruit'),
    );
  }
}
# File: ./lib/pages/docs/components/select/select_example_1.dart
import 'package:shadcn_flutter/shadcn_flutter.dart';
class SelectExample1 extends StatefulWidget {
  const SelectExample1({super.key});
  @override
  State<SelectExample1> createState() => _SelectExample1State();
}
class _SelectExample1State extends State<SelectExample1> {
  String? selectedValue;
  @override
  Widget build(BuildContext context) {
    return Select<String>(
      // How to render each selected item as text in the field.
      itemBuilder: (context, item) {
        return Text(item);
      },
      // Limit the popup size so it doesn't grow too large in the docs view.
      popupConstraints: const BoxConstraints(
        maxHeight: 300,
        maxWidth: 200,
      ),
      onChanged: (value) {
        setState(() {
          // Save the currently selected value (or null to clear).
          selectedValue = value;
        });
      },
      // The current selection bound to this field.
      value: selectedValue,
      placeholder: const Text('Select a fruit'),
      popup: const SelectPopup(
        items: SelectItemList(
          children: [
            // A simple static list of options.
            SelectItemButton(
              value: 'Apple',
              child: Text('Apple'),
            ),
            SelectItemButton(
              value: 'Banana',
              child: Text('Banana'),
            ),
            SelectItemButton(
              value: 'Cherry',
              child: Text('Cherry'),
            ),
          ],
        ),
      ),
    );
  }
}
# File: ./lib/pages/docs/components/select/select_example_3.dart
import 'package:shadcn_flutter/shadcn_flutter.dart';
class SelectExample3 extends StatefulWidget {
  const SelectExample3({super.key});
  @override
  State<SelectExample3> createState() => _SelectExample3State();
}
class _SelectExample3State extends State<SelectExample3> {
  final Map<String, List<String>> fruits = {
    'Apple': ['Red Apple', 'Green Apple'],
    'Banana': ['Yellow Banana', 'Brown Banana'],
    'Lemon': ['Yellow Lemon', 'Green Lemon'],
    'Tomato': ['Red', 'Green', 'Yellow', 'Brown'],
  };
  String? selectedValue;
  Iterable<MapEntry<String, List<String>>> _filteredFruits(
      String searchQuery) sync* {
    for (final entry in fruits.entries) {
      final filteredValues = entry.value
          .where((value) => _filterName(value, searchQuery))
          .toList();
      if (filteredValues.isNotEmpty) {
        yield MapEntry(entry.key, filteredValues);
      } else if (_filterName(entry.key, searchQuery)) {
        yield entry;
      }
    }
  }
  bool _filterName(String name, String searchQuery) {
    return name.toLowerCase().contains(searchQuery);
  }
  @override
  Widget build(BuildContext context) {
    return Select<String>(
      itemBuilder: (context, item) {
        return Text(item);
      },
      popup: SelectPopup.builder(
        // Popup with async data loading and custom empty/loading UI.
        searchPlaceholder: const Text('Search fruit'),
        emptyBuilder: (context) {
          return const Center(
            child: Text('No fruit found'),
          );
        },
        loadingBuilder: (context) {
          return const Center(
            child: CircularProgressIndicator(),
          );
        },
        builder: (context, searchQuery) async {
          final filteredFruits = searchQuery == null
              ? fruits.entries.toList()
              : _filteredFruits(searchQuery).toList();
          // Simulate a delay for loading
          // In a real-world scenario, you would fetch data from an API or database
          await Future.delayed(const Duration(milliseconds: 500));
          return SelectItemBuilder(
            // When 0, the popup renders the emptyBuilder; otherwise the builder lazily builds rows.
            childCount: filteredFruits.isEmpty ? 0 : null,
            builder: (context, index) {
              final entry = filteredFruits[index % filteredFruits.length];
              return SelectGroup(
                headers: [
                  SelectLabel(
                    child: Text(entry.key),
                  ),
                ],
                children: [
                  for (final value in entry.value)
                    SelectItemButton(
                      value: value,
                      child: Text(value),
                    ),
                ],
              );
            },
          );
        },
      ),
      onChanged: (value) {
        setState(() {
          selectedValue = value;
        });
      },
      constraints: const BoxConstraints(
        minWidth: 200,
      ),
      value: selectedValue,
      placeholder: const Text('Select a fruit'),
    );
  }
}
# File: ./lib/pages/docs/components/app_bar/app_bar_example_1.dart
import 'package:shadcn_flutter/shadcn_flutter.dart';
/// AppBar with header, title, subtitle, and action buttons.
///
/// Demonstrates the structure of [AppBar] and how to provide leading and
/// trailing actions using outline-styled icon buttons.
class AppBarExample1 extends StatelessWidget {
  const AppBarExample1({super.key});
  @override
  Widget build(BuildContext context) {
    return OutlinedContainer(
      clipBehavior: Clip.antiAlias,
      child: AppBar(
        // Optional top line above the main title area.
        header: const Text('This is Header'),
        // Primary title and an optional subtitle.
        title: const Text('This is Title'),
        subtitle: const Text('This is Subtitle'),
        leading: [
          // Leading actions typically appear on the left.
          OutlineButton(
            density: ButtonDensity.icon,
            onPressed: () {},
            child: const Icon(Icons.arrow_back),
          ),
        ],
        trailing: [
          // Trailing actions typically appear on the right.
          OutlineButton(
            density: ButtonDensity.icon,
            onPressed: () {},
            child: const Icon(Icons.search),
          ),
          OutlineButton(
            density: ButtonDensity.icon,
            onPressed: () {},
            child: const Icon(Icons.more_vert),
          ),
        ],
      ),
    );
  }
}
# File: ./lib/pages/docs/components/choices/choices_example_1.dart
import 'package:shadcn_flutter/shadcn_flutter.dart';
class ChoicesExample1 extends StatefulWidget {
  const ChoicesExample1({super.key});
  @override
  State<ChoicesExample1> createState() => _ChoicesExample1State();
}
class _ChoicesExample1State extends State<ChoicesExample1> {
  @override
  Widget build(BuildContext context) {
    // MultipleChoice provides a context for building a set of mutually-exclusive
    // or multi-selectable options, depending on the configuration. This stub
    // example keeps an empty Column to demonstrate the container itself.
    // In practical examples, you would place choice items (e.g., ChoiceTile,
    // Checkboxes/Radio or custom widgets) inside the child.
    return const MultipleChoice(
      child: Column(
        children: [],
      ),
    );
  }
}
# File: ./lib/pages/docs/components/window/window_example_1.dart
import 'package:docs/debug.dart';
import 'package:shadcn_flutter/shadcn_flutter.dart';
// Demonstrates a WindowNavigator simulating multiple desktop-style windows,
// with an action to add a new window at runtime.
class WindowExample1 extends StatefulWidget {
  const WindowExample1({super.key});
  @override
  State<WindowExample1> createState() => _WindowExample1State();
}
class _WindowExample1State extends State<WindowExample1> {
  final GlobalKey<WindowNavigatorHandle> navigatorKey = GlobalKey();
  @override
  Widget build(BuildContext context) {
    return Column(
      crossAxisAlignment: CrossAxisAlignment.stretch,
      children: [
        OutlinedContainer(
          height: 600, // for example purpose
          child: WindowNavigator(
            key: navigatorKey,
            // Pre-populate with two windows, each with its own bounds and title.
            initialWindows: [
              Window(
                bounds: const Rect.fromLTWH(0, 0, 200, 200),
                title: const Text('Window 1'),
                content: const RebuildCounter(),
              ),
              Window(
                bounds: const Rect.fromLTWH(200, 0, 200, 200),
                title: const Text('Window 2'),
                content: const RebuildCounter(),
              ),
            ],
            child: const Center(
              child: Text('Desktop'),
            ),
          ),
        ),
        PrimaryButton(
          child: const Text('Add Window'),
          onPressed: () {
            // Push a new window via the navigator; title uses the current count.
            navigatorKey.currentState?.pushWindow(
              Window(
                bounds: const Rect.fromLTWH(0, 0, 200, 200),
                title: Text(
                    'Window ${navigatorKey.currentState!.windows.length + 1}'),
                content: const RebuildCounter(),
              ),
            );
          },
        )
      ],
    );
  }
}
# File: ./lib/pages/docs/components/color_picker/color_picker_example_3.dart
import 'package:shadcn_flutter/shadcn_flutter.dart';
class ColorPickerExample3 extends StatefulWidget {
  const ColorPickerExample3({super.key});
  @override
  State<ColorPickerExample3> createState() => _ColorPickerExample3State();
}
class _ColorPickerExample3State extends State<ColorPickerExample3> {
  final ValueNotifier<ColorDerivative> selectedColorNotifier = ValueNotifier(
    ColorDerivative.fromColor(Colors.blue),
  );
  @override
  Widget build(BuildContext context) {
    return Column(
      mainAxisSize: MainAxisSize.min,
      children: [
        Builder(builder: (context) {
          return PrimaryButton(
            onPressed: () {
              // Show the color picker as a popover anchored to the button.
              showPopover(
                context: context,
                alignment: Alignment.topCenter,
                anchorAlignment: Alignment.bottomCenter,
                widthConstraint: PopoverConstraint.intrinsic,
                heightConstraint: PopoverConstraint.intrinsic,
                offset: const Offset(0, 8),
                builder: (context) {
                  return ListenableBuilder(
                      listenable: selectedColorNotifier,
                      builder: (context, _) {
                        return SurfaceCard(
                          child: ColorPicker(
                            value: selectedColorNotifier.value,
                            orientation: Axis.horizontal,
                            showAlpha: true,
                            onChanged: (value) {
                              setState(() {
                                selectedColorNotifier.value = value;
                              });
                            },
                          ),
                        );
                      });
                },
              );
            },
            child: const Text('Open Color Picker Popover'),
          );
        }),
        const Gap(16),
        PrimaryButton(
          onPressed: () {
            // Show the color picker as a dialog with a title.
            showDialog(
              context: context,
              builder: (context) {
                return AlertDialog(
                  title: const Text('Select Color'),
                  content: ListenableBuilder(
                      listenable: selectedColorNotifier,
                      builder: (context, _) {
                        return ColorPicker(
                          value: selectedColorNotifier.value,
                          orientation: Axis.horizontal,
                          showAlpha: true,
                          onChanged: (value) {
                            setState(() {
                              selectedColorNotifier.value = value;
                            });
                          },
                        );
                      }),
                  actions: [
                    PrimaryButton(
                      onPressed: () {
                        Navigator.of(context).pop();
                      },
                      child: const Text('Close'),
                    ),
                  ],
                );
              },
            );
          },
          child: const Text('Open Color Picker Dialog'),
        ),
      ],
    );
  }
}
# File: ./lib/pages/docs/components/color_picker/color_picker_example_1.dart
import 'package:shadcn_flutter/shadcn_flutter.dart';
class ColorPickerExample1 extends StatefulWidget {
  const ColorPickerExample1({super.key});
  @override
  State<ColorPickerExample1> createState() => _ColorPickerExample1State();
}
class _ColorPickerExample1State extends State<ColorPickerExample1> {
  ColorDerivative color = ColorDerivative.fromColor(Colors.blue);
  @override
  Widget build(BuildContext context) {
    return SizedBox(
      width: 200,
      child: Column(
        crossAxisAlignment: CrossAxisAlignment.start,
        children: [
          SizedBox(
            width: 32,
            height: 32,
            child: ColorInput(
              // A compact square color input that opens a popover prompt.
              value: color,
              orientation: Axis.horizontal,
              promptMode: PromptMode.popover,
              onChanged: (value) {
                setState(() {
                  color = value;
                });
              },
            ),
          ),
          const Gap(16),
          ColorInput(
            value: color,
            // Full dialog mode with a title.
            promptMode: PromptMode.dialog,
            dialogTitle: const Text('Select Color'),
            onChanged: (value) {
              setState(() {
                color = value;
              });
            },
            // Show the textual label/hex alongside the swatch.
            showLabel: true,
          ),
        ],
      ),
    );
  }
}
# File: ./lib/pages/docs/components/color_picker/color_picker_example_2.dart
import 'package:shadcn_flutter/shadcn_flutter.dart';
class ColorPickerExample2 extends StatelessWidget {
  const ColorPickerExample2({super.key});
  @override
  Widget build(BuildContext context) {
    return PrimaryButton(
      onPressed: () async {
        // Screen color picker: lets the user sample any on-screen color.
        final history = ColorHistoryStorage.of(context);
        final result = await pickColorFromScreen(context, history);
        if (result != null && context.mounted) {
          // Show a toast with the hex value and a preview swatch.
          showToast(
            context: context,
            builder: (context, overlay) {
              return SurfaceCard(
                  child: Row(
                mainAxisSize: MainAxisSize.min,
                mainAxisAlignment: MainAxisAlignment.center,
                children: [
                  Text('Color: ${colorToHex(result)}'),
                  const Gap(16),
                  Container(
                    width: 24,
                    height: 24,
                    decoration: BoxDecoration(
                      color: result,
                      borderRadius: BorderRadius.circular(4),
                    ),
                  ),
                ],
              ));
            },
          );
        }
      },
      child: const Text('Pick Color'),
    );
  }
}
# File: ./lib/pages/docs/components/card_image/card_image_example_1.dart
import 'dart:ui';
import 'package:shadcn_flutter/shadcn_flutter.dart';
/// Horizontally scrollable list of CardImage items.
///
/// Demonstrates enabling both touch and mouse drag for horizontal scroll,
/// and using [CardImage] to show an image with title/subtitle. Tapping a
/// card opens a simple dialog.
class CardImageExample1 extends StatelessWidget {
  const CardImageExample1({super.key});
  @override
  Widget build(BuildContext context) {
    return ScrollConfiguration(
      behavior: ScrollConfiguration.of(context).copyWith(
        dragDevices: {
          PointerDeviceKind.touch,
          PointerDeviceKind.mouse,
        },
      ),
      child: SingleChildScrollView(
        scrollDirection: Axis.horizontal,
        child: IntrinsicHeight(
          child: Row(
            crossAxisAlignment: CrossAxisAlignment.stretch,
            mainAxisSize: MainAxisSize.min,
            children: [
              for (int i = 0; i < 10; i++)
                CardImage(
                  // Simple interaction: open a dialog on tap.
                  onPressed: () {
                    showDialog(
                      context: context,
                      builder: (context) {
                        return AlertDialog(
                          title: const Text('Card Image'),
                          content: const Text('You clicked on a card image.'),
                          actions: [
                            PrimaryButton(
                              onPressed: () {
                                Navigator.of(context).pop();
                              },
                              child: const Text('Close'),
                            ),
                          ],
                        );
                      },
                    );
                  },
                  // Network image; replace with your own provider as needed.
                  image: Image.network(
                    'https://picsum.photos/200/300',
                  ),
                  // Title and subtitle appear over the image.
                  title: Text('Card Number ${i + 1}'),
                  subtitle: const Text('Lorem ipsum dolor sit amet'),
                ),
            ],
          ).gap(8),
        ),
      ),
    );
  }
}
# File: ./lib/pages/docs/components/time_picker/time_picker_example_1.dart
import 'package:shadcn_flutter/shadcn_flutter.dart';
// Demonstrates TimePicker in popover and dialog modes, updating state and
// handling cancel by falling back to current time.
class TimePickerExample1 extends StatefulWidget {
  const TimePickerExample1({super.key});
  @override
  State<TimePickerExample1> createState() => _TimePickerExample1State();
}
class _TimePickerExample1State extends State<TimePickerExample1> {
  TimeOfDay _value = TimeOfDay.now();
  @override
  Widget build(BuildContext context) {
    return Column(
      children: [
        TimePicker(
          value: _value,
          // Popover mode shows a compact inline picker anchored to the field.
          mode: PromptMode.popover,
          onChanged: (value) {
            setState(() {
              // If user cancels, keep time by falling back to now.
              _value = value ?? TimeOfDay.now();
            });
          },
        ),
        const Gap(16),
        TimePicker(
          value: _value,
          // Dialog mode opens a modal sheet/dialog for selection.
          mode: PromptMode.dialog,
          dialogTitle: const Text('Select Time'),
          onChanged: (value) {
            setState(() {
              _value = value ?? TimeOfDay.now();
            });
          },
        ),
      ],
    );
  }
}
# File: ./lib/pages/docs/components/form/form_example_9.dart
import 'package:shadcn_flutter/shadcn_flutter.dart';
/// Compares standard vs Controlled component boilerplate.
///
/// The left column uses standard widgets that require manual state
/// management (StatefulWidget, setState, value/onChanged wiring).
/// The right column uses Controlled variants that handle state
/// internally ‚Äî no StatefulWidget or setState needed.
class FormExample9 extends StatefulWidget {
  const FormExample9({super.key});
  @override
  State<FormExample9> createState() => _FormExample9State();
}
class _FormExample9State extends State<FormExample9> {
  // ‚îÄ‚îÄ Standard widgets need manual state ‚îÄ‚îÄ
  CheckboxState _checkboxState = CheckboxState.unchecked;
  bool _switchValue = false;
  @override
  Widget build(BuildContext context) {
    return IntrinsicWidth(
      child: Column(
        mainAxisSize: MainAxisSize.min,
        crossAxisAlignment: CrossAxisAlignment.stretch,
        children: [
          // ‚îÄ‚îÄ Standard: you manage the state ‚îÄ‚îÄ
          const Text('Standard (manual state)').semiBold,
          const Gap(24),
          Checkbox(
            state: _checkboxState,
            onChanged: (value) {
              setState(() {
                _checkboxState = value;
              });
            },
            trailing: const Text('Accept terms'),
          ),
          const Gap(8),
          Switch(
            value: _switchValue,
            onChanged: (value) {
              setState(() {
                _switchValue = value;
              });
            },
            trailing: const Text('Dark mode'),
          ),
          const Gap(32),
          const Divider(),
          const Gap(32),
          // ‚îÄ‚îÄ Controlled: zero boilerplate ‚îÄ‚îÄ
          const Text('Controlled (no manual state)').semiBold,
          const Gap(24),
          const ControlledCheckbox(
            trailing: Text('Accept terms'),
          ),
          const Gap(8),
          const ControlledSwitch(
            trailing: Text('Dark mode'),
          ),
        ],
      ),
    );
  }
}
# File: ./lib/pages/docs/components/form/form_example_2.dart
import 'dart:convert';
import 'package:shadcn_flutter/shadcn_flutter.dart';
class FormExample2 extends StatefulWidget {
  const FormExample2({super.key});
  @override
  State<FormExample2> createState() => _FormExample2State();
}
class _FormExample2State extends State<FormExample2> {
  final _usernameKey = const TextFieldKey(#username);
  final _passwordKey = const TextFieldKey(#password);
  final _confirmPasswordKey = const TextFieldKey(#confirmPassword);
  final _agreeKey = const CheckboxKey(#agree);
  CheckboxState state = CheckboxState.unchecked;
  @override
  Widget build(BuildContext context) {
    return SizedBox(
      width: 480,
      child: Form(
        onSubmit: (context, values) {
          // Get the values individually
          String? username = _usernameKey[values];
          String? password = _passwordKey[values];
          String? confirmPassword = _confirmPasswordKey[values];
          CheckboxState? agree = _agreeKey[values];
          // or just encode the whole map to JSON directly
          String json = jsonEncode(values.map((key, value) {
            return MapEntry(key.key, value);
          }));
          showDialog(
            context: context,
            builder: (context) {
              return AlertDialog(
                title: const Text('Form Values'),
                content: Column(
                  mainAxisSize: MainAxisSize.min,
                  crossAxisAlignment: CrossAxisAlignment.start,
                  children: [
                    Text('Username: $username'),
                    Text('Password: $password'),
                    Text('Confirm Password: $confirmPassword'),
                    Text('Agree: $agree'),
                    Text('JSON: $json'),
                  ],
                ),
                actions: [
                  PrimaryButton(
                    onPressed: () => Navigator.of(context).pop(),
                    child: const Text('Close'),
                  ),
                ],
              );
            },
          );
        },
        child: Column(
          mainAxisSize: MainAxisSize.min,
          crossAxisAlignment: CrossAxisAlignment.end,
          children: [
            Column(
              crossAxisAlignment: CrossAxisAlignment.stretch,
              children: [
                FormField(
                  key: _usernameKey,
                  label: const Text('Username'),
                  hint: const Text('This is your public display name'),
                  validator: const LengthValidator(min: 4),
                  // Show validation messages when the value changes and after submit.
                  showErrors: const {
                    FormValidationMode.changed,
                    FormValidationMode.submitted
                  },
                  child: const TextField(),
                ),
                FormField(
                  key: _passwordKey,
                  label: const Text('Password'),
                  validator: const LengthValidator(min: 8),
                  // Same validation visibility behavior for password.
                  showErrors: const {
                    FormValidationMode.changed,
                    FormValidationMode.submitted
                  },
                  child: const TextField(
                    obscureText: true,
                  ),
                ),
                FormField(
                  key: _confirmPasswordKey,
                  label: const Text('Confirm Password'),
                  validator: CompareWith.equal(_passwordKey,
                      message: 'Passwords do not match'),
                  // Mirror validation visibility on confirm.
                  showErrors: const {
                    FormValidationMode.changed,
                    FormValidationMode.submitted
                  },
                  child: const TextField(
                    obscureText: true,
                  ),
                ),
                FormInline(
                  key: _agreeKey,
                  label: const Text('I agree to the terms and conditions'),
                  validator: const CompareTo.equal(CheckboxState.checked,
                      message: 'You must agree to the terms and conditions'),
                  // Inline field with a trailing checkbox and same visibility behavior.
                  showErrors: const {
                    FormValidationMode.changed,
                    FormValidationMode.submitted
                  },
                  child: Align(
                    alignment: AlignmentDirectional.centerEnd,
                    child: Checkbox(
                        state: state,
                        onChanged: (value) {
                          setState(() {
                            state = value;
                          });
                        }),
                  ),
                ),
              ],
            ).gap(24),
            const Gap(24),
            FormErrorBuilder(
              builder: (context, errors, child) {
                return PrimaryButton(
                  onPressed: errors.isEmpty ? () => context.submitForm() : null,
                  child: const Text('Submit'),
                );
              },
            )
          ],
        ),
      ),
    );
  }
}
# File: ./lib/pages/docs/components/form/form_example_4.dart
import 'package:shadcn_flutter/shadcn_flutter.dart';
/// Demonstrates using the correct typed FormKey for each widget.
///
/// Every form-capable widget reports a specific value type. The FormKey's
/// generic type must match ‚Äî use the typed alias (TextFieldKey, CheckboxKey,
/// DatePickerKey, SwitchKey, etc.) instead of the generic FormKey.
class FormExample4 extends StatefulWidget {
  const FormExample4({super.key});
  @override
  State<FormExample4> createState() => _FormExample4State();
}
class _FormExample4State extends State<FormExample4> {
  // ‚úÖ Each key uses the correct typed alias for the widget it pairs with.
  //    Always use const to preserve key identity across rebuilds.
  final _nameKey = const TextFieldKey('name'); // TextField ‚Üí String
  final _agreeKey = const CheckboxKey('agree'); // Checkbox ‚Üí CheckboxState
  final _birthdayKey = const DatePickerKey('birthday'); // DatePicker ‚Üí DateTime
  final _notifyKey = const SwitchKey('notify'); // Switch ‚Üí bool
  CheckboxState _agreeState = CheckboxState.unchecked;
  bool _notifyState = false;
  @override
  Widget build(BuildContext context) {
    return SizedBox(
      width: 480,
      child: Form(
        onSubmit: (context, values) {
          // Read values with full type safety ‚Äî no casting needed.
          String? name = _nameKey[values];
          CheckboxState? agree = _agreeKey[values];
          DateTime? birthday = _birthdayKey[values];
          bool? notify = _notifyKey[values];
          showDialog(
            context: context,
            builder: (context) {
              return AlertDialog(
                title: const Text('Form Values'),
                content: Column(
                  mainAxisSize: MainAxisSize.min,
                  crossAxisAlignment: CrossAxisAlignment.start,
                  children: [
                    Text('Name: $name'),
                    Text('Agree: $agree'),
                    Text('Birthday: $birthday'),
                    Text('Notify: $notify'),
                  ],
                ),
                actions: [
                  PrimaryButton(
                    onPressed: () => Navigator.of(context).pop(),
                    child: const Text('Close'),
                  ),
                ],
              );
            },
          );
        },
        child: Column(
          mainAxisSize: MainAxisSize.min,
          crossAxisAlignment: CrossAxisAlignment.end,
          children: [
            Column(
              crossAxisAlignment: CrossAxisAlignment.stretch,
              children: [
                FormField<String>(
                  key: _nameKey,
                  label: const Text('Name'),
                  validator: const LengthValidator(min: 2),
                  child: const TextField(
                    initialValue: 'Jane Doe',
                  ),
                ),
                FormInline<CheckboxState>(
                  key: _agreeKey,
                  label: const Text('I agree to the terms'),
                  validator: const CompareTo.equal(CheckboxState.checked,
                      message: 'You must agree'),
                  child: Align(
                    alignment: AlignmentDirectional.centerEnd,
                    child: Checkbox(
                      state: _agreeState,
                      onChanged: (value) {
                        setState(() {
                          _agreeState = value;
                        });
                      },
                    ),
                  ),
                ),
                FormField<DateTime>(
                  key: _birthdayKey,
                  label: const Text('Birthday'),
                  validator:
                      const NonNullValidator(message: 'Please select a date'),
                  child: const ControlledDatePicker(),
                ),
                FormInline<bool>(
                  key: _notifyKey,
                  label: const Text('Email notifications'),
                  child: Align(
                    alignment: AlignmentDirectional.centerEnd,
                    child: Switch(
                      value: _notifyState,
                      onChanged: (value) {
                        setState(() {
                          _notifyState = value;
                        });
                      },
                    ),
                  ),
                ),
              ],
            ).gap(24),
            const Gap(24),
            FormErrorBuilder(
              builder: (context, errors, child) {
                return PrimaryButton(
                  onPressed: errors.isEmpty ? () => context.submitForm() : null,
                  child: const Text('Submit'),
                );
              },
            ),
          ],
        ),
      ),
    );
  }
}
# File: ./lib/pages/docs/components/form/form_example_6.dart
import 'package:shadcn_flutter/shadcn_flutter.dart';
/// Demonstrates the difference between showErrors and ValidationMode.
///
/// - ValidationMode controls WHEN a validator RUNS.
/// - showErrors controls WHEN error messages are VISIBLE in the UI.
///
/// In this example the email field uses ValidationMode to only run the
/// async "already taken" check on submit, while showErrors hides all
/// error messages until the user interacts or submits.
class FormExample6 extends StatelessWidget {
  const FormExample6({super.key});
  static const _emailKey = TextFieldKey('email');
  static const _takenEmails = ['admin@example.com', 'user@example.com'];
  @override
  Widget build(BuildContext context) {
    return SizedBox(
      width: 480,
      child: Form(
        onSubmit: (context, values) {
          showDialog(
            context: context,
            builder: (context) {
              return AlertDialog(
                title: const Text('Submitted'),
                content: Text('Email: ${_emailKey[values]}'),
                actions: [
                  PrimaryButton(
                    onPressed: () => Navigator.of(context).pop(),
                    child: const Text('Close'),
                  ),
                ],
              );
            },
          );
        },
        child: Column(
          mainAxisSize: MainAxisSize.min,
          crossAxisAlignment: CrossAxisAlignment.end,
          children: [
            FormTableLayout(
              rows: [
                FormField<String>(
                  key: _emailKey,
                  label: const Text('Email'),
                  hint: const Text('Try admin@example.com to see async error'),
                  // Validator composition:
                  //  1. EmailValidator always runs (on initial, change, submit)
                  //  2. "Already taken" check only runs on submit
                  validator: const EmailValidator() &
                      ValidationMode(
                        ConditionalValidator((value) async {
                          await Future.delayed(const Duration(seconds: 1));
                          return !_takenEmails.contains(value);
                        }, message: 'Email already taken'),
                        // This validator only RUNS on submit
                        mode: {FormValidationMode.submitted},
                      ),
                  // Error messages only VISIBLE after change or submit
                  // (not on initial load, so the form starts clean)
                  showErrors: const {
                    FormValidationMode.changed,
                    FormValidationMode.submitted,
                  },
                  child: const TextField(),
                ),
              ],
            ),
            const Gap(24),
            const SubmitButton(
              loadingTrailing: AspectRatio(
                aspectRatio: 1,
                child: CircularProgressIndicator(onSurface: true),
              ),
              child: Text('Submit'),
            ),
          ],
        ),
      ),
    );
  }
}
# File: ./lib/pages/docs/components/form/form_example_1.dart
import 'dart:convert';
import 'package:shadcn_flutter/shadcn_flutter.dart';
class FormExample1 extends StatefulWidget {
  const FormExample1({super.key});
  @override
  State<FormExample1> createState() => _FormExample1State();
}
class _FormExample1State extends State<FormExample1> {
  final _usernameKey = const TextFieldKey('username');
  final _passwordKey = const TextFieldKey('password');
  final _confirmPasswordKey = const TextFieldKey('confirmPassword');
  @override
  Widget build(BuildContext context) {
    return SizedBox(
      width: 480,
      child: Form(
        // Submit handler receives a typed map of field keys to values.
        onSubmit: (context, values) {
          // Get the values individually
          String? username = _usernameKey[values];
          String? password = _passwordKey[values];
          String? confirmPassword = _confirmPasswordKey[values];
          // or just encode the whole map to JSON directly
          String json = jsonEncode(values.map((key, value) {
            return MapEntry(key.key, value);
          }));
          showDialog(
            context: context,
            builder: (context) {
              return AlertDialog(
                title: const Text('Form Values'),
                content: Column(
                  mainAxisSize: MainAxisSize.min,
                  crossAxisAlignment: CrossAxisAlignment.start,
                  children: [
                    Text('Username: $username'),
                    Text('Password: $password'),
                    Text('Confirm Password: $confirmPassword'),
                    Text('JSON: $json'),
                  ],
                ),
                actions: [
                  PrimaryButton(
                    onPressed: () => Navigator.of(context).pop(),
                    child: const Text('Close'),
                  ),
                ],
              );
            },
          );
        },
        child: Column(
          mainAxisSize: MainAxisSize.min,
          crossAxisAlignment: CrossAxisAlignment.end,
          children: [
            FormTableLayout(
              rows: [
                FormField(
                  key: _usernameKey,
                  label: const Text('Username'),
                  hint: const Text('This is your public display name'),
                  validator: const LengthValidator(min: 4),
                  child: const TextField(
                    initialValue: 'sunarya-thito',
                  ),
                ),
                FormField(
                  key: _passwordKey,
                  label: const Text('Password'),
                  validator: const LengthValidator(min: 8),
                  child: const TextField(
                    obscureText: true,
                  ),
                ),
                FormField(
                  key: _confirmPasswordKey,
                  label: const Text('Confirm Password'),
                  validator: CompareWith.equal(_passwordKey,
                      message: 'Passwords do not match'),
                  child: const TextField(
                    obscureText: true,
                  ),
                ),
              ],
            ),
            const Gap(24),
            FormErrorBuilder(
              builder: (context, errors, child) {
                // Disable the submit button while there are validation errors.
                return PrimaryButton(
                  onPressed: errors.isEmpty ? () => context.submitForm() : null,
                  child: const Text('Submit'),
                );
              },
            )
          ],
        ),
      ),
    );
  }
}
# File: ./lib/pages/docs/components/form/form_example_7.dart
import 'dart:convert';
import 'package:shadcn_flutter/shadcn_flutter.dart';
/// Demonstrates IgnoreForm to exclude widgets from form participation.
///
/// Any form-capable widget (TextField, Checkbox, etc.) placed inside a Form
/// will automatically register with the FormController. Wrap non-form inputs
/// in IgnoreForm to prevent them from participating in validation or submission.
///
/// In this example the search field at the top is excluded from the form,
/// while the name and email fields participate normally.
class FormExample7 extends StatelessWidget {
  const FormExample7({super.key});
  static const _nameKey = TextFieldKey('name');
  static const _emailKey = TextFieldKey('email');
  @override
  Widget build(BuildContext context) {
    return SizedBox(
      width: 480,
      child: Form(
        onSubmit: (context, values) {
          String json = jsonEncode(values.map((key, value) {
            return MapEntry(key.key, value);
          }));
          showDialog(
            context: context,
            builder: (context) {
              return AlertDialog(
                title: const Text('Submitted Values'),
                content: Text(json),
                actions: [
                  PrimaryButton(
                    onPressed: () => Navigator.of(context).pop(),
                    child: const Text('Close'),
                  ),
                ],
              );
            },
          );
        },
        child: Column(
          mainAxisSize: MainAxisSize.min,
          crossAxisAlignment: CrossAxisAlignment.end,
          children: [
            const Gap(16),
            FormTableLayout(
              rows: [
                const FormField<String>(
                  key: TextFieldKey('search'),
                  label: Text('Search (ignored)'),
                  // This TextField is wrapped in IgnoreForm, so it does NOT
                  // participate in form validation or submission.
                  child: IgnoreForm(
                    child: TextField(
                      placeholder: Text('Type to search...'),
                    ),
                  ),
                ),
                // These fields participate in the form normally.
                const FormField<String>(
                  key: _nameKey,
                  label: Text('Name'),
                  validator: LengthValidator(min: 2),
                  child: TextField(),
                ),
                FormField<String>(
                  key: _emailKey,
                  label: const Text('Email'),
                  validator: const EmailValidator() & const NotEmptyValidator(),
                  child: const TextField(),
                ),
              ],
            ),
            const Gap(24),
            const SubmitButton(child: Text('Submit')),
          ],
        ),
      ),
    );
  }
}
# File: ./lib/pages/docs/components/form/form_example_5.dart
import 'package:shadcn_flutter/shadcn_flutter.dart';
/// Demonstrates composing validators with operators.
///
/// Validators can be combined using:
///   & (AND) ‚Äî all must pass
///   | (OR)  ‚Äî any one passing is enough
///   ~ (NOT) ‚Äî negates a validator
///
/// This example shows a password field that requires both minimum length
/// AND password complexity, combined with & operator.
class FormExample5 extends StatelessWidget {
  const FormExample5({super.key});
  static const _passwordKey = TextFieldKey('password');
  static const _confirmKey = TextFieldKey('confirm');
  @override
  Widget build(BuildContext context) {
    return SizedBox(
      width: 480,
      child: Form(
        onSubmit: (context, values) {
          showDialog(
            context: context,
            builder: (context) {
              return AlertDialog(
                title: const Text('Success'),
                content: const Text('Password is valid!'),
                actions: [
                  PrimaryButton(
                    onPressed: () => Navigator.of(context).pop(),
                    child: const Text('Close'),
                  ),
                ],
              );
            },
          );
        },
        child: Column(
          mainAxisSize: MainAxisSize.min,
          crossAxisAlignment: CrossAxisAlignment.end,
          children: [
            FormTableLayout(
              rows: [
                FormField<String>(
                  key: _passwordKey,
                  label: const Text('Password'),
                  // Compose validators with & (AND): both must pass.
                  validator: const LengthValidator(min: 8) &
                      const SafePasswordValidator(
                        requireSpecialChar: false,
                        requireUppercase: false,
                        requireLowercase: false,
                      ),
                  showErrors: const {
                    FormValidationMode.changed,
                    FormValidationMode.submitted,
                  },
                  child: const TextField(obscureText: true),
                ),
                const FormField<String>(
                  key: _confirmKey,
                  label: Text('Confirm'),
                  // Cross-field validation: must equal the password field.
                  // CompareWith automatically re-validates when the
                  // referenced field (_passwordKey) changes.
                  validator: CompareWith.equal(
                    _passwordKey,
                    message: 'Passwords do not match',
                  ),
                  showErrors: {
                    FormValidationMode.changed,
                    FormValidationMode.submitted,
                  },
                  child: TextField(obscureText: true),
                ),
              ],
            ),
            const Gap(24),
            const SubmitButton(child: Text('Validate')),
          ],
        ),
      ),
    );
  }
}
# File: ./lib/pages/docs/components/form/form_example_8.dart
import 'package:shadcn_flutter/shadcn_flutter.dart';
/// Demonstrates the two ways to build a submit button.
///
/// Option 1: FormErrorBuilder ‚Äî full manual control over button state.
///   Rebuilds whenever validation errors change. Lets you customize
///   the button appearance for error, loading, and valid states.
///
/// Option 2: SubmitButton ‚Äî automatic handling of loading and error states.
///   Disables while async validators are pending, shows a loading indicator,
///   and disables while validation errors exist.
class FormExample8 extends StatelessWidget {
  const FormExample8({super.key});
  static const _nameKey = TextFieldKey('name');
  static const _emailKey = TextFieldKey('email');
  @override
  Widget build(BuildContext context) {
    return SizedBox(
      width: 480,
      child: Form(
        onSubmit: (context, values) {
          showDialog(
            context: context,
            builder: (context) {
              return AlertDialog(
                title: const Text('Success'),
                content: Text('Name: ${_nameKey[values]}\n'
                    'Email: ${_emailKey[values]}'),
                actions: [
                  PrimaryButton(
                    onPressed: () => Navigator.of(context).pop(),
                    child: const Text('Close'),
                  ),
                ],
              );
            },
          );
        },
        child: Column(
          mainAxisSize: MainAxisSize.min,
          crossAxisAlignment: CrossAxisAlignment.end,
          children: [
            FormTableLayout(
              rows: [
                const FormField<String>(
                  key: _nameKey,
                  label: Text('Name'),
                  validator: LengthValidator(min: 2),
                  child: TextField(),
                ),
                FormField<String>(
                  key: _emailKey,
                  label: const Text('Email'),
                  // Async validator only runs on submit
                  validator: const EmailValidator() &
                      ValidationMode(
                        ConditionalValidator((value) async {
                          await Future.delayed(const Duration(seconds: 1));
                          return true; // always passes (demo)
                        }, message: 'Checking email...'),
                        mode: {FormValidationMode.submitted},
                      ),
                  child: const TextField(),
                ),
              ],
            ),
            const Gap(24),
            // Option 1: Manual submit with FormErrorBuilder
            FormErrorBuilder(
              builder: (context, errors, child) {
                return PrimaryButton(
                  onPressed: errors.isEmpty ? () => context.submitForm() : null,
                  child: const Text('Manual Submit'),
                );
              },
            ),
            const Gap(8),
            // Option 2: Automatic submit with SubmitButton
            const SubmitButton(
              loadingTrailing: AspectRatio(
                aspectRatio: 1,
                child: CircularProgressIndicator(onSurface: true),
              ),
              child: Text('Auto Submit'),
            ),
          ],
        ),
      ),
    );
  }
}
# File: ./lib/pages/docs/components/form/form_example_3.dart
import 'dart:convert';
import 'package:shadcn_flutter/shadcn_flutter.dart';
class FormExample3 extends StatefulWidget {
  const FormExample3({super.key});
  @override
  State<FormExample3> createState() => _FormExample3State();
}
class _FormExample3State extends State<FormExample3> {
  final _dummyData = [
    'sunarya-thito',
    'septogeddon',
    'shadcn',
  ];
  final _usernameKey = const TextFieldKey('username');
  final _passwordKey = const TextFieldKey('password');
  final _confirmPasswordKey = const TextFieldKey('confirmPassword');
  @override
  Widget build(BuildContext context) {
    return SizedBox(
      width: 480,
      child: Form(
        onSubmit: (context, values) {
          showDialog(
            context: context,
            builder: (context) {
              return AlertDialog(
                title: const Text('Form Values'),
                content: Text(jsonEncode(values.map(
                  (key, value) {
                    return MapEntry(key.key, value);
                  },
                ))),
                actions: [
                  PrimaryButton(
                    onPressed: () => Navigator.of(context).pop(),
                    child: const Text('Close'),
                  ),
                ],
              );
            },
          );
        },
        child: Column(
          mainAxisSize: MainAxisSize.min,
          crossAxisAlignment: CrossAxisAlignment.end,
          children: [
            FormTableLayout(
              rows: [
                FormField(
                  key: _usernameKey,
                  label: const Text('Username'),
                  hint: const Text('This is your public display name'),
                  // Combine validators: length + async availability check,
                  // but only run the async validator on submit.
                  validator: const LengthValidator(min: 4) &
                      ValidationMode(
                        ConditionalValidator((value) async {
                          // simulate a network delay for example purpose
                          await Future.delayed(const Duration(seconds: 1));
                          return !_dummyData.contains(value);
                        }, message: 'Username already taken'),
                        // only validate when the form is submitted
                        mode: {FormValidationMode.submitted},
                      ),
                  child: const TextField(
                    initialValue: 'sunarya-thito',
                  ),
                ),
                FormField(
                  key: _passwordKey,
                  label: const Text('Password'),
                  validator: const LengthValidator(min: 8),
                  showErrors: const {
                    FormValidationMode.submitted,
                    FormValidationMode.changed
                  },
                  child: const TextField(
                    obscureText: true,
                  ),
                ),
                FormField<String>(
                  key: _confirmPasswordKey,
                  label: const Text('Confirm Password'),
                  showErrors: const {
                    FormValidationMode.submitted,
                    FormValidationMode.changed
                  },
                  validator: CompareWith.equal(_passwordKey,
                      message: 'Passwords do not match'),
                  child: const TextField(
                    obscureText: true,
                  ),
                ),
              ],
            ),
            const Gap(24),
            const SubmitButton(
              loadingTrailing: AspectRatio(
                aspectRatio: 1,
                child: CircularProgressIndicator(
                  onSurface: true,
                ),
              ),
              child: Text('Register'),
            ),
          ],
        ),
      ),
    );
  }
}
# File: ./lib/pages/docs/components/number_ticker/number_ticker_example_2.dart
import 'dart:math';
import 'package:shadcn_flutter/shadcn_flutter.dart';
class NumberTickerExample2 extends StatefulWidget {
  const NumberTickerExample2({super.key});
  @override
  State<NumberTickerExample2> createState() => _NumberTickerExample2State();
}
class _NumberTickerExample2State extends State<NumberTickerExample2> {
  int _currentNumber = 100;
  void _nextRandomNumber() {
    setState(() {
      Random random = Random();
      _currentNumber = random.nextInt(9000) + 1000;
    });
  }
  @override
  Widget build(BuildContext context) {
    return Column(
      crossAxisAlignment: CrossAxisAlignment.start,
      children: [
        TextFlipper(text: '$_currentNumber').x3Large.mono,
        const SizedBox(height: 16),
        Button.primary(
          onPressed: _nextRandomNumber,
          child: const Text('Next Random Number'),
        ),
      ],
    );
  }
}
# File: ./lib/pages/docs/components/number_ticker/number_ticker_example_1.dart
import 'package:intl/intl.dart';
import 'package:shadcn_flutter/shadcn_flutter.dart';
// Demonstrates NumberTicker animating from its previous value to a new value.
// The TextField lets you enter a target integer; committing the edit triggers
// the ticker to animate the change. A formatter compact-prints large numbers.
class NumberTickerExample1 extends StatefulWidget {
  const NumberTickerExample1({super.key});
  @override
  State<NumberTickerExample1> createState() => _NumberTickerExample1State();
}
class _NumberTickerExample1State extends State<NumberTickerExample1> {
  // Current target number. Changing this causes NumberTicker to animate
  // from the old value to the new value.
  int _number = 0;
  final TextEditingController _controller = TextEditingController();
  @override
  Widget build(BuildContext context) {
    return Column(
      children: [
        NumberTicker(
          // Starting point for the first animation frame.
          initialNumber: 0,
          // The live value to animate toward. When this changes, the ticker
          // interpolates between the previous and the new value.
          number: _number,
          style: const TextStyle(fontSize: 32),
          formatter: (number) {
            // Optional display formatter: 1200 -> 1.2K, etc.
            return NumberFormat.compact().format(number);
          },
        ),
        const Gap(24),
        TextField(
          // Show the current number as the initial text.
          initialValue: _number.toString(),
          controller: _controller,
          onEditingComplete: () {
            // Commit input on edit complete and update the ticker target.
            int? number = int.tryParse(_controller.text);
            if (number != null) {
              setState(() {
                _number = number;
              });
            }
          },
        )
      ],
    );
  }
}
# File: ./lib/pages/docs/components/paint_order/paint_order_example_3.dart
import 'package:shadcn_flutter/shadcn_flutter.dart';
class PaintOrderExample3 extends StatefulWidget {
  const PaintOrderExample3({super.key});
  @override
  State<PaintOrderExample3> createState() => _PaintOrderExample3State();
}
class _PaintOrderExample3State extends State<PaintOrderExample3> {
  final List<int> _paintOrders = [0, 0, 0];
  int _topIndex = 0;
  @override
  Widget build(BuildContext context) {
    final colors = [Colors.red, Colors.green, Colors.blue];
    return OutlinedContainer(
      width: 350,
      height: 200,
      child: Column(
        mainAxisAlignment: MainAxisAlignment.center,
        children: [
          SizedBox(
            width: 200,
            height: 120,
            child: Stack(
              clipBehavior: Clip.none,
              children: [
                for (int i = 0; i < 3; i++)
                  Positioned(
                    left: i * 50.0,
                    top: i * 20.0,
                    paintOrder: _paintOrders[i],
                    child: GestureDetector(
                      onTap: () =>
                          setState(() => _paintOrders[i] = ++_topIndex),
                      child: Container(
                        width: 80,
                        height: 80,
                        decoration: BoxDecoration(
                          color: colors[i],
                          borderRadius: BorderRadius.circular(8),
                          boxShadow: [
                            BoxShadow(
                              color: Colors.black.withAlpha(64),
                              blurRadius: 8,
                            ),
                          ],
                        ),
                        child: Center(
                          child: Text(
                            'Card ${i + 1}',
                            style: const TextStyle(color: Colors.white),
                          ),
                        ),
                      ),
                    ),
                  ),
              ],
            ),
          ),
          const SizedBox(height: 16),
          const Text('Tap a card to bring it to front'),
        ],
      ),
    );
  }
}
# File: ./lib/pages/docs/components/paint_order/paint_order_example_2.dart
import 'package:shadcn_flutter/shadcn_flutter.dart';
class PaintOrderExample2 extends StatefulWidget {
  const PaintOrderExample2({super.key});
  @override
  State<PaintOrderExample2> createState() => _PaintOrderExample2State();
}
class _PaintOrderExample2State extends State<PaintOrderExample2> {
  final List<int> _paintOrders = [0, 0, 0];
  int _topIndex = 0;
  @override
  Widget build(BuildContext context) {
    final colors = [Colors.red, Colors.green, Colors.blue];
    return OutlinedContainer(
      width: 350,
      height: 180,
      child: Column(
        mainAxisSize: MainAxisSize.min,
        mainAxisAlignment: MainAxisAlignment.center,
        children: [
          Row(
            mainAxisAlignment: MainAxisAlignment.center,
            mainAxisSize: MainAxisSize.min,
            children: [
              for (int i = 0; i < 3; i++)
                PaintOrder(
                  paintOrder: _paintOrders[i],
                  child: Transform.translate(
                    offset: Offset((i - 1) * -30.0, 0),
                    child: GestureDetector(
                      onTap: () =>
                          setState(() => _paintOrders[i] = ++_topIndex),
                      child: Container(
                        width: 80,
                        height: 80,
                        decoration: BoxDecoration(
                          color: colors[i],
                          borderRadius: BorderRadius.circular(8),
                          boxShadow: [
                            BoxShadow(
                              color: Colors.black.withAlpha(64),
                              blurRadius: 8,
                            ),
                          ],
                        ),
                        child: Center(
                          child: Text(
                            'Card ${i + 1}',
                            style: const TextStyle(color: Colors.white),
                          ),
                        ),
                      ),
                    ),
                  ),
                ),
            ],
          ),
          const SizedBox(height: 16),
          const Text('Tap a card to bring it to front'),
        ],
      ),
    );
  }
}
# File: ./lib/pages/docs/components/paint_order/paint_order_example_1.dart
import 'package:shadcn_flutter/shadcn_flutter.dart';
class PaintOrderExample1 extends StatelessWidget {
  const PaintOrderExample1({super.key});
  @override
  Widget build(BuildContext context) {
    return OutlinedContainer(
      width: 300,
      height: 120,
      child: Row(
        mainAxisAlignment: MainAxisAlignment.center,
        children: [
          // First child (painted first, appears below)
          Transform.translate(
            offset: const Offset(20, 0),
            child: Container(
              width: 80,
              height: 80,
              decoration: BoxDecoration(
                color: Colors.blue,
                borderRadius: BorderRadius.circular(8),
              ),
              child: const Center(
                child: Text(
                  'Below',
                  style: TextStyle(color: Colors.white),
                ),
              ),
            ),
          ),
          // Second child with higher paintOrder (painted last, appears on top)
          PaintOrder(
            paintOrder: 1,
            child: Transform.translate(
              offset: const Offset(-20, 0),
              child: Container(
                width: 80,
                height: 80,
                decoration: BoxDecoration(
                  color: Colors.red,
                  borderRadius: BorderRadius.circular(8),
                ),
                child: const Center(
                  child: Text(
                    'On Top',
                    style: TextStyle(color: Colors.white),
                  ),
                ),
              ),
            ),
          ),
        ],
      ),
    );
  }
}
# File: ./lib/pages/docs/components/avatar_group/avatar_group_example_1.dart
import 'package:shadcn_flutter/shadcn_flutter.dart';
/// AvatarGroup directions demo.
///
/// Displays the same set of avatars grouped in four different stacking
/// directions: left, right, top, and bottom. Useful for dense displays
/// where overlapping avatars save space.
class AvatarGroupExample1 extends StatefulWidget {
  const AvatarGroupExample1({super.key});
  @override
  State<AvatarGroupExample1> createState() => _AvatarGroupExample1State();
}
class _AvatarGroupExample1State extends State<AvatarGroupExample1> {
  /// Helper that returns a few colored avatars to visualize overlap.
  List<AvatarWidget> getAvatars() {
    return [
      Avatar(
        initials: Avatar.getInitials('sunarya-thito'),
        backgroundColor: Colors.red,
      ),
      Avatar(
        initials: Avatar.getInitials('sunarya-thito'),
        backgroundColor: Colors.green,
      ),
      Avatar(
        initials: Avatar.getInitials('sunarya-thito'),
        backgroundColor: Colors.blue,
      ),
      Avatar(
        initials: Avatar.getInitials('sunarya-thito'),
        backgroundColor: Colors.yellow,
      ),
    ];
  }
  @override
  Widget build(BuildContext context) {
    return Wrap(
      spacing: 16,
      runSpacing: 16,
      children: [
        // Overlap avatars towards the left.
        AvatarGroup.toLeft(children: getAvatars()),
        // Overlap avatars towards the right.
        AvatarGroup.toRight(children: getAvatars()),
        // Stack vertically upwards.
        AvatarGroup.toTop(children: getAvatars()),
        // Stack vertically downwards.
        AvatarGroup.toBottom(children: getAvatars()),
      ],
    );
  }
}
# File: ./lib/pages/docs/components/tabs/tabs_example_1.dart
import 'package:docs/pages/docs/components/carousel_example.dart';
import 'package:shadcn_flutter/shadcn_flutter.dart';
// Demonstrates Tabs as a header paired with an IndexedStack body.
// Tabs manages the active index; the stack swaps content without unmounting.
class TabsExample1 extends StatefulWidget {
  const TabsExample1({super.key});
  @override
  State<TabsExample1> createState() => _TabsExample1State();
}
class _TabsExample1State extends State<TabsExample1> {
  int index = 0;
  @override
  Widget build(BuildContext context) {
    return Column(
      children: [
        Tabs(
          // Bind the active tab index; Tabs is the header-only control.
          index: index,
          children: const [
            TabItem(child: Text('Tab 1')),
            TabItem(child: Text('Tab 2')),
            TabItem(child: Text('Tab 3')),
          ],
          onChanged: (int value) {
            // Keep header and body in sync by updating state.
            setState(() {
              index = value;
            });
          },
        ),
        const Gap(8),
        // The IndexedStack acts as the tab body; it switches content by index
        // without unmounting inactive children.
        IndexedStack(
          index: index,
          children: const [
            NumberedContainer(
              index: 1,
            ),
            NumberedContainer(
              index: 2,
            ),
            NumberedContainer(
              index: 3,
            ),
          ],
        ).sized(height: 300),
      ],
    );
  }
}
# File: ./lib/pages/docs/components/navigation_menu/navigation_menu_example_1.dart
import 'package:shadcn_flutter/shadcn_flutter.dart';
class NavigationMenuExample1 extends StatelessWidget {
  const NavigationMenuExample1({super.key});
  @override
  Widget build(BuildContext context) {
    final theme = Theme.of(context);
    // NavigationMenu displays a horizontal menu with items that can reveal
    // rich content on hover/press. Each NavigationMenuItem below demonstrates
    // different kinds of content lists and grid layouts.
    return NavigationMenu(
      children: [
        NavigationMenuItem(
          content: NavigationMenuContentList(
            // Reverse places the text/content list before the hero card.
            reverse: true,
            children: [
              NavigationMenuContent(
                title: const Text('Introduction'),
                content: const Text(
                    'Component library for Flutter based on Shadcn/UI design.'),
                onPressed: () {},
              ),
              NavigationMenuContent(
                title: const Text('Installation'),
                content: const Text(
                    'How to install this package in your Flutter project.'),
                onPressed: () {},
              ),
              NavigationMenuContent(
                title: const Text('Typography'),
                content: const Text(
                    'Styles and usage of typography in this package.'),
                onPressed: () {},
              ),
              Clickable(
                mouseCursor:
                    const WidgetStatePropertyAll(SystemMouseCursors.click),
                child: Card(
                  borderRadius: theme.borderRadiusMd,
                  child: Column(
                    mainAxisSize: MainAxisSize.min,
                    crossAxisAlignment: CrossAxisAlignment.start,
                    mainAxisAlignment: MainAxisAlignment.end,
                    children: [
                      const FlutterLogo(
                        size: 32,
                      ),
                      const Gap(16),
                      const Text('shadcn_flutter').mono().semiBold().large(),
                      const Gap(8),
                      const Text(
                              'Beautifully designed components from Shadcn/UI is now available for Flutter')
                          .muted(),
                    ],
                  ),
                ).constrained(maxWidth: 192),
              ),
            ],
          ),
          child: const Text('Getting started'),
        ),
        NavigationMenuItem(
          content: NavigationMenuContentList(
            children: [
              NavigationMenuContent(
                title: const Text('Accordion'),
                content: const Text('Accordion component for Flutter.'),
                onPressed: () {},
              ),
              NavigationMenuContent(
                title: const Text('Alert'),
                content: const Text('Alert component for Flutter.'),
                onPressed: () {},
              ),
              NavigationMenuContent(
                title: const Text('Alert Dialog'),
                content: const Text('Alert Dialog component for Flutter.'),
                onPressed: () {},
              ),
              NavigationMenuContent(
                title: const Text('Animation'),
                content: const Text('Animation component for Flutter.'),
                onPressed: () {},
              ),
              NavigationMenuContent(
                title: const Text('Avatar'),
                content: const Text('Avatar component for Flutter.'),
                onPressed: () {},
              ),
              NavigationMenuContent(
                title: const Text('Badge'),
                content: const Text('Badge component for Flutter.'),
                onPressed: () {},
              ),
            ],
          ),
          child: const Text('Components'),
        ),
        NavigationMenuItem(
          content: NavigationMenuContentList(
            // Use a simple 2-column grid for a more "news board" feel.
            crossAxisCount: 2,
            children: [
              // latest news
              NavigationMenuContent(
                title: const Text('Latest news'),
                content: const Text('Stay updated with the latest news.'),
                onPressed: () {},
              ),
              NavigationMenuContent(
                title: const Text('Change log'),
                content: const Text('View the change log of this package.'),
                onPressed: () {},
              ),
              NavigationMenuContent(
                title: const Text('Contributors'),
                content: const Text('List of contributors to this package.'),
                onPressed: () {},
              ),
            ],
          ),
          child: const Text('Blog'),
        ),
        NavigationMenuItem(
          onPressed: () {},
          child: const Text('Documentation'),
        ),
      ],
    );
  }
}
# File: ./lib/pages/docs/components/wrapper/wrapper_example_1.dart
import 'package:shadcn_flutter/shadcn_flutter.dart' as shadcn;
import 'package:flutter/material.dart';
// Wrap an existing Material/Cupertino app with ShadcnUI and Theme.
// Useful when you want to adopt Shadcn components and theming without
// replacing your root MaterialApp/CupertinoApp structure.
class WrapperExample1 extends StatelessWidget {
  const WrapperExample1({super.key});
  @override
  Widget build(BuildContext context) {
    // If you are using MaterialApp or CupertinoApp
    // but still want to use Shadcn UI theming and components,
    // you can wrap your app with ShadcnUI and Theme.
    return const shadcn.ShadcnLayer(
      theme: shadcn.ThemeData(),
      darkTheme: shadcn.ThemeData.dark(),
      child: shadcn.Scaffold(
        headers: [
          shadcn.AppBar(
            title: Text('Shadcn UI Wrapper Example'),
          ),
          shadcn.Divider(),
        ],
        child: Center(
          child: shadcn.Text('Hello, Shadcn Flutter!'),
        ),
      ),
    );
  }
}
# File: ./lib/pages/docs/components/checkbox/checkbox_example_2.dart
import 'package:shadcn_flutter/shadcn_flutter.dart';
/// Checkbox with three states (unchecked, indeterminate, checked).
///
/// Enabling [tristate] allows the middle "indeterminate" state.
class CheckboxExample2 extends StatefulWidget {
  const CheckboxExample2({super.key});
  @override
  State<CheckboxExample2> createState() => _CheckboxExample2State();
}
class _CheckboxExample2State extends State<CheckboxExample2> {
  CheckboxState _state = CheckboxState.unchecked;
  @override
  Widget build(BuildContext context) {
    return Checkbox(
      state: _state,
      onChanged: (value) {
        setState(() {
          _state = value;
        });
      },
      trailing: const Text('Remember me'),
      // Allow toggling: unchecked -> indeterminate -> checked -> ...
      tristate: true,
    );
  }
}
# File: ./lib/pages/docs/components/checkbox/checkbox_example_1.dart
import 'package:shadcn_flutter/shadcn_flutter.dart';
/// Checkbox with two states (checked/unchecked).
///
/// Demonstrates controlling [Checkbox] via a local [CheckboxState]
/// and updating it from [onChanged].
class CheckboxExample1 extends StatefulWidget {
  const CheckboxExample1({super.key});
  @override
  State<CheckboxExample1> createState() => _CheckboxExample1State();
}
class _CheckboxExample1State extends State<CheckboxExample1> {
  // Start unchecked; toggle when the user taps the control.
  CheckboxState _state = CheckboxState.unchecked;
  @override
  Widget build(BuildContext context) {
    return Checkbox(
      state: _state,
      onChanged: (value) {
        setState(() {
          _state = value;
        });
      },
      // Optional label placed on the trailing side.
      trailing: const Text('Remember me'),
    );
  }
}
# File: ./lib/pages/docs/components/swiper/swiper_example_1.dart
import 'package:shadcn_flutter/shadcn_flutter.dart';
class SwiperExample1 extends StatefulWidget {
  const SwiperExample1({super.key});
  @override
  State<SwiperExample1> createState() => _SwiperExample1State();
}
class _SwiperExample1State extends State<SwiperExample1> {
  OverlayPosition _position = OverlayPosition.end;
  bool _typeDrawer = true;
  Widget _buildSelectPosition(OverlayPosition position, String label) {
    return SelectedButton(
      value: _position == position,
      onChanged: (value) {
        if (value) {
          setState(() {
            _position = position;
          });
        }
      },
      style: const ButtonStyle.outline(),
      selectedStyle: const ButtonStyle.primary(),
      child: Text(label),
    );
  }
  @override
  Widget build(BuildContext context) {
    return Swiper(
      builder: (context) {
        return Container(
          constraints: const BoxConstraints(
            minWidth: 320,
            minHeight: 320,
          ),
          child: Column(
            mainAxisSize: MainAxisSize.min,
            mainAxisAlignment: MainAxisAlignment.center,
            children: [
              const Text('Hello!'),
              const Gap(24),
              PrimaryButton(
                onPressed: () {
                  openDrawer(
                      context: context,
                      builder: (context) {
                        return ListView.separated(
                          itemCount: 1000,
                          itemBuilder: (context, index) {
                            return Card(
                              child: Text('Item $index'),
                            );
                          },
                          separatorBuilder: (context, index) {
                            return const Gap(8);
                          },
                        );
                      },
                      position: OverlayPosition.bottom);
                },
                child: const Text('Close'),
              ),
            ],
          ),
        );
      },
      // Swiper displays an overlay (drawer/sheet) that can be swiped in from a chosen edge.
      position: _position,
      // Choose the overlay type: Drawer slides over content; Sheet peeks up from an edge.
      handler: _typeDrawer ? SwiperHandler.drawer : SwiperHandler.sheet,
      child: SizedBox(
        height: 500,
        child: Card(
          child: Center(
            child: Column(
              mainAxisSize: MainAxisSize.min,
              children: [
                const Text('Swipe me!'),
                const Gap(24),
                ButtonGroup(children: [
                  _buildSelectPosition(OverlayPosition.left, 'Left'),
                  _buildSelectPosition(OverlayPosition.right, 'Right'),
                  _buildSelectPosition(OverlayPosition.top, 'Top'),
                  _buildSelectPosition(OverlayPosition.bottom, 'Bottom'),
                ]),
                const Gap(24),
                ButtonGroup(children: [
                  Toggle(
                    value: _typeDrawer,
                    onChanged: (value) {
                      setState(() {
                        _typeDrawer = value;
                      });
                    },
                    child: const Text('Drawer'),
                  ),
                  Toggle(
                    value: !_typeDrawer,
                    onChanged: (value) {
                      setState(() {
                        _typeDrawer = !value;
                      });
                    },
                    child: const Text('Sheet'),
                  ),
                ]),
              ],
            ),
          ),
        ),
      ),
    );
  }
}
# File: ./lib/pages/docs/components/navigation_bar/navigation_bar_example_1.dart
import 'package:shadcn_flutter/shadcn_flutter.dart';
class NavigationBarExample1 extends StatefulWidget {
  const NavigationBarExample1({super.key});
  @override
  State<NavigationBarExample1> createState() => _NavigationBarExample1State();
}
class _NavigationBarExample1State extends State<NavigationBarExample1> {
  Key? selected = const ValueKey(0);
  NavigationBarAlignment alignment = NavigationBarAlignment.spaceAround;
  NavigationLabelType labelType = NavigationLabelType.none;
  bool customButtonStyle = true;
  bool expanded = true;
  NavigationItem buildButton(String label, IconData icon, Key key) {
    return NavigationItem(
      key: key,
      style: customButtonStyle
          ? const ButtonStyle.muted(density: ButtonDensity.icon)
          : null,
      selectedStyle: customButtonStyle
          ? const ButtonStyle.fixed(density: ButtonDensity.icon)
          : null,
      label: Text(label),
      child: Icon(icon),
    );
  }
  @override
  Widget build(BuildContext context) {
    return OutlinedContainer(
      width: 500,
      height: 400,
      child: Scaffold(
        footers: [
          const Divider(),
          NavigationBar(
            alignment: alignment,
            labelType: labelType,
            expanded: expanded,
            onSelected: (key) {
              setState(() {
                selected = key;
              });
            },
            selectedKey: selected,
            children: [
              buildButton('Home', BootstrapIcons.house, const ValueKey(0)),
              buildButton('Explore', BootstrapIcons.compass, const ValueKey(1)),
              buildButton(
                  'Library', BootstrapIcons.musicNoteList, const ValueKey(2)),
              buildButton('Profile', BootstrapIcons.person, const ValueKey(3)),
              buildButton(
                  'App', BootstrapIcons.appIndicator, const ValueKey(4)),
            ],
          ),
        ],
        child: Container(
          color: Colors.primaries[
              Colors.primaries.length - (selected as ValueKey<int>).value - 1],
          padding: const EdgeInsets.all(24),
          child: Card(
            child: Wrap(
              alignment: WrapAlignment.center,
              runAlignment: WrapAlignment.center,
              crossAxisAlignment: WrapCrossAlignment.center,
              runSpacing: 8,
              spacing: 8,
              children: [
                // Configure how the items are distributed across the bar.
                Select<NavigationBarAlignment>(
                  value: alignment,
                  itemBuilder:
                      (BuildContext context, NavigationBarAlignment item) {
                    return Text(item.name);
                  },
                  popupWidthConstraint: PopoverConstraint.anchorFixedSize,
                  onChanged: (value) {
                    if (value != null) {
                      setState(() {
                        alignment = value;
                      });
                    }
                  },
                  popup: SelectPopup(
                      items: SelectItemList(children: [
                    for (var value in NavigationBarAlignment.values)
                      SelectItemButton(
                        value: value,
                        child: Text(value.name),
                      ),
                  ])),
                ),
                // Control how labels are shown for each navigation item.
                Select<NavigationLabelType>(
                  value: labelType,
                  itemBuilder:
                      (BuildContext context, NavigationLabelType item) {
                    return Text(item.name);
                  },
                  popupWidthConstraint: PopoverConstraint.anchorFixedSize,
                  onChanged: (value) {
                    if (value != null) {
                      setState(() {
                        labelType = value;
                      });
                    }
                  },
                  popup: SelectPopup(
                      items: SelectItemList(children: [
                    for (var value in NavigationLabelType.values)
                      SelectItemButton(
                        value: value,
                        child: Text(value.name),
                      ),
                  ])),
                ),
                // Use custom button styles for normal vs selected states.
                Checkbox(
                  state: customButtonStyle
                      ? CheckboxState.checked
                      : CheckboxState.unchecked,
                  onChanged: (value) {
                    setState(() {
                      customButtonStyle = value == CheckboxState.checked;
                    });
                  },
                  trailing: const Text('Custom Button Style'),
                ),
                // Toggle the expanded label behavior.
                Checkbox(
                  state: expanded
                      ? CheckboxState.checked
                      : CheckboxState.unchecked,
                  onChanged: (value) {
                    setState(() {
                      expanded = value == CheckboxState.checked;
                    });
                  },
                  trailing: const Text('Expanded'),
                ),
              ],
            ),
          ),
        ),
      ),
    );
  }
}
# File: ./lib/pages/docs/components/calendar/calendar_example_3.dart
import 'package:shadcn_flutter/shadcn_flutter.dart';
/// Calendar with multi-date selection.
///
/// [CalendarSelectionMode.multi] allows selecting multiple individual days.
class CalendarExample3 extends StatefulWidget {
  const CalendarExample3({super.key});
  @override
  State<CalendarExample3> createState() => _CalendarExample3State();
}
class _CalendarExample3State extends State<CalendarExample3> {
  CalendarValue? _value;
  CalendarView _view = CalendarView.now();
  @override
  Widget build(BuildContext context) {
    ShadcnLocalizations localizations = ShadcnLocalizations.of(context);
    return Card(
      child: IntrinsicWidth(
        child: Column(
          mainAxisSize: MainAxisSize.min,
          crossAxisAlignment: CrossAxisAlignment.stretch,
          children: [
            Row(
              children: [
                OutlineButton(
                  density: ButtonDensity.icon,
                  onPressed: () {
                    setState(() {
                      _view = _view.previous;
                    });
                  },
                  child: const Icon(Icons.arrow_back).iconXSmall(),
                ),
                Text('${localizations.getMonth(_view.month)} ${_view.year}')
                    .small()
                    .medium()
                    .center()
                    .expanded(),
                OutlineButton(
                  density: ButtonDensity.icon,
                  onPressed: () {
                    setState(() {
                      _view = _view.next;
                    });
                  },
                  child: const Icon(Icons.arrow_forward).iconXSmall(),
                ),
              ],
            ),
            const Gap(16),
            Calendar(
              value: _value,
              view: _view,
              onChanged: (value) {
                setState(() {
                  _value = value;
                });
              },
              // Multi selection lets users toggle arbitrary dates on/off.
              selectionMode: CalendarSelectionMode.multi,
            ),
          ],
        ),
      ),
    );
  }
}
# File: ./lib/pages/docs/components/calendar/calendar_example_2.dart
import 'package:shadcn_flutter/shadcn_flutter.dart';
/// Calendar with single-date selection and a "today" marker.
///
/// Uses [CalendarSelectionMode.single] to allow selecting exactly one date,
/// and passes `now` to highlight the current day in the view.
class CalendarExample2 extends StatefulWidget {
  const CalendarExample2({super.key});
  @override
  State<CalendarExample2> createState() => _CalendarExample2State();
}
class _CalendarExample2State extends State<CalendarExample2> {
  CalendarValue? _value;
  CalendarView _view = CalendarView.now();
  @override
  Widget build(BuildContext context) {
    ShadcnLocalizations localizations = ShadcnLocalizations.of(context);
    return Card(
      child: IntrinsicWidth(
        child: Column(
          mainAxisSize: MainAxisSize.min,
          crossAxisAlignment: CrossAxisAlignment.stretch,
          children: [
            Row(
              children: [
                OutlineButton(
                  density: ButtonDensity.icon,
                  onPressed: () {
                    setState(() {
                      _view = _view.previous;
                    });
                  },
                  child: const Icon(Icons.arrow_back).iconXSmall(),
                ),
                Text('${localizations.getMonth(_view.month)} ${_view.year}')
                    .small()
                    .medium()
                    .center()
                    .expanded(),
                OutlineButton(
                  density: ButtonDensity.icon,
                  onPressed: () {
                    setState(() {
                      _view = _view.next;
                    });
                  },
                  child: const Icon(Icons.arrow_forward).iconXSmall(),
                ),
              ],
            ),
            const Gap(16),
            Calendar(
              value: _value,
              view: _view,
              onChanged: (value) {
                setState(() {
                  _value = value;
                });
              },
              selectionMode: CalendarSelectionMode.single,
              // Provide a "today" reference for visual emphasis.
              now: DateTime.now(),
            ),
          ],
        ),
      ),
    );
  }
}
# File: ./lib/pages/docs/components/calendar/calendar_example_1.dart
import 'package:shadcn_flutter/shadcn_flutter.dart';
/// Calendar with range selection mode.
///
/// Demonstrates navigating months using a custom header and binding
/// a [CalendarValue] for a date range via [CalendarSelectionMode.range].
class CalendarExample1 extends StatefulWidget {
  const CalendarExample1({super.key});
  @override
  State<CalendarExample1> createState() => _CalendarExample1State();
}
class _CalendarExample1State extends State<CalendarExample1> {
  // Holds the current selection (start/end) when in range mode.
  CalendarValue? _value;
  // Tracks the current month/year view independent of selection.
  CalendarView _view = CalendarView.now();
  @override
  Widget build(BuildContext context) {
    ShadcnLocalizations localizations = ShadcnLocalizations.of(context);
    return Card(
      child: IntrinsicWidth(
        child: Column(
          mainAxisSize: MainAxisSize.min,
          crossAxisAlignment: CrossAxisAlignment.stretch,
          children: [
            Row(
              children: [
                OutlineButton(
                  density: ButtonDensity.icon,
                  onPressed: () {
                    setState(() {
                      // Move the calendar view to the previous month.
                      _view = _view.previous;
                    });
                  },
                  child: const Icon(Icons.arrow_back).iconXSmall(),
                ),
                Text('${localizations.getMonth(_view.month)} ${_view.year}')
                    .small()
                    .medium()
                    .center()
                    .expanded(),
                OutlineButton(
                  density: ButtonDensity.icon,
                  onPressed: () {
                    setState(() {
                      // Move the calendar view to the next month.
                      _view = _view.next;
                    });
                  },
                  child: const Icon(Icons.arrow_forward).iconXSmall(),
                ),
              ],
            ),
            const Gap(16),
            Calendar(
              value: _value,
              view: _view,
              onChanged: (value) {
                setState(() {
                  _value = value;
                });
              },
              // Range selection allows choosing a start and end date.
              selectionMode: CalendarSelectionMode.range,
            ),
          ],
        ),
      ),
    );
  }
}
# File: ./lib/pages/docs/components/calendar/calendar_example_4.dart
import 'package:shadcn_flutter/shadcn_flutter.dart';
/// Calendar in read-only mode (no selection).
///
/// [CalendarSelectionMode.none] displays the month grid without allowing
/// user selections; useful for a visual calendar-only view.
class CalendarExample4 extends StatefulWidget {
  const CalendarExample4({super.key});
  @override
  State<CalendarExample4> createState() => _CalendarExample4State();
}
class _CalendarExample4State extends State<CalendarExample4> {
  CalendarValue? _value;
  CalendarView _view = CalendarView.now();
  @override
  Widget build(BuildContext context) {
    ShadcnLocalizations localizations = ShadcnLocalizations.of(context);
    return Card(
      child: IntrinsicWidth(
        child: Column(
          mainAxisSize: MainAxisSize.min,
          crossAxisAlignment: CrossAxisAlignment.stretch,
          children: [
            Row(
              children: [
                OutlineButton(
                  density: ButtonDensity.icon,
                  onPressed: () {
                    setState(() {
                      _view = _view.previous;
                    });
                  },
                  child: const Icon(Icons.arrow_back).iconXSmall(),
                ),
                Text('${localizations.getMonth(_view.month)} ${_view.year}')
                    .small()
                    .medium()
                    .center()
                    .expanded(),
                OutlineButton(
                  density: ButtonDensity.icon,
                  onPressed: () {
                    setState(() {
                      _view = _view.next;
                    });
                  },
                  child: const Icon(Icons.arrow_forward).iconXSmall(),
                ),
              ],
            ),
            const Gap(16),
            Calendar(
              value: _value,
              view: _view,
              onChanged: (value) {
                setState(() {
                  _value = value;
                });
              },
              now: DateTime.now(),
              // Disable all selection (view-only).
              selectionMode: CalendarSelectionMode.none,
            ),
          ],
        ),
      ),
    );
  }
}
# File: ./lib/pages/docs/components/command/command_example_1.dart
import 'package:shadcn_flutter/shadcn_flutter.dart';
class CommandExample1 extends StatelessWidget {
  const CommandExample1({super.key});
  @override
  Widget build(BuildContext context) {
    return Command(
      // The builder is an async generator producing lists of CommandCategory
      // based on the current search query. Each yield updates the UI.
      builder: (context, query) async* {
        Map<String, List<String>> items = {
          'Suggestions': ['Calendar', 'Search Emoji', 'Launch'],
          'Settings': ['Profile', 'Mail', 'Settings'],
        };
        Map<String, Widget> icons = {
          'Calendar': const Icon(Icons.calendar_today),
          'Search Emoji': const Icon(Icons.emoji_emotions_outlined),
          'Launch': const Icon(Icons.rocket_launch_outlined),
          'Profile': const Icon(Icons.person_outline),
          'Mail': const Icon(Icons.mail_outline),
          'Settings': const Icon(Icons.settings_outlined),
        };
        for (final values in items.entries) {
          List<Widget> resultItems = [];
          for (final item in values.value) {
            if (query == null ||
                item.toLowerCase().contains(query.toLowerCase())) {
              resultItems.add(CommandItem(
                title: Text(item),
                leading: icons[item],
                onTap: () {},
              ));
            }
          }
          if (resultItems.isNotEmpty) {
            // Simulate latency to showcase incremental results.
            await Future.delayed(const Duration(seconds: 1));
            yield [
              CommandCategory(
                title: Text(values.key),
                children: resultItems,
              ),
            ];
          }
        }
      },
    ).sized(width: 300, height: 300);
  }
}
# File: ./lib/pages/docs/components/tab_list/tab_list_example_1.dart
import 'package:docs/pages/docs/components/carousel_example.dart';
import 'package:shadcn_flutter/shadcn_flutter.dart';
// Demonstrates TabList (a low-level tab header) with an IndexedStack body.
// The header controls the index; the content is managed separately.
class TabListExample1 extends StatefulWidget {
  const TabListExample1({super.key});
  @override
  State<TabListExample1> createState() => _TabListExample1State();
}
class _TabListExample1State extends State<TabListExample1> {
  int index = 0;
  @override
  Widget build(BuildContext context) {
    return Column(
      crossAxisAlignment: CrossAxisAlignment.stretch,
      children: [
        TabList(
          // TabList is a lower-level tab header; it doesn't manage content.
          index: index,
          onChanged: (value) {
            setState(() {
              index = value;
            });
          },
          children: const [
            TabItem(
              child: Text('Tab 1'),
            ),
            TabItem(
              child: Text('Tab 2'),
            ),
            TabItem(
              child: Text('Tab 3'),
            ),
          ],
        ),
        const Gap(16),
        // Like Tabs example, use an IndexedStack to switch the content area.
        IndexedStack(
          index: index,
          children: const [
            NumberedContainer(
              index: 1,
            ),
            NumberedContainer(
              index: 2,
            ),
            NumberedContainer(
              index: 3,
            ),
          ],
        ).sized(height: 300),
      ],
    );
  }
}
# File: ./lib/pages/docs/components/card/card_example_1.dart
import 'package:shadcn_flutter/shadcn_flutter.dart';
/// Card with form-like content and actions.
///
/// Demonstrates using [Card] as a container with padding, headings,
/// inputs, and action buttons aligned via a [Row] and [Spacer].
class CardExample1 extends StatelessWidget {
  const CardExample1({super.key});
  @override
  Widget build(BuildContext context) {
    return Card(
      padding: const EdgeInsets.all(24),
      child: Column(
        crossAxisAlignment: CrossAxisAlignment.start,
        children: [
          const Text('Create project').semiBold(),
          const SizedBox(height: 4),
          const Text('Deploy your new project in one-click').muted().small(),
          const SizedBox(height: 24),
          const Text('Name').semiBold().small(),
          const SizedBox(height: 4),
          const TextField(placeholder: Text('Name of your project')),
          const SizedBox(height: 16),
          const Text('Description').semiBold().small(),
          const SizedBox(height: 4),
          const TextField(placeholder: Text('Description of your project')),
          const SizedBox(height: 24),
          Row(
            children: [
              OutlineButton(
                child: const Text('Cancel'),
                onPressed: () {},
              ),
              const Spacer(),
              PrimaryButton(
                child: const Text('Deploy'),
                onPressed: () {},
              ),
            ],
          ),
        ],
      ),
    ).intrinsic();
  }
}
# File: ./lib/pages/docs/components/code_snippet/code_snippet_example_1.dart
import 'package:shadcn_flutter/shadcn_flutter.dart';
/// CodeSnippet for showing read-only command or code blocks.
///
/// `mode` controls syntax highlighting; here we show a shell command.
class CodeSnippetExample1 extends StatelessWidget {
  const CodeSnippetExample1({super.key});
  @override
  Widget build(BuildContext context) {
    return const CodeSnippet(
      code: Text('flutter pub get'),
    );
  }
}
# File: ./lib/pages/docs/components/scaffold/scaffold_example_1.dart
import 'package:shadcn_flutter/shadcn_flutter.dart';
class ScaffoldExample1 extends StatefulWidget {
  const ScaffoldExample1({super.key});
  @override
  State<ScaffoldExample1> createState() => _ScaffoldExample1State();
}
class _ScaffoldExample1State extends State<ScaffoldExample1> {
  // Simple counter to demonstrate updating content inside the Scaffold body.
  int _counter = 0;
  void _incrementCounter() {
    setState(() {
      _counter++;
    });
  }
  @override
  Widget build(BuildContext context) {
    return Scaffold(
      // Show an indeterminate progress indicator in the header area (for demo purposes).
      loadingProgressIndeterminate: true,
      headers: [
        AppBar(
          title: const Text('Counter App'),
          subtitle: const Text('A simple counter app'),
          leading: [
            OutlineButton(
              onPressed: () {},
              density: ButtonDensity.icon,
              child: const Icon(Icons.menu),
            ),
          ],
          trailing: [
            OutlineButton(
              onPressed: () {},
              density: ButtonDensity.icon,
              child: const Icon(Icons.search),
            ),
            OutlineButton(
              onPressed: () {},
              density: ButtonDensity.icon,
              child: const Icon(Icons.add),
            ),
          ],
        ),
        // Divider between the header and the body.
        const Divider(),
      ],
      child: Center(
        child: Column(
          mainAxisAlignment: MainAxisAlignment.center,
          children: <Widget>[
            // The .p() extension adds default padding around the widget.
            const Text('You have pushed the button this many times:').p(),
            Text(
              '$_counter',
            ).h1(),
            PrimaryButton(
              onPressed: _incrementCounter,
              density: ButtonDensity.icon,
              child: const Icon(Icons.add),
            ).p(),
          ],
        ),
      ),
    );
  }
}
# File: ./lib/pages/docs/components/switch/switch_example_1.dart
import 'package:shadcn_flutter/shadcn_flutter.dart';
class SwitchExample1 extends StatefulWidget {
  const SwitchExample1({super.key});
  @override
  State<SwitchExample1> createState() => _SwitchExample1State();
}
class _SwitchExample1State extends State<SwitchExample1> {
  // Simple on/off state bound to the Switch.
  bool value = false;
  @override
  Widget build(BuildContext context) {
    return Switch(
      value: value,
      onChanged: (value) {
        setState(() {
          // Flip the switch.
          this.value = value;
        });
      },
    );
  }
}
# File: ./lib/pages/docs/components/timeline_animation/timeline_animation_example_1.dart
import 'dart:math';
import 'package:shadcn_flutter/shadcn_flutter.dart';
// Demonstrates TimelineAnimation by composing offset and rotation keyframes
// sampled by a shared controller.
class TimelineAnimationExample1 extends StatefulWidget {
  const TimelineAnimationExample1({super.key});
  @override
  State<TimelineAnimationExample1> createState() =>
      _TimelineAnimationExample1State();
}
class _TimelineAnimationExample1State extends State<TimelineAnimationExample1>
    with SingleTickerProviderStateMixin {
  // Timeline of Offset values combining absolute and relative keyframes.
  // AbsoluteKeyframe defines a start and end value over a fixed duration.
  // RelativeKeyframe appends a delta over the given duration.
  final TimelineAnimation<Offset> offsetTimeline = TimelineAnimation(
    keyframes: [
      const AbsoluteKeyframe(
        Duration(seconds: 1),
        Offset(-100, -100),
        Offset(100, -100),
      ),
      const RelativeKeyframe(
        Duration(seconds: 2),
        Offset(100, 100),
      ),
      const RelativeKeyframe(
        Duration(seconds: 1),
        Offset(-100, 100),
      ),
      const RelativeKeyframe(
        Duration(seconds: 2),
        Offset(-100, -100),
      ),
    ],
    // Provide a lerp function for Offset values.
    lerp: Transformers.typeOffset,
  );
  // A separate timeline animating rotation in radians. StillKeyframe pauses movement.
  final TimelineAnimation<double> rotationTimeline = TimelineAnimation(
    keyframes: [
      const AbsoluteKeyframe(
        Duration(seconds: 1),
        0,
        pi / 2,
      ),
      const StillKeyframe(
        Duration(seconds: 2),
      ),
      const RelativeKeyframe(
        Duration(seconds: 1),
        0,
      ),
      const StillKeyframe(
        Duration(seconds: 2),
      ),
    ],
    // Provide a lerp function for double values.
    lerp: Transformers.typeDouble,
  );
  late AnimationController controller;
  @override
  void initState() {
    super.initState();
    controller = AnimationController(
      vsync: this,
      // Use the maximum duration across all timelines so they loop together.
      duration: timelineMaxDuration([
        offsetTimeline,
        rotationTimeline,
      ]),
    )..repeat();
  }
  @override
  void dispose() {
    controller.dispose();
    super.dispose();
  }
  @override
  Widget build(BuildContext context) {
    return AnimatedBuilder(
      animation: controller,
      builder: (context, child) {
        return Transform.translate(
          // Sample the offset timeline using the shared controller.
          offset: offsetTimeline.transformWithController(controller),
          child: Transform.rotate(
            // Sample the rotation timeline using the shared controller.
            angle: rotationTimeline.transformWithController(controller),
            child: Container(
              width: 50,
              height: 50,
              color: Colors.blue,
            ),
          ),
        );
      },
    );
  }
}
# File: ./lib/pages/docs/components/circular_progress/circular_progress_example_1.dart
import 'package:shadcn_flutter/shadcn_flutter.dart';
/// Indeterminate circular progress indicator.
///
/// Use when progress amount is unknown and you want to indicate activity.
class CircularProgressExample1 extends StatelessWidget {
  const CircularProgressExample1({super.key});
  @override
  Widget build(BuildContext context) {
    return const CircularProgressIndicator();
  }
}
# File: ./lib/pages/docs/components/circular_progress/circular_progress_example_2.dart
import 'package:shadcn_flutter/shadcn_flutter.dart';
/// Determinate circular progress indicator with controls.
///
/// Demonstrates binding a numeric progress value to [CircularProgressIndicator]
/// and updating it via buttons. Value should be a fraction between 0 and 1.
class CircularProgressExample2 extends StatefulWidget {
  const CircularProgressExample2({super.key});
  @override
  State<CircularProgressExample2> createState() =>
      _CircularProgressExample2State();
}
class _CircularProgressExample2State extends State<CircularProgressExample2> {
  // Track progress in percentage (0-100) for easier mental mapping.
  double _progress = 0;
  @override
  Widget build(BuildContext context) {
    return Column(
      mainAxisSize: MainAxisSize.min,
      children: [
        CircularProgressIndicator(
          // The widget expects a normalized value [0..1].
          value: _progress.clamp(0, 100) / 100,
          size: 48,
        ),
        const Gap(48),
        Row(
          children: [
            DestructiveButton(
              onPressed: () {
                setState(() {
                  // Reset to 0%.
                  _progress = 0;
                });
              },
              child: const Text('Reset'),
            ),
            const Gap(16),
            PrimaryButton(
              onPressed: () {
                setState(() {
                  // Decrease by 10%.
                  _progress -= 10;
                });
              },
              child: const Text('Decrease by 10'),
            ),
            const Gap(16),
            PrimaryButton(
              onPressed: () {
                setState(() {
                  // Increase by 10%.
                  _progress += 10;
                });
              },
              child: const Text('Increase by 10'),
            ),
          ],
        )
      ],
    );
  }
}
# File: ./lib/pages/docs/components/overflow_marquee/overflow_marquee_example_1.dart
import 'package:shadcn_flutter/shadcn_flutter.dart';
class OverflowMarqueeExample1 extends StatelessWidget {
  const OverflowMarqueeExample1({super.key});
  @override
  Widget build(BuildContext context) {
    return const SizedBox(
      width: 200,
      child: OverflowMarquee(
        // When the text exceeds the available width, it smoothly scrolls horizontally.
        child: Text(
          'Lorem ipsum dolor sit amet, consectetur adipiscing elit. Sed do eiusmod tempor incididunt ut labore et dolore magna aliqua.',
        ),
      ),
    );
  }
}
# File: ./lib/pages/docs/components/autocomplete/autocomplete_example_1.dart
import 'package:shadcn_flutter/shadcn_flutter.dart';
/// AutoComplete with a TextField and filtered suggestions.
///
/// Typing in the field updates the current word under the caret using
/// [TextEditingController.currentWord] and filters a static list of fruits.
/// The [AutoComplete] widget displays suggestions provided via `suggestions`.
class AutoCompleteExample1 extends StatefulWidget {
  const AutoCompleteExample1({super.key});
  @override
  State<AutoCompleteExample1> createState() => _AutoCompleteExample1State();
}
class _AutoCompleteExample1State extends State<AutoCompleteExample1> {
  // Source data for suggestions.
  final List<String> suggestions = [
    'Apple',
    'Banana',
    'Cherry',
    'Date',
    'Grape',
    'Kiwi',
    'Lemon',
    'Mango',
    'Orange',
    'Peach',
    'Pear',
    'Pineapple',
    'Strawberry',
    'Watermelon',
  ];
  // Filtered suggestions for the current input word.
  List<String> _currentSuggestions = [];
  // Controller for reading the current text and word at the caret.
  final TextEditingController _controller = TextEditingController();
  // Update the filtered suggestions based on the current word being typed.
  void _updateSuggestions(String value) {
    String? currentWord = _controller.currentWord;
    if (currentWord == null || currentWord.isEmpty) {
      setState(() {
        _currentSuggestions = [];
      });
      return;
    }
    setState(() {
      _currentSuggestions = suggestions
          .where((element) =>
              element.toLowerCase().contains(currentWord.toLowerCase()))
          .toList();
    });
  }
  @override
  Widget build(BuildContext context) {
    return AutoComplete(
      // Provide the list to be shown in the overlay.
      suggestions: _currentSuggestions,
      child: TextField(
        controller: _controller,
        // Each keystroke recalculates the suggestions.
        onChanged: _updateSuggestions,
        features: const [
          InputFeature.clear(),
        ],
      ),
    );
  }
}
# File: ./lib/pages/docs/components/formatted_input/formatted_input_example_4.dart
import 'package:shadcn_flutter/shadcn_flutter.dart';
class FormattedInputExample4 extends StatefulWidget {
  const FormattedInputExample4({super.key});
  @override
  State<FormattedInputExample4> createState() => _FormattedInputExample4State();
}
class _FormattedInputExample4State extends State<FormattedInputExample4> {
  Duration? _selected;
  @override
  Widget build(BuildContext context) {
    return Column(
      children: [
        DurationInput(
          // Built-in formatted control for durations; shows HH:MM and (optionally) SS.
          onChanged: (value) => setState(() => _selected = value),
          showSeconds: true,
        ),
        const Gap(16),
        if (_selected != null) Text('Selected duration: $_selected'),
      ],
    );
  }
}
# File: ./lib/pages/docs/components/formatted_input/formatted_input_example_1.dart
import 'package:flutter/foundation.dart';
import 'package:shadcn_flutter/shadcn_flutter.dart';
class FormattedInputExample1 extends StatelessWidget {
  const FormattedInputExample1({super.key});
  @override
  Widget build(BuildContext context) {
    return FormattedInput(
      // Demonstrates a date-like formatted input built from editable and static parts.
      onChanged: (value) {
        List<String> parts = [];
        for (FormattedValuePart part in value.values) {
          parts.add(part.value ?? '');
        }
        if (kDebugMode) {
          print(parts.join('/'));
        }
      },
      initialValue: FormattedValue([
        const InputPart.editable(length: 2, width: 40, placeholder: Text('MM'))
            .withValue('01'),
        const InputPart.static('/'),
        const InputPart.editable(length: 2, width: 40, placeholder: Text('DD'))
            .withValue('02'),
        const InputPart.static('/'),
        const InputPart.editable(
                length: 4, width: 60, placeholder: Text('YYYY'))
            .withValue('2021'),
      ]),
    );
  }
}
# File: ./lib/pages/docs/components/formatted_input/formatted_input_example_2.dart
import 'package:shadcn_flutter/shadcn_flutter.dart';
class FormattedInputExample2 extends StatefulWidget {
  const FormattedInputExample2({super.key});
  @override
  State<FormattedInputExample2> createState() => _FormattedInputExample2State();
}
class _FormattedInputExample2State extends State<FormattedInputExample2> {
  DateTime? _selectedDate;
  @override
  Widget build(BuildContext context) {
    return Column(
      children: [
        DateInput(
          onChanged: (value) => setState(() => _selectedDate = value),
        ),
        const Gap(16),
        if (_selectedDate != null) Text('Selected date: $_selectedDate'),
      ],
    );
  }
}
# File: ./lib/pages/docs/components/formatted_input/formatted_input_example_3.dart
import 'package:shadcn_flutter/shadcn_flutter.dart';
class FormattedInputExample3 extends StatefulWidget {
  const FormattedInputExample3({super.key});
  @override
  State<FormattedInputExample3> createState() => _FormattedInputExample3State();
}
class _FormattedInputExample3State extends State<FormattedInputExample3> {
  TimeOfDay? _selected;
  @override
  Widget build(BuildContext context) {
    return Column(
      children: [
        TimeInput(
          // Built-in formatted control for time-of-day values.
          onChanged: (value) => setState(() => _selected = value),
        ),
        const Gap(16),
        if (_selected != null) Text('Selected time: $_selected'),
      ],
    );
  }
}
# File: ./lib/pages/docs/components/button/button_example_14.dart
import 'package:shadcn_flutter/shadcn_flutter.dart';
class ButtonExample14 extends StatelessWidget {
  const ButtonExample14({super.key});
  @override
  Widget build(BuildContext context) {
    return ButtonGroup(
      children: [
        PrimaryButton(
          child: const Text('Primary'),
          onPressed: () {},
        ),
        SecondaryButton(
          child: const Text('Secondary'),
          onPressed: () {},
        ),
        DestructiveButton(
          child: const Text('Destructive'),
          onPressed: () {},
        ),
        OutlineButton(
          child: const Text('Outlined'),
          onPressed: () {},
        ),
        GhostButton(
          child: const Text('Ghost'),
          onPressed: () {},
        ),
        IconButton.primary(
          icon: const Icon(Icons.add),
          onPressed: () {},
        ),
      ],
    );
  }
}
# File: ./lib/pages/docs/components/button/button_example_13.dart
import 'package:shadcn_flutter/shadcn_flutter.dart';
class ButtonExample13 extends StatelessWidget {
  const ButtonExample13({super.key});
  @override
  Widget build(BuildContext context) {
    return Wrap(
      spacing: 8,
      runSpacing: 8,
      alignment: WrapAlignment.center,
      runAlignment: WrapAlignment.center,
      children: [
        PrimaryButton(
          onPressed: () {},
          shape: ButtonShape.circle,
          child: const Icon(Icons.add),
        ),
        PrimaryButton(
          onPressed: () {},
          shape: ButtonShape.rectangle,
          child: const Text('Rectangle'),
        ),
      ],
    );
  }
}
# File: ./lib/pages/docs/components/button/button_example_5.dart
import 'package:shadcn_flutter/shadcn_flutter.dart';
/// Destructive button.
///
/// Use to represent dangerous or irreversible actions (e.g., delete).
class ButtonExample5 extends StatelessWidget {
  const ButtonExample5({super.key});
  @override
  Widget build(BuildContext context) {
    return DestructiveButton(
      onPressed: () {},
      child: const Text('Destructive'),
    );
  }
}
# File: ./lib/pages/docs/components/button/button_example_9.dart
import 'package:shadcn_flutter/shadcn_flutter.dart';
class ButtonExample9 extends StatelessWidget {
  const ButtonExample9({super.key});
  @override
  Widget build(BuildContext context) {
    return Wrap(
      spacing: 8,
      runSpacing: 8,
      children: [
        PrimaryButton(
          onPressed: () {},
          trailing: const Icon(Icons.add),
          child: const Text('Add'),
        ),
        SecondaryButton(
          onPressed: () {},
          trailing: const Icon(Icons.add),
          child: const Text('Add'),
        ),
        OutlineButton(
          onPressed: () {},
          trailing: const Icon(Icons.add),
          child: const Text('Add'),
        ),
        GhostButton(
          onPressed: () {},
          trailing: const Icon(Icons.add),
          child: const Text('Add'),
        ),
        TextButton(
          onPressed: () {},
          trailing: const Icon(Icons.add),
          child: const Text('Add'),
        ),
        DestructiveButton(
          onPressed: () {},
          trailing: const Icon(Icons.add),
          child: const Text('Add'),
        ),
      ],
    );
  }
}
# File: ./lib/pages/docs/components/button/button_example_15.dart
import 'package:shadcn_flutter/shadcn_flutter.dart';
class ButtonExample15 extends StatelessWidget {
  const ButtonExample15({super.key});
  @override
  Widget build(BuildContext context) {
    return PrimaryButton(
      leading: const StatedWidget.map(
        states: {
          'disabled': Icon(Icons.close),
          {WidgetState.hovered, WidgetState.focused}:
              Icon(Icons.add_a_photo_rounded),
          WidgetState.hovered: Icon(Icons.add_a_photo),
        },
        child: Icon(Icons.add_a_photo_outlined),
      ),
      onPressed: () {},
      child: const StatedWidget(
        focused: Text('Focused'),
        hovered: Text('Hovered'),
        pressed: Text('Pressed'),
        child: Text('Normal'),
      ),
    );
  }
}
# File: ./lib/pages/docs/components/button/button_example_10.dart
import 'package:shadcn_flutter/shadcn_flutter.dart';
class ButtonExample10 extends StatelessWidget {
  const ButtonExample10({super.key});
  @override
  Widget build(BuildContext context) {
    return Wrap(
      spacing: 8,
      runSpacing: 8,
      alignment: WrapAlignment.center,
      runAlignment: WrapAlignment.center,
      children: [
        PrimaryButton(
          size: ButtonSize.xSmall,
          onPressed: () {},
          child: const Text('Extra Small'),
        ),
        PrimaryButton(
          onPressed: () {},
          size: ButtonSize.small,
          child: const Text('Small'),
        ),
        PrimaryButton(
          size: ButtonSize.normal,
          onPressed: () {},
          child: const Text('Normal'),
        ),
        PrimaryButton(
          size: ButtonSize.large,
          onPressed: () {},
          child: const Text('Large'),
        ),
        PrimaryButton(
          size: ButtonSize.xLarge,
          onPressed: () {},
          child: const Text('Extra Large'),
        ),
      ],
    );
  }
}
# File: ./lib/pages/docs/components/button/button_example_3.dart
import 'package:shadcn_flutter/shadcn_flutter.dart';
/// Outline button.
///
/// Uses an outlined border for a minimal visual weight.
class ButtonExample3 extends StatelessWidget {
  const ButtonExample3({super.key});
  @override
  Widget build(BuildContext context) {
    return OutlineButton(
      onPressed: () {},
      child: const Text('Outlined'),
    );
  }
}
# File: ./lib/pages/docs/components/button/button_example_17.dart
import 'package:shadcn_flutter/shadcn_flutter.dart';
class ButtonExample17 extends StatelessWidget {
  const ButtonExample17({super.key});
  @override
  Widget build(BuildContext context) {
    return Button(
      style: const ButtonStyle.primary()
          .withBackgroundColor(color: Colors.red, hoverColor: Colors.purple)
          .withForegroundColor(color: Colors.white)
          .withBorderRadius(hoverBorderRadius: BorderRadius.circular(16)),
      onPressed: () {},
      leading: const Icon(Icons.sunny),
      child: const Text('Custom Button'),
    );
  }
}
# File: ./lib/pages/docs/components/button/button_example_8.dart
import 'package:shadcn_flutter/shadcn_flutter.dart';
class ButtonExample8 extends StatelessWidget {
  const ButtonExample8({super.key});
  @override
  Widget build(BuildContext context) {
    return Wrap(
      runSpacing: 8,
      spacing: 8,
      children: [
        IconButton.primary(
          onPressed: () {},
          density: ButtonDensity.icon,
          icon: const Icon(Icons.add),
        ),
        IconButton.secondary(
          onPressed: () {},
          density: ButtonDensity.icon,
          icon: const Icon(Icons.add),
        ),
        IconButton.outline(
          onPressed: () {},
          density: ButtonDensity.icon,
          icon: const Icon(Icons.add),
        ),
        IconButton.ghost(
          onPressed: () {},
          density: ButtonDensity.icon,
          icon: const Icon(Icons.add),
        ),
        IconButton.text(
          onPressed: () {},
          density: ButtonDensity.icon,
          icon: const Icon(Icons.add),
        ),
        IconButton.destructive(
          onPressed: () {},
          density: ButtonDensity.icon,
          icon: const Icon(Icons.add),
        ),
      ],
    );
  }
}
# File: ./lib/pages/docs/components/button/button_example_2.dart
import 'package:shadcn_flutter/shadcn_flutter.dart';
/// Secondary button.
///
/// A lower-emphasis action compared to [PrimaryButton].
class ButtonExample2 extends StatelessWidget {
  const ButtonExample2({super.key});
  @override
  Widget build(BuildContext context) {
    return SecondaryButton(
      onPressed: () {},
      child: const Text('Secondary'),
    );
  }
}
# File: ./lib/pages/docs/components/button/button_example_4.dart
import 'package:shadcn_flutter/shadcn_flutter.dart';
/// Ghost button.
///
/// Very subtle styling for least-emphasis or inline actions.
class ButtonExample4 extends StatelessWidget {
  const ButtonExample4({super.key});
  @override
  Widget build(BuildContext context) {
    return GhostButton(
      onPressed: () {},
      child: const Text('Ghost'),
    );
  }
}
# File: ./lib/pages/docs/components/button/button_example_1.dart
import 'package:shadcn_flutter/shadcn_flutter.dart';
/// Primary button.
///
/// Use for the main call-to-action on a screen.
class ButtonExample1 extends StatelessWidget {
  const ButtonExample1({super.key});
  @override
  Widget build(BuildContext context) {
    return PrimaryButton(
      onPressed: () {},
      child: const Text('Primary'),
    );
  }
}
# File: ./lib/pages/docs/components/button/button_example_11.dart
import 'package:shadcn_flutter/shadcn_flutter.dart';
class ButtonExample11 extends StatelessWidget {
  const ButtonExample11({super.key});
  @override
  Widget build(BuildContext context) {
    return Wrap(
      spacing: 8,
      runSpacing: 8,
      alignment: WrapAlignment.center,
      runAlignment: WrapAlignment.center,
      children: [
        PrimaryButton(
          onPressed: () {},
          density: ButtonDensity.compact,
          child: const Text('Compact'),
        ),
        PrimaryButton(
          onPressed: () {},
          density: ButtonDensity.dense,
          child: const Text('Dense'),
        ),
        PrimaryButton(
          onPressed: () {},
          density: ButtonDensity.normal,
          child: const Text('Normal'),
        ),
        PrimaryButton(
          onPressed: () {},
          density: ButtonDensity.comfortable,
          child: const Text('Comfortable'),
        ),
        PrimaryButton(
          onPressed: () {},
          density: ButtonDensity.icon,
          child: const Text('Icon'),
        ),
        PrimaryButton(
          onPressed: () {},
          density: ButtonDensity.iconComfortable,
          child: const Text('Icon Comfortable'),
        ),
      ],
    );
  }
}
# File: ./lib/pages/docs/components/button/button_example_12.dart
import 'package:shadcn_flutter/shadcn_flutter.dart';
class ButtonExample12 extends StatelessWidget {
  const ButtonExample12({super.key});
  @override
  Widget build(BuildContext context) {
    return TextButton(
      onPressed: () {},
      child: const Text('Text Button'),
    );
  }
}
# File: ./lib/pages/docs/components/button/button_example_16.dart
import 'package:shadcn_flutter/shadcn_flutter.dart';
class ButtonExample16 extends StatelessWidget {
  const ButtonExample16({super.key});
  @override
  Widget build(BuildContext context) {
    return CardButton(
      onPressed: () {},
      child: const Basic(
        title: Text('Project #1'),
        subtitle: Text('Project description'),
        content:
            Text('Lorem ipsum dolor sit amet, consectetur adipiscing elit.'),
      ),
    );
  }
}
# File: ./lib/pages/docs/components/button/button_example_6.dart
import 'package:shadcn_flutter/shadcn_flutter.dart';
class ButtonExample6 extends StatelessWidget {
  const ButtonExample6({super.key});
  @override
  Widget build(BuildContext context) {
    return LinkButton(
      onPressed: () {},
      child: const Text('Link'),
    );
  }
}
# File: ./lib/pages/docs/components/button/button_example_7.dart
import 'package:shadcn_flutter/shadcn_flutter.dart';
class ButtonExample7 extends StatelessWidget {
  const ButtonExample7({super.key});
  @override
  Widget build(BuildContext context) {
    return const Wrap(
      spacing: 8,
      runSpacing: 8,
      children: [
        PrimaryButton(
          child: Text('Disabled'),
        ),
        SecondaryButton(
          child: Text('Disabled'),
        ),
        OutlineButton(
          child: Text('Disabled'),
        ),
        GhostButton(
          child: Text('Disabled'),
        ),
        TextButton(
          child: Text('Disabled'),
        ),
        DestructiveButton(
          child: Text('Disabled'),
        ),
      ],
    );
  }
}
